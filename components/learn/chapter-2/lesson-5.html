<main>
    <h1>Урок 5 Правильный нейминг классов</h1>
    <h2>Для чего нужна БЭМ-методология</h2>
    <p> Какие требования мы сформулировали: </p>
    <ul>
        <li>Разработчик должен понимать свой код (даже вернувшись к нему через год) и код любого программиста в команде БЭМ-проекта.</li>
        <li>Любой блок кода может быть использован повторно: необходимо создать общую базу знаний и не писать каждый раз всё с нуля, а использовать готовые наработки.</li>
        <li>Работая в одной команде, разработчики, менеджеры, дизайнеры и верстальщики должны называть одни и те же вещи одинаково. То есть говорить на одном языке.</li>
        <li>Команды могут обмениваться специалистами для реализации какой-то конкретной функциональности.</li>
        <li>Порог входа при переходе на новый проект должен быть снижен за счет одинаковой структуры организации всех БЭМ-проектов и одинаковых правил именования всех сущностей.</li>
    </ul>
    <p>Мы стремились к тому, чтобы с увеличением числа разработчиков улучшалось и качество продукта. Это значит, что разработчики должны быть в курсе работы друг друга и не изобретать заново то, что уже реализовано. Мы хотели создать единую команду, которая работает над разными проектами.</p>
    <h3>Мы стремились к тому, чтобы с увеличением числа разработчиков улучшалось и качество продукта. Это значит, что разработчики должны быть в курсе работы друг друга и не изобретать заново то, что уже реализовано. Мы хотели создать единую команду, которая работает над разными проектами.</h3>
    <p>Технологии (HTML, CSS, JavaScript), которые мы использовали, изменялись в зависимости от требований проекта, а принципы БЭМ должны были быть универсальны.</p>
    <p>Мы сформулировали основные правила, по которым будут жить и развиваться наши проекты, и которые никак не будут зависеть от технологий и инструментов.</p>
    <p>Чтобы ускорить разработку, необходимо было облегчить поддержку HTML и CSS отдельных компонентов страницы, сделать код менее связанным. Для этого мы разбили страницу на части. Так появилось новое понятие — блок. </p>
    <p>Блок мог состоять из различных элементов, которые не использовались вне самого блока. Состояния и поведение блока и элемента можно было задавать с помощью модификатора.</p>
    <p>Это были три ключевых понятия, на которых основывалось большинство правил. Аббревиатура от трех слов Блок, Элемент и Модификатор стала названием методологии — БЭМ.</p>
    <h3>Блок</h3>
    <p>Логически и функционально независимый компонент страницы. Блок полностью самодостаточен: у него может быть свое поведение, шаблоны, стили, документация и не только. Блоки могут использоваться в любом месте страницы, повторно, даже в другом проекте.</p>
    <p>Одни блоки можно вкладывать в другие, компоновать, использовать для создания более сложных блоков.</p>
    <h3>Элемент</h3>
    <p>Часть блока, которая не может использоваться в отрыве от него и имеет смысл только в рамках своего родителя. Элементы могут быть обязательными и опциональными.</p>
    <p>Работая с элементами, важно помнить правило: не рекомендуется создавать элементы элементов. Если вложить один элемент в другой, будет невозможно изменить внутреннюю структуру блока: элементы нельзя будет поменять местами, удалить или добавить без корректировки существующего кода.</p>
    <h3>Модификатор</h3>
    <p>Свойство блока или элемента, которое меняет их внешний вид, состояние или поведение.</p>
    <p>Модификатор имеет имя и может иметь значение. Использование модификаторов опционально. У блока/элемента может быть несколько разных модификаторов одновременно.</p>
    <p>Так, например, с помощью модификатора можно изменить не только цвет меча, но и его функциональность (как показано в случае с красным мечом):</p>
    <p>Так, например, с помощью модификатора можно изменить не только цвет меча, но и его функциональность (как показано в случае с красным мечом):</p>
    <ul>
        <li>тегов;</li>
        <li>вложенных селекторов;</li>
        <li>глобального сброса правил для всей страницы.</li>
    </ul>
    <p>Важной определяющей сущностью в именовании селекторов стал блок:</p>
    <ul>
        <li>Полное имя элемента/модификатора формируется так, чтобы из него можно было определить принадлежность данного элемента/модификатора к конкретному блоку.</li>
        <li>По имени модификатора элемента должно быть возможно определить принадлежность данного модификатора к конкретному элементу конкретного блока.</li>
    </ul>
    <h3>Правила формирования имени БЭМ-сущности</h3>
    <ul>
        <li>Каждая БЭМ-сущность должна иметь свой класс.</li>
        <li>CSS-свойства для блоков, элементов и модификаторов описываются только через классы.</li>
        <li>Для разделения слов в именах используется дефис (-).</li>
        <li>Элемент отделяется от блока двумя подчеркиваниями (__). Модификатор — одним (_).</li>
        <li>Имена БЭМ-сущностей записываются с помощью цифр и латинских букв в нижнем регистре.</li>
    </ul>
    <p>Мы долго экспериментировали с префиксами в именах, но в итоге отказались от них.</p>
    <p>Пример</p>
    <ul>
        <li>Имя блока — header.</li>
        <li>Имя элемента блока — header__search-form — элемент search-form блока header.</li>
        <li>Имя модификатора блока — header_theme_green-forest — модификатор theme в значении green-forest блока header. </li>
        <li>Имя модификатора элемента — header__search-form_disabled — булев модификатор disabled элемента search-form блока header.</li>
    </ul>
    <p>HTML</p>
    <pre><code data-language="html">
&lt;div class=&quot;header header_theme_green-forest&quot;&gt;
    ...
&lt;/div&gt;
</code></pre>
    <p>Существует ряд альтернативных схем именования. Выбор всегда остается за вами.</p>
    <p>Но мы рекомендуем придерживаться описанной выше схемы, так как инструменты БЭМ-платформы умеют работать именно с данным вариантом именования.</p>
    <h3>БЭМ в HTML</h3>
    <p>Мы хотели упорядочить HTML и в итоге пришли к тому, что больше не пишем HTML руками. Подробнее читайте в разделе про описание инструментов БЭМ.</p>
    <p>В HTML каждая БЭМ-сущность определяется своим классом.</p>
    <pre><code data-language="html"><div class="block-name">&lt;div class=&quot;block-name__elem&quot;&gt;&lt;/div&gt;...&lt;/div&gt;</code></pre>
    <p>В простейшем случае блок соответствует DOM-узлу, один к одному. Но DOM-узел и блок — это не всегда одно и то же. На одном DOM-узле может совмещаться несколько сущностей. Это называется миксом.</p>
    <p>В простейшем случае блок соответствует DOM-узлу, один к одному. Но DOM-узел и блок — это не всегда одно и то же. На одном DOM-узле может совмещаться несколько сущностей. Это называется миксом.</p>
    <ul>
        <li> объединять поведение и стили нескольких БЭМ-сущностей без дублирования кода; </li>
        <li>создавать семантически новые компоненты интерфейса на основе имеющихся блоков, элементов и модификаторов;</li>
        <li>задавать позицию вложенного блока в родительском, не создавая дополнительных модификаторов. Подробнее, о том, как создавать обёртки в HTML, читайте на форуме.</li>
    </ul>
    <h4>Пример</h4>
    <p>В проекте кнопки реализованы блоком button. Необходимо поместить кнопку в форму поиска (search-form) и задать для кнопки отступы. Для этого воспользуемся миксом блока button и элемента button блока search-form:</p>
    <pre><code data-language="html"><div class="block-name">&lt;div class=&quot;search-form&quot;&gt;    &lt;div class=&quot;button search-form__button&quot;&gt;&lt;/div&gt;&lt;/div&gt;</code></pre>
    <p>Микс позволяет использовать универсальную кнопку, которая ничего не знает об отступах от границ конкретной формы. В данном случае в форме поиска есть элемент search-form__button, который знает, где ему надо находиться, и блок button, который нужно отображать.</p>
    <p>Вместо микса можно создать дополнительный модификатор блоку button, но мы не рекомендуем этот способ, так как позиционирование блока button по смыслу не является частью универсального блока, а подходит только для его конкретного места использования</p>
</main>