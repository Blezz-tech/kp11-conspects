<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE tmx SYSTEM "tmx11.dtd">
<tmx version="1.1">
  <header creationtool="OmegaT" o-tmf="OmegaT TMX" adminlang="EN-US" datatype="plaintext" creationtoolversion="5.7.1_0_c3206253" segtype="sentence" srclang="en-US"/>
  <body>
<!-- Default translations -->
    <tu>
      <tuv lang="en-US">
        <seg>![[LYHfGG_10_cowboy.png]]</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230617T083014Z" creationid="jenya" creationdate="20230617T083014Z">
        <seg>![[LYHfGG_10_cowboy.png]]</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>![[LYHfGG_11_kermit.png]]</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230617T091157Z" creationid="jenya" creationdate="20230617T091157Z">
        <seg>![[LYHfGG_11_kermit.png]]</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>![[LYHfGG_13_tuple.png]]</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230617T111031Z" creationid="jenya" creationdate="20230617T111031Z">
        <seg>![[LYHfGG_13_tuple.png]]</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>![[LYHfGG_14_pythag.png]]</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230617T114234Z" creationid="jenya" creationdate="20230617T114234Z">
        <seg>![[LYHfGG_14_pythag.png]]</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>![[LYHfGG_15_cow.png]]</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230617T115601Z" creationid="jenya" creationdate="20230617T115601Z">
        <seg>![[LYHfGG_15_cow.png]]</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>![[LYHfGG_16_bomb.png]]</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230618T144656Z" creationid="jenya" creationdate="20230618T144656Z">
        <seg>![[LYHfGG_16_bomb.png]]</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>![[LYHfGG_17_box.png]]</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230618T151638Z" creationid="jenya" creationdate="20230618T151638Z">
        <seg>![[LYHfGG_17_box.png]]</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>![[LYHfGG_18_classes.png]]</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230618T155554Z" creationid="jenya" creationdate="20230618T155554Z">
        <seg>![[LYHfGG_18_classes.png]]</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>![[LYHfGG_1_bird.png]]</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230611T220409Z" creationid="jenya" creationdate="20230611T220409Z">
        <seg>![[LYHfGG_1_bird.png]]</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>![[LYHfGG_2_fx.png]]</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230611T220414Z" creationid="jenya" creationdate="20230611T220414Z">
        <seg>![[LYHfGG_2_fx.png]]</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>![[LYHfGG_3_lazy.png]]</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230615T170848Z" creationid="jenya" creationdate="20230615T170848Z">
        <seg>![[LYHfGG_3_lazy.png]]</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>![[LYHfGG_4_boat.png]]</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230615T172750Z" creationid="jenya" creationdate="20230615T172750Z">
        <seg>![[LYHfGG_4_boat.png]]</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>![[LYHfGG_5_startingout.png]]</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230615T174426Z" creationid="jenya" creationdate="20230615T174426Z">
        <seg>![[LYHfGG_5_startingout.png]]</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>![[LYHfGG_6_ringring.png]]</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230616T100953Z" creationid="jenya" creationdate="20230616T100953Z">
        <seg>![[LYHfGG_6_ringring.png]]</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>![[LYHfGG_7_baby.png]]</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230616T173854Z" creationid="jenya" creationdate="20230616T173854Z">
        <seg>![[LYHfGG_7_baby.png]]</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>![[LYHfGG_8_list.png]]</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230617T074531Z" creationid="jenya" creationdate="20230617T074531Z">
        <seg>![[LYHfGG_8_list.png]]</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>![[LYHfGG_9_listmonster.png]]</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230617T080615Z" creationid="jenya" creationdate="20230617T080615Z">
        <seg>![[LYHfGG_9_listmonster.png]]</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg># Functionally Solving Problems</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230613T160057Z" creationid="jenya" creationdate="20230613T160057Z">
        <seg># Functionally Solving Problems</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg># Higher order functions</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230613T160006Z" creationid="jenya" creationdate="20230613T160006Z">
        <seg># Higher order functions</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg># Introduction</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230610T211504Z" creationid="jenya" creationdate="20230610T211504Z">
        <seg># Введение</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg># Modules</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230613T160009Z" creationid="jenya" creationdate="20230613T160009Z">
        <seg># Modules</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg># Starting Out</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230615T174400Z" creationid="jenya" creationdate="20230615T174354Z">
        <seg># Начиная</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg># Syntax in Functions</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230619T113713Z" creationid="jenya" creationdate="20230619T113713Z">
        <seg># Синтаксис в функциях</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg># Translator's footnotes</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230617T115530Z" creationid="jenya" creationdate="20230617T115530Z">
        <seg># Сноски переводчика</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg># Types and Typeclasses</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230617T115557Z" creationid="jenya" creationdate="20230617T115549Z">
        <seg># Типы и классы типов</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>## About this tutorial</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230612T110356Z" creationid="jenya" creationdate="20230610T211543Z">
        <seg>## Об этом учебном пособии</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>## An intro to lists</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230617T074513Z" creationid="jenya" creationdate="20230617T074513Z">
        <seg>## Введение в списки</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>## Baby's first functions</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230616T132603Z" creationid="jenya" creationdate="20230616T132603Z">
        <seg>## Первые детские функции</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>## Believe the type</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230617T115600Z" creationid="jenya" creationdate="20230617T115600Z">
        <seg>## Верьте типу</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>## Guards, guards!</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230619T124540Z" creationid="jenya" creationdate="20230619T124540Z">
        <seg>## Стража, стража!</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>## I'm a list comprehension</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230617T121032Z" creationid="jenya" creationdate="20230617T091156Z">
        <seg>## Я - списковое включение (англ. _list comprehension_)

Списковое включение^[Альтернативное название, более понятное программистам "генераторы списков". Но использую по [вики](https://ru.wikipedia.org/wiki/%D0%A1%D0%BF%D0%B8%D1%81%D0%BA%D0%BE%D0%B2%D0%BE%D0%B5_%D0%B2%D0%BA%D0%BB%D1%8E%D1%87%D0%B5%D0%BD%D0%B8%D0%B5#:~:text=%D0%90%D0%B1%D1%81%D1%82%D1%80%D0%B0%D0%BA%D1%86%D0%B8%D1%8F%20%D1%81%D0%BF%D0%B8%D1%81%D0%BA%D0%BE%D0%B2%20%D0%B8%D0%BB%D0%B8%20%D1%81%D0%BF%D0%B8%D1%81%D0%BA%D0%BE%D0%B2%D0%BE%D0%B5%20%D0%B2%D0%BA%D0%BB%D1%8E%D1%87%D0%B5%D0%BD%D0%B8%D0%B5,%D0%BA%D0%BE%D0%BC%D0%BF%D0%B0%D0%BA%D1%82%D0%BD%D0%BE%D0%B3%D0%BE%20%D0%BE%D0%BF%D0%B8%D1%81%D0%B0%D0%BD%D0%B8%D1%8F%20%D0%BE%D0%BF%D0%B5%D1%80%D0%B0%D1%86%D0%B8%D0%B9%20%D0%BE%D0%B1%D1%80%D0%B0%D0%B1%D0%BE%D1%82%D0%BA%D0%B8%20%D1%81%D0%BF%D0%B8%D1%81%D0%BA%D0%BE%D0%B2.)) ]</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>## Pattern matching</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230619T113801Z" creationid="jenya" creationdate="20230619T113801Z">
        <seg>## Соответствие шаблону</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>## Ready, set, go!</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230616T092759Z" creationid="jenya" creationdate="20230615T174352Z">
        <seg>## На старт, внимание, марш!</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>## So what's Haskell?</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230615T174228Z" creationid="jenya" creationdate="20230615T165018Z">
        <seg>## Итак, что такое Haskell?</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>## Texas ranges</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230617T083056Z" creationid="jenya" creationdate="20230617T083010Z">
        <seg>## Техасские диапазоны</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>## Tuples</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230617T111029Z" creationid="jenya" creationdate="20230617T111029Z">
        <seg>## Кортежи</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>## Type variables</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230618T151605Z" creationid="jenya" creationdate="20230618T151605Z">
        <seg>## Переменные типа</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>## Typeclasses 101</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230618T155551Z" creationid="jenya" creationdate="20230618T155551Z">
        <seg>## Классы типов 101</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>## What you need to dive in</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230615T173615Z" creationid="jenya" creationdate="20230615T173615Z">
        <seg>## Во что вам нужно погрузиться</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>## Where!?</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230619T130947Z" creationid="jenya" creationdate="20230619T130947Z">
        <seg>## Где!?</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>1
33.2
```</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230617T075513Z" creationid="jenya" creationdate="20230617T075513Z">
        <seg>1
33.2
```</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>1]
[0.1,0.3,0.5,0.7,0.8999999999999999,1.0999999999999999]
```</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230617T090733Z" creationid="jenya" creationdate="20230617T090733Z">
        <seg>1]
[0.1,0.3,0.5,0.7,0.8999999999999999,1.0999999999999999]
```</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>2
[1,2,2,3,4] 
```</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230617T075926Z" creationid="jenya" creationdate="20230617T075926Z">
        <seg>2
[1,2,2,3,4] 
```</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>25 to 30 is overweight and more than 30 is obese.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230619T125622Z" creationid="jenya" creationdate="20230619T125622Z">
        <seg>От 25 до 30 - это избыточный вес, а более 30 - ожирение.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>5]
[3,4,5]
ghci&gt; succ 'B'
'C'
```</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230618T183912Z" creationid="jenya" creationdate="20230618T183912Z">
        <seg>5]
[3,4,5]
ghci&gt; succ 'B'
'C'
```</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>5] ["one", "two", "three", "four", "five"]
[(1,"one"),(2,"two"),(3,"three"),(4,"four"),(5,"five")]
```</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230617T112621Z" creationid="jenya" creationdate="20230617T112621Z">
        <seg>5] ["one", "two", "three", "four", "five"]
[(1,"one"),(2,"two"),(3,"three"),(4,"four"),(5,"five")]
```</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>6
'B'
ghci&gt; [9.4,33.2,96.2,11.2,23.25] !!</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230617T075512Z" creationid="jenya" creationdate="20230617T075512Z">
        <seg>6
'B'
ghci&gt; [9.4,33.2,96.2,11.2,23.25] !!</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>&gt; **Note** Not only can we call functions as infix with backticks, we can also define them using backticks.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230619T130918Z" creationid="jenya" creationdate="20230619T130914Z">
        <seg>&gt; **Примечание** Мы можем не только вызывать функции как инфиксные с обратными указателями, мы также можем определять их с помощью обратных указателей.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>&gt; **Note** these functions operate only on pairs.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230617T112448Z" creationid="jenya" creationdate="20230617T112448Z">
        <seg>&gt; **Примечание** эти функции работают только с парами.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>&gt; **Note**: The `x:xs` pattern is used a lot, especially with recursive functions.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230619T121356Z" creationid="jenya" creationdate="20230619T121356Z">
        <seg>&gt; **Примечание**: Шаблон `x:xs` используется часто, особенно с рекурсивными функциями.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>&gt; **Note**: We can use the `let` keyword to define a name right in GHCI.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230617T074816Z" creationid="jenya" creationdate="20230617T074816Z">
        <seg>&gt; **Примечание**: Мы можем использовать ключевое слово `let` для определения имени прямо в GHCI.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>&gt; **Note**: the equality operator, `==` is a function.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230618T160226Z" creationid="jenya" creationdate="20230618T160226Z">
        <seg>&gt; **Примечание**: оператор равенства `==` является функцией.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>&gt; **Note:** `[]`, `[[]]` and `[[],[],[]]` are all different things.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230617T075445Z" creationid="jenya" creationdate="20230617T075445Z">
        <seg>&gt; **Примечание:** `[]`, `[[]]` и `[[],[],[]]` это все разные вещи.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>A basic comprehension for a set that contains the first ten even natural numbers is $$S = \{2\ \cdot\ x\ |\ x \in \mathbb{N},\ x \leqslant 10\}$$.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230617T103155Z" creationid="jenya" creationdate="20230617T092953Z">
        <seg>Базовое списковое включение для набора, содержащего первые десять четных натуральных чисел, составляет^[Я не знаю какая запись более правильная для русской традиции записи. Поэтому оставил как в оригинале] $$S = \{2\ \cdot\ x\ |\ x \in \mathbb{N},\ x \leqslant 10\}$$.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>A common task is putting two lists together.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230617T075057Z" creationid="jenya" creationdate="20230617T075057Z">
        <seg>Обычная задача - собрать два списка воедино.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>A cool function that produces a list of pairs: `zip`.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230617T112531Z" creationid="jenya" creationdate="20230617T112531Z">
        <seg>Классная функция, которая выдает список пар: `zip`.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>A guard is basically a boolean expression.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230619T125923Z" creationid="jenya" creationdate="20230619T125912Z">
        <seg>Охранные выражения - это, по сути, логическое выражение.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>A handful of functions that produce infinite lists:</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230617T090923Z" creationid="jenya" creationdate="20230617T090923Z">
        <seg>Несколько функций, которые создают бесконечные списки:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>A list contains several lists of numbers.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230617T110837Z" creationid="jenya" creationdate="20230617T110837Z">
        <seg>Список содержит несколько списков чисел.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>A list of characters is a string.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230618T151115Z" creationid="jenya" creationdate="20230618T151115Z">
        <seg>Список символов представляет собой строку.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>A list of numbers is a list of numbers.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230617T111520Z" creationid="jenya" creationdate="20230617T111520Z">
        <seg>Список чисел - это список чисел.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>A list produced by a comprehension that draws from two lists of length 4 will have a length of 16, provided we don't filter them.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230617T105711Z" creationid="jenya" creationdate="20230617T105711Z">
        <seg>Список, созданный с помощью спискового включения, который основывается на двух списках длиной 4, будет иметь длину 16, при условии, что мы их не фильтруем.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>A little pitfall to watch out for here is negating numbers.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230616T095709Z" creationid="jenya" creationdate="20230616T095709Z">
        <seg>Небольшая ошибка, на которую следует обратить внимание здесь, - это отрицание чисел.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>A lot of people coming from OOP get confused by typeclasses because they think they are like classes in object oriented languages.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230618T160138Z" creationid="jenya" creationdate="20230618T160050Z">
        <seg>Многие люди, пришедшие из ООП, путаются в классах типов, потому что думают, что они похожи на классы в объектно-ориентированных языках.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>A pattern like `x:xs` will bind the head of the list to `x` and the rest of it to `xs`, even if there's only one element so `xs` ends up being an empty list.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230619T121150Z" creationid="jenya" creationdate="20230619T121150Z">
        <seg>Шаблон типа `x:xs` привяжет начало списка к `x`, а остальную его часть к `xs`, даже если есть только один элемент, так что `xs` окажется пустым списком.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>A singleton tuple would just be the value it contains and as such would have no benefit to us.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230617T112404Z" creationid="jenya" creationdate="20230617T112404Z">
        <seg>Одноэлементный кортеж был бы просто значением, которое он содержит, и как таковой не принес бы нам никакой пользы.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>A text editor and a Haskell compiler.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230615T173622Z" creationid="jenya" creationdate="20230615T173622Z">
        <seg>Текстовый редактор и компилятор Haskell.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>A type is a kind of label that every expression has.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230618T144355Z" creationid="jenya" creationdate="20230618T144355Z">
        <seg>Тип - это своего рода метка, которая есть у каждого выражения.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>A typeclass is a sort of interface that defines some behavior.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230618T155756Z" creationid="jenya" creationdate="20230618T155756Z">
        <seg>Класс типов - это своего рода интерфейс, который определяет определенное поведение.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>A very useful function for dealing with numbers is `fromIntegral`.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230618T190612Z" creationid="jenya" creationdate="20230618T190612Z">
        <seg>Очень полезная функция для работы с числами - `fromIntegral`.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Again, all types covered so far are in this typeclass.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230618T180951Z" creationid="jenya" creationdate="20230618T180951Z">
        <seg>Опять же, все рассмотренные до сих пор типы находятся в этом классе типов.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Ahahaha!"
"HA"
ghci&gt; removeNonUppercase "IdontLIKEFROGS"
"ILIKEFROGS" 
```</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230617T110529Z" creationid="jenya" creationdate="20230617T110529Z">
        <seg>Ahahaha!"
"HA"
ghci&gt; removeNonUppercase "IdontLIKEFROGS"
"ILIKEFROGS" 
```</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>All standard Haskell types except for IO (the type for dealing with input and output) and functions are a part of the `Eq` typeclass.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230618T160731Z" creationid="jenya" creationdate="20230618T160731Z">
        <seg>Все стандартные типы Haskell, за исключением ввода-вывода (тип для работы с вводом и выводом) и функций, являются частью класса типов `Eq`.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>All the types we covered so far except for functions are part of `Ord`.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230618T161126Z" creationid="jenya" creationdate="20230618T161126Z">
        <seg>Все типы, которые мы рассмотрели до сих пор, за исключением функций, являются частью `Ord`.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>All the types we mentioned previously except for functions are part of `Eq`, so they can be tested for equality.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230618T161112Z" creationid="jenya" creationdate="20230618T161112Z">
        <seg>Все типы, которые мы упоминали ранее, за исключением функций, являются частью `Eq`, поэтому их можно проверить на равенство.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>All tuples are also part of `Bounded` if the components are also in it.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230618T184414Z" creationid="jenya" creationdate="20230618T184414Z">
        <seg>Все кортежи также являются частью `Bounded`, если компоненты также находятся в нем.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>All types covered so far except for functions are a part of `Show`.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230618T180723Z" creationid="jenya" creationdate="20230618T180723Z">
        <seg>Все рассмотренные до сих пор типы, за исключением функций, являются частью `Показать`.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Alright, let's get started!</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230615T174436Z" creationid="jenya" creationdate="20230615T174427Z">
        <seg>Хорошо, давайте начнем!</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Also note that we've taken care of all possible patterns of a list.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230619T122644Z" creationid="jenya" creationdate="20230619T122644Z">
        <seg>Также обратите внимание, что мы позаботились обо всех возможных шаблонах списка.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Also notice the `error` function that we used.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230619T121936Z" creationid="jenya" creationdate="20230619T121936Z">
        <seg>Также обратите внимание на функцию `error`, которую мы использовали.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Although I bet that even if you don't have any significant programming experience, a smart person such as yourself will be able to follow along and learn Haskell.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230615T164243Z" creationid="jenya" creationdate="20230615T164243Z">
        <seg>Хотя я готов поспорить, что даже если у вас нет сколько-нибудь значительного опыта в программировании, такой умный человек, как вы, сможет последовать примеру и изучить Haskell.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Although it's simpler to just use the `replicate` function if you want some number of the same element in a list.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230617T091050Z" creationid="jenya" creationdate="20230617T091050Z">
        <seg>Хотя проще просто использовать функцию `replicate`, если вам нужно некоторое количество одного и того же элемента в списке.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Although type variables can have names longer than one character, we usually give them names of a, b, c, d …</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230618T154523Z" creationid="jenya" creationdate="20230618T154523Z">
        <seg>Хотя имена переменных типа могут быть длиннее одного символа, мы обычно присваиваем им имена a, b, c, d ...</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Ambiguous type variable `a' in the constraint:</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230618T181152Z" creationid="jenya" creationdate="20230618T181152Z">
        <seg>Ambiguous type variable `a' in the constraint:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>An expression is basically a piece of code that returns a value.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230617T073553Z" creationid="jenya" creationdate="20230617T073553Z">
        <seg>Выражение - это, по сути, фрагмент кода, который возвращает значение.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>And here it sees you just want the first 24 elements and it gladly obliges.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230617T090913Z" creationid="jenya" creationdate="20230617T090913Z">
        <seg>И вот он видит, что вам нужны только первые 24 элемента, и с радостью соглашается.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>And now, a list!</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230617T074750Z" creationid="jenya" creationdate="20230617T074750Z">
        <seg>А теперь список!</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>And secondly because some sequences that aren't arithmetic are ambiguous if given only by a few of their first terms.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230617T090704Z" creationid="jenya" creationdate="20230617T090704Z">
        <seg>А во-вторых, потому что некоторые последовательности, которые не являются арифметическими, неоднозначны, если заданы только несколькими их первыми членами.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>And shorter programs are easier to maintain than longer ones and have less bugs.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230615T173443Z" creationid="jenya" creationdate="20230615T173443Z">
        <seg>А более короткие программы легче поддерживать, чем более длинные, и в них меньше ошибок.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>And there's our answer!</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230617T114948Z" creationid="jenya" creationdate="20230617T114948Z">
        <seg>И вот наш ответ!</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>And we also know that the sum of a list is the head plus the sum of the rest of the list.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230619T123330Z" creationid="jenya" creationdate="20230619T123330Z">
        <seg>И мы также знаем, что сумма списка - это глава плюс сумма остальной части списка.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>And we've defined `length' []` to be `0`.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230619T123314Z" creationid="jenya" creationdate="20230619T123314Z">
        <seg>И мы определили `length' []` равным `0`.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Another key difference is that they don't have to be homogenous.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230617T111547Z" creationid="jenya" creationdate="20230617T111547Z">
        <seg>Еще одно ключевое отличие заключается в том, что они не обязательно должны быть однородными.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Another thing about the if statement in Haskell is that it is an _expression_.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230617T073657Z" creationid="jenya" creationdate="20230617T073415Z">
        <seg>Еще одна особенность оператора `if` в Haskell заключается в том, что оператор является _выражением_ .</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Another very simple example: let's implement our own `max` function.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230619T130712Z" creationid="jenya" creationdate="20230619T130712Z">
        <seg>Еще один очень простой пример: давайте реализуем нашу собственную функцию `max`.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Any type where it makes sense to test for equality between two values of that type should be a member of the `Eq` class.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230618T160723Z" creationid="jenya" creationdate="20230618T160723Z">
        <seg>Любой тип, в котором имеет смысл проверять равенство между двумя значениями этого типа, должен быть членом класса `Eq`.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Anyway, if we try to get a length of a list and then add it to `3.2`, we'll get an error because we tried to add together an `Int` and a floating point number.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230618T191145Z" creationid="jenya" creationdate="20230618T191145Z">
        <seg>В любом случае, если мы попытаемся получить длину списка, а затем добавить его к `3.2`, мы получим ошибку, потому что мы пытались сложить вместе `Int` и число с плавающей запятой.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>As expected, the length of the new list is 9.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230617T105812Z" creationid="jenya" creationdate="20230617T105812Z">
        <seg>Как и ожидалось, длина нового списка равна 9.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>As expected, you can call your own functions from other functions that you made.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230616T163025Z" creationid="jenya" creationdate="20230616T163005Z">
        <seg>Как и ожидалось, вы можете вызывать свои собственные функции из других созданных вами функций.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>As seen in this example, tuples can also contain lists.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230617T112126Z" creationid="jenya" creationdate="20230617T112126Z">
        <seg>Как видно из этого примера, кортежи также могут содержать списки.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>As you can see, lists are denoted by square brackets and the values in the lists are separated by commas.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230617T074848Z" creationid="jenya" creationdate="20230617T074848Z">
        <seg>Как вы можете видеть, списки заключены в квадратные скобки, а значения в списках разделены запятыми.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>As you can see, we get the desired results.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230617T102051Z" creationid="jenya" creationdate="20230617T102051Z">
        <seg>Как вы можете видеть, мы получаем желаемые результаты.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>As you can see, we just separate the function name from the parameter with a space.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230616T105256Z" creationid="jenya" creationdate="20230616T104803Z">
        <seg>Как вы можете видеть, мы просто отделяем имя функции от параметра пробелом.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>As you probably know, `&amp;&amp;` means a boolean _and_, `||` means a boolean _or_.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230616T095805Z" creationid="jenya" creationdate="20230616T095805Z">
        <seg>Как вы, вероятно, знаете, `&amp;&amp;` означает логическое _И_, `||` означает логическое _ИЛИ_ .</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>As you've seen, we call it by sandwiching it between them.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230616T100808Z" creationid="jenya" creationdate="20230616T100808Z">
        <seg>Как вы видели, мы вызываем это, помещая его между ними.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>At first, this seems kind of limiting but it actually has some very nice consequences: if a function is called twice with the same parameters, it's guaranteed to return the same result.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230615T170732Z" creationid="jenya" creationdate="20230615T170732Z">
        <seg>На первый взгляд это кажется своего рода ограничением, но на самом деле это имеет некоторые очень приятные последствия: если функция вызывается дважды с одними и теми же параметрами, она гарантированно возвращает один и тот же результат.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Because Haskell is lazy, it won't try to evaluate the infinite list immediately because it would never finish.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230617T090844Z" creationid="jenya" creationdate="20230617T090844Z">
        <seg>Поскольку Haskell ленив, он не будет пытаться оценить бесконечный список немедленно, потому что он никогда не завершится.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Because Haskell is lazy, we can zip finite lists with infinite lists:</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230617T114125Z" creationid="jenya" creationdate="20230617T114125Z">
        <seg>Поскольку Haskell ленив, мы можем объединять конечные списки с бесконечными списками:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Because `'` is a valid character in functions, we can make a function like this.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230617T073859Z" creationid="jenya" creationdate="20230617T073859Z">
        <seg>Поскольку `'` является допустимым символом в функциях, мы можем создать функцию, подобную этой.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Because `+` works on integers as well as on floating-point numbers (anything that can be considered a number, really), our function also works on any number.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230616T162708Z" creationid="jenya" creationdate="20230616T162708Z">
        <seg>Поскольку `+` работает как с целыми числами, так и с числами с плавающей запятой (все, что на самом деле можно считать числом), наша функция также работает с любым числом.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Because `head` takes a list of any type and returns the first element, so what could it be?</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230618T151617Z" creationid="jenya" creationdate="20230618T151617Z">
        <seg>Поскольку `head` принимает список любого типа и возвращает первый элемент, так что же это может быть?</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Because it isn't, it falls through to the next guard.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230619T130105Z" creationid="jenya" creationdate="20230619T125945Z">
        <seg>Поскольку это не так, это переходит к следующему охранному выражению.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Because it isn't, it falls through to the second pattern.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230619T123004Z" creationid="jenya" creationdate="20230619T123004Z">
        <seg>Поскольку это не так, это подпадает под второй шаблон.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Because it uses a lot of high level concepts, Haskell programs are usually shorter than their imperative equivalents.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230615T173430Z" creationid="jenya" creationdate="20230615T173430Z">
        <seg>Поскольку в нем используется много высокоуровневых концепций, программы на Haskell обычно короче своих императивных эквивалентов.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Because it's not in capital case it's actually a **type variable**.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230618T151803Z" creationid="jenya" creationdate="20230618T151745Z">
        <seg>Поскольку это не прописная буква, на самом деле это **переменная типа** (англ. **type variable**).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Because strings are lists, we can use list functions on them, which is really handy.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230617T075048Z" creationid="jenya" creationdate="20230617T075048Z">
        <seg>Поскольку строки представляют собой списки, мы можем использовать для них функции списка, что действительно удобно.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Because the else is mandatory, an if statement will always return something and that's why it's an expression.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230617T073645Z" creationid="jenya" creationdate="20230617T073642Z">
        <seg>Поскольку `else` является обязательным, оператор `if` всегда будет возвращать что-то, и именно поэтому это выражение.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Because they are not completely precise (by definition), their use in ranges can yield some pretty funky results.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230617T090730Z" creationid="jenya" creationdate="20230617T090730Z">
        <seg>Поскольку они не являются полностью точными (по определению), их использование в диапазонах может привести к довольно странным результатам.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Because we can't change what names (and functions) mean once we've defined them, `conanO'Brien` and the string `"It's a-me, Conan O'Brien!"` can be used interchangeably.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230617T074452Z" creationid="jenya" creationdate="20230617T074401Z">
        <seg>Поскольку мы не можем изменить значение имен (и функций), как только мы их определили, `conanO'Brien` и строка `"It's a-me, Conan O'Brien!"` могут использоваться взаимозаменяемо.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Boolean algebra is also pretty straightforward.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230616T095745Z" creationid="jenya" creationdate="20230616T095745Z">
        <seg>Булева алгебра также довольно проста.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>But Haskell just called me ugly.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230619T130626Z" creationid="jenya" creationdate="20230619T130626Z">
        <seg>Но Хаскелл только что назвал меня уродиной.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>But a tuple of size two (also called a pair) is its own type, which means that a list can't have a couple of pairs in it and then a triple (a tuple of size three), so let's use that instead.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230617T111727Z" creationid="jenya" creationdate="20230617T111727Z">
        <seg>Но кортеж второго размера (также называемый парой) имеет свой собственный тип, что означает, что в списке не может быть пары пар, а затем тройки (кортеж третьего размера), поэтому давайте используем кортеж вместо списка.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>But calling `head` on an empty list doesn't make sense.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230619T122017Z" creationid="jenya" creationdate="20230619T122017Z">
        <seg>Но вызывать `head` в пустом списке не имеет смысла.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>But how do we write out the type of a function that takes several parameters?</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230618T145456Z" creationid="jenya" creationdate="20230618T145456Z">
        <seg>Но как нам записать тип функции, которая принимает несколько параметров?</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>But if you try to get the sixth element from a list that only has four elements, you'll get an error so be careful!</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230617T075556Z" creationid="jenya" creationdate="20230617T075556Z">
        <seg>Но если вы попытаетесь получить шестой элемент из списка, состоящего всего из четырех элементов, вы получите сообщение об ошибке, так что будьте осторожны!</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>But in a nutshell, this is what happens if we try to get the factorial of, say, 3.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230619T114727Z" creationid="jenya" creationdate="20230619T114727Z">
        <seg>Но в двух словах, это то, что произойдет, если мы попытаемся получить факториал, скажем, 3.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>But now, it knows we want some type that is part of the `Read` class, it just doesn't know which one.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230618T181349Z" creationid="jenya" creationdate="20230618T181349Z">
        <seg>Но теперь он знает, что нам нужен какой-то тип, который является частью класса `Read`, он просто не знает, какой именно.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>But once you want to see the result, the first `doubleMe` tells the second one it wants the result, now!</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230615T172425Z" creationid="jenya" creationdate="20230615T172425Z">
        <seg>Но как только вы захотите увидеть результат, первая "двойная строка" сообщит второй, что она хочет получить результат, сейчас же!</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>But patterns that have `:` in them only match against lists of length 1 or more.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230619T121400Z" creationid="jenya" creationdate="20230619T121400Z">
        <seg>Но шаблоны, в которых есть `:`, совпадают только со списками длиной 1 или более.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>But putting something at the end of a list that's fifty million entries long is going to take a while.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230617T075219Z" creationid="jenya" creationdate="20230617T075219Z">
        <seg>Но для того, чтобы поместить что-то в конец списка длиной в пятьдесят миллионов записей, потребуется некоторое время.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>But since Haskell is a statically typed language, it has to know all the types before the code is compiled (or in the case of GHCI, evaluated).</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230618T183535Z" creationid="jenya" creationdate="20230618T183535Z">
        <seg>Но поскольку Haskell является статически типизированным языком, он должен знать все типы до того, как код будет скомпилирован (или, в случае GHCI, оценен).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>But since `[1,2,3]` is just syntactic sugar for `1:2:3:[]`, you can also use the former pattern.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230619T121143Z" creationid="jenya" creationdate="20230619T121143Z">
        <seg>Но поскольку `[1,2,3]` - это просто синтаксический сахар для `1:2:3:[]`, вы также можете использовать прежний шаблон.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>But sometimes, the compiler doesn't know whether to return a value of type `Int` or `Float` for an expression like `read "5"`.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230618T183511Z" creationid="jenya" creationdate="20230618T183511Z">
        <seg>Но иногда компилятор не знает, возвращать ли значение типа `Int` или `Float` для выражения типа `read "5"`.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>But the catch is that they both have to be the same type of thing.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230616T100350Z" creationid="jenya" creationdate="20230616T100350Z">
        <seg>Но загвоздка в том, что они оба должны быть одного типа.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>But then once it just "clicked" and after getting over that initial hurdle, it was pretty much smooth sailing.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230615T164811Z" creationid="jenya" creationdate="20230615T164811Z">
        <seg>Но затем, как только это просто "щелкнуло" и после преодоления этого первоначального препятствия, все прошло довольно гладко.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>But there's a better way: `take 24 [13,26..]`.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230617T090827Z" creationid="jenya" creationdate="20230617T090827Z">
        <seg>Но есть способ получше: `возьми 24 [13,26..]`.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>But to demonstrate, we could write `max'` like this:</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230619T130832Z" creationid="jenya" creationdate="20230619T130832Z">
        <seg>Но чтобы продемонстрировать, мы могли бы написать `max" вот так:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>But what about triples?</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230619T120509Z" creationid="jenya" creationdate="20230619T120509Z">
        <seg>Но как насчет троек?</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>But what happens if we try to do just `read "4"`?</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230618T180956Z" creationid="jenya" creationdate="20230618T180956Z">
        <seg>Но что произойдет, если мы попытаемся просто `прочитать "4"`?</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>But what happens if we try to get the head of an empty list?</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230617T080705Z" creationid="jenya" creationdate="20230617T080705Z">
        <seg>Но что произойдет, если мы попытаемся получить начало пустого списка?</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>But what if we didn't want doubles of the first 10 natural numbers but some kind of more complex function applied on them?</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230617T100157Z" creationid="jenya" creationdate="20230617T100157Z">
        <seg>Но что, если бы мы хотели получить не удвоения первых 10 натуральных чисел, а какую-то более сложную функцию, примененную к ним?</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>But what if we wanted a function that says the numbers from 1 to 5 and says `"Not between 1 and 5"` for any other number?</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230619T114230Z" creationid="jenya" creationdate="20230619T114148Z">
        <seg>Но что, если бы нам нужна была функция, которая произносит числа от 1 до 5 и говорит `"Не между 1 и 5"` для любого другого числа?</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>But what's this?</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230618T144909Z" creationid="jenya" creationdate="20230618T144909Z">
        <seg>Но что это такое?</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>But when defining functions, there's a `=` and after that we define what the function does.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230616T134836Z" creationid="jenya" creationdate="20230616T134836Z">
        <seg>Но при определении функций есть `=`, и после этого мы определяем, что делает функция.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>But when we call it like that, there may be some confusion as to which number is doing the division and which one is being divided.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230616T113756Z" creationid="jenya" creationdate="20230616T113756Z">
        <seg>Но когда мы называем это таким образом, может возникнуть некоторая путаница относительно того, какое число выполняет деление, а какое делится.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>By going through several resources, I was able put together the pieces and it all just came falling into place.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230615T164034Z" creationid="jenya" creationdate="20230615T164034Z">
        <seg>Просмотрев несколько ресурсов, я смог собрать воедино кусочки, и все просто встало на свои места.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Calling a function with several parameters is also simple.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230616T105301Z" creationid="jenya" creationdate="20230616T105301Z">
        <seg>Вызов функции с несколькими параметрами также прост.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Characters can also be enumerated.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230617T084630Z" creationid="jenya" creationdate="20230617T084630Z">
        <seg>Символы также могут быть пронумерованы.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Check this out:</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230619T120640Z" creationid="jenya" creationdate="20230619T120632Z">
        <seg>Оцени это:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Checking if it works:</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230619T121527Z" creationid="jenya" creationdate="20230619T121527Z">
        <seg>Проверка, работает ли это:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Congratulations, you're in GHCI!</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230616T093614Z" creationid="jenya" creationdate="20230616T093144Z">
        <seg>Поздравляю, вы находитесь в GHCI!</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Cool, it works.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230617T102339Z" creationid="jenya" creationdate="20230617T102339Z">
        <seg>Круто, это работает.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Doing `5 * -3` will make GHCI yell at you but doing `5 * (-3)` will work just fine.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230616T095740Z" creationid="jenya" creationdate="20230616T095740Z">
        <seg>Выполнение `5 * -3` заставит GHCI кричать на вас, но выполнение `5 * (-3)` будет работать просто отлично.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Doing `div 92 10` results in a 9.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230616T113733Z" creationid="jenya" creationdate="20230616T113733Z">
        <seg>Выполнение `div 92 10` приводит к получению 9.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Doing `let a = 1` inside GHCI is the equivalent of writing `a = 1` in a script and then loading it.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230617T074831Z" creationid="jenya" creationdate="20230617T074831Z">
        <seg>Выполнение `let a = 1` внутри GHCI эквивалентно записи `a = 1` в скрипте и последующей его загрузке.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Easy.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230617T102709Z" creationid="jenya" creationdate="20230617T102709Z">
        <seg>Легко.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Even if it wasn't `"llama"` but `"four"` or `"4"`, Haskell still wouldn't consider it to be a number.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230616T100127Z" creationid="jenya" creationdate="20230616T100127Z">
        <seg>Даже если бы это была не `"llama", а "four" или "4", Haskell все равно не счел бы это числом.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Even if you're adding an element to the end of a list with `++`, you have to surround it with square brackets so it becomes a list.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230617T075401Z" creationid="jenya" creationdate="20230617T075401Z">
        <seg>Даже если вы добавляете элемент в конец списка с помощью `++`, вы должны заключить его в квадратные скобки, чтобы он стал списком.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Everything before the `=&gt;` symbol is called a **class constraint**.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230618T160403Z" creationid="jenya" creationdate="20230618T160403Z">
        <seg>Все, что находится перед символом `=&gt;`, называется **ограничением класса** (англ. **class constraint**).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Everything in Haskell has a type, so the compiler can reason quite a lot about your program before compiling it.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230618T140208Z" creationid="jenya" creationdate="20230618T140208Z">
        <seg>Все в Haskell имеет тип, поэтому компилятор может довольно много рассуждать о вашей программе перед ее компиляцией.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Examining the type of `"HELLO!"` yields a `[Char]`.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230618T144926Z" creationid="jenya" creationdate="20230618T144918Z">
        <seg>Анализ типа `"ПРИВЕТ!"` выдает `[Char]`.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Explicit types are always denoted with the first letter in capital case.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230618T144727Z" creationid="jenya" creationdate="20230618T144727Z">
        <seg>Явные типы всегда обозначаются первой буквой с большой буквы.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>First the heads are compared.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230617T080426Z" creationid="jenya" creationdate="20230617T080426Z">
        <seg>Сначала сравниваются головы.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>First we defined the result of a known input — the empty list.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230619T122515Z" creationid="jenya" creationdate="20230619T122515Z">
        <seg>Сначала мы определили результат известного ввода — пустой список.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>First, it will check if it's an empty list.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230619T122735Z" creationid="jenya" creationdate="20230619T122735Z">
        <seg>Во-первых, он проверит, является ли это пустым списком.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>First, let's try generating all triangles with sides equal to or smaller than 10:</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230617T114314Z" creationid="jenya" creationdate="20230617T114259Z">
        <seg>Сначала давайте попробуем сгенерировать все треугольники со сторонами, равными или меньшими 10:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Firstly because you can only specify one step.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230617T090653Z" creationid="jenya" creationdate="20230617T090653Z">
        <seg>Во-первых, потому, что вы можете указать только один шаг.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>For a start, we'll try calling one of the most boring functions in Haskell.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230616T101829Z" creationid="jenya" creationdate="20230616T101829Z">
        <seg>Для начала мы попробуем вызвать одну из самых скучных функций в Haskell.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>For convenience, we'll put that comprehension inside a function so we can easily reuse it.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230617T103801Z" creationid="jenya" creationdate="20230617T103801Z">
        <seg>Для удобства мы поместим это списковое включение внутрь функции, чтобы мы могли легко использовать его повторно.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>For example, in C, you use parentheses to call functions like `foo()`, `bar(1)` or `baz(3, "haha")`.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230616T114030Z" creationid="jenya" creationdate="20230616T114030Z">
        <seg>Например, в `C` вы используете круглые скобки для вызова таких функций, как `foo()`, `bar(1)` или `baz(3, "ха-ха")`.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>For instance, `*` is a function that takes two numbers and multiplies them.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230616T100756Z" creationid="jenya" creationdate="20230616T100756Z">
        <seg>Например, `*` - это функция, которая принимает два числа и умножает их.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>For instance, if we wanted to represent someone's name and age in Haskell, we could use a triple: `("Christopher", "Walken", 55)`.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230617T112107Z" creationid="jenya" creationdate="20230617T112107Z">
        <seg>Например, если бы мы хотели представить чье-то имя и возраст в Haskell, мы могли бы использовать тройку: `("Christopher", "Walken", 55)`.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>For instance, the `div` function takes two integers and does integral division between them.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230616T113727Z" creationid="jenya" creationdate="20230616T113727Z">
        <seg>Например, функция `div` принимает два целых числа и выполняет целочисленное деление между ними.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>For instance, the `length` function has a type declaration of `length :: [a] -&gt; Int` instead of having a more general type of `(Num b) =&gt; length :: [a] -&gt; b`.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230618T191140Z" creationid="jenya" creationdate="20230618T191140Z">
        <seg>Например, функция `length` имеет объявление типа `length :: [a] -&gt; Int` вместо того, чтобы иметь более общий тип `(Num b) =&gt; length :: [a] -&gt; b`.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>For instance, the pattern `xs@(x:y:ys)`.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230619T124718Z" creationid="jenya" creationdate="20230619T123456Z">
        <seg>Например, образец `xs@(x:y:ys)`.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>For instance, you set variable `a` to 5 and then do some stuff and then set it to something else.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230615T165305Z" creationid="jenya" creationdate="20230615T165154Z">
        <seg>Например, вы устанавливаете переменной `a` значение 5, а затем делаете что-то еще, а затем устанавливаете ее значение на что-то другое.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>For learning it's a lot easier and faster than compiling every time you make a change and then running the program from the prompt.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230615T173903Z" creationid="jenya" creationdate="20230615T173903Z">
        <seg>Для обучения это намного проще и быстрее, чем компилировать каждый раз, когда вы вносите изменения, а затем запускать программу из командной строки.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>For now, let's examine how you would get the first 24 multiples of 13.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230617T090809Z" creationid="jenya" creationdate="20230617T090809Z">
        <seg>А пока давайте рассмотрим, как бы вы получили первые 24 числа, кратные 13.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>For the purposes of this tutorial we'll be using GHC, the most widely used Haskell compiler.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230615T173653Z" creationid="jenya" creationdate="20230615T173653Z">
        <seg>Для целей этого руководства мы будем использовать GHC, наиболее широко используемый компилятор Haskell.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>From here on, we'll give all the functions that we make type declarations.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230618T145233Z" creationid="jenya" creationdate="20230618T145233Z">
        <seg>С этого момента мы будем предоставлять все функции, для которых мы делаем объявления типов.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>From its type signature we see that it takes an integral number and turns it into a more general number.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230618T190809Z" creationid="jenya" creationdate="20230618T190809Z">
        <seg>Из его сигнатуры типа мы видим, что он принимает целое число и превращает его в более общее число.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Function application (calling a function by putting a space after it and then typing out the parameters) has the highest precedence of them all.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230616T113138Z" creationid="jenya" creationdate="20230616T113138Z">
        <seg>Функциональное приложение (вызывающее функцию, ставя после нее пробел, а затем вводя параметры) имеет самый высокий приоритет из всех.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Functions also have types.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230618T145106Z" creationid="jenya" creationdate="20230618T145106Z">
        <seg>Функции также имеют типы.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Functions are defined in a similar way that they are called.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230616T134618Z" creationid="jenya" creationdate="20230616T134618Z">
        <seg>Функции определяются аналогично тому, как они вызываются.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Functions are expressions too, so `:t` works on them without a problem.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230618T150033Z" creationid="jenya" creationdate="20230618T150033Z">
        <seg>Функции тоже являются выражениями, поэтому `:t` работает с ними без проблем.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Functions are usually prefix so from now on we won't explicitly state that a function is of the prefix form, we'll just assume it.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230616T101100Z" creationid="jenya" creationdate="20230616T101100Z">
        <seg>Функции обычно являются префиксными, поэтому с этого момента мы не будем явно указывать, что функция имеет префиксную форму, мы просто предположим это.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Functions in Haskell don't have to be in any particular order, so it doesn't matter if you define `doubleMe` first and then `doubleUs` or if you do it the other way around.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230616T173706Z" creationid="jenya" creationdate="20230616T173706Z">
        <seg>Функции в Haskell не обязательно должны располагаться в каком-либо определенном порядке, поэтому не имеет значения, определяете ли вы сначала `doubleMe`, а затем `doubleUs` или делаете это наоборот.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Functions that have type variables are called **polymorphic functions**.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230618T151853Z" creationid="jenya" creationdate="20230618T151849Z">
        <seg>Функции, имеющие переменные типа, называются **полиморфными функциями** (англ. **polymorphic functions**).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>GHC can take a Haskell script (they usually have a .hs extension) and compile it but it also has an interactive mode which allows you to interactively interact with scripts.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230615T173826Z" creationid="jenya" creationdate="20230615T173826Z">
        <seg>GHC может взять скрипт на Haskell (обычно они имеют расширение .hs) и скомпилировать его, но он также имеет интерактивный режим, который позволяет вам интерактивно взаимодействовать со скриптами.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>GT]
[LT,EQ,GT]
ghci&gt; [3 ..</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230618T183911Z" creationid="jenya" creationdate="20230618T183911Z">
        <seg>GT]
[LT,EQ,GT]
ghci&gt; [3 ..</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Guards are a very nice alternative for this.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230619T130257Z" creationid="jenya" creationdate="20230619T130143Z">
        <seg>Охранные выражения - очень хорошая альтернатива для этого.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Guards are indicated by pipes that follow a function's name and its parameters.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230619T125850Z" creationid="jenya" creationdate="20230619T125634Z">
        <seg>Охранные выражения обозначаются вертикальными чёрточками после имени и параметров функции.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Guards can also be written inline, although I'd advise against that because it's less readable, even for very short functions.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230619T130830Z" creationid="jenya" creationdate="20230619T130746Z">
        <seg>Защитные выражения также можно записать одной строкой, хотя я бы не советовал этого делать, потому что это менее читабельно даже для очень коротких функций.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Had we omitted the parentheses, it would have added one only if `x` wasn't greater than 100.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230617T073743Z" creationid="jenya" creationdate="20230617T073743Z">
        <seg>Если бы мы опустили круглые скобки, это добавило бы единицу только в том случае, если `x` было не больше 100.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Had we written the second pattern on top of the first one, it would catch all numbers, including 0 and our calculation would never terminate.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230619T114833Z" creationid="jenya" creationdate="20230619T114833Z">
        <seg>Если бы мы написали второй шаблон поверх первого, он бы улавливал все числа, включая 0, и наше вычисление никогда бы не завершилось.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Haskell is **elegant and concise**.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230615T173204Z" creationid="jenya" creationdate="20230615T173204Z">
        <seg>Haskell **элегантен и лаконичен**.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Haskell is **lazy**.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230615T174251Z" creationid="jenya" creationdate="20230615T170847Z">
        <seg>Haskell **ленив**.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Haskell is **statically typed**.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230615T172800Z" creationid="jenya" creationdate="20230615T172800Z">
        <seg>Haskell является **статически типизированным**.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Haskell is a **purely functional programming language**.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230615T165040Z" creationid="jenya" creationdate="20230615T165022Z">
        <seg>Haskell - это **чисто функциональный язык программирования**.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Haskell uses a very good type system that has **type inference**.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230615T172923Z" creationid="jenya" creationdate="20230615T172923Z">
        <seg>Haskell использует очень хорошую систему типов, которая имеет **вывод типа**.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Haskell was made by some **really smart guys** (with PhDs).</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230615T173458Z" creationid="jenya" creationdate="20230615T173458Z">
        <seg>Haskell был создан несколькими **действительно умными парнями** (с докторскими степенями).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Here are some basic functions that operate on lists.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230617T080528Z" creationid="jenya" creationdate="20230617T080528Z">
        <seg>Вот некоторые основные функции, которые работают со списками.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Here we see that doing `:t` on an expression prints out the expression followed by `::` and its type.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230618T144705Z" creationid="jenya" creationdate="20230618T144705Z">
        <seg>Здесь мы видим, что выполнение `:t` для выражения выводит выражение, за которым следует `::`, и его тип.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Here's a demonstration.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230617T112618Z" creationid="jenya" creationdate="20230617T112618Z">
        <seg>Вот демонстрация.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Here's a function that takes a string and removes everything except uppercase letters from it.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230617T110503Z" creationid="jenya" creationdate="20230617T110503Z">
        <seg>Вот функция, которая принимает строку и удаляет из нее все, кроме прописных букв.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Here's a problem that combines tuples and list comprehensions: which right triangle that has integers for all sides and all sides equal to or smaller than 10 has a perimeter of 24?</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230617T114254Z" creationid="jenya" creationdate="20230617T114233Z">
        <seg>Вот задача, которая сочетает в себе понимание кортежей и списков: какой прямоугольный треугольник, который имеет целые числа для всех сторон и все стороны которого равны или меньше 10, имеет периметр 24?</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Here's a quick and dirty example:</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230619T124213Z" creationid="jenya" creationdate="20230619T124213Z">
        <seg>Вот быстрый и грязный пример:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Here's a simple function that takes three integers and adds them together:</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230618T145503Z" creationid="jenya" creationdate="20230618T145503Z">
        <seg>Вот простая функция, которая принимает три целых числа и складывает их вместе:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Here's an overview of some common types.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230618T150037Z" creationid="jenya" creationdate="20230618T150037Z">
        <seg>Вот обзор некоторых распространенных типов.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Here's how it looks like with a type declaration.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230618T145250Z" creationid="jenya" creationdate="20230618T145250Z">
        <seg>Вот как это выглядит с объявлением типа.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Here's how that looks like translated in Haskell terms.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230619T114709Z" creationid="jenya" creationdate="20230619T114709Z">
        <seg>Вот как это выглядит в переводе на термины Haskell.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Here's how we would have done it if we didn't know about pattern matching:</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230619T120338Z" creationid="jenya" creationdate="20230619T120338Z">
        <seg>Вот как бы мы это сделали, если бы не знали о сопоставлении шаблонов:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Here's some simple arithmetic.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230616T095102Z" creationid="jenya" creationdate="20230616T095028Z">
        <seg>Вот несколько простых арифметических действий.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Here's that comprehension in action.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230617T104956Z" creationid="jenya" creationdate="20230617T100416Z">
        <seg>Вот списковое включение в действии.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Hmmm!</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230618T151643Z" creationid="jenya" creationdate="20230618T151643Z">
        <seg>Хммм!</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>How about a list comprehension that combines a list of adjectives and a list of nouns … for epic hilarity.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230617T105929Z" creationid="jenya" creationdate="20230617T105906Z">
        <seg>Как насчет спискового включения, которое сочетает в себе список прилагательных и список существительных ... для эпического веселья.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>How about if we wanted all numbers from 50 to 100 whose remainder when divided with the number 7 is 3?</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230617T102705Z" creationid="jenya" creationdate="20230617T102705Z">
        <seg>Как насчет того, если бы мы хотели получить все числа от 50 до 100, остаток от которых при делении на число 7 равен 3?</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>However, if we wanted to get the successor of the product of numbers 9 and 10, we couldn't write `succ 9 * 10` because that would get the successor of 9, which would then be multiplied by 10.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230616T113400Z" creationid="jenya" creationdate="20230616T113400Z">
        <seg>Однако, если бы мы хотели получить преемника произведения чисел 9 и 10, мы не могли бы написать `succ 9 * 10`, потому что это дало бы преемника 9, который затем был бы умножен на 10.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>However, putting something at the beginning of a list using the `:` operator (also called the cons operator) is instantaneous.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230617T075232Z" creationid="jenya" creationdate="20230617T075232Z">
        <seg>Однако поместить что-либо в начало списка с помощью оператора `:` (также называемого оператором `cons`) можно мгновенно.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>However, there are a few fundamental differences.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230617T111516Z" creationid="jenya" creationdate="20230617T111516Z">
        <seg>Однако есть несколько фундаментальных отличий.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>However, understanding the type system is a very important part of learning Haskell.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230618T144330Z" creationid="jenya" creationdate="20230618T144330Z">
        <seg>Однако понимание системы типов является очень важной частью изучения Haskell.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>However, with it:</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230619T114242Z" creationid="jenya" creationdate="20230619T114242Z">
        <seg>Однако, с этим:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>I decided to write this because I wanted to solidify my own knowledge of Haskell and because I thought I could help people new to Haskell learn it from my perspective.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230611T225720Z" creationid="jenya" creationdate="20230611T225608Z">
        <seg>Я решил написать это, потому что хотел укрепить свои собственные знания о Haskell и потому что думал, что смогу помочь людям, новичкам в Haskell, изучить его с моей точки зрения.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>I don't know.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230617T090532Z" creationid="jenya" creationdate="20230617T090532Z">
        <seg>Я не знаю.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>I failed to learn Haskell approximately 2 times before finally grasping it because it all just seemed too weird to me and I didn't get it.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230615T164552Z" creationid="jenya" creationdate="20230615T164552Z">
        <seg>Мне не удалось выучить Haskell примерно 2 раза, прежде чем я, наконец, понял его, потому что все это казалось мне слишком странным, и я этого не понял.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>I guess what I'm trying to say is: Haskell is great and if you're interested in programming you should really learn it even if it seems weird at first.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230615T164859Z" creationid="jenya" creationdate="20230615T164859Z">
        <seg>Наверное, я пытаюсь сказать следующее: Haskell великолепен, и если вы интересуетесь программированием, вам действительно следует его изучить, даже если поначалу это кажется странным.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>I know!</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230617T110042Z" creationid="jenya" creationdate="20230617T110042Z">
        <seg>Я знаю!</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>I mean like really big.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230618T150925Z" creationid="jenya" creationdate="20230618T150925Z">
        <seg>Я имею в виду, по-настоящему большой.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>I think that's there for historical reasons or something, although in my opinion, it's pretty stupid.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230618T191143Z" creationid="jenya" creationdate="20230618T191143Z">
        <seg>Я думаю, что это существует по историческим причинам или что-то в этом роде, хотя, на мой взгляд, это довольно глупо.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>I'm not fat!</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230619T130602Z" creationid="jenya" creationdate="20230619T130558Z">
        <seg>Я не толстый!</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>If a function is comprised only of special characters, it's considered an infix function by default.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230618T160245Z" creationid="jenya" creationdate="20230618T160245Z">
        <seg>Если функция состоит только из специальных символов, по умолчанию она считается инфиксной функцией.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>If a function takes two parameters, we can also call it as an infix function by surrounding it with backticks.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230616T113652Z" creationid="jenya" creationdate="20230616T113545Z">
        <seg>Если функция принимает два параметра, мы также можем вызвать ее как инфиксную функцию, окружив ее обратными кавычками (` `` `).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>If a function you make takes two parameters and adds them together and you don't explicitly state their type, the function will work on any two parameters that act like numbers.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230615T173156Z" creationid="jenya" creationdate="20230615T173156Z">
        <seg>Если созданная вами функция принимает два параметра и складывает их вместе, и вы явно не указываете их тип, функция будет работать с любыми двумя параметрами, которые действуют как числа.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>If a number isn't odd, we throw it out of our list.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230617T103733Z" creationid="jenya" creationdate="20230617T103632Z">
        <seg>Если число не нечетное, мы исключаем его из нашего списка.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>If a type is a part of a typeclass, that means that it supports and implements the behavior the typeclass describes.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230618T160128Z" creationid="jenya" creationdate="20230618T160128Z">
        <seg>Если тип является частью класса типов, это означает, что он поддерживает и реализует поведение, описываемое классом типов.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>If all the guards of a function evaluate to `False` (and we haven't provided an `otherwise` catch-all guard), evaluation falls through to the next **pattern**.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230619T130428Z" creationid="jenya" creationdate="20230619T130331Z">
        <seg>Если все защитные выражения функции оцениваются как `False` (и мы не предоставили всеобъемлющую защиту `otherwise`), оценка переходит к следующему **образцу**.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>If it evaluates to `False`, checking drops through to the next guard and so on.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230619T125937Z" creationid="jenya" creationdate="20230619T125926Z">
        <seg>Если он принимает значение `False`, проверка переходит к следующему охранному выражению и так далее.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>If it evaluates to `True`, then the corresponding function body is used.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230619T125923Z" creationid="jenya" creationdate="20230619T125923Z">
        <seg>Если он принимает значение `True`, то используется соответствующее тело функции.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>If it is, it returns `True`, otherwise it returns `False`.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230617T080805Z" creationid="jenya" creationdate="20230617T080805Z">
        <seg>Если это так, то он возвращает `True`, в противном случае он возвращает `False`.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>If it's anywhere from 18.5 to 25 then you're considered normal.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230619T125620Z" creationid="jenya" creationdate="20230619T125620Z">
        <seg>Если это где-то от 18,5 до 25, то вы считаетесь нормальным.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>If it's not, it falls through to the second pattern, which matches anything and binds it to `x`.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230619T114135Z" creationid="jenya" creationdate="20230619T114135Z">
        <seg>Если это не так, он переходит ко второму шаблону, который соответствует чему угодно и привязывает это к `x`.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>If no suitable guards or patterns are found, an error is thrown.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230619T130523Z" creationid="jenya" creationdate="20230619T130523Z">
        <seg>Если подходящие ограждения или шаблоны не найдены, выдается сообщение об ошибке.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>If there's no monster, it doesn't have a head.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230617T080729Z" creationid="jenya" creationdate="20230617T080729Z">
        <seg>Если монстра нет, то у него нет головы.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>If they are equal then the second elements are compared, etc.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230617T080433Z" creationid="jenya" creationdate="20230617T080433Z">
        <seg>Если они равны, то сравниваются вторые элементы и т.д.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>If we call this function with `24.3`, it will first check if that's smaller than or equal to `18.5`.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230619T125938Z" creationid="jenya" creationdate="20230619T125938Z">
        <seg>Если мы вызовем эту функцию с `24.3`, она сначала проверит, меньше ли это значение или равно `18.5`.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>If we define a function like this:</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230619T120143Z" creationid="jenya" creationdate="20230619T120143Z">
        <seg>Если мы определим функцию, подобную этой:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>If we examine the type of `*`, we'll see that it accepts all numbers.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230618T185658Z" creationid="jenya" creationdate="20230618T185658Z">
        <seg>Если мы рассмотрим тип `*`, то увидим, что он принимает все числа.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>If we have two lists, `[2,5,10]` and `[8,10,11]` and we want to get the products of all the possible combinations between numbers in those lists, here's what we'd do.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230617T105719Z" creationid="jenya" creationdate="20230617T105719Z">
        <seg>Если у нас есть два списка, `[2,5,10]` и `[8,10,11]`, и мы хотим получить произведения всех возможных комбинаций чисел в этих списках, вот что мы бы сделали.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>If we prepend `2` to that, it becomes `[2,3]`, and so on.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230617T075427Z" creationid="jenya" creationdate="20230617T075427Z">
        <seg>Если мы добавим к этому `2`, оно станет `[2,3]` и так далее.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>If we prepend `3` to it, it becomes `[3]`.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230617T075413Z" creationid="jenya" creationdate="20230617T075413Z">
        <seg>Если мы добавим к нему `3`, оно станет `[3]`.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>If we think of a list as a monster, here's what's what.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230617T080614Z" creationid="jenya" creationdate="20230617T080614Z">
        <seg>Если мы думаем о списке как о монстре, то вот что есть что.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>If we tried a list like `[1,2,'a',3,'b','c',4]`, Haskell would complain that characters (which are, by the way, denoted as a character between single quotes) are not numbers.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230617T074857Z" creationid="jenya" creationdate="20230617T074857Z">
        <seg>Если бы мы попробовали использовать список типа `[1,2,'a',3,'b','c',4]`, Haskell пожаловался бы, что символы (которые, кстати, обозначаются как символ между одинарными кавычками) не являются числами.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>If we tried to do `True == 5`, GHCI would tell us that the types don't match.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230616T100151Z" creationid="jenya" creationdate="20230616T100151Z">
        <seg>Если бы мы попытались выполнить `True == 5`, GHCI сказал бы нам, что типы не совпадают.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>If we try to take 0 elements, we get an empty list.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230617T081009Z" creationid="jenya" creationdate="20230617T081009Z">
        <seg>Если мы попытаемся взять 0 элементов, то получим пустой список.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>If we used it as a boolean, it knew it had to return a `Bool`.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230618T181313Z" creationid="jenya" creationdate="20230618T181313Z">
        <seg>Если мы использовали его как логическое значение, он знал, что должен вернуть `Bool`.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>If we want to examine its type, pass it to another function or call it as a prefix function, we have to surround it in parentheses.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230618T160332Z" creationid="jenya" creationdate="20230618T160304Z">
        <seg>Если мы хотим проверить её тип, передать его другой функции или вызвать его как префиксную функцию, мы должны заключить её в круглые скобки.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>If we want to have a negative number, it's always best to surround it with parentheses.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230616T095722Z" creationid="jenya" creationdate="20230616T095722Z">
        <seg>Если мы хотим получить отрицательное число, всегда лучше заключить его в круглые скобки.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>If we wanted all numbers from 10 to 20 that are not 13, 15 or 19, we'd do:</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230617T105225Z" creationid="jenya" creationdate="20230617T105225Z">
        <seg>Если бы нам нужны были все числа от 10 до 20, которые не равны 13, 15 или 19, мы бы сделали:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>If we wanted to add one to every number that's produced in our previous function, we could have written its body like this.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230617T073730Z" creationid="jenya" creationdate="20230617T073730Z">
        <seg>Если бы мы хотели добавить единицу к каждому числу, полученному в нашей предыдущей функции, мы могли бы написать ее тело следующим образом.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>If we wanted to multiply our list by 8 in an imperative language and did `doubleMe(doubleMe(doubleMe(xs)))`, it would probably pass through the list once and make a copy and then return it.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230615T174308Z" creationid="jenya" creationdate="20230615T171752Z">
        <seg>Если бы мы хотели умножить наш список на 8 на императивном языке и сделали `doubleMe( doubleMe( doubleMe(xs) ) )`, он, вероятно, прошел бы по списку один раз и сделал копию, а затем вернул бы ее.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>If we wanted to write that in Haskell, we could do something like `take 10 [2,4..]`.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230617T094804Z" creationid="jenya" creationdate="20230617T094804Z">
        <seg>Если бы мы хотели написать это на Haskell, мы могли бы сделать что-то вроде `take 10 [2,4..]`.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>If we write a number, we don't have to tell Haskell it's a number.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230618T144107Z" creationid="jenya" creationdate="20230618T144107Z">
        <seg>Если мы пишем число, нам не нужно говорить Haskell, что это число.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>If you change the .hs script, just run `:l myfunctions` again or do `:r`, which is equivalent because it reloads the current script.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230615T174028Z" creationid="jenya" creationdate="20230615T174028Z">
        <seg>Если вы измените скрипт .hs, просто снова запустите `:l myfunctions` или выполните `:r`, что эквивалентно, поскольку оно перезагружает текущий скрипт.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>If you evaluate that by typing out `triangles` in GHCI, you'll get a list of all possible triangles with sides under or equal to 10.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230617T114822Z" creationid="jenya" creationdate="20230617T114822Z">
        <seg>Если вы оцените это, введя `triangles` в GHCI, вы получите список всех возможных треугольников со сторонами меньше или равными 10.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>If you have defined some functions in a file called, say, `myfunctions.hs`, you load up those functions by typing in `:l myfunctions` and then you can play with them, provided `myfunctions.hs` is in the same folder from which `ghci` was invoked.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230615T173955Z" creationid="jenya" creationdate="20230615T173955Z">
        <seg>Если вы определили какие-то функции в файле с именем, скажем, `myfunctions.hs`, вы загружаете эти функции, введя `:l myfunctions`, а затем можете поиграть с ними, при условии, что `myfunctions.hs` находится в той же папке, из которой был вызван `ghci`.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>If you just try to display the result, it will go on forever so you have to slice it off somewhere.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230617T090941Z" creationid="jenya" creationdate="20230617T090941Z">
        <seg>Если вы просто попытаетесь отобразить результат, он будет продолжаться вечно, так что вам придется где-то его отрезать.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>If you remember, it takes two things that can be compared and returns the larger of them.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230619T130716Z" creationid="jenya" creationdate="20230619T130716Z">
        <seg>Если вы помните, он берет две вещи, которые можно сравнить, и возвращает большую из них.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>If you say `a = 5 + 4`, you don't have to tell Haskell that `a` is a number, it can figure that out by itself.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230615T173037Z" creationid="jenya" creationdate="20230615T173037Z">
        <seg>Если вы говорите `a = 5 + 4`, вам не нужно говорить Haskell, что `a` - это число, он может вычислить это сам.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>If you say that `a` is 5, you can't say it's something else later because you just said it was 5.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230615T170444Z" creationid="jenya" creationdate="20230615T170444Z">
        <seg>Если вы скажете, что `a` равно 5, вы не сможете позже сказать, что это что-то другое, потому что вы только что сказали, что это 5.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>If you tried to pattern match against `(xs ++ ys)`, what would be in the first and what would be in the second list?</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230619T124804Z" creationid="jenya" creationdate="20230619T124331Z">
        <seg>Если бы вы попытались сопоставить образец с `(xs ++ ys)`, что было бы в первом, а что во втором списке?</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>If you try to add together a number and a string, the compiler will whine at you.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230615T172910Z" creationid="jenya" creationdate="20230615T172910Z">
        <seg>Если вы попытаетесь сложить вместе число и строку, компилятор будет ныть на вас.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>If you want to bind, say, the first three elements to variables and the rest of the list to another variable, you can use something like `x:y:z:zs`.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230619T121444Z" creationid="jenya" creationdate="20230619T121444Z">
        <seg>Если вы хотите привязать, скажем, первые три элемента к переменным, а остальную часть списка к другой переменной, вы можете использовать что-то вроде `x:y:z:zs`.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>If you want to get an element out of a list by index, use `!!`.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230617T075506Z" creationid="jenya" creationdate="20230617T075506Z">
        <seg>Если вы хотите получить элемент из списка по индексу, используйте `!!`.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>If you want to give your function a type declaration but are unsure as to what it should be, you can always just write the function without it and then check it with `:t`.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230618T150015Z" creationid="jenya" creationdate="20230618T150015Z">
        <seg>Если вы хотите предоставить своей функции объявление типа, но не уверены в том, каким оно должно быть, вы всегда можете просто написать функцию без него, а затем проверить ее с помощью `:t`.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>If you want to have the same prompt, just type in `:set prompt "ghci&gt; "`.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230616T095057Z" creationid="jenya" creationdate="20230616T093632Z">
        <seg>Если вы хотите получить такое же приглашение, просто введите `:set prompt "ghci&gt; "`.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>If you write a program where you try to divide a boolean type with some number, it won't even compile.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230618T140148Z" creationid="jenya" creationdate="20230618T140148Z">
        <seg>Если вы напишете программу, в которой попытаетесь разделить логический тип на некоторое число, она даже не будет компилироваться.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>If you're reading this, chances are you want to learn Haskell.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230611T203057Z" creationid="jenya" creationdate="20230611T203057Z">
        <seg>Если вы читаете это, то возможно вы хотите выучить Haskell.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>If you're the sort of horrible person who doesn't read introductions to things and you skipped it, you might want to read the last section in the introduction anyway because it explains what you need to follow this tutorial and how we're going to load functions.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230616T092926Z" creationid="jenya" creationdate="20230616T092926Z">
        <seg>Если вы из тех ужасных людей, которые не читают введения к книгам, и вы пропустили его, возможно, вы все равно захотите прочитать последний раздел введения, потому что в нем объясняется, что вам нужно для выполнения этого руководства и как мы собираемся загружать функции.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>If you've ever taken a course in mathematics, you've probably run into _set comprehensions_.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230617T092930Z" creationid="jenya" creationdate="20230617T091908Z">
        <seg>Если вы когда-либо проходили курс математики, вы, вероятно, сталкивались с _множествами с заданными характеристическими свойствами_^[В оригинале был термин "set comprehensions". Ссылка откуда взял: [What is Russian translation for "set comprehension"](https://russian.stackexchange.com/questions/1530/what-is-russian-translation-for-set-comprehension). И я посчитал, что второй ответ более подходящий].</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>If your BMI is less than 18.5, you're considered underweight.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230619T125619Z" creationid="jenya" creationdate="20230619T125619Z">
        <seg>Если ваш ИМТ меньше 18,5, у вас считается недостаточный вес.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>In 2003 the Haskell Report was published, which defines a stable version of the language.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230615T173609Z" creationid="jenya" creationdate="20230615T173609Z">
        <seg>В 2003 году был опубликован отчет Haskell, в котором определяется стабильная версия языка.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>In C, that would be something like `bar(bar(3))`.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230616T132545Z" creationid="jenya" creationdate="20230616T132545Z">
        <seg>В `C` это было бы что-то вроде `bar(bar(3))`.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>In Haskell, functions are called by writing the function name, a space and then the parameters, separated by spaces.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230616T101219Z" creationid="jenya" creationdate="20230616T101219Z">
        <seg>В Haskell функции вызываются путем ввода имени функции, пробела, а затем параметров, разделенных пробелами.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>In Haskell, lists are a **homogenous** data structure.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230617T074700Z" creationid="jenya" creationdate="20230617T074619Z">
        <seg>В Haskell списки представляют собой **однородную** (англ. homogenous) структуру данных.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>In a lazy language, calling `doubleMe` on a list without forcing it to show you the result ends up in the program sort of telling you "Yeah yeah, I'll do it later!".</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230615T172010Z" creationid="jenya" creationdate="20230615T172010Z">
        <seg>На ленивом языке вызов `doubleMe` в списке, не заставляя его показывать вам результат, приводит к тому, что программа как бы говорит вам: "Да, да, я сделаю это позже!".</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>In a sense they are polymorphic constants.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230618T184357Z" creationid="jenya" creationdate="20230618T184357Z">
        <seg>В некотором смысле они являются полиморфными константами.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>In imperative languages you can just skip a couple of steps if the condition isn't satisfied but in Haskell every expression and function must return something.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230616T174145Z" creationid="jenya" creationdate="20230616T174145Z">
        <seg>В императивных языках вы можете просто пропустить пару шагов, если условие не выполнено, но в Haskell каждое выражение и функция должны что-то возвращать.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>In imperative languages you get things done by giving the computer a sequence of tasks and then it executes them.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230615T165136Z" creationid="jenya" creationdate="20230615T165136Z">
        <seg>В императивных языках вы добиваетесь цели, задавая компьютеру последовательность задач, а затем он их выполняет.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>In most imperative languages functions are called by writing the function name and then writing its parameters in parentheses, usually separated by commas.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230616T101158Z" creationid="jenya" creationdate="20230616T101158Z">
        <seg>В большинстве императивных языков функции вызываются путем ввода имени функции, а затем ее параметров в круглых скобках, обычно через запятую.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>In other words, it chops off a list's head.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230617T080552Z" creationid="jenya" creationdate="20230617T080552Z">
        <seg>Другими словами, это отрубает голову списку.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>In purely functional programming you don't tell the computer what to do as such but rather you tell it what stuff _is_.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230615T170029Z" creationid="jenya" creationdate="20230615T165155Z">
        <seg>В чисто функциональном программировании вы не указываете компьютеру, что делать как таковое, а скорее сообщаете ему, чем этот материал _является_.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>In some ways, tuples are like lists — they are a way to store several values into a single value.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230617T111513Z" creationid="jenya" creationdate="20230617T111046Z">
        <seg>В некотором смысле кортежи подобны спискам — это способ хранения нескольких значений в одном значении.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>In the previous section we got a basic feel for calling functions.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230616T132631Z" creationid="jenya" creationdate="20230616T132604Z">
        <seg>В предыдущем разделе мы получили базовое представление о вызове функций.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>In the previous section, we defined a BMI calculator function and berator like this:</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230620T090149Z" creationid="jenya" creationdate="20230620T090137Z">
        <seg>В предыдущем разделе мы определили функцию калькулятора ИМТ и "ругалочку" следующим образом:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>In this section we'll look at the basics of lists, strings (which are lists) and list comprehensions.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230617T074613Z" creationid="jenya" creationdate="20230617T074613Z">
        <seg>В этом разделе мы рассмотрим основы списков, строк (которые являются списками) и понимания списков.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>In this typeclass are `Int` and `Integer`.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230618T190334Z" creationid="jenya" creationdate="20230618T190334Z">
        <seg>В этом классе типов находятся `Int` и `Integer`.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Instead of explaining their syntax, let's just dive in and make a function using guards.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230619T125221Z" creationid="jenya" creationdate="20230619T125211Z">
        <seg>Вместо того чтобы объяснять их синтаксис, давайте просто углубимся и создадим функцию, используя охранные выражения.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Instead of having the user calculate his own BMI before calling the function, let's modify this function so that it takes a height and weight and calculates it for us.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230619T130542Z" creationid="jenya" creationdate="20230619T130542Z">
        <seg>Вместо того чтобы заставлять пользователя вычислять свой собственный ИМТ перед вызовом функции, давайте модифицируем эту функцию так, чтобы она брала рост и вес и вычисляла их для нас.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Instead of surrounding the vectors with square brackets, we use parentheses: `[(1,2),(8,11),(4,5)]`.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230617T111847Z" creationid="jenya" creationdate="20230617T111833Z">
        <seg>Вместо того чтобы заключать векторы в квадратные скобки, мы используем круглые скобки: `[(1,2),(8,11),(4,5)]`.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Instead, we'll use ranges.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230617T084554Z" creationid="jenya" creationdate="20230617T084554Z">
        <seg>Вместо этого мы будем использовать диапазоны.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Interactively.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230615T173829Z" creationid="jenya" creationdate="20230615T173829Z">
        <seg>Интерактивно.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Interesting.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230618T160335Z" creationid="jenya" creationdate="20230618T160335Z">
        <seg>Интересно.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Is it a type?</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230618T151724Z" creationid="jenya" creationdate="20230618T151724Z">
        <seg>Является ли это типом?</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>It all blows up in our face!</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230617T080721Z" creationid="jenya" creationdate="20230617T080721Z">
        <seg>Все это взрывается нам в лицо!</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>It also allows cool things such as infinite data structures.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230615T171704Z" creationid="jenya" creationdate="20230615T171704Z">
        <seg>Это также позволяет создавать интересные вещи, такие как бесконечные структуры данных.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>It appears that whole numbers are also polymorphic constants.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230618T185436Z" creationid="jenya" creationdate="20230618T185436Z">
        <seg>Похоже, что целые числа также являются полиморфными константами.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>It can _infer_ that on its own, so we don't have to explicitly write out the types of our functions and expressions to get things done.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230618T144202Z" creationid="jenya" creationdate="20230618T144202Z">
        <seg>Он может _сделать вывод_ сам по себе, поэтому нам не нужно явно выписывать типы наших функций и выражений, чтобы что-то сделать.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>It can have only two values: `True` and `False`.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230618T151100Z" creationid="jenya" creationdate="20230618T151100Z">
        <seg>Он может иметь только два значения: `True` и `False`.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>It causes the program to crash, so it's not good to use it too much.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230619T122012Z" creationid="jenya" creationdate="20230619T122012Z">
        <seg>Это приводит к сбою программы, поэтому не стоит использовать ее слишком часто.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>It complains that we have non-exhaustive patterns, and rightfully so.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230619T120159Z" creationid="jenya" creationdate="20230619T120159Z">
        <seg>Он жалуется, что у нас есть неисчерпывающие шаблоны, и это справедливо.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>It doesn't make much sense.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230619T124339Z" creationid="jenya" creationdate="20230619T124339Z">
        <seg>В этом нет особого смысла.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>It doesn't really make much sense when you think about it.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230617T112351Z" creationid="jenya" creationdate="20230617T112351Z">
        <seg>На самом деле это не имеет особого смысла, когда ты думаешь об этом.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>It extracts that many elements from the beginning of the list.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230617T080947Z" creationid="jenya" creationdate="20230617T080854Z">
        <seg>Он извлекает некоторое количество элементов из начала списка.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>It forces you to think differently, which brings us to the next section …</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230615T164947Z" creationid="jenya" creationdate="20230615T164947Z">
        <seg>Это заставляет вас думать по-другому, что подводит нас к следующему разделу ...</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>It has a type declaration of `fromIntegral :: (Num b, Integral a) =&gt; a -&gt; b`.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230618T190621Z" creationid="jenya" creationdate="20230618T190621Z">
        <seg>Он имеет объявление типа `fromIntegral :: (Num b, Integral a) =&gt; a -&gt; b`.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>It just states that the first component's type and the return value's type are the same.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230618T155547Z" creationid="jenya" creationdate="20230618T154858Z">
        <seg>В нем просто указано, что тип первого компонента и тип возвращаемого значения совпадают.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>It matches on the second pattern and there it says that the length is `1 + length' "am"`, because we broke it into a head and a tail and discarded the head.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230619T123049Z" creationid="jenya" creationdate="20230619T123008Z">
        <seg>Он совпадает со вторым шаблоном, и там написано, что длина равна `1 + length' "am"`, потому что мы разделили его на голову и хвост и выбросили голову.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>It means that we first call the function `bar` with `3` as the parameter to get some number and then we call `bar` again with that number.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230616T132531Z" creationid="jenya" creationdate="20230616T132531Z">
        <seg>Это означает, что мы сначала вызываем функцию `bar` с `3` в качестве параметра, чтобы получить некоторое число, а затем мы снова вызываем `bar` с этим числом.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>It means that we really don't care what that part is, so we just write a `_`.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230619T120526Z" creationid="jenya" creationdate="20230619T120526Z">
        <seg>Это означает, что нам действительно все равно, что это за часть, поэтому мы просто пишем `_`.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>It pairs up the elements and produces a new list.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230617T112624Z" creationid="jenya" creationdate="20230617T112624Z">
        <seg>Он объединяет элементы в пары и создает новый список.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>It returns a type that's part of `Read` but if we don't try to use it in some way later, it has no way of knowing which type.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230618T181410Z" creationid="jenya" creationdate="20230618T181410Z">
        <seg>Он возвращает тип, который является частью `Read`, но если мы не попытаемся использовать его каким-либо образом позже, у него не будет возможности узнать, какой тип.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>It returns the first component of a pair.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230618T154532Z" creationid="jenya" creationdate="20230618T154532Z">
        <seg>Он возвращает первый компонент пары.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>It says that the character will be included in the new list only if it's an element of the list `['A'..'Z']`.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230617T110727Z" creationid="jenya" creationdate="20230617T110727Z">
        <seg>В нем говорится, что символ будет включен в новый список, только если он является элементом списка `['A'..'Z']`.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>It stores several elements of the same type.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230617T074628Z" creationid="jenya" creationdate="20230617T074628Z">
        <seg>В нем хранится несколько элементов одного и того же типа.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>It takes a string and generates a runtime error, using that string as information about what kind of error occurred.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230619T122002Z" creationid="jenya" creationdate="20230619T122002Z">
        <seg>Он принимает строку и генерирует ошибку времени выполнения, используя эту строку в качестве информации о том, какого рода ошибка произошла.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>It takes a value whose type is a member of `Show` and presents it to us as a string.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230618T180830Z" creationid="jenya" creationdate="20230618T180830Z">
        <seg>Она принимает значение, тип которого является членом `Show`, и представляет его нам в виде строки.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>It takes two lists and then zips them together into one list by joining the matching elements into pairs.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230617T112545Z" creationid="jenya" creationdate="20230617T112545Z">
        <seg>Он берет два списка, а затем объединяет их в один список, объединяя совпадающие элементы в пары.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>It takes two numbers of the same type and returns a number of that type.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230618T185702Z" creationid="jenya" creationdate="20230618T185702Z">
        <seg>Он принимает два числа одного и того же типа и возвращает число этого типа.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>It tells us in which category of things that expression fits.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230618T144402Z" creationid="jenya" creationdate="20230618T144402Z">
        <seg>Это говорит нам, к какой категории вещей подходит это выражение.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>It tries to compute `3 * factorial 2`.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230619T114733Z" creationid="jenya" creationdate="20230619T114733Z">
        <seg>Он пытается вычислить `3 * factorial 2`.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>It will only match against lists that have three elements or more.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230619T121509Z" creationid="jenya" creationdate="20230619T121509Z">
        <seg>Он будет соответствовать только спискам, содержащим три элемента или более.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>It would make sense to match stuff against `(xs ++ [x,y,z])` or just `(xs ++ [x])`, but because of the nature of lists, you can't do that.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230619T124501Z" creationid="jenya" creationdate="20230619T124501Z">
        <seg>Было бы разумно сопоставить материал с `(xs ++ [x, y, z])` или просто `(xs ++ [x])`, но из-за природы списков вы не можете этого сделать.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>It'll wait to see what you want to get out of that infinite lists.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230617T090850Z" creationid="jenya" creationdate="20230617T090850Z">
        <seg>Это подождет, чтобы увидеть, что вы хотите получить из этих бесконечных списков.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>It's a really simple function but it has loads of uses.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230617T112607Z" creationid="jenya" creationdate="20230617T112607Z">
        <seg>Это действительно простая функция, но у нее множество применений.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>It's a valid character to use in a function name.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230617T073839Z" creationid="jenya" creationdate="20230617T073839Z">
        <seg>Это допустимый символ для использования в имени функции.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>It's denoted by single quotes.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230618T151140Z" creationid="jenya" creationdate="20230618T151111Z">
        <seg>Он обозначается одинарными кавычками.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>It's especially useful for when you want to combine two lists in a way or traverse two lists simultaneously.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230617T112614Z" creationid="jenya" creationdate="20230617T112614Z">
        <seg>Это особенно полезно, когда вы хотите каким-то образом объединить два списка или одновременно просматривать два списка.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>It's like cycling a list with only one element.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230617T091019Z" creationid="jenya" creationdate="20230617T091019Z">
        <seg>Это все равно что перебирать список, содержащий только один элемент.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>It's not hard to conclude that it stands for _character_.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230618T144854Z" creationid="jenya" creationdate="20230618T144740Z">
        <seg>Нетрудно сделать вывод, что это означает _символ_ (англ. _character_).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>It's simply a matter of separating the first two elements with a comma and then specifying what the upper limit is.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230617T090632Z" creationid="jenya" creationdate="20230617T090632Z">
        <seg>Это просто вопрос разделения первых двух элементов запятой, а затем указания верхнего предела.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>It's telling us that we tried to use a pair and a triple in the same list, which is not supposed to happen.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230617T111957Z" creationid="jenya" creationdate="20230617T111957Z">
        <seg>Это говорит нам о том, что мы пытались использовать пару и тройку в одном списке, чего не должно было произойти.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>It's the most used data structure and it can be used in a multitude of different ways to model and solve a whole bunch of problems.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230617T074551Z" creationid="jenya" creationdate="20230617T074551Z">
        <seg>Это наиболее используемая структура данных, и ее можно использовать множеством различных способов для моделирования и решения целого ряда проблем.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>It's used for whole numbers.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230618T150042Z" creationid="jenya" creationdate="20230618T150042Z">
        <seg>Он используется для целых чисел.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>It's usually called as an infix function because it's easier to read that way.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230617T082935Z" creationid="jenya" creationdate="20230617T082935Z">
        <seg>Обычно она вызывается как инфиксная функция, потому что так ее легче читать.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Its members have the property of being able to act like numbers.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230618T185419Z" creationid="jenya" creationdate="20230618T185419Z">
        <seg>Его члены обладают свойством вести себя подобно числам.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Just a friendly reminder: because strings are lists, we can use list comprehensions to process and produce strings.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230617T110440Z" creationid="jenya" creationdate="20230617T110440Z">
        <seg>Просто дружеское напоминание: поскольку строки являются списками, мы можем использовать списковое включение для обработки и создания строк.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Just like you can't have a list that has some characters and some numbers, you can't have a list that has some lists of characters and some lists of numbers.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230617T080324Z" creationid="jenya" creationdate="20230617T080122Z">
        <seg>Точно так же, как у вас не может быть списка, содержащего некоторые символы и некоторые цифры, у вас не может быть списка, содержащего некоторые списки символов и некоторые списки чисел.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Later on we'll see why they're all just separated with `-&gt;` instead of having some more explicit distinction between the return types and the parameters like `Int, Int, Int -&gt; Int` or something.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230618T150001Z" creationid="jenya" creationdate="20230618T150001Z">
        <seg>Позже мы увидим, почему все они просто разделены `-&gt;` вместо того, чтобы проводить какое-то более явное различие между возвращаемыми типами и параметрами, такими как `Int, Int, Int -&gt; Int` или что-то в этом роде.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Later we'll go into more detail on infinite lists.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230617T090801Z" creationid="jenya" creationdate="20230617T090801Z">
        <seg>Позже мы более подробно остановимся на бесконечных списках.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Learning Haskell is much like learning to program for the first time — it's fun!</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230615T164923Z" creationid="jenya" creationdate="20230615T164923Z">
        <seg>Изучение Haskell во многом похоже на обучение программированию в первый раз — это весело!</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Let's check!</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230618T151635Z" creationid="jenya" creationdate="20230618T151635Z">
        <seg>Давайте проверим!</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Let's examine its type.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230618T154535Z" creationid="jenya" creationdate="20230618T154535Z">
        <seg>Давайте рассмотрим его тип.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Let's examine the type of a number.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230618T185423Z" creationid="jenya" creationdate="20230618T185423Z">
        <seg>Давайте рассмотрим тип числа.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Let's give it a whirl.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230618T144428Z" creationid="jenya" creationdate="20230618T144428Z">
        <seg>Давайте раскрутим это дело.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Let's implement `sum`.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230619T123321Z" creationid="jenya" creationdate="20230619T123321Z">
        <seg>Давайте реализуем `sum`.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Let's make a function that takes two numbers and multiplies each by two and then adds them together.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230616T162716Z" creationid="jenya" creationdate="20230616T162716Z">
        <seg>Давайте создадим функцию, которая принимает два числа и умножает каждое на два, а затем складывает их вместе.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Let's make a really trivial function that checks if the number we supplied to it is a seven or not.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230619T114054Z" creationid="jenya" creationdate="20230619T114054Z">
        <seg>Давайте создадим действительно тривиальную функцию, которая проверяет, является ли число, которое мы ей указали, семеркой или нет.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Let's make a trivial function that tells us some of the first elements of the list in (in)convenient English form.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230619T122025Z" creationid="jenya" creationdate="20230619T122025Z">
        <seg>Давайте создадим тривиальную функцию, которая сообщает нам некоторые из первых элементов списка в удобной английской форме.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Let's modify the function so that it uses pattern matching.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230619T120353Z" creationid="jenya" creationdate="20230619T120353Z">
        <seg>Давайте модифицируем функцию таким образом, чтобы она использовала сопоставление с шаблоном.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Let's remove all odd numbers without flattening the list.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230617T110853Z" creationid="jenya" creationdate="20230617T110853Z">
        <seg>Давайте удалим все нечетные числа, не выравнивая список.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Let's say we want a comprehension that replaces each odd number greater than 10 with `"BANG!"` and each odd number that's less than 10 with `"BOOM!"`.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230617T103602Z" creationid="jenya" creationdate="20230617T102817Z">
        <seg>Допустим, нам нужно списковое включение, которое заменяет каждое нечетное число, большее 10, на `"BANG!"`, а каждое нечетное число, меньшее 10, на `"BOOM!"`.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Let's say we want only the elements which, doubled, are greater than or equal to 12.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230617T102134Z" creationid="jenya" creationdate="20230617T102134Z">
        <seg>Допустим, нам нужны только те элементы, которые в удвоенном виде больше или равны 12.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Let's see if I'm fat ...</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230619T130554Z" creationid="jenya" creationdate="20230619T130554Z">
        <seg>Давай посмотрим , толстый ли я ...</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Let's see what happens if we call `length'` on `"ham"`.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230619T123034Z" creationid="jenya" creationdate="20230619T122702Z">
        <seg>Давайте посмотрим, что произойдет, если мы вызовем `length'` на `"ham"`.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Let's take a look at the type signature of `read`.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230618T181353Z" creationid="jenya" creationdate="20230618T181353Z">
        <seg>Давайте взглянем на сигнатуру типа `read`.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Let's take a look at them.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230616T100951Z" creationid="jenya" creationdate="20230616T100942Z">
        <seg>Давайте взглянем на них.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Let's write our own version of `length`!</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230617T110200Z" creationid="jenya" creationdate="20230617T110200Z">
        <seg>Давайте напишем нашу собственную версию `длины`!</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Like lists, tuples can be compared with each other if their components can be compared.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230617T112411Z" creationid="jenya" creationdate="20230617T112411Z">
        <seg>Как и списки, кортежи можно сравнивать друг с другом, если можно сравнить их компоненты.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Like we said, spaces are used for function application in Haskell.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230616T125612Z" creationid="jenya" creationdate="20230616T125612Z">
        <seg>Как мы уже говорили, пробелы используются для применения функций в Haskell.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>List comprehensions are very similar to set comprehensions.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230617T103443Z" creationid="jenya" creationdate="20230617T100208Z">
        <seg>Списковое включение очень похоже на понимание набора.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Lists are SO awesome.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230617T074556Z" creationid="jenya" creationdate="20230617T074556Z">
        <seg>Списки - это ТАК здорово.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Lists can also contain lists.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230617T075644Z" creationid="jenya" creationdate="20230617T075644Z">
        <seg>Списки также могут содержать списки.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Lists can be compared if the stuff they contain can be compared.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230617T080414Z" creationid="jenya" creationdate="20230617T080414Z">
        <seg>Списки можно сравнивать, если можно сравнить содержащийся в них материал.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Lists themselves can also be used in pattern matching.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230619T121123Z" creationid="jenya" creationdate="20230619T121123Z">
        <seg>Сами списки также можно использовать при сопоставлении с шаблоном.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Lots of people who come from imperative languages tend to stick to the notion that parentheses should denote function application.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230616T114017Z" creationid="jenya" creationdate="20230616T114016Z">
        <seg>Многие люди, пришедшие из императивных языков, склонны придерживаться представления о том, что круглые скобки должны обозначать применение функции.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Making basic functions that are obviously correct and then combining them into more complex functions.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230616T163052Z" creationid="jenya" creationdate="20230616T163052Z">
        <seg>Создание базовых функций, которые, очевидно, являются правильными, а затем объединение их в более сложные функции.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Many newbies get syntax errors because they sometimes put it there.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230619T130708Z" creationid="jenya" creationdate="20230619T130708Z">
        <seg>Многие новички получают синтаксические ошибки, потому что они иногда помещают это туда.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Many times, the last guard is `otherwise`.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230619T130309Z" creationid="jenya" creationdate="20230619T130258Z">
        <seg>Много раз последним предупреждением было `otherwise`.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Members of `Show` can be presented as strings.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230618T180704Z" creationid="jenya" creationdate="20230618T180704Z">
        <seg>Члены `Show` могут быть представлены в виде строк.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Most expressions are such that the compiler can infer what their type is by itself.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230618T183456Z" creationid="jenya" creationdate="20230618T183456Z">
        <seg>Большинство выражений таковы, что компилятор может сам определить, каков их тип.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Most functions that aren't used with numbers are _prefix_ functions.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230616T100940Z" creationid="jenya" creationdate="20230616T100940Z">
        <seg>Большинство функций, которые не используются с числами, являются _префиксными_ функциями.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Moving on: let's implement our own `compare` by using guards.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230619T130908Z" creationid="jenya" creationdate="20230619T130838Z">
        <seg>Двигаемся дальше: давайте реализуем наш собственный `compare` с помощью охранных выражений.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Much better.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230619T120401Z" creationid="jenya" creationdate="20230619T120401Z">
        <seg>Намного лучше.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Much like shopping lists in the real world, lists in Haskell are very useful.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230617T074527Z" creationid="jenya" creationdate="20230617T074527Z">
        <seg>Подобно спискам покупок в реальном мире, списки в Haskell очень полезны.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>My advice is not to use them in list ranges.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230617T090743Z" creationid="jenya" creationdate="20230617T090743Z">
        <seg>Мой совет - не использовать их в диапазонах списков.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Nested list comprehensions are also possible if you're operating on lists that contain lists.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230617T110819Z" creationid="jenya" creationdate="20230617T110809Z">
        <seg>Вложенное списковое включение также возможно, если вы работаете со списками, которые содержат списки.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Next, we'll add a condition that they all have to be right triangles.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230617T114833Z" creationid="jenya" creationdate="20230617T114833Z">
        <seg>Далее мы добавим условие, что все они должны быть прямоугольными треугольниками.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Nice!</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230619T121809Z" creationid="jenya" creationdate="20230619T121542Z">
        <seg>Отлично!</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Normally we use as patterns to avoid repeating ourselves when matching against a bigger pattern when we have to use the whole thing again in the function body.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230619T124649Z" creationid="jenya" creationdate="20230619T124217Z">
        <seg>Обычно мы используем именованные образцы, чтобы избежать повторения при сопоставлении с более крупным шаблоном, когда нам приходится использовать все это снова в теле функции.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Not only can we have multiple predicates in list comprehensions (an element must satisfy all the predicates to be included in the resulting list), we can also draw from several lists.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230617T105516Z" creationid="jenya" creationdate="20230617T105303Z">
        <seg>Мы не только можем иметь несколько предикатов в списковом включении (элемент должен удовлетворять всем предикатам, которые будут включены в результирующий список), мы также можем извлекать данные из нескольких списков.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Not very readable at all!</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230619T130837Z" creationid="jenya" creationdate="20230619T130837Z">
        <seg>Вообще не очень читабельно!</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Note that `(x:[])` and `(x:y:[])` could be rewriten as `[x]` and `[x,y]` (because its syntatic sugar, we don't need the parentheses).</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230619T122114Z" creationid="jenya" creationdate="20230619T122114Z">
        <seg>Обратите внимание, что `(x:[])` и `(x:y: [])` могут быть переписаны как `[x]` и `[x,y]` (поскольку это синтаксический сахар, нам не нужны круглые скобки).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Note that if we moved the last pattern (the catch-all one) to the top, it would always say `"Not between 1 and 5"`, because it would catch all the numbers and they wouldn't have a chance to fall through and be checked for any other patterns.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230619T114431Z" creationid="jenya" creationdate="20230619T114246Z">
        <seg>Обратите внимание, что если бы мы переместили последний шаблон (универсальный) наверх, он всегда говорил бы `"Не между 1 и 5"`, потому что он перехватил бы все числа, и у них не было бы шанса провалиться и быть проверенными на наличие любых других шаблонов.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Note that just because `a` and `b` are different type variables, they don't have to be different types.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230618T154853Z" creationid="jenya" creationdate="20230618T154853Z">
        <seg>Обратите внимание, что только потому, что `a` и `b` являются переменными разного типа, они не обязательно должны быть разных типов.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Note that the empty tuple `()` is also a type which can only have a single value: `()`</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230618T151600Z" creationid="jenya" creationdate="20230618T151600Z">
        <seg>Обратите внимание, что пустой кортеж `()` также является типом, который может иметь только одно значение: `()`</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Note that there's no `=` right after the function name and its parameters, before the first guard.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230619T130706Z" creationid="jenya" creationdate="20230619T130657Z">
        <seg>Обратите внимание, что сразу после имени функции и ее параметров, перед первым защитным выражением, нет `=`.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Note that this is already a catch-all pattern.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230619T120403Z" creationid="jenya" creationdate="20230619T120403Z">
        <seg>Обратите внимание, что это уже универсальный шаблон.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Note that weeding out lists by predicates is also called **filtering**.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230617T102748Z" creationid="jenya" creationdate="20230617T102712Z">
        <seg>Обратите внимание, что отсеивание списков по предикатам также называется **фильтрацией** (англ. filtering).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Note the `'` at the end of the function name.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230617T073813Z" creationid="jenya" creationdate="20230617T073813Z">
        <seg>Обратите внимание на `'` в конце имени функции.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Note: you can do `5 + 4.0` because `5` is sneaky and can act like an integer or a floating-point number.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230616T100659Z" creationid="jenya" creationdate="20230616T100551Z">
        <seg>

&gt; Примечание: вы можете использовать `5 + 4.0`, потому что `5` является скрытым и может действовать как целое число или число с плавающей запятой.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Notice how `:` takes a number and a list of numbers or a character and a list of characters, whereas `++` takes two lists.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230617T075313Z" creationid="jenya" creationdate="20230617T075313Z">
        <seg>Обратите внимание, как `:` принимает число и список чисел или символ и список символов, тогда как `++` принимает два списка.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Notice that `fromIntegral` has several class constraints in its type signature.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230618T191149Z" creationid="jenya" creationdate="20230618T191149Z">
        <seg>Обратите внимание, что `fromIntegral` имеет несколько ограничений класса в своей сигнатуре типа.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Notice that because pairs can have different types in them, `zip` can take two lists that contain different types and zip them up.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230617T114226Z" creationid="jenya" creationdate="20230617T112812Z">
        <seg>Обратите внимание, что, поскольку пары могут содержать разные типы, `zip` может взять два списка, содержащих разные типы, и объединить их.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Notice that if you want to bind to several variables (even if one of them is just `_` and doesn't actually bind at all), we have to surround them in parentheses.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230619T121810Z" creationid="jenya" creationdate="20230619T121810Z">
        <seg>Обратите внимание, что если вы хотите привязать к нескольким переменным (даже если одна из них просто `_` и на самом деле вообще не привязывается), мы должны заключить их в круглые скобки.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Notice that in the previous uses of `read` we did something with the result afterwards.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230618T181210Z" creationid="jenya" creationdate="20230618T181210Z">
        <seg>Обратите внимание, что при предыдущем использовании `read` мы впоследствии что-то делали с результатом.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Notice that we repeat ourselves here three times.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230620T090152Z" creationid="jenya" creationdate="20230620T090152Z">
        <seg>Обратите внимание, что мы повторяемся здесь три раза.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Now for another example.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230617T102808Z" creationid="jenya" creationdate="20230617T102808Z">
        <seg>Теперь перейдем к другому примеру.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Now here comes the trick — we've defined the factorial of 0 to be just 1 and because it encounters that pattern before the catch-all one, it just returns 1.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230619T114805Z" creationid="jenya" creationdate="20230619T114805Z">
        <seg>Теперь начинается хитрость — мы определили, что факториал 0 равен всего лишь 1, и поскольку он встречает этот шаблон перед всеобъемлющим, он просто возвращает 1.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Now let's add a condition (or a predicate) to that comprehension.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230617T103537Z" creationid="jenya" creationdate="20230617T102056Z">
        <seg>Теперь давайте добавим условие (или предикат) к этому списковому включению.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Now let's try making our own!</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230616T132701Z" creationid="jenya" creationdate="20230616T132701Z">
        <seg>Теперь давайте попробуем сделать нашу собственную функцию!</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Now navigate to where it's saved and run `ghci` from there.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230616T161033Z" creationid="jenya" creationdate="20230616T161033Z">
        <seg>Теперь перейдите туда, где он сохранен, и запустите `ghci` оттуда.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Now that our script is loaded, we can play with the function that we defined.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230616T161052Z" creationid="jenya" creationdate="20230616T161052Z">
        <seg>Теперь, когда наш скрипт загружен, мы можем поиграть с функцией, которую мы определили.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Now that we know how to pattern match against list, let's make our own implementation of the `head` function.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230619T121520Z" creationid="jenya" creationdate="20230619T121520Z">
        <seg>Теперь, когда мы знаем, как сопоставить шаблон со списком, давайте создадим нашу собственную реализацию функции `head`.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Now we'll do it by using pattern matching and a little recursion:</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230619T122457Z" creationid="jenya" creationdate="20230619T122457Z">
        <seg>Теперь мы сделаем это, используя сопоставление с шаблоном и небольшую рекурсию:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Now we'll use GHCI to examine the types of some expressions.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230618T144415Z" creationid="jenya" creationdate="20230618T144415Z">
        <seg>Теперь мы будем использовать GHCI для изучения типов некоторых выражений.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Now we're going to make a function that multiplies a number by 2 but only if that number is smaller than or equal to 100 because numbers bigger than 100 are big enough as it is!</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230616T173827Z" creationid="jenya" creationdate="20230616T173827Z">
        <seg>Теперь мы собираемся создать функцию, которая умножает число на 2, но только если это число меньше или равно 100, потому что числа больше 100 и так достаточно велики!</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Now, we just modify the function by saying that we want the ones where the perimeter is 24.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230617T114926Z" creationid="jenya" creationdate="20230617T114926Z">
        <seg>Теперь мы просто модифицируем функцию, сказав, что нам нужны те, у которых периметр равен 24.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Numbers can be enumerated.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230617T084615Z" creationid="jenya" creationdate="20230617T084615Z">
        <seg>Числа можно перечислять.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>O-kay.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230619T123126Z" creationid="jenya" creationdate="20230619T123116Z">
        <seg>Хорошо.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Observe:</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230618T183449Z" creationid="jenya" creationdate="20230618T183449Z">
        <seg>Наблюдай:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Of course we can use guards with functions that take as many parameters as we want.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230619T130541Z" creationid="jenya" creationdate="20230619T130529Z">
        <seg>Конечно, мы можем использовать охранные выражения с функциями, которые принимают столько параметров, сколько мы хотим.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Oh my!</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230617T080710Z" creationid="jenya" creationdate="20230617T080710Z">
        <seg>О боже!</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Once inside GHCI, do `:l baby`.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230616T161047Z" creationid="jenya" creationdate="20230616T161047Z">
        <seg>Оказавшись внутри GHCI, выполните `:l baby`.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>One more thing — you can't use `++` in pattern matches.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230619T124752Z" creationid="jenya" creationdate="20230619T124316Z">
        <seg>Еще одна вещь — вы не можете использовать `++` при сопоставлении образцов.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>One way would be to use a list.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230617T111608Z" creationid="jenya" creationdate="20230617T111608Z">
        <seg>Одним из способов было бы использовать список.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>One, two, three, four, etc.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230617T084627Z" creationid="jenya" creationdate="20230617T084627Z">
        <seg>Один, два, три, четыре и так далее.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Only you can't compare two tuples of different sizes, whereas you can compare two lists of different sizes.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230617T112420Z" creationid="jenya" creationdate="20230617T112420Z">
        <seg>Только вы не можете сравнить два кортежа разных размеров, в то время как вы можете сравнить два списка разных размеров.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Open up your favorite text editor and punch in this function that takes a number and multiplies it by two.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230616T132718Z" creationid="jenya" creationdate="20230616T132718Z">
        <seg>Откройте свой любимый текстовый редактор и введите эту функцию, которая принимает число и умножает его на два.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Open your terminal and type in `ghci`.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230616T093018Z" creationid="jenya" creationdate="20230616T093018Z">
        <seg>Откройте свой терминал и введите `ghci`.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Or every third number between 1 and 20?</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230617T090623Z" creationid="jenya" creationdate="20230617T090623Z">
        <seg>Или каждое третье число от 1 до 20?</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Pattern matching can also be used on tuples.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230619T120307Z" creationid="jenya" creationdate="20230619T120307Z">
        <seg>Сопоставление с образцом также может быть использовано для кортежей.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Pattern matching can also fail.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230619T120141Z" creationid="jenya" creationdate="20230619T120141Z">
        <seg>Сопоставление с образцом также может привести к сбою.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Pattern matching consists of specifying patterns to which some data should conform and then checking to see if it does and deconstructing the data according to those patterns.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230619T114016Z" creationid="jenya" creationdate="20230619T113923Z">
        <seg>Сопоставление с образцом состоит в указании шаблонов, которым должны соответствовать некоторые данные, а затем проверке, соответствует ли это, и деструктуризации данных в соответствии с этими шаблонами.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>People there are extremely nice, patient and understanding to newbies.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230615T164415Z" creationid="jenya" creationdate="20230615T164415Z">
        <seg>Люди там чрезвычайно милы, терпеливы и с пониманием относятся к новичкам.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Predicates go after the binding parts and are separated from them by a comma.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230617T102127Z" creationid="jenya" creationdate="20230617T102127Z">
        <seg>Предикаты идут после связующих частей и отделяются от них запятой.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Prelude&gt;
```</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230616T093205Z" creationid="jenya" creationdate="20230616T093205Z">
        <seg>Prelude&gt;
```</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Pretty cool, huh?</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230616T095344Z" creationid="jenya" creationdate="20230616T095344Z">
        <seg>Довольно круто, да?</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Previously we mentioned that Haskell has a static type system.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230618T140127Z" creationid="jenya" creationdate="20230618T140127Z">
        <seg>Ранее мы упоминали, что в Haskell есть система статических типов.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Probable fix: add a type signature that fixes these type variable(s)
```</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230618T181153Z" creationid="jenya" creationdate="20230618T181153Z">
        <seg>Probable fix: add a type signature that fixes these type variable(s)
```</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Ranges are a way of making lists that are arithmetic sequences of elements that can be enumerated.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230617T084610Z" creationid="jenya" creationdate="20230617T084610Z">
        <seg>Диапазоны - это способ создания списков, представляющих собой арифметические последовательности элементов, которые можно перечислять.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Ranges are cool because you can also specify a step.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230617T090617Z" creationid="jenya" creationdate="20230617T090617Z">
        <seg>Диапазоны хороши тем, что вы также можете указать шаг.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Recursion is important in Haskell and we'll take a closer look at it later.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230619T114721Z" creationid="jenya" creationdate="20230619T114721Z">
        <seg>Рекурсия важна в Haskell, и мы подробнее рассмотрим ее позже.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Remember `fst`?</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230618T154528Z" creationid="jenya" creationdate="20230618T154528Z">
        <seg>Помнишь `fst`?</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Remember that we previously stated that types are written in capital case, so it can't exactly be a type.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230618T151730Z" creationid="jenya" creationdate="20230618T151730Z">
        <seg>Помните, что ранее мы указывали, что типы пишутся с большой буквы, поэтому это не может быть точно типом.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Remember the factorial function we implemented previously?</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230619T114620Z" creationid="jenya" creationdate="20230619T114620Z">
        <seg>Помните функцию факториала, которую мы реализовали ранее?</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Remember the list comprehension we made previously that filters a string so that only caps remain?</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230618T145247Z" creationid="jenya" creationdate="20230618T145247Z">
        <seg>Помните представление списка, которое мы сделали ранее, которое фильтрует строку так, чтобы оставались только заглавные буквы?</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Repeating yourself (three times) while programming is about as desirable as getting kicked inna head.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230620T090301Z" creationid="jenya" creationdate="20230620T090301Z">
        <seg>Повторяться (три раза) во время программирования примерно так же желательно, как получить удар по голове.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Right here we introduced Haskell's if statement.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230616T174114Z" creationid="jenya" creationdate="20230616T173855Z">
        <seg>Прямо здесь мы представили оператор `if`.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Save this as `baby.hs` or something.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230616T161021Z" creationid="jenya" creationdate="20230616T161021Z">
        <seg>Сохраните это как "baby.hs" или что-то в этом роде.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Say you have an immutable list of numbers `xs = [1,2,3,4,5,6,7,8]` and a function `doubleMe` which multiplies every element by 2 and then returns a new list.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230615T171742Z" creationid="jenya" creationdate="20230615T171742Z">
        <seg>Допустим, у вас есть неизменяемый список чисел `xs = [1,2,3,4,5,6,7,8]` и функция `doubleMe`, которая умножает каждый элемент на 2, а затем возвращает новый список.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>See for yourself:</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230616T113102Z" creationid="jenya" creationdate="20230616T113102Z">
        <seg>Смотрите сами:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>See how if we try to take more elements than there are in the list, it just returns the list.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230617T080959Z" creationid="jenya" creationdate="20230617T080959Z">
        <seg>Посмотрите, как если мы попытаемся взять больше элементов, чем есть в списке, это просто вернет список.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>See?</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230618T181357Z" creationid="jenya" creationdate="20230618T181357Z">
        <seg>Видишь?</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Should a pattern match fail, it will just move on to the next element.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230619T120643Z" creationid="jenya" creationdate="20230619T120643Z">
        <seg>Если совпадение с шаблоном завершится неудачей, он просто перейдет к следующему элементу.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Simple.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230616T162729Z" creationid="jenya" creationdate="20230616T162729Z">
        <seg>Просто.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Since we repeat the same expression three times, it would be ideal if we could calculate it once, bind it to a name and then use that name instead of the expression.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230620T090303Z" creationid="jenya" creationdate="20230620T090303Z">
        <seg>Поскольку мы повторяем одно и то же выражение три раза, было бы идеально, если бы мы могли вычислить его один раз, привязать к имени, а затем использовать это имя вместо выражения.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>So 100.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230616T113503Z" creationid="jenya" creationdate="20230616T113503Z">
        <seg>Итак, 100.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>So are `+`, `*`, `-`, `/` and pretty much all operators.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230618T160234Z" creationid="jenya" creationdate="20230618T160234Z">
        <seg>Так же как и `+`, `*`, `-`, `/` и почти все операторы.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>So far so good.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230618T180925Z" creationid="jenya" creationdate="20230618T180925Z">
        <seg>Пока все идет хорошо.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>So here's the function (we won't be calculating it right now, this function just gets a BMI and tells you off)</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230619T125625Z" creationid="jenya" creationdate="20230619T125625Z">
        <seg>Итак, вот функция (мы не будем вычислять ее прямо сейчас, эта функция просто получает ИМТ и сообщает вам об этом)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>So if there's an `Eq` class constraint for a type variable in a function, it uses `==` or `/=` somewhere inside its definition.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230618T160836Z" creationid="jenya" creationdate="20230618T160836Z">
        <seg>Таким образом, если существует ограничение класса `Eq` для переменной типа в функции, она использует `==` или `/=` где-то внутри своего определения.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>So if we write that down, we get:</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230619T123334Z" creationid="jenya" creationdate="20230619T123334Z">
        <seg>Итак, если мы запишем это, мы получим:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>So if you see something like `bar (bar 3)`, it doesn't mean that `bar` is called with `bar` and `3` as parameters.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230616T130601Z" creationid="jenya" creationdate="20230616T130601Z">
        <seg>Поэтому, если вы видите что-то вроде `bar (bar 3)`, это не означает, что `bar` вызывается с `bar` и `3` в качестве параметров.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>So if you're not in GHCI, it's better to split longer list comprehensions across multiple lines, especially if they're nested.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230617T111004Z" creationid="jenya" creationdate="20230617T111004Z">
        <seg>Поэтому, если вы не используете GHCI, лучше разделить более длинные списковые включения на несколько строк, особенно если они вложены.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>So in purely functional languages, a function has no side-effects.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230615T170538Z" creationid="jenya" creationdate="20230615T170538Z">
        <seg>Таким образом, в чисто функциональных языках функция не имеет побочных эффектов.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>So in the end we have `1 + (1 + (1 + 0))`.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230619T123318Z" creationid="jenya" creationdate="20230619T123318Z">
        <seg>Итак, в итоге мы имеем `1 + (1 + (1 + 0))`.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>So it only does one pass through the list and only when you really need it.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230615T172605Z" creationid="jenya" creationdate="20230615T172605Z">
        <seg>Таким образом, он выполняет только один проход по списку и только тогда, когда вам это действительно нужно.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>So right now we have `1 + (1 + length' "m")`.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230619T123243Z" creationid="jenya" creationdate="20230619T123238Z">
        <seg>Итак, прямо сейчас у нас есть `1 + (1 + length' "m")`.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>So the expression of `(True, 'a')` has a type of `(Bool, Char)`, whereas an expression such as `('a','b','c')` would have the type of `(Char, Char, Char)`.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230618T145057Z" creationid="jenya" creationdate="20230618T145057Z">
        <seg>Таким образом, выражение `(True, 'a')` имеет тип `(Bool, Char)`, тогда как такое выражение, как `('a','b','c')`, имело бы тип `(Char, Char, Char)`.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>So the final result is equivalent to `3 * (2 * (1 * 1))`.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230619T114827Z" creationid="jenya" creationdate="20230619T114827Z">
        <seg>Таким образом, конечный результат эквивалентен `3 * (2 * (1 * 1))`.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>So this is an attempt at adding another useful resource for learning Haskell so you have a bigger chance of finding one you like.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230615T164104Z" creationid="jenya" creationdate="20230615T164104Z">
        <seg>Итак, это попытка добавить еще один полезный ресурс для изучения Haskell, чтобы у вас было больше шансов найти тот, который вам понравится.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>So those functions in Haskell would be `foo`, `bar 1` and `baz 3 "haha"`.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230616T130300Z" creationid="jenya" creationdate="20230616T125613Z">
        <seg>Таким образом, этими функциями в Haskell были бы `foo`, `bar 1` и `baz 3 "ха-ха"`.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>So to get around this, we do `fromIntegral (length [1,2,3,4]) + 3.2` and it all works out.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230618T192015Z" creationid="jenya" creationdate="20230618T191147Z">
        <seg>Итак, чтобы обойти это, мы делаем `fromIntegral :: (Num b, Integral a) =&gt; a -&gt; b`., и все получается.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>So we can call it as an infix function by doing ``92 `div` 10`` and suddenly it's much clearer.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230616T113857Z" creationid="jenya" creationdate="20230616T113857Z">
        <seg>Таким образом, мы можем вызвать это как инфиксную функцию, выполнив команду ``92 `div` 10``, и внезапно все становится намного понятнее.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>So we have to tell Haskell: "Hey, this expression should have this type, in case you don't know!".</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230618T183555Z" creationid="jenya" creationdate="20230618T183543Z">
        <seg>Итак, мы должны сказать Хаскелю: "Эй, это выражение должно иметь этот тип, на случай, если вы не знаете!".</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>So we read that as it being _a list of characters_.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230618T144950Z" creationid="jenya" creationdate="20230618T144937Z">
        <seg>Итак, мы читаем это как _список символов_ (англ. _a list of characters_).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>So what if we wanted to put a couple of vectors in a list to represent points of a shape on a two-dimensional plane?</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230617T111621Z" creationid="jenya" creationdate="20230617T111621Z">
        <seg>Итак, что, если бы мы захотели поместить пару векторов в список для представления точек фигуры на двумерной плоскости?</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Some basic typeclasses:</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230618T160800Z" creationid="jenya" creationdate="20230618T160800Z">
        <seg>Некоторые основные классы типов:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Sometimes it's easier to read that way.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230619T130944Z" creationid="jenya" creationdate="20230619T130944Z">
        <seg>Иногда так читать легче.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Speaking of characters, strings are just lists of characters.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230617T075022Z" creationid="jenya" creationdate="20230617T075022Z">
        <seg>Говоря о символах, строки - это просто списки символов.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Success!</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230617T102715Z" creationid="jenya" creationdate="20230617T102711Z">
        <seg>Успех!</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Sure, we could just type them all out but obviously that's not a solution for gentlemen who demand excellence from their programming languages.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230617T084550Z" creationid="jenya" creationdate="20230617T084550Z">
        <seg>Конечно, мы могли бы просто напечатать их все, но, очевидно, это не решение для джентльменов, которые требуют совершенства от своих языков программирования.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Sure, you could do `[13,26..24*13]`.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230617T090820Z" creationid="jenya" creationdate="20230617T090820Z">
        <seg>Конечно, вы могли бы сделать `[13,26..24*13]`.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Surprise!</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230617T112442Z" creationid="jenya" creationdate="20230617T112442Z">
        <seg>Сюрприз!</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Testing for equality is done like so.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230616T095931Z" creationid="jenya" creationdate="20230616T095931Z">
        <seg>Проверка на равенство выполняется следующим образом.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Testing it out produces pretty predictable results (remember to append this function to the `baby.hs` file, save it and then do `:l baby` inside GHCI).</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230616T162807Z" creationid="jenya" creationdate="20230616T162807Z">
        <seg>Тестирование дает довольно предсказуемые результаты (не забудьте добавить эту функцию в файл `baby.hs`, сохранить его, а затем выполнить `:l baby` внутри GHCI).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Testing it out:</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230617T110509Z" creationid="jenya" creationdate="20230617T110509Z">
        <seg>Проверяю это на практике:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>That apostrophe doesn't have any special meaning in Haskell's syntax.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230617T073827Z" creationid="jenya" creationdate="20230617T073827Z">
        <seg>Этот апостроф не имеет никакого особого значения в синтаксисе Haskell.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>That goes well with referential transparency and it allows you to think of programs as a series of **transformations on data**.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230615T171559Z" creationid="jenya" creationdate="20230615T171559Z">
        <seg>Это хорошо сочетается со ссылочной прозрачностью и позволяет вам думать о программах как о серии **преобразований данных**.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>That is the equivalent of writing `[1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20]` and there's no difference between writing one or the other except that writing out long enumeration sequences manually is stupid.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230617T090611Z" creationid="jenya" creationdate="20230617T090611Z">
        <seg>Это эквивалентно написанию `[1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20]`, и нет никакой разницы между написанием одного или другого, за исключением того, что записывать длинные последовательности перечисления вручную глупо.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>That makes sense.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230618T144902Z" creationid="jenya" creationdate="20230618T144856Z">
        <seg>В этом есть смысл.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>That means that `a` can be of any type.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230618T151819Z" creationid="jenya" creationdate="20230618T151819Z">
        <seg>Это означает, что `a` может быть любого типа.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>That means that a lot of possible errors are caught at compile time.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230615T172853Z" creationid="jenya" creationdate="20230615T172853Z">
        <seg>Это означает, что во время компиляции обнаруживается множество возможных ошибок.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>That means that the set contains the doubles of all natural numbers that satisfy the predicate.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230617T094635Z" creationid="jenya" creationdate="20230617T094635Z">
        <seg>Это означает, что множество содержит удвоения всех натуральных чисел, которые удовлетворяют предикату.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>That means that unless specifically told otherwise, Haskell won't execute functions and calculate things until it's really forced to show you a result.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230615T171434Z" creationid="jenya" creationdate="20230615T171434Z">
        <seg>Это означает, что, если специально не указано иное, Haskell не будет выполнять функции и вычислять что-либо, пока его действительно не заставят показать вам результат.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>That means that we can have a list of integers or a list of characters but we can't have a list that has a few integers and then a few characters.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230617T074632Z" creationid="jenya" creationdate="20230617T074632Z">
        <seg>Это означает, что у нас может быть список целых чисел или список символов, но у нас не может быть списка, состоящего из нескольких целых чисел, а затем нескольких символов.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>That means that you don't have to explicitly label every piece of code with a type because the type system can intelligently figure out a lot about it.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230615T173015Z" creationid="jenya" creationdate="20230615T173015Z">
        <seg>Это означает, что вам не нужно явно помечать каждый фрагмент кода типом, потому что система типов может разумно многое выяснить об этом.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>That sounds a lot like an if statement and it's very similar.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230619T125143Z" creationid="jenya" creationdate="20230619T125143Z">
        <seg>Это звучит очень похоже на оператор if, и это очень похоже.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>That way when you want something from a lazy language you can just take some initial data and efficiently transform and mend it so it resembles what you want at the end.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230615T172749Z" creationid="jenya" creationdate="20230615T172749Z">
        <seg>Таким образом, когда вам нужно что-то из ленивого языка, вы можете просто взять некоторые исходные данные и эффективно преобразовать и исправить их, чтобы они напоминали то, что вы хотите в конце.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>That way, GHCI could infer what kind of result we wanted out of our `read`.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230618T181218Z" creationid="jenya" creationdate="20230618T181218Z">
        <seg>Таким образом, GHCI мог бы сделать вывод, какого рода результат мы хотели получить от нашего `read`.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>That would kind of work.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230617T111612Z" creationid="jenya" creationdate="20230617T111612Z">
        <seg>Это вроде как сработало бы.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>That's because functions can't begin with uppercase letters.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230617T074111Z" creationid="jenya" creationdate="20230617T074111Z">
        <seg>Это потому, что функции не могут начинаться с заглавных букв.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>That's because it takes one string as a parameter and returns another as a result.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230618T145353Z" creationid="jenya" creationdate="20230618T145353Z">
        <seg>Это потому, что он принимает одну строку в качестве параметра и возвращает другую в результате.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>That's called referential transparency and not only does it allow the compiler to reason about the program's behavior, but it also allows you to easily deduce (and even prove) that a function is correct and then build more complex functions by gluing simple functions together.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230615T170846Z" creationid="jenya" creationdate="20230615T170846Z">
        <seg>Это называется прозрачностью ссылок, и она не только позволяет компилятору рассуждать о поведении программы, но и позволяет вам легко вывести (и даже доказать), что функция верна, а затем создавать более сложные функции путем склеивания простых функций вместе.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>That's completely valid and as you can see, the class constraints are separated by commas inside the parentheses.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230618T191152Z" creationid="jenya" creationdate="20230618T191152Z">
        <seg>Это полностью допустимо, и, как вы можете видеть, ограничения класса разделены запятыми внутри круглых скобок.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>That's good because it's better to catch such errors at compile time instead of having your program crash.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230618T140157Z" creationid="jenya" creationdate="20230618T140157Z">
        <seg>Это хорошо, потому что лучше отлавливать такие ошибки во время компиляции, а не вызывать сбой вашей программы.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>That's how patterns and guards play nicely together.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230619T130453Z" creationid="jenya" creationdate="20230619T130429Z">
        <seg>Вот как образцы и охранные выражения прекрасно сочетаются друг с другом.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>That's its type and it doesn't matter if it has only one number in it or an infinite amount of numbers.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230617T111526Z" creationid="jenya" creationdate="20230617T111526Z">
        <seg>Это его тип, и не имеет значения, содержит ли он только одно число или бесконечное количество чисел.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>That's not a problem when dealing with lists that aren't too big.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230617T075204Z" creationid="jenya" creationdate="20230617T075204Z">
        <seg>Это не проблема, когда имеешь дело со списками, которые не слишком велики.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>That's useful when you want integral and floating point types to work together nicely.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230618T190811Z" creationid="jenya" creationdate="20230618T190811Z">
        <seg>Это полезно, когда вы хотите, чтобы целочисленные типы и типы с плавающей запятой хорошо работали вместе.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>That's why `(5 :: Int) * (6 :: Integer)` will result in a type error whereas `5 * (6 :: Integer)` will work just fine and produce an `Integer` because `5` can act like an `Integer` or an `Int`.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230618T185716Z" creationid="jenya" creationdate="20230618T185716Z">
        <seg>Вот почему `(5 :: Int) * (6 :: Integer)` приведет к ошибке типа, тогда как `5 * (6 :: Integer)` будет работать просто отлично и выдаст `Integer`, потому что `5` может действовать как `Integer` или `Int`.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>That's why order is important when specifying patterns and it's always best to specify the most specific ones first and then the more general ones later.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230619T120136Z" creationid="jenya" creationdate="20230619T120136Z">
        <seg>Вот почему порядок важен при указании шаблонов, и всегда лучше сначала указать наиболее конкретные из них, а затем более общие.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>That's why we can use `fst` on a pair that contains any two types.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230618T154843Z" creationid="jenya" creationdate="20230618T154843Z">
        <seg>Вот почему мы можем использовать `fst` для пары, которая содержит любые два типа.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>That's why we can use explicit **type annotations**.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230618T183305Z" creationid="jenya" creationdate="20230618T183305Z">
        <seg>Вот почему мы можем использовать явные **аннотации типа** (англ. _type annotations_).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The `Eq` typeclass provides an interface for testing for equality.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230618T160715Z" creationid="jenya" creationdate="20230618T160715Z">
        <seg>Класс типов `Eq` предоставляет интерфейс для проверки на равенство.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The `[Char]` type is synonymous with `String` so it's clearer if we write `removeNonUppercase :: String -&gt; String`.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230618T145431Z" creationid="jenya" creationdate="20230618T145409Z">
        <seg>Тип `[Char]` является синонимом `String`, поэтому будет понятнее, если мы напишем `removeNonUppercase :: String -&gt; String`.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The `_` means the same thing as it does in list comprehensions.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230619T120601Z" creationid="jenya" creationdate="20230619T120518Z">
        <seg>`_` означает то же самое, что и в списковом включении.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The `compare` function takes two `Ord` members of the same type and returns an ordering.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230618T180321Z" creationid="jenya" creationdate="20230618T174630Z">
        <seg>Функция `compare` принимает два элемента `Ord` одного и того же типа и возвращает `ordering`.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The `elem` function has a type of `(Eq a) =&gt; a -&gt; [a] -&gt; Bool` because it uses `==` over a list to check whether some value we're looking for is in it.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230618T160752Z" creationid="jenya" creationdate="20230618T160752Z">
        <seg>Функция `elem` имеет тип `(Eq a) =&gt; a -&gt; [a] -&gt; Bool`, потому что она использует `==` над списком, чтобы проверить, есть ли в нем какое-то значение, которое мы ищем.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The `length'` of `"am"` is, similarly, `1 + length' "m"`.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230619T123231Z" creationid="jenya" creationdate="20230619T123128Z">
        <seg>`length "am"` аналогично равна `1 + length' "m"`.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The `read` function takes a string and returns a type which is a member of `Read`.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230618T180917Z" creationid="jenya" creationdate="20230618T180917Z">
        <seg>Функция `read` принимает строку и возвращает тип, который является членом `Read`.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The `succ` function takes anything that has a defined successor and returns that successor.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230616T112618Z" creationid="jenya" creationdate="20230616T104801Z">
        <seg>Функция `succ` принимает все, что имеет определенного преемника, и возвращает этого преемника.^[Преемник (successor) - это число, следующее после некоторого натурального числа. &lt;br&gt;
Форма: Число + 1 = Преемник &lt;br&gt;
Функция приемника (successor function) - это функция, которая отправляет натуральное число следующему. &lt;br&gt;
Формула: f(x) = x + 1]</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The alphabet is an enumeration of characters from A to Z. Names can't be enumerated.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230617T090508Z" creationid="jenya" creationdate="20230617T084642Z">
        <seg>Алфавит - это перечисление символов от `A` до `Z`^[Стандарт вышел 10 лет назад и он сохраняет обратную совместимость. Поэтому, чтобы использовать unicode, нужно провести небольшие манипуляции. Об этом можно поискать в интернете. "ghci how add utf 8"]. Имена не могут быть пронумерованы.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The best way to get started is to download the [Haskell Platform](http://hackage.haskell.org/platform/), which is basically Haskell with batteries included.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230615T173740Z" creationid="jenya" creationdate="20230615T173740Z">
        <seg>Лучший способ начать - это загрузить [Haskell Platform](http://hackage.haskell.org/platform/), который в основном представляет собой Haskell с включенными батарейками.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The channel #haskell on the freenode network is a great place to ask questions if you're feeling stuck.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230615T164359Z" creationid="jenya" creationdate="20230615T164254Z">
        <seg>Канал #haskell в сети freenode - отличное место, чтобы задать вопросы, если вы чувствуете себя застрявшим.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The check is carried out with the second guard and because 24.3 is less than 25.0, the second string is returned.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230619T130116Z" creationid="jenya" creationdate="20230619T130039Z">
        <seg>Проверка выполняется со вторым охранным выражением, и поскольку 24.3 меньше 25.0, возвращается вторая строка.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The difference between Haskell's if statement and if statements in imperative languages is that the else part is mandatory in Haskell.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230616T174131Z" creationid="jenya" creationdate="20230616T174107Z">
        <seg>Разница между оператором `if` в Haskell и операторами `if` в императивных языках заключается в том, что часть `else` является обязательной в Haskell.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The element is included in the list only if all the predicates evaluate to `True`.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230617T103941Z" creationid="jenya" creationdate="20230617T103941Z">
        <seg>Элемент включается в список только в том случае, если все предикаты оцениваются как `True`.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The expression `True` is a boolean, `"hello"` is a string, etc.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230618T144409Z" creationid="jenya" creationdate="20230618T144409Z">
        <seg>Выражение `True` - это логическое значение, `"hello"` - это строка и т.д.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The factorial of 2 is `2 * factorial 1`, so for now we have `3 * (2 * factorial 1)`.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230619T114742Z" creationid="jenya" creationdate="20230619T114740Z">
        <seg>Факториал 2 равен `2 * factorial 1`, так что на данный момент у нас есть `3 * (2 * factorial 1)`.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The factorial of a number is the product of all the numbers from 1 to that number, the sum of a list of numbers is the first number plus the sum of all the other numbers, and so on.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230615T170232Z" creationid="jenya" creationdate="20230615T165159Z">
        <seg>Факториал числа - это произведение всех чисел от 1 до этого числа, сумма списка чисел - это первое число плюс сумма всех остальных чисел и так далее.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The first element goes with the first, the second with the second, etc.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230617T112723Z" creationid="jenya" creationdate="20230617T112723Z">
        <seg>Первый элемент сочетается с первым, второй - со вторым и т.д.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The first is that in the function name we didn't capitalize Conan's name.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230617T074107Z" creationid="jenya" creationdate="20230617T074034Z">
        <seg>Во-первых, мы не написали имя функции с заглавной буквы.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The first one is an empty list, the seconds one is a list that contains one empty list, the third one is a list that contains three empty lists.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230617T075501Z" creationid="jenya" creationdate="20230617T075501Z">
        <seg>Первый - это пустой список, второй - это список, содержащий один пустой список, третий - это список, содержащий три пустых списка.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The first one sees that and tells you the first element is 8.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230615T172550Z" creationid="jenya" creationdate="20230615T172550Z">
        <seg>Первая видит это и сообщает вам, что первый элемент равен 8.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The first pattern matches an empty list and the second one matches anything that isn't an empty list.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230619T122653Z" creationid="jenya" creationdate="20230619T122653Z">
        <seg>Первый шаблон соответствует пустому списку, а второй соответствует всему, что не является пустым списком.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The first thing we're going to do is run ghc's interactive mode and call some function to get a very basic feel for haskell.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230616T093007Z" creationid="jenya" creationdate="20230616T093007Z">
        <seg>Первое, что мы собираемся сделать, это запустить интерактивный режим ghc и вызвать какую-нибудь функцию, чтобы получить самое базовое представление о Haskell.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The first two elements are: " ++ show x ++ " and " ++ show y
```</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230619T122040Z" creationid="jenya" creationdate="20230619T122034Z">
        <seg>Первыми двумя элементами являются: " ++ show x ++ " и " ++ show y</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The function `odd` returns `True` on an odd number and `False` on an even one.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230617T103846Z" creationid="jenya" creationdate="20230617T103846Z">
        <seg>Функция `odd` возвращает `True` для нечетного числа и `False` для четного.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The function name is followed by parameters seperated by spaces.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230616T134625Z" creationid="jenya" creationdate="20230616T134625Z">
        <seg>За именем функции следуют параметры, разделенные пробелами.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The functions `min` and `max` take two things that can be put in an order (like numbers!).</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230616T105333Z" creationid="jenya" creationdate="20230616T105333Z">
        <seg>Функции `min` и `max` используют две вещи, которые можно упорядочить (например, числа!).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The functions its members implement are `==` and `/=`.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230618T160833Z" creationid="jenya" creationdate="20230618T160833Z">
        <seg>Функциями, которые реализуют его члены, являются `==` и `/=`.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The head of a list is basically its first element.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230617T080541Z" creationid="jenya" creationdate="20230617T080541Z">
        <seg>Заголовок списка - это, по сути, его первый элемент.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The indices start at 0.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230617T075510Z" creationid="jenya" creationdate="20230617T075510Z">
        <seg>Индексы начинаются с 0.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The interactive mode is invoked by typing in `ghci` at your prompt.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230615T173915Z" creationid="jenya" creationdate="20230615T173915Z">
        <seg>Интерактивный режим вызывается путем ввода `ghci` в вашей командной строке.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The last part of the comprehension is the predicate.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230617T103831Z" creationid="jenya" creationdate="20230617T103818Z">
        <seg>Последняя часть спискового включения - это предикат.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The list comprehension we could use is `[x*2 | x &lt;- [1..10]]`.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230617T103457Z" creationid="jenya" creationdate="20230617T100351Z">
        <seg>Списковое включение, которое мы могли бы использовать, - это `[x * 2 | x &lt;- [1..10]]`.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The lists within a list can be of different lengths but they can't be of different types.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230617T080106Z" creationid="jenya" creationdate="20230617T080106Z">
        <seg>Списки внутри списка могут быть разной длины, но они не могут быть разных типов.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The longer list simply gets cut off to match the length of the shorter one.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230617T113623Z" creationid="jenya" creationdate="20230617T113623Z">
        <seg>Более длинный список просто обрезается, чтобы соответствовать длине более короткого.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The main advantage of the `Enum` typeclass is that we can use its types in list ranges.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230618T183729Z" creationid="jenya" creationdate="20230618T183729Z">
        <seg>Главное преимущество класса типов `Enum` заключается в том, что мы можем использовать его типы в диапазонах списков.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The main difference is that it's not bounded so it can be used to represent really really big numbers.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230618T150921Z" creationid="jenya" creationdate="20230618T150921Z">
        <seg>Главное отличие заключается в том, что он не ограничен, поэтому его можно использовать для представления действительно очень больших чисел.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The most used function that deals with the `Show` typeclass is `show`.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230618T180824Z" creationid="jenya" creationdate="20230618T180824Z">
        <seg>Наиболее используемой функцией, которая имеет дело с классом типов `Show`, является `show`.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The only thing a function can do is calculate something and return it as a result.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230615T170608Z" creationid="jenya" creationdate="20230615T170608Z">
        <seg>Единственное, что может сделать функция, - это вычислить что-то и вернуть это в результате.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The only way a number can conform to the first pattern here is if it is 7.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230619T114125Z" creationid="jenya" creationdate="20230619T114125Z">
        <seg>Единственный способ, которым число может соответствовать первому шаблону здесь, - это если оно равно 7.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The parameters are separated with `-&gt;` and there's no special distinction between the parameters and the return type.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230618T145514Z" creationid="jenya" creationdate="20230618T145514Z">
        <seg>Параметры разделяются символом `-&gt;`, и нет особого различия между параметрами и возвращаемым типом.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The part before the pipe is called the output function, `x` is the variable, `N` is the input set and `x &lt;= 10` is the predicate.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230617T094739Z" creationid="jenya" creationdate="20230617T094547Z">
        <seg>Часть перед вертикальной чертой называется выходной функцией, `x` - это переменная, `N` - это входной набор, а `x &lt;= 10` - это предикат^[Предикат - если просто, то это условие].</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The predicate here does all the work.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230617T110547Z" creationid="jenya" creationdate="20230617T110547Z">
        <seg>Предикат здесь выполняет всю работу.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The problem with that method is that we could also do stuff like `[[1,2],[8,11,5],[4,5]]`, which Haskell has no problem with since it's still a list of lists with numbers but it kind of doesn't make sense.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230617T111647Z" creationid="jenya" creationdate="20230617T111647Z">
        <seg>Проблема с этим методом заключается в том, что мы также могли бы делать такие вещи, как `[[1,2],[8,11,5],[4,5]]`, с чем у Haskell нет проблем, поскольку это все еще список списков с числами, но это как бы не имеет смысла.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The prompt here is `Prelude&gt;` but because it can get longer when you load stuff into the session, we're going to use `ghci&gt;`.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230616T093818Z" creationid="jenya" creationdate="20230616T093630Z">
        <seg>Подсказка здесь `Prelude&gt;`, но поскольку она может стать длиннее, когда вы загружаете материал в сеанс, мы собираемся использовать `ghci&gt;`.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The return type is the last item in the declaration and the parameters are the first three.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230618T145622Z" creationid="jenya" creationdate="20230618T145622Z">
        <seg>Возвращаемый тип - это последний элемент в объявлении, а параметры - первые три.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The second one receives that and gives back 4 to the first one.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230615T172540Z" creationid="jenya" creationdate="20230615T172540Z">
        <seg>Вторая получает это и возвращает 4 первой.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The second one says that to the third one and the third one reluctantly gives back a doubled 1, which is a 2.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230615T172511Z" creationid="jenya" creationdate="20230615T172511Z">
        <seg>Вторая скажет это третьей, и третья неохотно возвращает удвоенную 1, которая равна 2.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The second thing is that this function doesn't take any parameters.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230617T074133Z" creationid="jenya" creationdate="20230617T074133Z">
        <seg>Во-вторых, эта функция не принимает никаких параметров.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The square brackets denote a list.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230618T144931Z" creationid="jenya" creationdate="20230618T144931Z">
        <seg>Квадратные скобки обозначают список.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The thing is that guards are a lot more readable when you have several conditions and they play really nicely with patterns.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230619T125208Z" creationid="jenya" creationdate="20230619T125147Z">
        <seg>Дело в том, что охранные выражения намного лучше читаются, когда у вас есть несколько условий, и они действительно хорошо сочетаются с образцами.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The type declaration of `head` states that it takes a list of any type and returns one element of that type.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230618T151910Z" creationid="jenya" creationdate="20230618T151910Z">
        <seg>В объявлении типа `head` указано, что он принимает список любого типа и возвращает один элемент этого типа.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The type of `addVectors` (in both cases) is `addVectors :: (Num a) =&gt; (a, a) -&gt; (a, a) - &gt; (a, a)`, so we are guaranteed to get two pairs as parameters.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230619T120409Z" creationid="jenya" creationdate="20230619T120409Z">
        <seg>Тип `addVectors` (в обоих случаях) - `addVectors :: (Num a) =&gt; (a, a) -&gt; (a, a) - &gt; (a, a)`, поэтому мы гарантированно получим две пары в качестве параметров.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The type of every expression is known at compile time, which leads to safer code.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230618T140135Z" creationid="jenya" creationdate="20230618T140135Z">
        <seg>Тип каждого выражения известен во время компиляции, что приводит к созданию более безопасного кода.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The type of those two values must be a member of the `Eq` class (this was the class constraint).</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230618T160708Z" creationid="jenya" creationdate="20230618T160708Z">
        <seg>Тип этих двух значений должен быть членом класса `Eq` (это было ограничение класса).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The usual workflow for me when playing around in stuff is defining some functions in a .hs file, loading it up and messing around with them and then changing the .hs file, loading it up again and so on.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230615T174144Z" creationid="jenya" creationdate="20230615T174144Z">
        <seg>Обычный рабочий процесс для меня, когда я копаюсь в материалах, - это определение некоторых функций в файле .hs, его загрузка и возня с ними, а затем изменение файла .hs, повторная загрузка и так далее.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The way I learned it was by reading several different tutorials and articles because each explained something in a different way than the other did.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230612T110623Z" creationid="jenya" creationdate="20230612T110346Z">
        <seg>Я научился, прочитав несколько разных учебников и статей, потому что каждый объяснял что-то по другому, чем другой.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Then in the second pattern we take the list apart by splitting it into a head and a tail.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230619T122627Z" creationid="jenya" creationdate="20230619T122627Z">
        <seg>Затем во втором шаблоне мы разбираем список на части, разделяя его на начало и конец.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Then it would pass through the list another two times and return the result.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230615T171921Z" creationid="jenya" creationdate="20230615T171921Z">
        <seg>Затем он пройдет по списку еще два раза и вернет результат.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Then we state that the factorial of any positive integer is that integer multiplied by the factorial of its predecessor.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230619T114659Z" creationid="jenya" creationdate="20230619T114659Z">
        <seg>Затем мы утверждаем, что факториал любого положительного целого числа - это это целое число, умноженное на факториал его предшественника.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>There are quite a few tutorials on Haskell floating around on the internet.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230612T110414Z" creationid="jenya" creationdate="20230611T225815Z">
        <seg>В Интернете есть довольно много учебных пособий по Haskell.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>There are two noteworthy things here.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230617T073932Z" creationid="jenya" creationdate="20230617T073918Z">
        <seg>Здесь есть две заслуживающие внимания вещи.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>There we go!</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230619T120359Z" creationid="jenya" creationdate="20230619T120359Z">
        <seg>Вот так!</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>There's also a thing called _as patterns_.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230619T124655Z" creationid="jenya" creationdate="20230619T123338Z">
        <seg>Существует также такая вещь, как _именованные образцы_ (англ. _as patterns_) .</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>They also have defined successors and predecesors, which you can get with the `succ` and `pred` functions.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230618T183849Z" creationid="jenya" creationdate="20230618T183849Z">
        <seg>У них также есть определенные преемники (англ. _successors_) и предшественники (англ. _predecesors_), которые вы можете получить с помощью функций `succ` и `pred`.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>They are denoted with parentheses and their components are separated by commas.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230617T111541Z" creationid="jenya" creationdate="20230617T111541Z">
        <seg>Они обозначаются круглыми скобками, а их компоненты разделяются запятыми.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>They can act like any type that's a member of the `Num` typeclass.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230618T185637Z" creationid="jenya" creationdate="20230618T185637Z">
        <seg>Они могут действовать как любой тип, являющийся членом класса типов `Num`.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>They can also contain lists that contain lists that contain lists …</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230617T080116Z" creationid="jenya" creationdate="20230617T075707Z">
        <seg>Они также могут содержать списки, которые содержат списки, которые содержат списки ...</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>They won't work on triples, 4-tuples, 5-tuples, etc.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230617T112502Z" creationid="jenya" creationdate="20230617T112459Z">
        <seg>Они не будут работать с тройками, 4-кортежами, 5-кортежами и т.д.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>They're normally used for building more specific sets out of general sets.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230617T092944Z" creationid="jenya" creationdate="20230617T092944Z">
        <seg>Обычно они используются для построения более специфичных наборов из общих наборов.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Think about how we'd represent a two-dimensional vector in Haskell.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230617T111600Z" creationid="jenya" creationdate="20230617T111600Z">
        <seg>Подумайте о том, как бы мы представили двумерный вектор в Haskell.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>This chapter will cover some of Haskell's cool syntactic constructs and we'll start with pattern matching.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230619T113909Z" creationid="jenya" creationdate="20230619T113909Z">
        <seg>В этой главе будут рассмотрены некоторые интересные синтаксические конструкции Haskell, и мы начнем с сопоставления с шаблоном.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>This error cannot be caught at compile time so it's always good practice to take precautions against accidentally telling Haskell to give you some elements from an empty list.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230617T080747Z" creationid="jenya" creationdate="20230617T080747Z">
        <seg>Эта ошибка не может быть обнаружена во время компиляции, поэтому всегда рекомендуется принимать меры предосторожности, чтобы случайно не попросить Haskell предоставить вам некоторые элементы из пустого списка.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>This function could have also been implemented by using an if statement.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230619T114142Z" creationid="jenya" creationdate="20230619T114142Z">
        <seg>Эта функция также могла бы быть реализована с помощью оператора if .</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>This function is safe because it takes care of the empty list, a singleton list, a list with two elements and a list with more than two elements.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230619T122059Z" creationid="jenya" creationdate="20230619T122059Z">
        <seg>Эта функция безопасна, поскольку она обрабатывает пустой список, одноэлементный список, список с двумя элементами и список с более чем двумя элементами.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>This function replaces every element of a list with `1` and then sums that up.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230617T110349Z" creationid="jenya" creationdate="20230617T110349Z">
        <seg>Эта функция заменяет каждый элемент списка на `1`, а затем суммирует его.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>This is a common pattern in functional programming.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230617T114952Z" creationid="jenya" creationdate="20230617T114952Z">
        <seg>Это распространенный шаблон в функциональном программировании.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>This is a very simple example of a common pattern you will see throughout Haskell.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230616T163046Z" creationid="jenya" creationdate="20230616T163046Z">
        <seg>Это очень простой пример общего шаблона, который вы увидите во всем Haskell.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>This is also known as the edge condition.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230619T122626Z" creationid="jenya" creationdate="20230619T122626Z">
        <seg>Это также известно как граничное условие.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>This is also what we'll be doing here.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230615T174152Z" creationid="jenya" creationdate="20230615T174152Z">
        <seg>Это тоже то, чем мы будем заниматься здесь.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>This is done by using the `++` operator.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230617T075102Z" creationid="jenya" creationdate="20230617T075102Z">
        <seg>Это делается с помощью оператора `++`.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>This is generally considered to be good practice except when writing very short functions.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230618T145126Z" creationid="jenya" creationdate="20230618T145126Z">
        <seg>Обычно это считается хорошей практикой, за исключением случаев написания очень коротких функций.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>This is much like generics in other languages, only in Haskell it's much more powerful because it allows us to easily write very general functions if they don't use any specific behavior of the types in them.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230618T151838Z" creationid="jenya" creationdate="20230618T151838Z">
        <seg>Это очень похоже на дженерики в других языках, только в Haskell это намного мощнее, потому что позволяет нам легко писать очень общие функции, если они не используют какое-либо специфическое поведение используемых в них типов.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>This is pretty self-explanatory.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230616T095138Z" creationid="jenya" creationdate="20230616T095120Z">
        <seg>Это говорит само за себя.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>This is similar to the factorial function we wrote earlier.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230619T122503Z" creationid="jenya" creationdate="20230619T122503Z">
        <seg>Это похоже на факторную функцию, о которой мы писали ранее.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>This is the first time we've defined a function recursively.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230619T114718Z" creationid="jenya" creationdate="20230619T114718Z">
        <seg>Это первый раз, когда мы определили функцию рекурсивно.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>This is very reminiscent of a big if else tree in imperative languages, only this is far better and more readable.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230619T130119Z" creationid="jenya" creationdate="20230619T130119Z">
        <seg>Это очень напоминает большое дерево if else в императивных языках, только это намного лучше и читабельнее.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>This is very similar to patterns, only they check if the input satisfies a pattern but guards check for boolean conditions.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230619T130323Z" creationid="jenya" creationdate="20230619T130323Z">
        <seg>Это очень похоже на шаблоны, только они проверяют, удовлетворяет ли ввод шаблону, но охранники проверяют логические условия.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>This is what we call an _infix_ function.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230616T100905Z" creationid="jenya" creationdate="20230616T100905Z">
        <seg>Это то, что мы называем _инфиксной_ функцией.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>This leads to really neat code that's simple and readable.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230619T114034Z" creationid="jenya" creationdate="20230619T114034Z">
        <seg>Это приводит к действительно аккуратному коду, простому и читабельному.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>This means that the resulting sum will be the length of our list.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230617T110426Z" creationid="jenya" creationdate="20230617T110426Z">
        <seg>Это означает, что результирующая сумма будет равна длине нашего списка.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>This pattern will match exactly the same thing as `x:y:ys` but you can easily get the whole list via `xs` instead of repeating yourself by typing out `x:y:ys` in the function body again.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230619T124723Z" creationid="jenya" creationdate="20230619T123459Z">
        <seg>Этот образец будет соответствовать точно тому же, что и `x:y:ys`, но вы можете легко получить весь список через `xs` вместо того, чтобы повторяться, снова введя `x:y:ys` в теле функции.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>This tutorial is aimed at people who have experience in imperative programming languages (C, C++, Java, Python …) but haven't programmed in a functional language before (Haskell, ML, OCaml …).</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230615T164157Z" creationid="jenya" creationdate="20230615T164157Z">
        <seg>Это руководство предназначено для людей, которые имеют опыт работы с императивными языками программирования (C, C ++, Java, Python ...), но никогда раньше не программировали на функциональном языке (Haskell, ML, OCaml вЂ/).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>This way you also avoid repetition.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230616T163055Z" creationid="jenya" creationdate="20230616T163055Z">
        <seg>Таким образом, вы также избежите повторения.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Those are a handy way of breaking something up according to a pattern and binding it to names whilst still keeping a reference to the whole thing.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230619T124702Z" creationid="jenya" creationdate="20230619T123353Z">
        <seg>Это удобный способ разбить что-либо в соответствии с образцом и привязать его к именам, сохраняя при этом ссылку на все это.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Those are types that are in the `Num` typeclass.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230618T185650Z" creationid="jenya" creationdate="20230618T185650Z">
        <seg>Это типы, которые находятся в классе типов `Num`.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Those were a few basic functions that operate on lists.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230617T082944Z" creationid="jenya" creationdate="20230617T082944Z">
        <seg>Это было несколько основных функций, которые работают со списками.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>To add together two vectors, we add their x components separately and then their y components separately.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230619T120318Z" creationid="jenya" creationdate="20230619T120318Z">
        <seg>Чтобы сложить вместе два вектора, мы добавляем их компоненты x отдельно, а затем их компоненты y отдельно.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>To be a member of `Ord`, a type must first have membership in the prestigious and exclusive `Eq` club.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230618T180307Z" creationid="jenya" creationdate="20230618T180307Z">
        <seg>Чтобы стать членом `Ord`, тип должен сначала иметь членство в престижном и эксклюзивном клубе `Eq`.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>To join `Num`, a type must already be friends with `Show` and `Eq`.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230618T185825Z" creationid="jenya" creationdate="20230618T185825Z">
        <seg>Чтобы присоединиться к `Num`, тип уже должен быть дружен с `Show` и `Eq`.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>To make a list containing all the natural numbers from 1 to 20, you just write `[1..20]`.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230617T090547Z" creationid="jenya" creationdate="20230617T090547Z">
        <seg>Чтобы составить список, содержащий все натуральные числа от 1 до 20, вы просто пишете `[1..20]`.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>To make a list with all the numbers from 20 to 1, you can't just do `[20..1]`, you have to do `[20,19..1]`.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230617T090714Z" creationid="jenya" creationdate="20230617T090714Z">
        <seg>Чтобы составить список со всеми числами от 20 до 1, вы не можете просто выполнить `[20..1]`, вы должны выполнить `[20,19..1]`.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>To see what the type is, Haskell would have to actually evaluate `read "5"`.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230618T183521Z" creationid="jenya" creationdate="20230618T183521Z">
        <seg>Чтобы увидеть, что это за тип, Haskell пришлось бы на самом деле оценить `read "5"`.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Tuples are much more rigid because each different size of tuple is its own type, so you can't write a general function to append an element to a tuple — you'd have to write a function for appending to a pair, one function for appending to a triple, one function for appending to a 4-tuple, etc.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230617T112211Z" creationid="jenya" creationdate="20230617T112211Z">
        <seg>Кортежи намного более жесткие, потому что каждый кортеж разного размера имеет свой собственный тип, поэтому вы не можете написать общую функцию для добавления элемента к кортежу — вам пришлось бы написать функцию для добавления к паре, одну функцию для добавления к тройке, одну функцию для добавления к 4-му кортежу и т.д.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Tuples are types but they are dependent on their length as well as the types of their components, so there is theoretically an infinite number of tuple types, which is too many to cover in this tutorial.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230618T151235Z" creationid="jenya" creationdate="20230618T151235Z">
        <seg>Кортежи - это типы, которые зависят от длины кортежей, а также от типов их компонентов, поэтому теоретически существует бесконечное количество типов кортежей, которых слишком много, чтобы рассматривать их в этом руководстве.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Tuples can also be used to represent a wide variety of data.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230617T112044Z" creationid="jenya" creationdate="20230617T112044Z">
        <seg>Кортежи также могут использоваться для представления самых разнообразных данных.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Tuples, however, are used when you know exactly how many values you want to combine and its type depends on how many components it has and the types of the components.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230617T111536Z" creationid="jenya" creationdate="20230617T111536Z">
        <seg>Однако кортежи используются, когда вы точно знаете, сколько значений вы хотите объединить, а их тип зависит от того, сколько в нем компонентов и типов компонентов.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Two useful functions that operate on pairs:</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230617T112428Z" creationid="jenya" creationdate="20230617T112428Z">
        <seg>Две полезные функции, которые работают с парами:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Type annotations are a way of explicitly saying what the type of an expression should be.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230618T183311Z" creationid="jenya" creationdate="20230618T183311Z">
        <seg>Аннотации типов - это способ явно указать, каким должен быть тип выражения.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Type inference also allows your code to be more general.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230615T173100Z" creationid="jenya" creationdate="20230615T173100Z">
        <seg>Вывод типа также позволяет вашему коду быть более общим.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Types in this class: `()`, `Bool`, `Char`, `Ordering`, `Int`, `Integer`, `Float` and `Double`.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230618T183856Z" creationid="jenya" creationdate="20230618T183856Z">
        <seg>Типы в этом классе: `()`, `Bool`, `Char`, `Ordering`, `Int`, `Integer`, `Float` и `Double`.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Ugh!</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230619T130835Z" creationid="jenya" creationdate="20230619T130835Z">
        <seg>Тьфу!</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Unlike Java or Pascal, Haskell has type inference.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230618T144103Z" creationid="jenya" creationdate="20230618T144103Z">
        <seg>В отличие от Java или Pascal, в Haskell есть вывод типа.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Unlike a list, a tuple can contain a combination of several types.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230617T111551Z" creationid="jenya" creationdate="20230617T111551Z">
        <seg>В отличие от списка, кортеж может содержать комбинацию нескольких типов.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Unlike lists, each tuple length has its own type.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230618T145043Z" creationid="jenya" creationdate="20230618T145043Z">
        <seg>В отличие от списков, длина каждого кортежа имеет свой собственный тип.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Use this function instead of `xs == []` (if you have a list called `xs`)</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230617T080827Z" creationid="jenya" creationdate="20230617T080827Z">
        <seg>Используйте эту функцию вместо `xs == []` (если у вас есть список с именем `xs`)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Use tuples when you know in advance how many components some piece of data should have.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230617T112137Z" creationid="jenya" creationdate="20230617T112137Z">
        <seg>Используйте кортежи, когда вы заранее знаете, сколько компонентов должно быть в том или ином фрагменте данных.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Usually on 32-bit machines the maximum possible `Int` is 2147483647 and the minimum is -2147483648.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230618T150101Z" creationid="jenya" creationdate="20230618T150101Z">
        <seg>Обычно на 32-разрядных машинах максимально возможное значение `Int` равно 2147483647, а минимальное -2147483648.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Usually, they're indented a bit to the right and lined up.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230619T125853Z" creationid="jenya" creationdate="20230619T125853Z">
        <seg>Обычно они имеют небольшой отступ вправо и выстраиваются в ряд.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Watch out when repeatedly using the `++` operator on long strings.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230617T075128Z" creationid="jenya" creationdate="20230617T075128Z">
        <seg>Будьте осторожны при повторном использовании оператора `++` для длинных строк.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Watch out when using floating point numbers in ranges!</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230617T090723Z" creationid="jenya" creationdate="20230617T090723Z">
        <seg>Будьте осторожны при использовании чисел с плавающей запятой в диапазонах!</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Watch.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230617T080913Z" creationid="jenya" creationdate="20230617T080913Z">
        <seg>Посмотри.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>We already implemented our own `length` function using list comprehension.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230619T122452Z" creationid="jenya" creationdate="20230619T122434Z">
        <seg>Мы уже реализовали нашу собственную функцию `length`, используя списковое включение.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>We can also define a factorial function _recursively_, the way it is usually defined in mathematics.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230619T114647Z" creationid="jenya" creationdate="20230619T114632Z">
        <seg>Мы также можем определить функцию факториала _рекурсивно_, как это обычно определяется в математике.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>We can also use several operators on one line and all the usual precedence rules are obeyed.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230616T095232Z" creationid="jenya" creationdate="20230616T095232Z">
        <seg>Мы также можем использовать несколько операторов в одной строке, и при этом соблюдаются все обычные правила приоритета.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>We can include several predicates.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230617T105208Z" creationid="jenya" creationdate="20230617T105208Z">
        <seg>Мы можем включить несколько предикатов.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>We can read the previous type declaration like this: the equality function takes any two values that are of the same type and returns a `Bool`.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230618T160703Z" creationid="jenya" creationdate="20230618T160348Z">
        <seg>Мы можем прочитать предыдущее объявление типа следующим образом: функция равенства принимает любые два значения одного и того же типа и возвращает `Bool`.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>We can use parentheses to make the precedence explicit or to change it.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230616T095311Z" creationid="jenya" creationdate="20230616T095311Z">
        <seg>Мы можем использовать круглые скобки, чтобы сделать приоритет явным или изменить его.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>We can't rewrite `(x:y:_)` with square brackets because it matches any list of length 2 or more.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230619T122358Z" creationid="jenya" creationdate="20230619T122358Z">
        <seg>Мы не можем переписать `(x:y:_)` в квадратных скобках, потому что он соответствует любому списку длиной 2 или более.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>We could do something like `[[1,2],[8,11],[4,5]]`.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230617T111634Z" creationid="jenya" creationdate="20230617T111634Z">
        <seg>Мы могли бы сделать что-то вроде `[[1,2],[8,11],[4,5]]`.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>We could have also defined it as `doubleUs x y = x + x + y + y`.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230616T162740Z" creationid="jenya" creationdate="20230616T162740Z">
        <seg>Мы могли бы также определить это как `doubleUs x y = x + x + y + y`.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>We could have also written that if statement in one line but I find this way more readable.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230617T073652Z" creationid="jenya" creationdate="20230617T073347Z">
        <seg>Мы могли бы также написать это выражение `if` в одной строке, но я нахожу этот способ более читабельным.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>We could use a list comprehension for that.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230617T103429Z" creationid="jenya" creationdate="20230617T100203Z">
        <seg>Для этого мы могли бы использовать списковое включение.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>We covered some of the basics of Haskell with only a very superficial glance at types.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230618T144325Z" creationid="jenya" creationdate="20230618T144325Z">
        <seg>Мы рассмотрели некоторые основы Haskell, лишь очень поверхностно взглянув на типы.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>We defined the factorial of a number `n` as `product [1..n]`.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230619T114629Z" creationid="jenya" creationdate="20230619T114629Z">
        <seg>Мы определили факториал числа `n` как `произведение [1..n]`.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>We didn't have to give this function a type declaration because the compiler can infer by itself that it's a function from a string to a string but we did anyway.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230618T145428Z" creationid="jenya" creationdate="20230618T145428Z">
        <seg>Нам не нужно было давать этой функции объявление типа, потому что компилятор может сам сделать вывод, что это функция из строки в строку, но мы все равно это сделали.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>We do that by adding `::` at the end of the expression and then specifying a type.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230618T183428Z" creationid="jenya" creationdate="20230618T183428Z">
        <seg>Мы делаем это, добавляя `::` в конце выражения, а затем указывая тип.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>We know that the sum of an empty list is 0.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230619T123322Z" creationid="jenya" creationdate="20230619T123322Z">
        <seg>Мы знаем, что сумма пустого списка равна 0.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>We repeat ourselves three times.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230620T090250Z" creationid="jenya" creationdate="20230620T090250Z">
        <seg>Мы повторяем это три раза.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>We say that the length is equal to 1 plus the length of the tail.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230619T122634Z" creationid="jenya" creationdate="20230619T122634Z">
        <seg>Мы говорим, что длина равна 1 плюс длина хвоста.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>We see a new thing here, the `=&gt;` symbol.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230618T160343Z" creationid="jenya" creationdate="20230618T160343Z">
        <seg>Здесь мы видим новую вещь - символ `=&gt;`.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>We see that `fst` takes a tuple which contains two types and returns an element which is of the same type as the pair's first component.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230618T154826Z" creationid="jenya" creationdate="20230618T154826Z">
        <seg>Мы видим, что `fst` принимает кортеж, который содержит два типа, и возвращает элемент того же типа, что и первый компонент пары.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>We start by saying that the factorial of 0 is 1.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230619T114657Z" creationid="jenya" creationdate="20230619T114657Z">
        <seg>Мы начнем с того, что скажем, что факториал 0 равен 1.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>We took a list of numbers and we filtered them by the predicate.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230617T102804Z" creationid="jenya" creationdate="20230617T102804Z">
        <seg>Мы взяли список чисел и отфильтровали их по предикату.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>We use `_` to match the head because we don't actually care what it is.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230619T122640Z" creationid="jenya" creationdate="20230619T122640Z">
        <seg>Мы используем `_` для обозначения заголовка, потому что на самом деле нам все равно, что это такое.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>We usually use `'` to either denote a strict version of a function (one that isn't lazy) or a slightly modified version of a function or a variable.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230617T073847Z" creationid="jenya" creationdate="20230617T073830Z">
        <seg>Обычно мы используем `'` либо для обозначения строгой версии функции (той, которая не является ленивой), либо для слегка измененной версии функции или переменной.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>We write that down as a pattern.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230619T123325Z" creationid="jenya" creationdate="20230619T123325Z">
        <seg>Мы записываем это как шаблон.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>We'd have to write `succ (9 * 10)` to get 91.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230616T113510Z" creationid="jenya" creationdate="20230616T113510Z">
        <seg>Нам пришлось бы написать `succ (9 * 10)`, чтобы получить 91.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>We'll also modify this function by taking into consideration that side b isn't larger than the hypothenuse and that side a isn't larger than side b.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230617T114901Z" creationid="jenya" creationdate="20230617T114901Z">
        <seg>Мы также модифицируем эту функцию, принимая во внимание, что сторона `b` не больше гипотенузы и что сторона `a` не больше стороны `b`.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>We'll call it `length'`.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230617T110259Z" creationid="jenya" creationdate="20230617T110259Z">
        <seg>Мы будем называть это `length'`.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>We'll do that by using the `:t` command which, followed by any valid expression, tells us its type.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230618T144422Z" creationid="jenya" creationdate="20230618T144422Z">
        <seg>Мы сделаем это с помощью команды `:t`, за которой следует любое допустимое выражение, сообщающее нам его тип.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>We'll go over extracting data from tuples in different ways a bit later.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230617T112522Z" creationid="jenya" creationdate="20230617T112508Z">
        <seg>Чуть позже мы рассмотрим извлечение данных из кортежей различными способами.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>We'll see why a bit later.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230617T074114Z" creationid="jenya" creationdate="20230617T074114Z">
        <seg>Мы поймем, почему, чуть позже.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>We'll stick to getting the first 10 even numbers for now.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230617T100222Z" creationid="jenya" creationdate="20230617T100222Z">
        <seg>Пока мы будем придерживаться получения первых 10 четных чисел.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>We'll take a closer look at types a bit later.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230616T100408Z" creationid="jenya" creationdate="20230616T100408Z">
        <seg>Мы подробнее рассмотрим типы чуть позже.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>We'll take a look at more list functions [later](http://learnyouahaskell.com/modules#data-list)</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230617T083003Z" creationid="jenya" creationdate="20230617T082938Z">
        <seg>Мы рассмотрим дополнительные функции списка [позже](http://learnyouahaskell.com/modules#data-list)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>We're almost done.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230617T114915Z" creationid="jenya" creationdate="20230617T114915Z">
        <seg>Мы почти закончили.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>We're going to make a simple function that berates you differently depending on your [BMI](http://en.wikipedia.org/wiki/Body_mass_index) (body mass index).</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230619T125436Z" creationid="jenya" creationdate="20230619T125222Z">
        <seg>Мы собираемся создать простую функцию, которая ругает вас по-разному в зависимости от вашего [ИМТ](http://en.wikipedia.org/wiki/Body_mass_index)  (индекс массы тела).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>We're just drawing from three lists and our output function is combining them into a triple.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230617T114409Z" creationid="jenya" creationdate="20230617T114325Z">
        <seg>Мы просто рисуем из трех списков, и наша функция вывода объединяет их в тройку.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Welcome to **Learn You a Haskell for Great Good**!</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230611T202853Z" creationid="jenya" creationdate="20230611T143314Z">
        <seg>Добро пожаловать в **Выучи Haskell для Великого Блага**!</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Well, if we try the first snippet, we get a big scary error message!</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230616T095958Z" creationid="jenya" creationdate="20230616T095958Z">
        <seg>Что ж, если мы попробуем первый фрагмент, то получим большое пугающее сообщение об ошибке!</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Well, that works, but there's a better way to do it.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230619T120349Z" creationid="jenya" creationdate="20230619T120349Z">
        <seg>Что ж, это работает, но есть способ получше сделать это.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Well, there are no provided functions that do that but we can make our own.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230619T120511Z" creationid="jenya" creationdate="20230619T120511Z">
        <seg>Ну, нет никаких предусмотренных функций, которые делали бы это, но мы можем создать наши собственные.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Well, they're not.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230618T160141Z" creationid="jenya" creationdate="20230618T160141Z">
        <seg>Ну, это не так.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Well, we can modify our function like this:</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230620T090305Z" creationid="jenya" creationdate="20230620T090305Z">
        <seg>Что ж, мы можем изменить нашу функцию следующим образом:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Well, we'd get this error:</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230617T111952Z" creationid="jenya" creationdate="20230617T111952Z">
        <seg>Ну, мы бы получили эту ошибку:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Well, you've come to the right place, but let's talk about this tutorial a bit first.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230611T225601Z" creationid="jenya" creationdate="20230611T225424Z">
        <seg>Что ж, вы обратились по адресу, но давайте немного поговорим об этом уроке.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>What GHCI is telling us here is that `"llama"` is not a number and so it doesn't know how to add it to 5.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230616T100100Z" creationid="jenya" creationdate="20230616T100100Z">
        <seg>GHCI говорит нам здесь, что "llama" - это не число, и поэтому он не знает, как добавить его к 5.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>What GHCI is telling us here is that it doesn't know what we want in return.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230618T181202Z" creationid="jenya" creationdate="20230618T181154Z">
        <seg>Что GHCI говорит нам здесь, так это то, что он не знает, чего мы хотим взамен.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>What about doing `5 + "llama"` or `5 == True`?</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230616T095950Z" creationid="jenya" creationdate="20230616T095950Z">
        <seg>Как насчет того, чтобы сделать `5 + "llama"` или `5 == True`?</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>What are you, some kind of liar?</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230615T170457Z" creationid="jenya" creationdate="20230615T170457Z">
        <seg>Ты что, какой-то лжец?</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>What comes after "John"?</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230617T090526Z" creationid="jenya" creationdate="20230617T090526Z">
        <seg>Что следует за словом "John"?</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>What do you think is the type of the `head` function?</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230618T151612Z" creationid="jenya" creationdate="20230618T151612Z">
        <seg>Как вы думаете, что это за тип функции `head`?</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>What else can you do with lists?</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230617T080519Z" creationid="jenya" creationdate="20230617T080519Z">
        <seg>Что еще вы можете сделать со списками?</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>What happens if the lengths of the lists don't match?</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230617T112908Z" creationid="jenya" creationdate="20230617T112908Z">
        <seg>Что произойдет, если длины списков не совпадут?</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>What if some mathematicians figured out that 2 is actually 3 and you had to change your program?</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230616T163105Z" creationid="jenya" creationdate="20230616T163105Z">
        <seg>Что, если бы какие-нибудь математики выяснили, что 2 на самом деле равно 3, и вам пришлось бы изменить свою программу?</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>What if we tried to make a shape like `[(1,2),(8,11,5),(4,5)]`?</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230617T111934Z" creationid="jenya" creationdate="20230617T111915Z">
        <seg>Что, если бы мы попытались создать форму, подобную `[(1,2),(8,11,5),(4,5)]`?</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>What if we want a list of all numbers between 1 and 20?</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230617T083019Z" creationid="jenya" creationdate="20230617T083019Z">
        <seg>Что, если нам нужен список всех чисел от 1 до 20?</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>What if we want all even numbers between 1 and 20?</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230617T090621Z" creationid="jenya" creationdate="20230617T090621Z">
        <seg>Что, если нам нужны все четные числа от 1 до 20?</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>What if we wanted all possible products that are more than 50?</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230617T105843Z" creationid="jenya" creationdate="20230617T105838Z">
        <seg>Что, если бы нам понадобились все возможные произведения, которых более 50?</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>What if we wanted to make a function that takes two vectors in a 2D space (that are in the form of pairs) and adds them together?</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230619T120317Z" creationid="jenya" creationdate="20230619T120317Z">
        <seg>Что, если бы мы хотели создать функцию, которая берет два вектора в 2D-пространстве (которые находятся в виде пар) и складывает их вместе?</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>What is this `a`?</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230618T151651Z" creationid="jenya" creationdate="20230618T151646Z">
        <seg>Что это за буква `a`?</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>What that means for us is that these two statements are equivalent.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230616T113148Z" creationid="jenya" creationdate="20230616T113148Z">
        <seg>Для нас это означает, что эти два утверждения эквивалентны.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>What's the type signature of the `==` function?</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230618T160157Z" creationid="jenya" creationdate="20230618T160142Z">
        <seg>Какова сигнатура типа функции `==`?</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Whatever!</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230619T130632Z" creationid="jenya" creationdate="20230619T130632Z">
        <seg>Неважно!</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>When I was starting out in Haskell, I didn't learn from just one resource.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230612T110259Z" creationid="jenya" creationdate="20230612T110259Z">
        <seg>Когда я начинал изучать Haskell, я учился на нескольких ресурсах.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>When a function doesn't take any parameters, we usually say it's a _definition_ (or a _name_).</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230617T074409Z" creationid="jenya" creationdate="20230617T074152Z">
        <seg>Когда функция не принимает никаких параметров, мы обычно говорим, что это _определение_ (или _имя_^[Честно говоря не знаю как правильнее в данном случае перевести слово name]).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>When defining functions, you can define separate function bodies for different patterns.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230619T114021Z" creationid="jenya" creationdate="20230619T114021Z">
        <seg>При определении функций вы можете определить отдельные тела функций для разных шаблонов.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>When drawing from several lists, comprehensions produce all combinations of the given lists and then join them by the output function we supply.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230617T105558Z" creationid="jenya" creationdate="20230617T105558Z">
        <seg>При рисовании из нескольких списковых включений создает все комбинации заданных списков, а затем объединяет их с помощью функции вывода, которую мы предоставляем.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>When making patterns, we should always include a catch-all pattern so that our program doesn't crash if we get some unexpected input.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230619T120303Z" creationid="jenya" creationdate="20230619T120303Z">
        <seg>При создании шаблонов мы всегда должны включать универсальный шаблон, чтобы наша программа не завершилась сбоем, если мы получим какие-то неожиданные входные данные.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>When using `&lt;`, `&lt;=`, `&gt;` and `&gt;=` to compare lists, they are compared in lexicographical order.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230617T080423Z" creationid="jenya" creationdate="20230617T080423Z">
        <seg>При использовании `&lt;`, `&lt;=`, `&gt;` и `&gt;=` для сравнения списков они сравниваются в лексикографическом порядке.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>When using `head`, `tail`, `last` and `init`, be careful not to use them on empty lists.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230617T080735Z" creationid="jenya" creationdate="20230617T080735Z">
        <seg>При использовании `head`, `tail`, `last` и `init` будьте осторожны и не используйте их в пустых списках.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>When writing our own functions, we can choose to give them an explicit type declaration.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230618T145113Z" creationid="jenya" creationdate="20230618T145113Z">
        <seg>При написании наших собственных функций мы можем предоставить им явное объявление типа.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>When you call `lucky`, the patterns will be checked from top to bottom and when it conforms to a pattern, the corresponding function body will be used.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230619T114105Z" creationid="jenya" creationdate="20230619T114105Z">
        <seg>Когда вы вызываете `lucky`, шаблоны будут проверены сверху вниз, и когда они будут соответствовать шаблону, будет использовано соответствующее тело функции.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>When you compile your program, the compiler knows which piece of code is a number, which is a string and so on.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230615T172825Z" creationid="jenya" creationdate="20230615T172825Z">
        <seg>Когда вы компилируете свою программу, компилятор знает, какой фрагмент кода является числом, который - строкой и так далее.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>When you put together two lists (even if you append a singleton list to a list, for instance: `[1,2,3] ++ [4]`), internally, Haskell has to walk through the whole list on the left side of `++`.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230617T075159Z" creationid="jenya" creationdate="20230617T075159Z">
        <seg>Когда вы объединяете два списка (даже если вы добавляете одноэлементный список к списку, например: `[1,2,3] ++ [4]`), внутренне Haskell должен просмотреть весь список в левой части `++`.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Whereas `+` works only on things that are considered numbers, `==` works on any two things that can be compared.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230616T100338Z" creationid="jenya" creationdate="20230616T100338Z">
        <seg>В то время как `+` работает только с теми вещами, которые считаются числами, `==` работает с любыми двумя вещами, которые можно сравнить.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Whereas patterns are a way of making sure a value conforms to some form and deconstructing it, guards are a way of testing whether some property of a value (or several of them) are true or false.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230619T125124Z" creationid="jenya" creationdate="20230619T124544Z">
        <seg>В то время как образцы - это способ убедиться, что значение соответствует некоторой форме, и деструктуризации образцов, охранные выражения - это способ проверить, является ли какое-либо свойство значения (или несколько из них) истинным или ложным.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Which reminds me, you can also pattern match in list comprehensions.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230619T120630Z" creationid="jenya" creationdate="20230619T120611Z">
        <seg>Это напоминает мне, что вы также можете сопоставлять шаблоны в списковом включении.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>While big if else trees are usually frowned upon, sometimes a problem is defined in such a discrete way that you can't get around them.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230619T130128Z" creationid="jenya" creationdate="20230619T130128Z">
        <seg>В то время как к большим деревьям if else обычно относятся неодобрительно, иногда проблема определяется таким дискретным способом, что вы не можете их обойти.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>While executing them, it can change state.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230615T165151Z" creationid="jenya" creationdate="20230615T165151Z">
        <seg>Во время их выполнения он может изменять состояние.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>While pretty smart, ranges with steps aren't as smart as some people expect them to be.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230617T090642Z" creationid="jenya" creationdate="20230617T090642Z">
        <seg>Несмотря на то, что диапазоны со ступенями довольно умны, они не так умны, как некоторые люди ожидают от них.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>While there are singleton lists, there's no such thing as a singleton tuple.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230617T112223Z" creationid="jenya" creationdate="20230617T112223Z">
        <seg>Хотя существуют одноэлементные списки, такого понятия, как одноэлементный кортеж, не существует.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>With that in mind, we could redefine `doubleUs` like this:</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230616T163032Z" creationid="jenya" creationdate="20230616T163032Z">
        <seg>Имея это в виду, мы могли бы переопределить `doubleUs` следующим образом:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Without pattern matching, we'd have to make a pretty convoluted if then else tree.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230619T114232Z" creationid="jenya" creationdate="20230619T114232Z">
        <seg>Без сопоставления с шаблоном нам пришлось бы создать довольно запутанное дерево if then else.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Work on Haskell began in 1987 when a committee of researchers got together to design a kick-ass language.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230615T173549Z" creationid="jenya" creationdate="20230615T173549Z">
        <seg>Работа над Haskell началась в 1987 году, когда комитет исследователей собрался вместе для разработки потрясающего языка.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Yay!</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230619T130557Z" creationid="jenya" creationdate="20230619T130557Z">
        <seg>Ура!</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Yeah, I know it's not but bear with me.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230616T095637Z" creationid="jenya" creationdate="20230616T095637Z">
        <seg>Да, я знаю, что это не так, но потерпи меня.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Yikes!</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230617T115035Z" creationid="jenya" creationdate="20230616T100025Z">
        <seg>Черт возьми!</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>You also can't set a variable to something and then set it to something else later.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230615T170331Z" creationid="jenya" creationdate="20230615T170331Z">
        <seg>Вы также не можете присвоить переменной значение чего-то, а затем присвоить ей значение чего-то другого позже.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>You also couldn't make a list like `[(1,2),("One",2)]` because the first element of the list is a pair of numbers and the second element is a pair consisting of a string and a number.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230617T112033Z" creationid="jenya" creationdate="20230617T112033Z">
        <seg>Вы также не смогли бы составить список типа `[(1,2),("Один",2)]`, потому что первый элемент списка - это пара чисел, а второй элемент - это пара, состоящая из строки и числа.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>You can also use ranges to make infinite lists by just not specifying an upper limit.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230617T090753Z" creationid="jenya" creationdate="20230617T090753Z">
        <seg>Вы также можете использовать диапазоны для создания бесконечных списков, просто не указывая верхний предел.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>You can call functions from scripts that you load and the results are displayed immediately.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230615T173840Z" creationid="jenya" creationdate="20230615T173840Z">
        <seg>Вы можете вызывать функции из скриптов, которые вы загружаете, и результаты отображаются немедленно.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>You can match with the empty list `[]` or any pattern that involves `:` and the empty list.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230619T121128Z" creationid="jenya" creationdate="20230619T121128Z">
        <seg>Вы можете сопоставить с пустым списком `[]` или любым шаблоном, который включает `:` и пустой список.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>You can pattern match on any data type — numbers, characters, lists, tuples, etc.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230619T114039Z" creationid="jenya" creationdate="20230619T114039Z">
        <seg>Вы можете сопоставлять шаблоны для любого типа данных — числа, символы, списки, кортежи и т.д.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>You can think of them kind of as Java interfaces, only better.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230618T160147Z" creationid="jenya" creationdate="20230618T160147Z">
        <seg>Вы можете думать о них как о интерфейсах Java, только лучше.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>You can write list comprehensions across several lines.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230617T110946Z" creationid="jenya" creationdate="20230617T110946Z">
        <seg>Вы можете написать списковое включение в нескольких строках.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>You can't compare apples and oranges.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230616T100356Z" creationid="jenya" creationdate="20230616T100356Z">
        <seg>Вы не можете сравнивать яблоки и апельсины.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>You can't do `[1,2,4,8,16..100]` and expect to get all the powers of 2.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230617T090648Z" creationid="jenya" creationdate="20230617T090648Z">
        <seg>Вы не можете выполнить `[1,2,4,8,16..100]` и ожидать, что получите все степени 2.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>You could just redefine `doubleMe` to be `x + x + x` and since `doubleUs` calls `doubleMe`, it would automatically work in this strange new world where 2 is 3.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230616T173629Z" creationid="jenya" creationdate="20230616T173629Z">
        <seg>Вы могли бы просто переопределить `doubleMe` на `x + x + x`, и поскольку `doubleUs` вызывает `doubleMe`, это автоматически сработало бы в этом странном новом мире, где 2 равно 3.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>You do that by putting a name and an `@` in front of a pattern.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230619T124710Z" creationid="jenya" creationdate="20230619T123450Z">
        <seg>Вы делаете это, помещая имя и знак `@` перед образцом.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>You express that in the form of functions.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230615T170250Z" creationid="jenya" creationdate="20230615T170250Z">
        <seg>Вы выражаете это в форме функций.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>You have control flow structures for doing some action several times.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230615T165654Z" creationid="jenya" creationdate="20230615T165153Z">
        <seg>У вас есть структуры потока управления для выполнения какого-либо действия несколько раз.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>You may not have known it but we've been using functions now all along.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230616T100748Z" creationid="jenya" creationdate="20230616T100748Z">
        <seg>Возможно, вы этого не знали, но мы все это время использовали функции.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>You probably already have your favorite text editor installed so we won't waste time on that.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230615T173638Z" creationid="jenya" creationdate="20230615T173638Z">
        <seg>Вероятно, у вас уже установлен ваш любимый текстовый редактор, так что мы не будем тратить на это время.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>You take a starting set of solutions and then you apply transformations to those solutions and filter them until you get the right ones.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230617T114956Z" creationid="jenya" creationdate="20230617T114956Z">
        <seg>Вы берете начальный набор решений, а затем применяете преобразования к этим решениям и фильтруете их до тех пор, пока не получите правильные.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>You will be greeted with something like this.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230616T093129Z" creationid="jenya" creationdate="20230616T093129Z">
        <seg>Вас встретят чем-то вроде этого.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>You're probably familiar with if statements from other languages.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230616T174117Z" creationid="jenya" creationdate="20230616T174112Z">
        <seg>Вероятно, вы знакомы с операторами `if` из других языков.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Your BMI equals your weight divided by your height squared.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230619T125434Z" creationid="jenya" creationdate="20230619T125248Z">
        <seg>Ваш ИМТ равен вашему весу, деленному на ваш рост в квадрате.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>`"hello"` is just syntactic sugar for `['h','e','l','l','o']`.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230617T075039Z" creationid="jenya" creationdate="20230617T075039Z">
        <seg>`"hello"` - это просто синтаксический сахар для `['h','e','l','l','o']`.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>`'a'`, as it would seem, has a type of `Char`.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230618T144738Z" creationid="jenya" creationdate="20230618T144738Z">
        <seg>`'a'`, как могло бы показаться, имеет тип `Char`.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>`+` expects its left and right side to be numbers.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230616T100138Z" creationid="jenya" creationdate="20230616T100138Z">
        <seg>`+` ожидает, что его левая и правая стороны будут числами.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>`4 == 5` will always return `False`, so its type is `Bool`.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230618T145103Z" creationid="jenya" creationdate="20230618T145103Z">
        <seg>`4 == 5` всегда возвращает `False`, поэтому его тип - `Bool`.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>`4.0` can't act like an integer, so `5` is the one that has to adapt.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230616T100735Z" creationid="jenya" creationdate="20230616T100554Z">
        <seg>`4.0` не может действовать как целое число, поэтому `5` - это то, что должно адаптироваться.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>`5` is an expression because it returns 5, `4 + 8` is an expression, `x + y` is an expression because it returns the sum of `x` and `y`.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230617T073628Z" creationid="jenya" creationdate="20230617T073628Z">
        <seg>`5` - это выражение, потому что оно возвращает 5, `4 + 8` - это выражение, `x + y` - это выражение, потому что оно возвращает сумму `x` и `y`.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>`7` can be an `Int` but `7.2` cannot.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230618T150047Z" creationid="jenya" creationdate="20230618T150047Z">
        <seg>`7` может быть `Int`, но `7.2` не может.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>`::` is read as "has type of".</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230618T144712Z" creationid="jenya" creationdate="20230618T144712Z">
        <seg>`::` читается как "имеет тип".</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>`Bool` is a boolean type.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230618T151056Z" creationid="jenya" creationdate="20230618T151056Z">
        <seg>`Bool` - это логический тип.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>`Bounded` members have an upper and a lower bound.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230618T184429Z" creationid="jenya" creationdate="20230618T183915Z">
        <seg>Элементы типа `Bounded` имеют верхнюю и нижнюю границы.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>`Char` represents a character.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230618T151105Z" creationid="jenya" creationdate="20230618T151105Z">
        <seg>`Char` представляет символ.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>`Double` is a real floating point with double the precision!</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230618T151048Z" creationid="jenya" creationdate="20230618T151048Z">
        <seg>`Double` - это настоящая плавающая точка с удвоенной точностью!</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>`Enum` members are sequentially ordered types — they can be enumerated.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230618T183632Z" creationid="jenya" creationdate="20230618T183544Z">
        <seg>Члены `Enum` представляют собой последовательно упорядоченные типы — их можно перечислять.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>`Eq` is used for types that support equality testing.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230618T160821Z" creationid="jenya" creationdate="20230618T160821Z">
        <seg>`Eq` используется для типов, которые поддерживают проверку на равенство.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>`Float` is a real floating point with single precision.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230618T151031Z" creationid="jenya" creationdate="20230618T151031Z">
        <seg>`Float` - это реальная плавающая точка с одинарной точностью.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>`Floating` includes only floating point numbers, so `Float` and `Double`.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230618T190337Z" creationid="jenya" creationdate="20230618T190337Z">
        <seg>`Floating` включает в себя только числа с плавающей запятой, поэтому `Float` и `Double`.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>`Int` is bounded, which means that it has a minimum and a maximum value.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230618T150054Z" creationid="jenya" creationdate="20230618T150054Z">
        <seg>`Int` ограничен, что означает, что он имеет минимальное и максимальное значения.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>`Int` stands for integer.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230618T150039Z" creationid="jenya" creationdate="20230618T150039Z">
        <seg>`Int` означает целое число.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>`Int`, however, is more efficient.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230618T150930Z" creationid="jenya" creationdate="20230618T150930Z">
        <seg>`Int`, однако, более эффективен.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>`Integer` stands for, er … also integer.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230618T150908Z" creationid="jenya" creationdate="20230618T150908Z">
        <seg>`Integer` означает, э-э... тоже целое число.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>`Integral` is also a numeric typeclass.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230618T185828Z" creationid="jenya" creationdate="20230618T185828Z">
        <seg>`Integral` также является числовым классом типов.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>`Num` includes all numbers, including real numbers and integral numbers, `Integral` includes only integral (whole) numbers.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230618T185838Z" creationid="jenya" creationdate="20230618T185838Z">
        <seg>`Num` включает в себя все числа, включая действительные числа и целые числа, `Integral` включает в себя только целые числа.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>`Num` is a numeric typeclass.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230618T185414Z" creationid="jenya" creationdate="20230618T185414Z">
        <seg>`Num` - это числовой класс типов.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>`Ord` covers all the standard comparing functions such as `&gt;`, `&lt;`, `&gt;=` and `&lt;=`.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230618T174623Z" creationid="jenya" creationdate="20230618T174623Z">
        <seg>`Ord` охватывает все стандартные функции сравнения, такие как `&gt;`, `&lt;`, `&gt;=` и `&lt;=`.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>`Ord` is for types that have an ordering.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230618T161121Z" creationid="jenya" creationdate="20230618T161121Z">
        <seg>`Ord` предназначен для типов, которые имеют порядок.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>`Ordering` is a type that can be `GT`, `LT` or `EQ`, meaning _greater than_, _lesser than_ and _equal_, respectively.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230618T180300Z" creationid="jenya" creationdate="20230618T174633Z">
        <seg>`Ordering` - это тип, который может быть `GT`, `LT` или `EQ`, что означает _больше чем_ , _меньше чем_ и _эквивалентно_ соответственно. (англ. _greater than_, _lesser than_, _equal_ соответственно)</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>`Read a' arising from a use of `read' at &lt;interactive&gt;:1:0-7</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230618T181153Z" creationid="jenya" creationdate="20230618T181153Z">
        <seg>`Read a' arising from a use of `read' at &lt;interactive&gt;:1:0-7</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>`Read` is sort of the opposite typeclass of `Show`.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230618T180844Z" creationid="jenya" creationdate="20230618T180844Z">
        <seg>`Read` - это своего рода класс, противоположный типу `Show`.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>`True` is of a `Bool` type.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230618T144900Z" creationid="jenya" creationdate="20230618T144900Z">
        <seg>`True` относится к типу `Bool`.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>`[1,2,3]` is actually just syntactic sugar for `1:2:3:[]`.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230617T075409Z" creationid="jenya" creationdate="20230617T075409Z">
        <seg>`[1,2,3]` на самом деле является просто синтаксическим сахаром для `1:2:3:[]`.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>`[]` is an empty list.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230617T075416Z" creationid="jenya" creationdate="20230617T075416Z">
        <seg>`[]` - это пустой список.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>`_` means that we don't care what we'll draw from the list anyway so instead of writing a variable name that we'll never use, we just write `_`.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230617T110315Z" creationid="jenya" creationdate="20230617T110315Z">
        <seg>`_` означает, что нам все равно, что мы будем извлекать из списка, поэтому вместо того, чтобы писать имя переменной, которое мы никогда не будем использовать, мы просто пишем `_`.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>```haskell
Couldn't match expected type `(t, t1)'
against inferred type `(t2, t3, t4)'
In the expression: (8, 11, 5)
In the expression: [(1, 2), (8, 11, 5), (4, 5)]
In the definition of `it': it = [(1, 2), (8, 11, 5), (4, 5)]
```</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230617T111954Z" creationid="jenya" creationdate="20230617T111954Z">
        <seg>```haskell
Couldn't match expected type `(t, t1)'
against inferred type `(t2, t3, t4)'
In the expression: (8, 11, 5)
In the expression: [(1, 2), (8, 11, 5), (4, 5)]
In the definition of `it': it = [(1, 2), (8, 11, 5), (4, 5)]
```</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>```haskell
GHCi, version 6.8.2: http://www.haskell.org/ghc/  :?</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230616T093200Z" creationid="jenya" creationdate="20230616T093200Z">
        <seg>```haskell
GHCi, version 6.8.2: http://www.haskell.org/ghc/  :?</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>```haskell
No instance for (Num [Char])
arising from a use of `+' at &lt;interactive&gt;:1:0-9
Possible fix: add an instance declaration for (Num [Char])
In the expression: 5 + "llama"
In the definition of `it': it = 5 + "llama" 
```</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230616T100020Z" creationid="jenya" creationdate="20230616T100020Z">
        <seg>```haskell
No instance for (Num [Char])
arising from a use of `+' at &lt;interactive&gt;:1:0-9
Possible fix: add an instance declaration for (Num [Char])
In the expression: 5 + "llama"
In the definition of `it': it = 5 + "llama" 
```</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>```haskell
addThree :: Int -&gt; Int -&gt; Int -&gt; Int
addThree x y z = x + y + z
```</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230618T145504Z" creationid="jenya" creationdate="20230618T145504Z">
        <seg>```haskell
addThree :: Int -&gt; Int -&gt; Int -&gt; Int
addThree x y z = x + y + z
```</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>```haskell
boomBangs xs = [ if x &lt; 10 then "BOOM!" else "BANG!" | x &lt;- xs, odd x] 
```</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230617T103809Z" creationid="jenya" creationdate="20230617T103809Z">
        <seg>```haskell
boomBangs xs = [ if x &lt; 10 then "BOOM!" else "BANG!" | x &lt;- xs, odd x] 
```</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>```haskell
circumference :: Float -&gt; Float
circumference r = 2 * pi * r
```</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230618T151033Z" creationid="jenya" creationdate="20230618T151033Z">
        <seg>```haskell
circumference :: Float -&gt; Float
circumference r = 2 * pi * r
```</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>```haskell
circumference' :: Double -&gt; Double
circumference' r = 2 * pi * r
```</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230618T151049Z" creationid="jenya" creationdate="20230618T151049Z">
        <seg>```haskell
circumference' :: Double -&gt; Double
circumference' r = 2 * pi * r
```</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>```haskell
conanO'Brien = "It's a-me, Conan O'Brien!" 
```</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230617T073919Z" creationid="jenya" creationdate="20230617T073919Z">
        <seg>```haskell
conanO'Brien = "It's a-me, Conan O'Brien!" 
```</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>```haskell
doubleMe x = x + x
```</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230616T132719Z" creationid="jenya" creationdate="20230616T132719Z">
        <seg>```haskell
doubleMe x = x + x
```</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>```haskell
doubleSmallNumber x = if x &gt; 100</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230616T173828Z" creationid="jenya" creationdate="20230616T173828Z">
        <seg>```haskell
doubleSmallNumber x = if x &gt; 100</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>```haskell
doubleSmallNumber' x = (if x &gt; 100 then x else x*2) + 1
```</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230617T073732Z" creationid="jenya" creationdate="20230617T073732Z">
        <seg>```haskell
doubleSmallNumber' x = (if x &gt; 100 then x else x*2) + 1
```</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>```haskell
doubleUs x y = doubleMe x + doubleMe y 
```</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230616T163038Z" creationid="jenya" creationdate="20230616T163038Z">
        <seg>```haskell
doubleUs x y = doubleMe x + doubleMe y 
```</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>```haskell
doubleUs x y = x*2 + y*2 
```</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230616T162717Z" creationid="jenya" creationdate="20230616T162717Z">
        <seg>```haskell
doubleUs x y = x*2 + y*2 
```</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>```haskell
factorial :: Integer -&gt; Integer
factorial n = product [1..n]
```</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230618T150932Z" creationid="jenya" creationdate="20230618T150932Z">
        <seg>```haskell
factorial :: Integer -&gt; Integer
factorial n = product [1..n]
```</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>```haskell
ghci&gt; "Abrakadabra" &lt; "Zebra"
True
ghci&gt; "Abrakadabra" `compare` "Zebra"
LT
ghci&gt; 5 &gt;= 2
True
ghci&gt; 5 `compare` 3
GT
```</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230618T180651Z" creationid="jenya" creationdate="20230618T180651Z">
        <seg>```haskell
ghci&gt; "Abrakadabra" &lt; "Zebra"
True
ghci&gt; "Abrakadabra" `compare` "Zebra"
LT
ghci&gt; 5 &gt;= 2
True
ghci&gt; 5 `compare` 3
GT
```</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>```haskell
ghci&gt; "Steve Buscemi" !!</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230617T075511Z" creationid="jenya" creationdate="20230617T075511Z">
        <seg>```haskell
ghci&gt; "Steve Buscemi" !!</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>```haskell
ghci&gt; 'A':" SMALL CAT"
"A SMALL CAT"
ghci&gt; 5:[1,2,3,4,5]
[5,1,2,3,4,5]
```</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230617T075242Z" creationid="jenya" creationdate="20230617T075242Z">
        <seg>```haskell
ghci&gt; 'A':" SMALL CAT"
"A SMALL CAT"
ghci&gt; 5:[1,2,3,4,5]
[5,1,2,3,4,5]
```</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>```haskell
ghci&gt; (50 * 100) - 4999
1
ghci&gt; 50 * 100 - 4999
1
ghci&gt; 50 * (100 - 4999)
-244950
```</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230616T095325Z" creationid="jenya" creationdate="20230616T095325Z">
        <seg>```haskell
ghci&gt; (50 * 100) - 4999
1
ghci&gt; 50 * 100 - 4999
1
ghci&gt; 50 * (100 - 4999)
-244950
```</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>```haskell
ghci&gt; 2 + 15
17
ghci&gt; 49 * 100
4900
ghci&gt; 1892 - 1472
420
ghci&gt; 5 / 2
2.5
ghci&gt;
```</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230616T095114Z" creationid="jenya" creationdate="20230616T095114Z">
        <seg>```haskell
ghci&gt; 2 + 15
17
ghci&gt; 49 * 100
4900
ghci&gt; 1892 - 1472
420
ghci&gt; 5 / 2
2.5
ghci&gt;
```</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>```haskell
ghci&gt; 20 :: Int
20
ghci&gt; 20 :: Integer
20
ghci&gt; 20 :: Float
20.0
ghci&gt; 20 :: Double
20.0
```</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230618T185638Z" creationid="jenya" creationdate="20230618T185638Z">
        <seg>```haskell
ghci&gt; 20 :: Int
20
ghci&gt; 20 :: Integer
20
ghci&gt; 20 :: Float
20.0
ghci&gt; 20 :: Double
20.0
```</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>```haskell
ghci&gt; 4 `elem` [3,4,5,6]
True
ghci&gt; 10 `elem` [3,4,5,6]
False
```</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230617T082936Z" creationid="jenya" creationdate="20230617T082936Z">
        <seg>```haskell
ghci&gt; 4 `elem` [3,4,5,6]
True
ghci&gt; 10 `elem` [3,4,5,6]
False
```</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>```haskell
ghci&gt; 5 == 5
True
ghci&gt; 1 == 0
False
ghci&gt; 5 /= 5
False
ghci&gt; 5 /= 4
True
ghci&gt; "hello" == "hello"
True 
```</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230616T095937Z" creationid="jenya" creationdate="20230616T095937Z">
        <seg>```haskell
ghci&gt; 5 == 5
True
ghci&gt; 1 == 0
False
ghci&gt; 5 /= 5
False
ghci&gt; 5 /= 4
True
ghci&gt; "hello" == "hello"
True 
```</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>```haskell
ghci&gt; 5 == 5
True
ghci&gt; 5 /= 5
False
ghci&gt; 'a' == 'a'
True
ghci&gt; "Ho Ho" == "Ho Ho"
True
ghci&gt; 3.432 == 3.432
True
```</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230618T161114Z" creationid="jenya" creationdate="20230618T161114Z">
        <seg>```haskell
ghci&gt; 5 == 5
True
ghci&gt; 5 /= 5
False
ghci&gt; 'a' == 'a'
True
ghci&gt; "Ho Ho" == "Ho Ho"
True
ghci&gt; 3.432 == 3.432
True
```</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>```haskell
ghci&gt; :l baby
[1 of 1] Compiling Main             ( baby.hs, interpreted )
Ok, modules loaded: Main.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230616T161053Z" creationid="jenya" creationdate="20230616T161053Z">
        <seg>```haskell
ghci&gt; :l baby
[1 of 1] Compiling Main             ( baby.hs, interpreted )
Ok, modules loaded: Main.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>```haskell
ghci&gt; :t 'a'
'a' :: Char
ghci&gt; :t True
True :: Bool
ghci&gt; :t "HELLO!"
"HELLO!" :: [Char]
ghci&gt; :t (True, 'a')
(True, 'a') :: (Bool, Char)
ghci&gt; :t 4 == 5
4 == 5 :: Bool
```</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230618T144429Z" creationid="jenya" creationdate="20230618T144429Z">
        <seg>```haskell
ghci&gt; :t 'a'
'a' :: Char
ghci&gt; :t True
True :: Bool
ghci&gt; :t "HELLO!"
"HELLO!" :: [Char]
ghci&gt; :t (True, 'a')
(True, 'a') :: (Bool, Char)
ghci&gt; :t 4 == 5
4 == 5 :: Bool
```</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>```haskell
ghci&gt; :t (*)
(*) :: (Num a) =&gt; a -&gt; a -&gt; a
```</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230618T185652Z" creationid="jenya" creationdate="20230618T185652Z">
        <seg>```haskell
ghci&gt; :t (*)
(*) :: (Num a) =&gt; a -&gt; a -&gt; a
```</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>```haskell
ghci&gt; :t (==)
(==) :: (Eq a) =&gt; a -&gt; a -&gt; Bool
```</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230618T160200Z" creationid="jenya" creationdate="20230618T160200Z">
        <seg>```haskell
ghci&gt; :t (==)
(==) :: (Eq a) =&gt; a -&gt; a -&gt; Bool
```</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>```haskell
ghci&gt; :t (&gt;)
(&gt;) :: (Ord a) =&gt; a -&gt; a -&gt; Bool
```</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230618T161123Z" creationid="jenya" creationdate="20230618T161123Z">
        <seg>```haskell
ghci&gt; :t (&gt;)
(&gt;) :: (Ord a) =&gt; a -&gt; a -&gt; Bool
```</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>```haskell
ghci&gt; :t 20
20 :: (Num t) =&gt; t
```</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230618T185424Z" creationid="jenya" creationdate="20230618T185424Z">
        <seg>```haskell
ghci&gt; :t 20
20 :: (Num t) =&gt; t
```</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>```haskell
ghci&gt; :t fst
fst :: (a, b) -&gt; a
```</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230618T154535Z" creationid="jenya" creationdate="20230618T154535Z">
        <seg>```haskell
ghci&gt; :t fst
fst :: (a, b) -&gt; a
```</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>```haskell
ghci&gt; :t head
head :: [a] -&gt; a
```</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230618T151637Z" creationid="jenya" creationdate="20230618T151637Z">
        <seg>```haskell
ghci&gt; :t head
head :: [a] -&gt; a
```</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>```haskell
ghci&gt; :t read
read :: (Read a) =&gt; String -&gt; a
```</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230618T181354Z" creationid="jenya" creationdate="20230618T181354Z">
        <seg>```haskell
ghci&gt; :t read
read :: (Read a) =&gt; String -&gt; a
```</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>```haskell
ghci&gt; True &amp;&amp; False
False
ghci&gt; True &amp;&amp; True
True
ghci&gt; False || True
True 
ghci&gt; not False
True
ghci&gt; not (True &amp;&amp; True)
False
```</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230616T095921Z" creationid="jenya" creationdate="20230616T095921Z">
        <seg>```haskell
ghci&gt; True &amp;&amp; False
False
ghci&gt; True &amp;&amp; True
True
ghci&gt; False || True
True 
ghci&gt; not False
True
ghci&gt; not (True &amp;&amp; True)
False
```</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>```haskell
ghci&gt; [ x | x &lt;- [10..20], x /= 13, x /= 15, x /= 19]
[10,11,12,14,16,17,18,20]
```</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230617T105229Z" creationid="jenya" creationdate="20230617T105229Z">
        <seg>ghci&gt; [ x | x &lt;- [10..20], x /= 13, x /= 15, x /= 19]</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>```haskell
ghci&gt; [ x | x &lt;- [50..100], x `mod` 7 == 3]
[52,59,66,73,80,87,94] 
```</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230617T102706Z" creationid="jenya" creationdate="20230617T102706Z">
        <seg>```haskell
ghci&gt; [ x | x &lt;- [50..100], x `mod` 7 == 3]
[52,59,66,73,80,87,94] 
```</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>```haskell
ghci&gt; [ x*y | x &lt;- [2,5,10], y &lt;- [8,10,11], x*y &gt; 50]
[55,80,100,110] 
```</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230617T105846Z" creationid="jenya" creationdate="20230617T105846Z">
        <seg>```haskell
ghci&gt; [ x*y | x &lt;- [2,5,10], y &lt;- [8,10,11], x*y &gt; 50]
[55,80,100,110] 
```</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>```haskell
ghci&gt; [ x*y | x &lt;- [2,5,10], y &lt;- [8,10,11]]
[16,20,22,40,50,55,80,100,110] 
```</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230617T105720Z" creationid="jenya" creationdate="20230617T105720Z">
        <seg>```haskell
ghci&gt; [ x*y | x &lt;- [2,5,10], y &lt;- [8,10,11]]
[16,20,22,40,50,55,80,100,110] 
```</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>```haskell
ghci&gt; ['a'..'e']
"abcde"
ghci&gt; [LT ..</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230618T183910Z" creationid="jenya" creationdate="20230618T183910Z">
        <seg>```haskell
ghci&gt; ['a'..'e']
"abcde"
ghci&gt; [LT ..</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>```haskell
ghci&gt; [0.1, 0.3 ..</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230617T090731Z" creationid="jenya" creationdate="20230617T090731Z">
        <seg>```haskell
ghci&gt; [0.1, 0.3 ..</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>```haskell
ghci&gt; [1,2,3,4] ++ [9,10,11,12]
[1,2,3,4,9,10,11,12]
ghci&gt; "hello" ++ " " ++ "world"
"hello world"
ghci&gt; ['w','o'] ++ ['o','t']
"woot"
```</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230617T075103Z" creationid="jenya" creationdate="20230617T075103Z">
        <seg>```haskell
ghci&gt; [1,2,3,4] ++ [9,10,11,12]
[1,2,3,4,9,10,11,12]
ghci&gt; "hello" ++ " " ++ "world"
"hello world"
ghci&gt; ['w','o'] ++ ['o','t']
"woot"
```</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>```haskell
ghci&gt; [1..20]
[1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20]
ghci&gt; ['a'..'z']
"abcdefghijklmnopqrstuvwxyz"
ghci&gt; ['K'..'Z']
"KLMNOPQRSTUVWXYZ" 
```</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230617T090612Z" creationid="jenya" creationdate="20230617T090612Z">
        <seg>```haskell
ghci&gt; [1..20]
[1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20]
ghci&gt; ['a'..'z']
"abcdefghijklmnopqrstuvwxyz"
ghci&gt; ['K'..'Z']
"KLMNOPQRSTUVWXYZ" 
```</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>```haskell
ghci&gt; [2,4..20]
[2,4,6,8,10,12,14,16,18,20]
ghci&gt; [3,6..20]
[3,6,9,12,15,18] 
```</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230617T090624Z" creationid="jenya" creationdate="20230617T090624Z">
        <seg>```haskell
ghci&gt; [2,4..20]
[2,4,6,8,10,12,14,16,18,20]
ghci&gt; [3,6..20]
[3,6,9,12,15,18] 
```</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>```haskell
ghci&gt; [3,2,1] &gt; [2,1,0]
True
ghci&gt; [3,2,1] &gt; [2,10,100]
True
ghci&gt; [3,4,2] &gt; [3,4]
True
ghci&gt; [3,4,2] &gt; [2,4]
True
ghci&gt; [3,4,2] == [3,4,2]
True
```</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230617T080435Z" creationid="jenya" creationdate="20230617T080435Z">
        <seg>```haskell
ghci&gt; [3,2,1] &gt; [2,1,0]
True
ghci&gt; [3,2,1] &gt; [2,10,100]
True
ghci&gt; [3,4,2] &gt; [3,4]
True
ghci&gt; [3,4,2] &gt; [2,4]
True
ghci&gt; [3,4,2] == [3,4,2]
True
```</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>```haskell
ghci&gt; [x*2 | x &lt;- [1..10], x*2 &gt;= 12]
[12,14,16,18,20]
```</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230617T102135Z" creationid="jenya" creationdate="20230617T102135Z">
        <seg>```haskell
ghci&gt; [x*2 | x &lt;- [1..10], x*2 &gt;= 12]
[12,14,16,18,20]
```</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>```haskell
ghci&gt; [x*2 | x &lt;- [1..10]]
[2,4,6,8,10,12,14,16,18,20]
```</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230617T100421Z" creationid="jenya" creationdate="20230617T100421Z">
        <seg>```haskell
ghci&gt; [x*2 | x &lt;- [1..10]]
[2,4,6,8,10,12,14,16,18,20]
```</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>```haskell
ghci&gt; boomBangs [7..13]
["BOOM!","BOOM!","BANG!","BANG!"] 
```</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230617T104046Z" creationid="jenya" creationdate="20230617T104046Z">
        <seg>```haskell
ghci&gt; boomBangs [7..13]
["BOOM!","BOOM!","BANG!","BANG!"] 
```</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>```haskell
ghci&gt; circumference 4.0
25.132742
```</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230618T151034Z" creationid="jenya" creationdate="20230618T151034Z">
        <seg>```haskell
ghci&gt; circumference 4.0
25.132742
```</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>```haskell
ghci&gt; circumference' 4.0
25.132741228718345
```</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230618T151050Z" creationid="jenya" creationdate="20230618T151050Z">
        <seg>```haskell
ghci&gt; circumference' 4.0
25.132741228718345
```</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>```haskell
ghci&gt; doubleUs 4 9
26
ghci&gt; doubleUs 2.3 34.2
73.0
ghci&gt; doubleUs 28 88 + doubleMe 123
478
```</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230616T162809Z" creationid="jenya" creationdate="20230616T162809Z">
        <seg>```haskell
ghci&gt; doubleUs 4 9
26
ghci&gt; doubleUs 2.3 34.2
73.0
ghci&gt; doubleUs 28 88 + doubleMe 123
478
```</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>```haskell
ghci&gt; drop 3 [8,4,2,1,5,6]
[1,5,6]
ghci&gt; drop 0 [1,2,3,4]
[1,2,3,4]
ghci&gt; drop 100 [1,2,3,4]
[] 
```</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230617T081042Z" creationid="jenya" creationdate="20230617T081042Z">
        <seg>```haskell
ghci&gt; drop 3 [8,4,2,1,5,6]
[1,5,6]
ghci&gt; drop 0 [1,2,3,4]
[1,2,3,4]
ghci&gt; drop 100 [1,2,3,4]
[] 
```</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>```haskell
ghci&gt; factorial 50
30414093201713378043612608166064768844377641568960512000000000000
```</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230618T150933Z" creationid="jenya" creationdate="20230618T150933Z">
        <seg>```haskell
ghci&gt; factorial 50
30414093201713378043612608166064768844377641568960512000000000000
```</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>```haskell
ghci&gt; fst (8,11)
8
ghci&gt; fst ("Wow", False)
"Wow"
```</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230617T112436Z" creationid="jenya" creationdate="20230617T112436Z">
        <seg>```haskell
ghci&gt; fst (8,11)
8
ghci&gt; fst ("Wow", False)
"Wow"
```</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>```haskell
ghci&gt; head [5,4,3,2,1]
5 
```</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230617T080542Z" creationid="jenya" creationdate="20230617T080542Z">
        <seg>```haskell
ghci&gt; head [5,4,3,2,1]
5 
```</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>```haskell
ghci&gt; head []
*** Exception: Prelude.head: empty list
```</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230617T080708Z" creationid="jenya" creationdate="20230617T080708Z">
        <seg>```haskell
ghci&gt; head []
*** Exception: Prelude.head: empty list
```</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>```haskell
ghci&gt; init [5,4,3,2,1]
[5,4,3,2] 
```</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230617T115148Z" creationid="jenya" creationdate="20230617T115148Z">
        <seg>```haskell
ghci&gt; init [5,4,3,2,1]
[5,4,3,2] 
```</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>```haskell
ghci&gt; last [5,4,3,2,1]
1 
```</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230617T080603Z" creationid="jenya" creationdate="20230617T080603Z">
        <seg>```haskell
ghci&gt; last [5,4,3,2,1]
1 
```</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>```haskell
ghci&gt; length [5,4,3,2,1]
5
```</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230617T080755Z" creationid="jenya" creationdate="20230617T080755Z">
        <seg>```haskell
ghci&gt; length [5,4,3,2,1]
5
```</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>```haskell
ghci&gt; let b = [[1,2,3,4],[5,3,3,3],[1,2,2,3,4],[1,2,3]]
ghci&gt; b
[[1,2,3,4],[5,3,3,3],[1,2,2,3,4],[1,2,3]]
ghci&gt; b ++ [[1,1,1,1]]
[[1,2,3,4],[5,3,3,3],[1,2,2,3,4],[1,2,3],[1,1,1,1]]
ghci&gt; [6,6,6]:b
[[6,6,6],[1,2,3,4],[5,3,3,3],[1,2,2,3,4],[1,2,3]]
ghci&gt; b !!</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230617T075925Z" creationid="jenya" creationdate="20230617T075925Z">
        <seg>```haskell
ghci&gt; let b = [[1,2,3,4],[5,3,3,3],[1,2,2,3,4],[1,2,3]]
ghci&gt; b
[[1,2,3,4],[5,3,3,3],[1,2,2,3,4],[1,2,3]]
ghci&gt; b ++ [[1,1,1,1]]
[[1,2,3,4],[5,3,3,3],[1,2,2,3,4],[1,2,3],[1,1,1,1]]
ghci&gt; [6,6,6]:b
[[6,6,6],[1,2,3,4],[5,3,3,3],[1,2,2,3,4],[1,2,3]]
ghci&gt; b !!</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>```haskell
ghci&gt; let lostNumbers = [4,8,15,16,23,42]
ghci&gt; lostNumbers
[4,8,15,16,23,42]
```</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230617T074836Z" creationid="jenya" creationdate="20230617T074836Z">
        <seg>```haskell
ghci&gt; let lostNumbers = [4,8,15,16,23,42]
ghci&gt; lostNumbers
[4,8,15,16,23,42]
```</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>```haskell
ghci&gt; let nouns = ["hobo","frog","pope"]
ghci&gt; let adjectives = ["lazy","grouchy","scheming"]
ghci&gt; [adjective ++ " " ++ noun | adjective &lt;- adjectives, noun &lt;- nouns]
["lazy hobo","lazy frog","lazy pope","grouchy hobo","grouchy frog",
"grouchy pope","scheming hobo","scheming frog","scheming pope"] 
```</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230617T110039Z" creationid="jenya" creationdate="20230617T110039Z">
        <seg>```haskell
ghci&gt; let nouns = ["hobo","frog","pope"]
ghci&gt; let adjectives = ["lazy","grouchy","scheming"]
ghci&gt; [adjective ++ " " ++ noun | adjective &lt;- adjectives, noun &lt;- nouns]
["lazy hobo","lazy frog","lazy pope","grouchy hobo","grouchy frog",
"grouchy pope","scheming hobo","scheming frog","scheming pope"] 
```</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>```haskell
ghci&gt; let rightTriangles = [ (a,b,c) | c &lt;- [1..10], b &lt;- [1..c], a &lt;- [1..b], a^2 + b^2 == c^2] 
```</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230617T114903Z" creationid="jenya" creationdate="20230617T114903Z">
        <seg>```haskell
ghci&gt; let rightTriangles = [ (a,b,c) | c &lt;- [1..10], b &lt;- [1..c], a &lt;- [1..b], a^2 + b^2 == c^2] 
```</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>```haskell
ghci&gt; let rightTriangles' = [ (a,b,c) | c &lt;- [1..10], b &lt;- [1..c], a &lt;- [1..b], a^2 + b^2 == c^2, a+b+c == 24]
ghci&gt; rightTriangles'
[(6,8,10)]
```</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230617T114927Z" creationid="jenya" creationdate="20230617T114927Z">
        <seg>```haskell
ghci&gt; let rightTriangles' = [ (a,b,c) | c &lt;- [1..10], b &lt;- [1..c], a &lt;- [1..b], a^2 + b^2 == c^2, a+b+c == 24]
ghci&gt; rightTriangles'
[(6,8,10)]
```</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>```haskell
ghci&gt; let triangles = [ (a,b,c) | c &lt;- [1..10], b &lt;- [1..10], a &lt;- [1..10] ] 
```</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230617T114324Z" creationid="jenya" creationdate="20230617T114324Z">
        <seg>```haskell
ghci&gt; let triangles = [ (a,b,c) | c &lt;- [1..10], b &lt;- [1..10], a &lt;- [1..10] ] 
```</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>```haskell
ghci&gt; let xxs = [[1,3,5,2,3,1,2,4,5],[1,2,3,4,5,6,7,8,9],[1,2,4,2,1,6,3,1,3,2,3,6]]
ghci&gt; [ [ x | x &lt;- xs, even x ] | xs &lt;- xxs]
[[2,2,4],[2,4,6,8],[2,4,2,6,2,6]]
```</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230617T110854Z" creationid="jenya" creationdate="20230617T110854Z">
        <seg>```haskell
ghci&gt; let xxs = [[1,3,5,2,3,1,2,4,5],[1,2,3,4,5,6,7,8,9],[1,2,4,2,1,6,3,1,3,2,3,6]]
ghci&gt; [ [ x | x &lt;- xs, even x ] | xs &lt;- xxs]
[[2,2,4],[2,4,6,8],[2,4,2,6,2,6]]
```</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>```haskell
ghci&gt; maxBound :: (Bool, Int, Char)
(True,2147483647,'\1114111')
```</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230618T185406Z" creationid="jenya" creationdate="20230618T185406Z">
        <seg>```haskell
ghci&gt; maxBound :: (Bool, Int, Char)
(True,2147483647,'\1114111')
```</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>```haskell
ghci&gt; min 9 10
9
ghci&gt; min 3.4 3.2
3.2
ghci&gt; max 100 101
101 
```</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230616T113104Z" creationid="jenya" creationdate="20230616T113104Z">
        <seg>```haskell
ghci&gt; min 9 10
9
ghci&gt; min 3.4 3.2
3.2
ghci&gt; max 100 101
101 
```</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>```haskell
ghci&gt; minBound :: Int
-2147483648
ghci&gt; maxBound :: Char
'\1114111'
ghci&gt; maxBound :: Bool
True
ghci&gt; minBound :: Bool
False
```</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230618T184031Z" creationid="jenya" creationdate="20230618T184031Z">
        <seg>```haskell
ghci&gt; minBound :: Int
-2147483648
ghci&gt; maxBound :: Char
'\1114111'
ghci&gt; maxBound :: Bool
True
ghci&gt; minBound :: Bool
False
```</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>```haskell
ghci&gt; minimum [8,4,2,1,5,6]
1
ghci&gt; maximum [1,9,2,3,4]
9 
```</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230617T082817Z" creationid="jenya" creationdate="20230617T082817Z">
        <seg>```haskell
ghci&gt; minimum [8,4,2,1,5,6]
1
ghci&gt; maximum [1,9,2,3,4]
9 
```</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>```haskell
ghci&gt; null [1,2,3]
False
ghci&gt; null []
True
```</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230617T080828Z" creationid="jenya" creationdate="20230617T080828Z">
        <seg>```haskell
ghci&gt; null [1,2,3]
False
ghci&gt; null []
True
```</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>```haskell
ghci&gt; read "4"
&lt;interactive&gt;:1:0:</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230618T180957Z" creationid="jenya" creationdate="20230618T180957Z">
        <seg>```haskell
ghci&gt; read "4"
&lt;interactive&gt;:1:0:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>```haskell
ghci&gt; read "5" :: Int
5
ghci&gt; read "5" :: Float
5.0
ghci&gt; (read "5" :: Float) * 4
20.0
ghci&gt; read "[1,2,3,4]" :: [Int]
[1,2,3,4]
ghci&gt; read "(3, 'a')" :: (Int, Char)
(3, 'a')
```</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230618T183452Z" creationid="jenya" creationdate="20230618T183452Z">
        <seg>```haskell
ghci&gt; read "5" :: Int
5
ghci&gt; read "5" :: Float
5.0
ghci&gt; (read "5" :: Float) * 4
20.0
ghci&gt; read "[1,2,3,4]" :: [Int]
[1,2,3,4]
ghci&gt; read "(3, 'a')" :: (Int, Char)
(3, 'a')
```</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>```haskell
ghci&gt; read "True" || False
True
ghci&gt; read "8.2" + 3.8
12.0
ghci&gt; read "5" - 2
3
ghci&gt; read "[1,2,3,4]" ++ [3]
[1,2,3,4,3]
```</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230618T180919Z" creationid="jenya" creationdate="20230618T180919Z">
        <seg>```haskell
ghci&gt; read "True" || False
True
ghci&gt; read "8.2" + 3.8
12.0
ghci&gt; read "5" - 2
3
ghci&gt; read "[1,2,3,4]" ++ [3]
[1,2,3,4,3]
```</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>```haskell
ghci&gt; removeNonUppercase "Hahaha!</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230617T110527Z" creationid="jenya" creationdate="20230617T110527Z">
        <seg>```haskell
ghci&gt; removeNonUppercase "Hahaha!</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>```haskell
ghci&gt; reverse [5,4,3,2,1]
[1,2,3,4,5]
```</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230617T080833Z" creationid="jenya" creationdate="20230617T080833Z">
        <seg>```haskell
ghci&gt; reverse [5,4,3,2,1]
[1,2,3,4,5]
```</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>```haskell
ghci&gt; show 3
"3"
ghci&gt; show 5.334
"5.334"
ghci&gt; show True
"True"
```</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230618T180837Z" creationid="jenya" creationdate="20230618T180837Z">
        <seg>```haskell
ghci&gt; show 3
"3"
ghci&gt; show 5.334
"5.334"
ghci&gt; show True
"True"
```</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>```haskell
ghci&gt; snd (8,11)
11
ghci&gt; snd ("Wow", False)
False
```</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230617T112443Z" creationid="jenya" creationdate="20230617T112443Z">
        <seg>```haskell
ghci&gt; snd (8,11)
11
ghci&gt; snd ("Wow", False)
False
```</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>```haskell
ghci&gt; succ 8
9 
```</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230616T101831Z" creationid="jenya" creationdate="20230616T101831Z">
        <seg>```haskell
ghci&gt; succ 8
9 
```</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>```haskell
ghci&gt; succ 9 + max 5 4 + 1
16
ghci&gt; (succ 9) + (max 5 4) + 1
16
```</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230616T113153Z" creationid="jenya" creationdate="20230616T113153Z">
        <seg>```haskell
ghci&gt; succ 9 + max 5 4 + 1
16
ghci&gt; (succ 9) + (max 5 4) + 1
16
```</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>```haskell
ghci&gt; sum [5,2,1,6,3,2,5,7]
31
ghci&gt; product [6,2,1,2]
24
ghci&gt; product [1,2,5,6,7,9,2,0]
0 
```</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230617T082858Z" creationid="jenya" creationdate="20230617T082858Z">
        <seg>```haskell
ghci&gt; sum [5,2,1,6,3,2,5,7]
31
ghci&gt; product [6,2,1,2]
24
ghci&gt; product [1,2,5,6,7,9,2,0]
0 
```</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>```haskell
ghci&gt; tail [5,4,3,2,1]
[4,3,2,1] 
```</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230617T080553Z" creationid="jenya" creationdate="20230617T080553Z">
        <seg>```haskell
ghci&gt; tail [5,4,3,2,1]
[4,3,2,1] 
```</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>```haskell
ghci&gt; take 10 (cycle [1,2,3])
[1,2,3,1,2,3,1,2,3,1]
ghci&gt; take 12 (cycle "LOL ")
"LOL LOL LOL " 
```</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230617T090952Z" creationid="jenya" creationdate="20230617T090952Z">
        <seg>```haskell
ghci&gt; take 10 (cycle [1,2,3])
[1,2,3,1,2,3,1,2,3,1]
ghci&gt; take 12 (cycle "LOL ")
"LOL LOL LOL " 
```</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>```haskell
ghci&gt; take 10 (repeat 5)
[5,5,5,5,5,5,5,5,5,5]
```</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230617T115155Z" creationid="jenya" creationdate="20230617T115155Z">
        <seg>```haskell
ghci&gt; take 10 (repeat 5)
[5,5,5,5,5,5,5,5,5,5]
```</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>```haskell
ghci&gt; take 3 [5,4,3,2,1]
[5,4,3]
ghci&gt; take 1 [3,9,3]
[3]
ghci&gt; take 5 [1,2]
[1,2]
ghci&gt; take 0 [6,6,6]
[]
```</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230617T080855Z" creationid="jenya" creationdate="20230617T080855Z">
        <seg>```haskell
ghci&gt; take 3 [5,4,3,2,1]
[5,4,3]
ghci&gt; take 1 [3,9,3]
[3]
ghci&gt; take 5 [1,2]
[1,2]
ghci&gt; take 0 [6,6,6]
[]
```</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>```haskell
ghci&gt; zip [1,2,3,4,5] [5,5,5,5,5]
[(1,5),(2,5),(3,5),(4,5),(5,5)]
ghci&gt; zip [1 ..</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230617T112619Z" creationid="jenya" creationdate="20230617T112619Z">
        <seg>```haskell
ghci&gt; zip [1,2,3,4,5] [5,5,5,5,5]
[(1,5),(2,5),(3,5),(4,5),(5,5)]
ghci&gt; zip [1 ..</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>```haskell
ghci&gt; zip [1..] ["apple", "orange", "cherry", "mango"]
[(1,"apple"),(2,"orange"),(3,"cherry"),(4,"mango")]
```</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230617T114231Z" creationid="jenya" creationdate="20230617T114231Z">
        <seg>```haskell
ghci&gt; zip [1..] ["apple", "orange", "cherry", "mango"]
[(1,"apple"),(2,"orange"),(3,"cherry"),(4,"mango")]
```</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>```haskell
ghci&gt; zip [5,3,2,6,2,7,2,5,4,6,6] ["im","a","turtle"]
[(5,"im"),(3,"a"),(2,"turtle")]
```</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230617T113247Z" creationid="jenya" creationdate="20230617T113247Z">
        <seg>```haskell
ghci&gt; zip [5,3,2,6,2,7,2,5,4,6,6] ["im","a","turtle"]
[(5,"im"),(3,"a"),(2,"turtle")]
```</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>```haskell
length' xs = sum [1 | _ &lt;- xs] 
```</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230617T110302Z" creationid="jenya" creationdate="20230617T110302Z">
        <seg>```haskell
length' xs = sum [1 | _ &lt;- xs] 
```</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>```haskell
removeNonUppercase :: [Char] -&gt; [Char]
removeNonUppercase st = [ c | c &lt;- st, c `elem` ['A'..'Z']] 
```</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230618T145252Z" creationid="jenya" creationdate="20230618T145252Z">
        <seg>```haskell
removeNonUppercase :: [Char] -&gt; [Char]
removeNonUppercase st = [ c | c &lt;- st, c `elem` ['A'..'Z']] 
```</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>```haskell
removeNonUppercase st = [ c | c &lt;- st, c `elem` ['A'..'Z']] 
```</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230617T110524Z" creationid="jenya" creationdate="20230617T110504Z">
        <seg>```haskell
removeNonUppercase st = [ c | c &lt;- st, c `elem` ['A'..'Z']]
```</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>`cycle` takes a list and cycles it into an infinite list.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230617T090935Z" creationid="jenya" creationdate="20230617T090935Z">
        <seg>`cycle` берет список и преобразует его в бесконечный список.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>`drop` works in a similar way, only it drops the number of elements from the beginning of a list.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230617T081041Z" creationid="jenya" creationdate="20230617T081041Z">
        <seg>`drop` работает аналогичным образом, только он уменьшает количество элементов из начала списка.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>`elem` takes a thing and a list of things and tells us if that thing is an element of the list.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230617T082926Z" creationid="jenya" creationdate="20230617T082926Z">
        <seg>`elem` берет вещь и список вещей и сообщает нам, является ли эта вещь элементом списка.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>`factorial 1` is `1 * factorial 0`, so we have `3 * (2 * (1 * factorial 0))`.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230619T114802Z" creationid="jenya" creationdate="20230619T114755Z">
        <seg>`factorial 1` равен `1 * factorial 0`, таким образом, мы имеем `3 * (2 * (1 * factorial 0))`.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>`fst` and `snd` extract the components of pairs.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230619T120505Z" creationid="jenya" creationdate="20230619T120505Z">
        <seg>`fst` и `snd` извлекают компоненты пар.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>`fst` takes a pair and returns its first component.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230617T112435Z" creationid="jenya" creationdate="20230617T112435Z">
        <seg>`fst` принимает пару и возвращает ее первый компонент.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>`head` takes a list and returns its head.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230617T080533Z" creationid="jenya" creationdate="20230617T080533Z">
        <seg>`head` принимает список и возвращает его заголовок.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>`init` takes a list and returns everything except its last element.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230617T080608Z" creationid="jenya" creationdate="20230617T080608Z">
        <seg>`init` принимает список и возвращает все, кроме его последнего элемента.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>`last` takes a list and returns its last element.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230617T080602Z" creationid="jenya" creationdate="20230617T080602Z">
        <seg>`last` принимает список и возвращает его последний элемент.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>`length' "m"` is `1 + length' ""` (could also be written as `1 + length' []`).</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230619T123307Z" creationid="jenya" creationdate="20230619T123247Z">
        <seg>`length' "m"` равна `1 + length' ""` (также может быть записана как `1 + length' []`).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>`length` takes a list and returns its length, obviously.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230617T080753Z" creationid="jenya" creationdate="20230617T080753Z">
        <seg>очевидно, что `length` принимает список и возвращает его длину.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>`maximum` takes a list of stuff that can be put in some kind of order and returns the biggest element.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230617T081058Z" creationid="jenya" creationdate="20230617T081058Z">
        <seg>`maximum` принимает список элементов, которые можно расположить в определенном порядке, и возвращает самый большой элемент.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>`minBound` and `maxBound` are interesting because they have a type of `(Bounded a) =&gt; a`.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230618T184354Z" creationid="jenya" creationdate="20230618T184354Z">
        <seg>`minBound` и `maxBound` интересны тем, что они имеют тип `(Bounded a) =&gt; a`.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>`min` returns the one that's lesser and `max` returns the one that's greater.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230616T111446Z" creationid="jenya" creationdate="20230616T111446Z">
        <seg>`min` возвращает значение, которое меньше, а `max` возвращает значение, которое больше.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>`minimum` returns the smallest.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230617T081110Z" creationid="jenya" creationdate="20230617T081110Z">
        <seg>`minimum` возвращает наименьшее значение.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>`not` negates a `True` or a `False`.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230616T095822Z" creationid="jenya" creationdate="20230616T095822Z">
        <seg>`not` отрицает `True` или `False`.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>`null` checks if a list is empty.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230617T080758Z" creationid="jenya" creationdate="20230617T080758Z">
        <seg>`null` проверяет, пуст ли список.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>`otherwise` is defined simply as `otherwise = True` and catches everything.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230619T130322Z" creationid="jenya" creationdate="20230619T130314Z">
        <seg>`otherwise` определяется просто как `otherwise = True` и улавливает все.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>`product` takes a list of numbers and returns their product.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230617T082852Z" creationid="jenya" creationdate="20230617T082827Z">
        <seg>`product` принимает список чисел и возвращает их произведение.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>`removeNonUppercase` has a type of `[Char] -&gt; [Char]`, meaning that it maps from a string to a string.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230618T145316Z" creationid="jenya" creationdate="20230618T145316Z">
        <seg>`removeNonUppercase` имеет тип `[Char] -&gt; [Char]`, что означает, что он преобразуется из строки в строку.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>`repeat` takes an element and produces an infinite list of just that element.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230617T091011Z" creationid="jenya" creationdate="20230617T091011Z">
        <seg>`repeat` принимает элемент и создает бесконечный список только этого элемента.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>`replicate 3 10` returns `[10,10,10]`.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230617T091131Z" creationid="jenya" creationdate="20230617T091131Z">
        <seg>`replicate 3 10` возвращает `[10,10,10]`.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>`reverse` reverses a list.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230617T080832Z" creationid="jenya" creationdate="20230617T080832Z">
        <seg>`reverse` переворачивает список.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>`snd` takes a pair and returns its second component.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230617T112439Z" creationid="jenya" creationdate="20230617T112439Z">
        <seg>`snd` принимает пару и возвращает ее второй компонент.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>`sum` takes a list of numbers and returns their sum.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230617T082822Z" creationid="jenya" creationdate="20230617T082822Z">
        <seg>`sum` принимает список чисел и возвращает их сумму.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>`tail` takes a list and returns its tail.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230617T080546Z" creationid="jenya" creationdate="20230617T080546Z">
        <seg>`tail` принимает список и возвращает его хвост.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>`take` takes number and a list.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230617T080845Z" creationid="jenya" creationdate="20230617T080845Z">
        <seg>`take` принимает номер и список.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>`x` is drawn from `[1..10]` and for every element in `[1..10]` (which we have bound to `x`), we get that element, only doubled.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230617T100411Z" creationid="jenya" creationdate="20230617T100411Z">
        <seg>`x` берется из `[1..10]`, и для каждого элемента в `[1..10]` (который мы привязали к `x`) мы получаем этот элемент, только удвоенный.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>and then try to call it with an input that we didn't expect, this is what happens:</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230619T120146Z" creationid="jenya" creationdate="20230619T120146Z">
        <seg>а затем попробуйте вызвать его с помощью ввода, которого мы не ожидали, вот что произойдет:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>else x*2 
```</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230616T173852Z" creationid="jenya" creationdate="20230616T173852Z">
        <seg>else x*2 
```</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>for help
Loading package base ... linking ... done.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230616T093203Z" creationid="jenya" creationdate="20230616T093203Z">
        <seg>for help
Loading package base ... linking ... done.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>ghci&gt; doubleMe 9
18
ghci&gt; doubleMe 8.3
16.6 
```</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230616T161056Z" creationid="jenya" creationdate="20230616T161056Z">
        <seg>ghci&gt; doubleMe 9
18
ghci&gt; doubleMe 8.3
16.6 
```</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>then x</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230616T173850Z" creationid="jenya" creationdate="20230616T173850Z">
        <seg>then x</seg>
      </tuv>
    </tu>
<!-- Alternative translations -->
  </body>
</tmx>
