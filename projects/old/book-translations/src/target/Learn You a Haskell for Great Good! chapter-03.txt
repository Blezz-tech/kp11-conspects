# Типы и классы типов

## Верьте типу

![[LYHfGG_15_cow.png]]

Ранее мы упоминали, что в Haskell есть система статических типов. Тип каждого выражения известен во время компиляции, что приводит к созданию более безопасного кода. Если вы напишете программу, в которой попытаетесь разделить логический тип на некоторое число, она даже не будет компилироваться. Это хорошо, потому что лучше отлавливать такие ошибки во время компиляции, а не вызывать сбой вашей программы. Все в Haskell имеет тип, поэтому компилятор может довольно много рассуждать о вашей программе перед ее компиляцией.

В отличие от Java или Pascal, в Haskell есть вывод типа. Если мы пишем число, нам не нужно говорить Haskell, что это число. Он может _сделать вывод_ сам по себе, поэтому нам не нужно явно выписывать типы наших функций и выражений, чтобы что-то сделать. Мы рассмотрели некоторые основы Haskell, лишь очень поверхностно взглянув на типы. Однако понимание системы типов является очень важной частью изучения Haskell.

Тип - это своего рода метка, которая есть у каждого выражения. Это говорит нам, к какой категории вещей подходит это выражение. Выражение `True` - это логическое значение, `"hello"` - это строка и т.д.

Теперь мы будем использовать GHCI для изучения типов некоторых выражений. Мы сделаем это с помощью команды `:t`, за которой следует любое допустимое выражение, сообщающее нам его тип. Давайте раскрутим это дело.

```haskell
ghci> :t 'a'
'a' :: Char
ghci> :t True
True :: Bool
ghci> :t "HELLO!"
"HELLO!" :: [Char]
ghci> :t (True, 'a')
(True, 'a') :: (Bool, Char)
ghci> :t 4 == 5
4 == 5 :: Bool
```

![[LYHfGG_16_bomb.png]]

Здесь мы видим, что выполнение `:t` для выражения выводит выражение, за которым следует `::`, и его тип. `::` читается как "имеет тип". Явные типы всегда обозначаются первой буквой с большой буквы. `'a'`, как могло бы показаться, имеет тип `Char`. Нетрудно сделать вывод, что это означает _символ_ (англ. _character_). `True` относится к типу `Bool`. В этом есть смысл. Но что это такое? Анализ типа `"ПРИВЕТ!"` выдает `[Char]`. Квадратные скобки обозначают список. Итак, мы читаем это как _список символов_ (англ. _a list of characters_). В отличие от списков, длина каждого кортежа имеет свой собственный тип. Таким образом, выражение `(True, 'a')` имеет тип `(Bool, Char)`, тогда как такое выражение, как `('a','b','c')`, имело бы тип `(Char, Char, Char)`. `4 == 5` всегда возвращает `False`, поэтому его тип - `Bool`.

Функции также имеют типы. При написании наших собственных функций мы можем предоставить им явное объявление типа. Обычно это считается хорошей практикой, за исключением случаев написания очень коротких функций. С этого момента мы будем предоставлять все функции, для которых мы делаем объявления типов. Помните представление списка, которое мы сделали ранее, которое фильтрует строку так, чтобы оставались только заглавные буквы? Вот как это выглядит с объявлением типа.

```haskell
removeNonUppercase :: [Char] -> [Char]
removeNonUppercase st = [ c | c <- st, c `elem` ['A'..'Z']] 
```

`removeNonUppercase` имеет тип `[Char] -> [Char]`, что означает, что он преобразуется из строки в строку. Это потому, что он принимает одну строку в качестве параметра и возвращает другую в результате. Тип `[Char]` является синонимом `String`, поэтому будет понятнее, если мы напишем `removeNonUppercase :: String -> String`. Нам не нужно было давать этой функции объявление типа, потому что компилятор может сам сделать вывод, что это функция из строки в строку, но мы все равно это сделали. Но как нам записать тип функции, которая принимает несколько параметров? Вот простая функция, которая принимает три целых числа и складывает их вместе:

```haskell
addThree :: Int -> Int -> Int -> Int
addThree x y z = x + y + z
```

Параметры разделяются символом `->`, и нет особого различия между параметрами и возвращаемым типом. Возвращаемый тип - это последний элемент в объявлении, а параметры - первые три. Позже мы увидим, почему все они просто разделены `->` вместо того, чтобы проводить какое-то более явное различие между возвращаемыми типами и параметрами, такими как `Int, Int, Int -> Int` или что-то в этом роде.

Если вы хотите предоставить своей функции объявление типа, но не уверены в том, каким оно должно быть, вы всегда можете просто написать функцию без него, а затем проверить ее с помощью `:t`. Функции тоже являются выражениями, поэтому `:t` работает с ними без проблем.

Вот обзор некоторых распространенных типов.

`Int` означает целое число. Он используется для целых чисел. `7` может быть `Int`, но `7.2` не может. `Int` ограничен, что означает, что он имеет минимальное и максимальное значения. Обычно на 32-разрядных машинах максимально возможное значение `Int` равно 2147483647, а минимальное -2147483648.

`Integer` означает, э-э... тоже целое число. Главное отличие заключается в том, что он не ограничен, поэтому его можно использовать для представления действительно очень больших чисел. Я имею в виду, по-настоящему большой. `Int`, однако, более эффективен.

```haskell
factorial :: Integer -> Integer
factorial n = product [1..n]
```

```haskell
ghci> factorial 50
30414093201713378043612608166064768844377641568960512000000000000
```

`Float` - это реальная плавающая точка с одинарной точностью.

```haskell
circumference :: Float -> Float
circumference r = 2 * pi * r
```

```haskell
ghci> circumference 4.0
25.132742
```

`Double` - это настоящая плавающая точка с удвоенной точностью!

```haskell
circumference' :: Double -> Double
circumference' r = 2 * pi * r
```

```haskell
ghci> circumference' 4.0
25.132741228718345
```

`Bool` - это логический тип. Он может иметь только два значения: `True` и `False`.

`Char` представляет символ. Он обозначается одинарными кавычками. Список символов представляет собой строку.

Кортежи - это типы, которые зависят от длины кортежей, а также от типов их компонентов, поэтому теоретически существует бесконечное количество типов кортежей, которых слишком много, чтобы рассматривать их в этом руководстве. Обратите внимание, что пустой кортеж `()` также является типом, который может иметь только одно значение: `()`

## Переменные типа

Как вы думаете, что это за тип функции `head`? Поскольку `head` принимает список любого типа и возвращает первый элемент, так что же это может быть? Давайте проверим!

```haskell
ghci> :t head
head :: [a] -> a
```

![[LYHfGG_17_box.png]]

Хммм! Что это за буква `a`? Является ли это типом? Помните, что ранее мы указывали, что типы пишутся с большой буквы, поэтому это не может быть точно типом. Поскольку это не прописная буква, на самом деле это **переменная типа** (англ. **type variable**). Это означает, что `a` может быть любого типа. Это очень похоже на дженерики в других языках, только в Haskell это намного мощнее, потому что позволяет нам легко писать очень общие функции, если они не используют какое-либо специфическое поведение используемых в них типов. Функции, имеющие переменные типа, называются **полиморфными функциями** (англ. **polymorphic functions**). В объявлении типа `head` указано, что он принимает список любого типа и возвращает один элемент этого типа.

Хотя имена переменных типа могут быть длиннее одного символа, мы обычно присваиваем им имена a, b, c, d ...

Помнишь `fst`? Он возвращает первый компонент пары. Давайте рассмотрим его тип.

```haskell
ghci> :t fst
fst :: (a, b) -> a
```

Мы видим, что `fst` принимает кортеж, который содержит два типа, и возвращает элемент того же типа, что и первый компонент пары. Вот почему мы можем использовать `fst` для пары, которая содержит любые два типа. Обратите внимание, что только потому, что `a` и `b` являются переменными разного типа, они не обязательно должны быть разных типов. В нем просто указано, что тип первого компонента и тип возвращаемого значения совпадают.

## Классы типов 101

![[LYHfGG_18_classes.png]]

Класс типов - это своего рода интерфейс, который определяет определенное поведение. Если тип является частью класса типов, это означает, что он поддерживает и реализует поведение, описываемое классом типов. Многие люди, пришедшие из ООП, путаются в классах типов, потому что думают, что они похожи на классы в объектно-ориентированных языках. Ну, это не так. Вы можете думать о них как о интерфейсах Java, только лучше.

Какова сигнатура типа функции `==`?

```haskell
ghci> :t (==)
(==) :: (Eq a) => a -> a -> Bool
```

> **Примечание**: оператор равенства `==` является функцией. Так же как и `+`, `*`, `-`, `/` и почти все операторы. Если функция состоит только из специальных символов, по умолчанию она считается инфиксной функцией. Если мы хотим проверить её тип, передать его другой функции или вызвать его как префиксную функцию, мы должны заключить её в круглые скобки.

Интересно. Здесь мы видим новую вещь - символ `=>`. Все, что находится перед символом `=>`, называется **ограничением класса** (англ. **class constraint**). Мы можем прочитать предыдущее объявление типа следующим образом: функция равенства принимает любые два значения одного и того же типа и возвращает `Bool`. Тип этих двух значений должен быть членом класса `Eq` (это было ограничение класса).

Класс типов `Eq` предоставляет интерфейс для проверки на равенство. Любой тип, в котором имеет смысл проверять равенство между двумя значениями этого типа, должен быть членом класса `Eq`. Все стандартные типы Haskell, за исключением ввода-вывода (тип для работы с вводом и выводом) и функций, являются частью класса типов `Eq`.

Функция `elem` имеет тип `(Eq a) => a -> [a] -> Bool`, потому что она использует `==` над списком, чтобы проверить, есть ли в нем какое-то значение, которое мы ищем.

Некоторые основные классы типов:

`Eq` используется для типов, которые поддерживают проверку на равенство. Функциями, которые реализуют его члены, являются `==` и `/=`. Таким образом, если существует ограничение класса `Eq` для переменной типа в функции, она использует `==` или `/=` где-то внутри своего определения. Все типы, которые мы упоминали ранее, за исключением функций, являются частью `Eq`, поэтому их можно проверить на равенство.

```haskell
ghci> 5 == 5
True
ghci> 5 /= 5
False
ghci> 'a' == 'a'
True
ghci> "Ho Ho" == "Ho Ho"
True
ghci> 3.432 == 3.432
True
```

`Ord` предназначен для типов, которые имеют порядок.

```haskell
ghci> :t (>)
(>) :: (Ord a) => a -> a -> Bool
```

Все типы, которые мы рассмотрели до сих пор, за исключением функций, являются частью `Ord`. `Ord` охватывает все стандартные функции сравнения, такие как `>`, `<`, `>=` и `<=`. Функция `compare` принимает два элемента `Ord` одного и того же типа и возвращает `ordering`. `Ordering` - это тип, который может быть `GT`, `LT` или `EQ`, что означает _больше чем_ , _меньше чем_ и _эквивалентно_ соответственно. (англ. _greater than_, _lesser than_, _equal_ соответственно)

Чтобы стать членом `Ord`, тип должен сначала иметь членство в престижном и эксклюзивном клубе `Eq`.

```haskell
ghci> "Abrakadabra" < "Zebra"
True
ghci> "Abrakadabra" `compare` "Zebra"
LT
ghci> 5 >= 2
True
ghci> 5 `compare` 3
GT
```

Члены `Show` могут быть представлены в виде строк. Все рассмотренные до сих пор типы, за исключением функций, являются частью `Показать`. Наиболее используемой функцией, которая имеет дело с классом типов `Show`, является `show`. Она принимает значение, тип которого является членом `Show`, и представляет его нам в виде строки.

```haskell
ghci> show 3
"3"
ghci> show 5.334
"5.334"
ghci> show True
"True"
```

`Read` - это своего рода класс, противоположный типу `Show`. Функция `read` принимает строку и возвращает тип, который является членом `Read`.

```haskell
ghci> read "True" || False
True
ghci> read "8.2" + 3.8
12.0
ghci> read "5" - 2
3
ghci> read "[1,2,3,4]" ++ [3]
[1,2,3,4,3]
```

Пока все идет хорошо. Опять же, все рассмотренные до сих пор типы находятся в этом классе типов. Но что произойдет, если мы попытаемся просто `прочитать "4"`?

```haskell
ghci> read "4"
<interactive>:1:0:
    Ambiguous type variable `a' in the constraint:
      `Read a' arising from a use of `read' at <interactive>:1:0-7
    Probable fix: add a type signature that fixes these type variable(s)
```

Что GHCI говорит нам здесь, так это то, что он не знает, чего мы хотим взамен. Обратите внимание, что при предыдущем использовании `read` мы впоследствии что-то делали с результатом. Таким образом, GHCI мог бы сделать вывод, какого рода результат мы хотели получить от нашего `read`. Если мы использовали его как логическое значение, он знал, что должен вернуть `Bool`. Но теперь он знает, что нам нужен какой-то тип, который является частью класса `Read`, он просто не знает, какой именно. Давайте взглянем на сигнатуру типа `read`.

```haskell
ghci> :t read
read :: (Read a) => String -> a
```

Видишь? Он возвращает тип, который является частью `Read`, но если мы не попытаемся использовать его каким-либо образом позже, у него не будет возможности узнать, какой тип. Вот почему мы можем использовать явные **аннотации типа** (англ. _type annotations_). Аннотации типов - это способ явно указать, каким должен быть тип выражения. Мы делаем это, добавляя `::` в конце выражения, а затем указывая тип. Наблюдай:

```haskell
ghci> read "5" :: Int
5
ghci> read "5" :: Float
5.0
ghci> (read "5" :: Float) * 4
20.0
ghci> read "[1,2,3,4]" :: [Int]
[1,2,3,4]
ghci> read "(3, 'a')" :: (Int, Char)
(3, 'a')
```

Большинство выражений таковы, что компилятор может сам определить, каков их тип. Но иногда компилятор не знает, возвращать ли значение типа `Int` или `Float` для выражения типа `read "5"`. Чтобы увидеть, что это за тип, Haskell пришлось бы на самом деле оценить `read "5"`. Но поскольку Haskell является статически типизированным языком, он должен знать все типы до того, как код будет скомпилирован (или, в случае GHCI, оценен). Итак, мы должны сказать Хаскелю: "Эй, это выражение должно иметь этот тип, на случай, если вы не знаете!".

Члены `Enum` представляют собой последовательно упорядоченные типы — их можно перечислять. Главное преимущество класса типов `Enum` заключается в том, что мы можем использовать его типы в диапазонах списков. У них также есть определенные преемники (англ. _successors_) и предшественники (англ. _predecesors_), которые вы можете получить с помощью функций `succ` и `pred`. Типы в этом классе: `()`, `Bool`, `Char`, `Ordering`, `Int`, `Integer`, `Float` и `Double`.

```haskell
ghci> ['a'..'e']
"abcde"
ghci> [LT .. GT]
[LT,EQ,GT]
ghci> [3 .. 5]
[3,4,5]
ghci> succ 'B'
'C'
```

Элементы типа `Bounded` имеют верхнюю и нижнюю границы.

```haskell
ghci> minBound :: Int
-2147483648
ghci> maxBound :: Char
'\1114111'
ghci> maxBound :: Bool
True
ghci> minBound :: Bool
False
```

`minBound` и `maxBound` интересны тем, что они имеют тип `(Bounded a) => a`. В некотором смысле они являются полиморфными константами.

Все кортежи также являются частью `Bounded`, если компоненты также находятся в нем.

```haskell
ghci> maxBound :: (Bool, Int, Char)
(True,2147483647,'\1114111')
```

`Num` - это числовой класс типов. Его члены обладают свойством вести себя подобно числам. Давайте рассмотрим тип числа.

```haskell
ghci> :t 20
20 :: (Num t) => t
```

Похоже, что целые числа также являются полиморфными константами. Они могут действовать как любой тип, являющийся членом класса типов `Num`.

```haskell
ghci> 20 :: Int
20
ghci> 20 :: Integer
20
ghci> 20 :: Float
20.0
ghci> 20 :: Double
20.0
```

Это типы, которые находятся в классе типов `Num`. Если мы рассмотрим тип `*`, то увидим, что он принимает все числа.

```haskell
ghci> :t (*)
(*) :: (Num a) => a -> a -> a
```

Он принимает два числа одного и того же типа и возвращает число этого типа. Вот почему `(5 :: Int) * (6 :: Integer)` приведет к ошибке типа, тогда как `5 * (6 :: Integer)` будет работать просто отлично и выдаст `Integer`, потому что `5` может действовать как `Integer` или `Int`.

Чтобы присоединиться к `Num`, тип уже должен быть дружен с `Show` и `Eq`.

`Integral` также является числовым классом типов. `Num` включает в себя все числа, включая действительные числа и целые числа, `Integral` включает в себя только целые числа. В этом классе типов находятся `Int` и `Integer`.

`Floating` включает в себя только числа с плавающей запятой, поэтому `Float` и `Double`.

Очень полезная функция для работы с числами - `fromIntegral`. Он имеет объявление типа `fromIntegral :: (Num b, Integral a) => a -> b`. Из его сигнатуры типа мы видим, что он принимает целое число и превращает его в более общее число. Это полезно, когда вы хотите, чтобы целочисленные типы и типы с плавающей запятой хорошо работали вместе. Например, функция `length` имеет объявление типа `length :: [a] -> Int` вместо того, чтобы иметь более общий тип `(Num b) => length :: [a] -> b`. Я думаю, что это существует по историческим причинам или что-то в этом роде, хотя, на мой взгляд, это довольно глупо. В любом случае, если мы попытаемся получить длину списка, а затем добавить его к `3.2`, мы получим ошибку, потому что мы пытались сложить вместе `Int` и число с плавающей запятой. Итак, чтобы обойти это, мы делаем `fromIntegral :: (Num b, Integral a) => a -> b`., и все получается.

Обратите внимание, что `fromIntegral` имеет несколько ограничений класса в своей сигнатуре типа. Это полностью допустимо, и, как вы можете видеть, ограничения класса разделены запятыми внутри круглых скобок.
