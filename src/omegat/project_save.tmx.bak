<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE tmx SYSTEM "tmx11.dtd">
<tmx version="1.1">
  <header creationtool="OmegaT" o-tmf="OmegaT TMX" adminlang="EN-US" datatype="plaintext" creationtoolversion="5.7.1_0_c3206253" segtype="sentence" srclang="en-US"/>
  <body>
<!-- Default translations -->
    <tu>
      <tuv lang="en-US">
        <seg>![[LYHfGG_1_bird.png]]</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230611T220409Z" creationid="jenya" creationdate="20230611T220409Z">
        <seg>![[LYHfGG_1_bird.png]]</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>![[LYHfGG_2_fx.png]]</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230611T220414Z" creationid="jenya" creationdate="20230611T220414Z">
        <seg>![[LYHfGG_2_fx.png]]</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>![[LYHfGG_3_lazy.png]]</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230615T170848Z" creationid="jenya" creationdate="20230615T170848Z">
        <seg>![[LYHfGG_3_lazy.png]]</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>![[LYHfGG_4_boat.png]]</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230615T172750Z" creationid="jenya" creationdate="20230615T172750Z">
        <seg>![[LYHfGG_4_boat.png]]</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>![[LYHfGG_5_startingout.png]]</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230615T174426Z" creationid="jenya" creationdate="20230615T174426Z">
        <seg>![[LYHfGG_5_startingout.png]]</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>![[LYHfGG_6_ringring.png]]</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230616T100953Z" creationid="jenya" creationdate="20230616T100953Z">
        <seg>![[LYHfGG_6_ringring.png]]</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>![[LYHfGG_7_baby.png]]</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230616T173854Z" creationid="jenya" creationdate="20230616T173854Z">
        <seg>![[LYHfGG_7_baby.png]]</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg># Functionally Solving Problems</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230613T160057Z" creationid="jenya" creationdate="20230613T160057Z">
        <seg># Functionally Solving Problems</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg># Higher order functions</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230613T160006Z" creationid="jenya" creationdate="20230613T160006Z">
        <seg># Higher order functions</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg># Introduction</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230610T211504Z" creationid="jenya" creationdate="20230610T211504Z">
        <seg># Введение</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg># Modules</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230613T160009Z" creationid="jenya" creationdate="20230613T160009Z">
        <seg># Modules</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg># Starting Out</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230615T174400Z" creationid="jenya" creationdate="20230615T174354Z">
        <seg># Начиная</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>## About this tutorial</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230612T110356Z" creationid="jenya" creationdate="20230610T211543Z">
        <seg>## Об этом учебном пособии</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>## Baby's first functions</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230616T132603Z" creationid="jenya" creationdate="20230616T132603Z">
        <seg>## Первые детские функции</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>## Ready, set, go!</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230616T092759Z" creationid="jenya" creationdate="20230615T174352Z">
        <seg>## На старт, внимание, марш!</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>## So what's Haskell?</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230615T174228Z" creationid="jenya" creationdate="20230615T165018Z">
        <seg>## Итак, что такое Haskell?</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>## What you need to dive in</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230615T173615Z" creationid="jenya" creationdate="20230615T173615Z">
        <seg>## Во что вам нужно погрузиться</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>A little pitfall to watch out for here is negating numbers.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230616T095709Z" creationid="jenya" creationdate="20230616T095709Z">
        <seg>Небольшая ошибка, на которую следует обратить внимание здесь, - это отрицание чисел.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>A text editor and a Haskell compiler.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230615T173622Z" creationid="jenya" creationdate="20230615T173622Z">
        <seg>Текстовый редактор и компилятор Haskell.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Alright, let's get started!</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230615T174436Z" creationid="jenya" creationdate="20230615T174427Z">
        <seg>Хорошо, давайте начнем!</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Although I bet that even if you don't have any significant programming experience, a smart person such as yourself will be able to follow along and learn Haskell.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230615T164243Z" creationid="jenya" creationdate="20230615T164243Z">
        <seg>Хотя я готов поспорить, что даже если у вас нет сколько-нибудь значительного опыта в программировании, такой умный человек, как вы, сможет последовать примеру и изучить Haskell.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>And shorter programs are easier to maintain than longer ones and have less bugs.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230615T173443Z" creationid="jenya" creationdate="20230615T173443Z">
        <seg>А более короткие программы легче поддерживать, чем более длинные, и в них меньше ошибок.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>As expected, you can call your own functions from other functions that you made.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230616T163025Z" creationid="jenya" creationdate="20230616T163005Z">
        <seg>Как и ожидалось, вы можете вызывать свои собственные функции из других созданных вами функций.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>As you can see, we just separate the function name from the parameter with a space.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230616T105256Z" creationid="jenya" creationdate="20230616T104803Z">
        <seg>Как вы можете видеть, мы просто отделяем имя функции от параметра пробелом.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>As you probably know, `&amp;&amp;` means a boolean _and_, `||` means a boolean _or_.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230616T095805Z" creationid="jenya" creationdate="20230616T095805Z">
        <seg>Как вы, вероятно, знаете, `&amp;&amp;` означает логическое _И_, `||` означает логическое _ИЛИ_ .</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>As you've seen, we call it by sandwiching it between them.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230616T100808Z" creationid="jenya" creationdate="20230616T100808Z">
        <seg>Как вы видели, мы вызываем это, помещая его между ними.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>At first, this seems kind of limiting but it actually has some very nice consequences: if a function is called twice with the same parameters, it's guaranteed to return the same result.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230615T170732Z" creationid="jenya" creationdate="20230615T170732Z">
        <seg>На первый взгляд это кажется своего рода ограничением, но на самом деле это имеет некоторые очень приятные последствия: если функция вызывается дважды с одними и теми же параметрами, она гарантированно возвращает один и тот же результат.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Because `+` works on integers as well as on floating-point numbers (anything that can be considered a number, really), our function also works on any number.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230616T162708Z" creationid="jenya" creationdate="20230616T162708Z">
        <seg>Поскольку `+` работает как с целыми числами, так и с числами с плавающей запятой (все, что на самом деле можно считать числом), наша функция также работает с любым числом.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Because it uses a lot of high level concepts, Haskell programs are usually shorter than their imperative equivalents.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230615T173430Z" creationid="jenya" creationdate="20230615T173430Z">
        <seg>Поскольку в нем используется много высокоуровневых концепций, программы на Haskell обычно короче своих императивных эквивалентов.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Boolean algebra is also pretty straightforward.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230616T095745Z" creationid="jenya" creationdate="20230616T095745Z">
        <seg>Булева алгебра также довольно проста.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>But once you want to see the result, the first `doubleMe` tells the second one it wants the result, now!</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230615T172425Z" creationid="jenya" creationdate="20230615T172425Z">
        <seg>Но как только вы захотите увидеть результат, первая "двойная строка" сообщит второй, что она хочет получить результат, сейчас же!</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>But the catch is that they both have to be the same type of thing.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230616T100350Z" creationid="jenya" creationdate="20230616T100350Z">
        <seg>Но загвоздка в том, что они оба должны быть одного типа.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>But then once it just "clicked" and after getting over that initial hurdle, it was pretty much smooth sailing.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230615T164811Z" creationid="jenya" creationdate="20230615T164811Z">
        <seg>Но затем, как только это просто "щелкнуло" и после преодоления этого первоначального препятствия, все прошло довольно гладко.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>But when defining functions, there's a `=` and after that we define what the function does.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230616T134836Z" creationid="jenya" creationdate="20230616T134836Z">
        <seg>Но при определении функций есть `=`, и после этого мы определяем, что делает функция.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>But when we call it like that, there may be some confusion as to which number is doing the division and which one is being divided.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230616T113756Z" creationid="jenya" creationdate="20230616T113756Z">
        <seg>Но когда мы называем это таким образом, может возникнуть некоторая путаница относительно того, какое число выполняет деление, а какое делится.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>By going through several resources, I was able put together the pieces and it all just came falling into place.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230615T164034Z" creationid="jenya" creationdate="20230615T164034Z">
        <seg>Просмотрев несколько ресурсов, я смог собрать воедино кусочки, и все просто встало на свои места.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Calling a function with several parameters is also simple.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230616T105301Z" creationid="jenya" creationdate="20230616T105301Z">
        <seg>Вызов функции с несколькими параметрами также прост.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Congratulations, you're in GHCI!</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230616T093614Z" creationid="jenya" creationdate="20230616T093144Z">
        <seg>Поздравляю, вы находитесь в GHCI!</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Doing `5 * -3` will make GHCI yell at you but doing `5 * (-3)` will work just fine.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230616T095740Z" creationid="jenya" creationdate="20230616T095740Z">
        <seg>Выполнение `5 * -3` заставит GHCI кричать на вас, но выполнение `5 * (-3)` будет работать просто отлично.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Doing `div 92 10` results in a 9.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230616T113733Z" creationid="jenya" creationdate="20230616T113733Z">
        <seg>Выполнение `div 92 10` приводит к получению 9.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Even if it wasn't `"llama"` but `"four"` or `"4"`, Haskell still wouldn't consider it to be a number.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230616T100127Z" creationid="jenya" creationdate="20230616T100127Z">
        <seg>Даже если бы это была не `"llama", а "four" или "4", Haskell все равно не счел бы это числом.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>For a start, we'll try calling one of the most boring functions in Haskell.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230616T101829Z" creationid="jenya" creationdate="20230616T101829Z">
        <seg>Для начала мы попробуем вызвать одну из самых скучных функций в Haskell.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>For example, in C, you use parentheses to call functions like `foo()`, `bar(1)` or `baz(3, "haha")`.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230616T114030Z" creationid="jenya" creationdate="20230616T114030Z">
        <seg>Например, в `C` вы используете круглые скобки для вызова таких функций, как `foo()`, `bar(1)` или `baz(3, "ха-ха")`.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>For instance, `*` is a function that takes two numbers and multiplies them.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230616T100756Z" creationid="jenya" creationdate="20230616T100756Z">
        <seg>Например, `*` - это функция, которая принимает два числа и умножает их.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>For instance, the `div` function takes two integers and does integral division between them.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230616T113727Z" creationid="jenya" creationdate="20230616T113727Z">
        <seg>Например, функция `div` принимает два целых числа и выполняет целочисленное деление между ними.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>For instance, you set variable `a` to 5 and then do some stuff and then set it to something else.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230615T165305Z" creationid="jenya" creationdate="20230615T165154Z">
        <seg>Например, вы устанавливаете переменной `a` значение 5, а затем делаете что-то еще, а затем устанавливаете ее значение на что-то другое.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>For learning it's a lot easier and faster than compiling every time you make a change and then running the program from the prompt.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230615T173903Z" creationid="jenya" creationdate="20230615T173903Z">
        <seg>Для обучения это намного проще и быстрее, чем компилировать каждый раз, когда вы вносите изменения, а затем запускать программу из командной строки.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>For the purposes of this tutorial we'll be using GHC, the most widely used Haskell compiler.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230615T173653Z" creationid="jenya" creationdate="20230615T173653Z">
        <seg>Для целей этого руководства мы будем использовать GHC, наиболее широко используемый компилятор Haskell.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Function application (calling a function by putting a space after it and then typing out the parameters) has the highest precedence of them all.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230616T113138Z" creationid="jenya" creationdate="20230616T113138Z">
        <seg>Функциональное приложение (вызывающее функцию, ставя после нее пробел, а затем вводя параметры) имеет самый высокий приоритет из всех.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Functions are defined in a similar way that they are called.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230616T134618Z" creationid="jenya" creationdate="20230616T134618Z">
        <seg>Функции определяются аналогично тому, как они вызываются.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Functions are usually prefix so from now on we won't explicitly state that a function is of the prefix form, we'll just assume it.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230616T101100Z" creationid="jenya" creationdate="20230616T101100Z">
        <seg>Функции обычно являются префиксными, поэтому с этого момента мы не будем явно указывать, что функция имеет префиксную форму, мы просто предположим это.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Functions in Haskell don't have to be in any particular order, so it doesn't matter if you define `doubleMe` first and then `doubleUs` or if you do it the other way around.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230616T173706Z" creationid="jenya" creationdate="20230616T173706Z">
        <seg>Функции в Haskell не обязательно должны располагаться в каком-либо определенном порядке, поэтому не имеет значения, определяете ли вы сначала `doubleMe`, а затем `doubleUs` или делаете это наоборот.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>GHC can take a Haskell script (they usually have a .hs extension) and compile it but it also has an interactive mode which allows you to interactively interact with scripts.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230615T173826Z" creationid="jenya" creationdate="20230615T173826Z">
        <seg>GHC может взять скрипт на Haskell (обычно они имеют расширение .hs) и скомпилировать его, но он также имеет интерактивный режим, который позволяет вам интерактивно взаимодействовать со скриптами.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Haskell is **elegant and concise**.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230615T173204Z" creationid="jenya" creationdate="20230615T173204Z">
        <seg>Haskell **элегантен и лаконичен**.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Haskell is **lazy**.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230615T174251Z" creationid="jenya" creationdate="20230615T170847Z">
        <seg>Haskell **ленив**.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Haskell is **statically typed**.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230615T172800Z" creationid="jenya" creationdate="20230615T172800Z">
        <seg>Haskell является **статически типизированным**.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Haskell is a **purely functional programming language**.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230615T165040Z" creationid="jenya" creationdate="20230615T165022Z">
        <seg>Haskell - это **чисто функциональный язык программирования**.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Haskell uses a very good type system that has **type inference**.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230615T172923Z" creationid="jenya" creationdate="20230615T172923Z">
        <seg>Haskell использует очень хорошую систему типов, которая имеет **вывод типа**.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Haskell was made by some **really smart guys** (with PhDs).</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230615T173458Z" creationid="jenya" creationdate="20230615T173458Z">
        <seg>Haskell был создан несколькими **действительно умными парнями** (с докторскими степенями).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Here's some simple arithmetic.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230616T095102Z" creationid="jenya" creationdate="20230616T095028Z">
        <seg>Вот несколько простых арифметических действий.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>However, if we wanted to get the successor of the product of numbers 9 and 10, we couldn't write `succ 9 * 10` because that would get the successor of 9, which would then be multiplied by 10.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230616T113400Z" creationid="jenya" creationdate="20230616T113400Z">
        <seg>Однако, если бы мы хотели получить преемника произведения чисел 9 и 10, мы не могли бы написать `succ 9 * 10`, потому что это дало бы преемника 9, который затем был бы умножен на 10.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>I decided to write this because I wanted to solidify my own knowledge of Haskell and because I thought I could help people new to Haskell learn it from my perspective.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230611T225720Z" creationid="jenya" creationdate="20230611T225608Z">
        <seg>Я решил написать это, потому что хотел укрепить свои собственные знания о Haskell и потому что думал, что смогу помочь людям, новичкам в Haskell, изучить его с моей точки зрения.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>I failed to learn Haskell approximately 2 times before finally grasping it because it all just seemed too weird to me and I didn't get it.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230615T164552Z" creationid="jenya" creationdate="20230615T164552Z">
        <seg>Мне не удалось выучить Haskell примерно 2 раза, прежде чем я, наконец, понял его, потому что все это казалось мне слишком странным, и я этого не понял.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>I guess what I'm trying to say is: Haskell is great and if you're interested in programming you should really learn it even if it seems weird at first.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230615T164859Z" creationid="jenya" creationdate="20230615T164859Z">
        <seg>Наверное, я пытаюсь сказать следующее: Haskell великолепен, и если вы интересуетесь программированием, вам действительно следует его изучить, даже если поначалу это кажется странным.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>If a function takes two parameters, we can also call it as an infix function by surrounding it with backticks.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230616T113652Z" creationid="jenya" creationdate="20230616T113545Z">
        <seg>Если функция принимает два параметра, мы также можем вызвать ее как инфиксную функцию, окружив ее обратными кавычками (` `` `).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>If a function you make takes two parameters and adds them together and you don't explicitly state their type, the function will work on any two parameters that act like numbers.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230615T173156Z" creationid="jenya" creationdate="20230615T173156Z">
        <seg>Если созданная вами функция принимает два параметра и складывает их вместе, и вы явно не указываете их тип, функция будет работать с любыми двумя параметрами, которые действуют как числа.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>If we tried to do `True == 5`, GHCI would tell us that the types don't match.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230616T100151Z" creationid="jenya" creationdate="20230616T100151Z">
        <seg>Если бы мы попытались выполнить `True == 5`, GHCI сказал бы нам, что типы не совпадают.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>If we want to have a negative number, it's always best to surround it with parentheses.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230616T095722Z" creationid="jenya" creationdate="20230616T095722Z">
        <seg>Если мы хотим получить отрицательное число, всегда лучше заключить его в круглые скобки.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>If we wanted to multiply our list by 8 in an imperative language and did `doubleMe(doubleMe(doubleMe(xs)))`, it would probably pass through the list once and make a copy and then return it.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230615T174308Z" creationid="jenya" creationdate="20230615T171752Z">
        <seg>Если бы мы хотели умножить наш список на 8 на императивном языке и сделали `doubleMe( doubleMe( doubleMe(xs) ) )`, он, вероятно, прошел бы по списку один раз и сделал копию, а затем вернул бы ее.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>If you change the .hs script, just run `:l myfunctions` again or do `:r`, which is equivalent because it reloads the current script.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230615T174028Z" creationid="jenya" creationdate="20230615T174028Z">
        <seg>Если вы измените скрипт .hs, просто снова запустите `:l myfunctions` или выполните `:r`, что эквивалентно, поскольку оно перезагружает текущий скрипт.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>If you have defined some functions in a file called, say, `myfunctions.hs`, you load up those functions by typing in `:l myfunctions` and then you can play with them, provided `myfunctions.hs` is in the same folder from which `ghci` was invoked.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230615T173955Z" creationid="jenya" creationdate="20230615T173955Z">
        <seg>Если вы определили какие-то функции в файле с именем, скажем, `myfunctions.hs`, вы загружаете эти функции, введя `:l myfunctions`, а затем можете поиграть с ними, при условии, что `myfunctions.hs` находится в той же папке, из которой был вызван `ghci`.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>If you say `a = 5 + 4`, you don't have to tell Haskell that `a` is a number, it can figure that out by itself.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230615T173037Z" creationid="jenya" creationdate="20230615T173037Z">
        <seg>Если вы говорите `a = 5 + 4`, вам не нужно говорить Haskell, что `a` - это число, он может вычислить это сам.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>If you say that `a` is 5, you can't say it's something else later because you just said it was 5.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230615T170444Z" creationid="jenya" creationdate="20230615T170444Z">
        <seg>Если вы скажете, что `a` равно 5, вы не сможете позже сказать, что это что-то другое, потому что вы только что сказали, что это 5.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>If you try to add together a number and a string, the compiler will whine at you.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230615T172910Z" creationid="jenya" creationdate="20230615T172910Z">
        <seg>Если вы попытаетесь сложить вместе число и строку, компилятор будет ныть на вас.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>If you want to have the same prompt, just type in `:set prompt "ghci&gt; "`.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230616T095057Z" creationid="jenya" creationdate="20230616T093632Z">
        <seg>Если вы хотите получить такое же приглашение, просто введите `:set prompt "ghci&gt; "`.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>If you're reading this, chances are you want to learn Haskell.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230611T203057Z" creationid="jenya" creationdate="20230611T203057Z">
        <seg>Если вы читаете это, то возможно вы хотите выучить Haskell.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>If you're the sort of horrible person who doesn't read introductions to things and you skipped it, you might want to read the last section in the introduction anyway because it explains what you need to follow this tutorial and how we're going to load functions.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230616T092926Z" creationid="jenya" creationdate="20230616T092926Z">
        <seg>Если вы из тех ужасных людей, которые не читают введения к книгам, и вы пропустили его, возможно, вы все равно захотите прочитать последний раздел введения, потому что в нем объясняется, что вам нужно для выполнения этого руководства и как мы собираемся загружать функции.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>In 2003 the Haskell Report was published, which defines a stable version of the language.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230615T173609Z" creationid="jenya" creationdate="20230615T173609Z">
        <seg>В 2003 году был опубликован отчет Haskell, в котором определяется стабильная версия языка.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>In C, that would be something like `bar(bar(3))`.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230616T132545Z" creationid="jenya" creationdate="20230616T132545Z">
        <seg>В `C` это было бы что-то вроде `bar(bar(3))`.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>In Haskell, functions are called by writing the function name, a space and then the parameters, separated by spaces.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230616T101219Z" creationid="jenya" creationdate="20230616T101219Z">
        <seg>В Haskell функции вызываются путем ввода имени функции, пробела, а затем параметров, разделенных пробелами.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>In a lazy language, calling `doubleMe` on a list without forcing it to show you the result ends up in the program sort of telling you "Yeah yeah, I'll do it later!".</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230615T172010Z" creationid="jenya" creationdate="20230615T172010Z">
        <seg>На ленивом языке вызов `doubleMe` в списке, не заставляя его показывать вам результат, приводит к тому, что программа как бы говорит вам: "Да, да, я сделаю это позже!".</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>In imperative languages you get things done by giving the computer a sequence of tasks and then it executes them.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230615T165136Z" creationid="jenya" creationdate="20230615T165136Z">
        <seg>В императивных языках вы добиваетесь цели, задавая компьютеру последовательность задач, а затем он их выполняет.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>In most imperative languages functions are called by writing the function name and then writing its parameters in parentheses, usually separated by commas.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230616T101158Z" creationid="jenya" creationdate="20230616T101158Z">
        <seg>В большинстве императивных языков функции вызываются путем ввода имени функции, а затем ее параметров в круглых скобках, обычно через запятую.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>In purely functional programming you don't tell the computer what to do as such but rather you tell it what stuff _is_.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230615T170029Z" creationid="jenya" creationdate="20230615T165155Z">
        <seg>В чисто функциональном программировании вы не указываете компьютеру, что делать как таковое, а скорее сообщаете ему, чем этот материал _является_.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>In the previous section we got a basic feel for calling functions.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230616T132631Z" creationid="jenya" creationdate="20230616T132604Z">
        <seg>В предыдущем разделе мы получили базовое представление о вызове функций.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Interactively.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230615T173829Z" creationid="jenya" creationdate="20230615T173829Z">
        <seg>Интерактивно.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>It also allows cool things such as infinite data structures.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230615T171704Z" creationid="jenya" creationdate="20230615T171704Z">
        <seg>Это также позволяет создавать интересные вещи, такие как бесконечные структуры данных.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>It forces you to think differently, which brings us to the next section …</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230615T164947Z" creationid="jenya" creationdate="20230615T164947Z">
        <seg>Это заставляет вас думать по-другому, что подводит нас к следующему разделу ...</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>It means that we first call the function `bar` with `3` as the parameter to get some number and then we call `bar` again with that number.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230616T132531Z" creationid="jenya" creationdate="20230616T132531Z">
        <seg>Это означает, что мы сначала вызываем функцию `bar` с `3` в качестве параметра, чтобы получить некоторое число, а затем мы снова вызываем `bar` с этим числом.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Learning Haskell is much like learning to program for the first time — it's fun!</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230615T164923Z" creationid="jenya" creationdate="20230615T164923Z">
        <seg>Изучение Haskell во многом похоже на обучение программированию в первый раз — это весело!</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Let's make a function that takes two numbers and multiplies each by two and then adds them together.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230616T162716Z" creationid="jenya" creationdate="20230616T162716Z">
        <seg>Давайте создадим функцию, которая принимает два числа и умножает каждое на два, а затем складывает их вместе.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Let's take a look at them.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230616T100951Z" creationid="jenya" creationdate="20230616T100942Z">
        <seg>Давайте взглянем на них.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Like we said, spaces are used for function application in Haskell.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230616T125612Z" creationid="jenya" creationdate="20230616T125612Z">
        <seg>Как мы уже говорили, пробелы используются для применения функций в Haskell.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Lots of people who come from imperative languages tend to stick to the notion that parentheses should denote function application.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230616T114017Z" creationid="jenya" creationdate="20230616T114016Z">
        <seg>Многие люди, пришедшие из императивных языков, склонны придерживаться представления о том, что круглые скобки должны обозначать применение функции.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Making basic functions that are obviously correct and then combining them into more complex functions.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230616T163052Z" creationid="jenya" creationdate="20230616T163052Z">
        <seg>Создание базовых функций, которые, очевидно, являются правильными, а затем объединение их в более сложные функции.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Most functions that aren't used with numbers are _prefix_ functions.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230616T100940Z" creationid="jenya" creationdate="20230616T100940Z">
        <seg>Большинство функций, которые не используются с числами, являются _префиксными_ функциями.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Note: you can do `5 + 4.0` because `5` is sneaky and can act like an integer or a floating-point number.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230616T100659Z" creationid="jenya" creationdate="20230616T100551Z">
        <seg>

&gt; Примечание: вы можете использовать `5 + 4.0`, потому что `5` является скрытым и может действовать как целое число или число с плавающей запятой.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Now let's try making our own!</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230616T132701Z" creationid="jenya" creationdate="20230616T132701Z">
        <seg>Теперь давайте попробуем сделать нашу собственную функцию!</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Now navigate to where it's saved and run `ghci` from there.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230616T161033Z" creationid="jenya" creationdate="20230616T161033Z">
        <seg>Теперь перейдите туда, где он сохранен, и запустите `ghci` оттуда.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Now that our script is loaded, we can play with the function that we defined.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230616T161052Z" creationid="jenya" creationdate="20230616T161052Z">
        <seg>Теперь, когда наш скрипт загружен, мы можем поиграть с функцией, которую мы определили.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Now we're going to make a function that multiplies a number by 2 but only if that number is smaller than or equal to 100 because numbers bigger than 100 are big enough as it is!</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230616T173827Z" creationid="jenya" creationdate="20230616T173827Z">
        <seg>Теперь мы собираемся создать функцию, которая умножает число на 2, но только если это число меньше или равно 100, потому что числа больше 100 и так достаточно велики!</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Once inside GHCI, do `:l baby`.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230616T161047Z" creationid="jenya" creationdate="20230616T161047Z">
        <seg>Оказавшись внутри GHCI, выполните `:l baby`.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Open up your favorite text editor and punch in this function that takes a number and multiplies it by two.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230616T132718Z" creationid="jenya" creationdate="20230616T132718Z">
        <seg>Откройте свой любимый текстовый редактор и введите эту функцию, которая принимает число и умножает его на два.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Open your terminal and type in `ghci`.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230616T093018Z" creationid="jenya" creationdate="20230616T093018Z">
        <seg>Откройте свой терминал и введите `ghci`.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>People there are extremely nice, patient and understanding to newbies.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230615T164415Z" creationid="jenya" creationdate="20230615T164415Z">
        <seg>Люди там чрезвычайно милы, терпеливы и с пониманием относятся к новичкам.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Prelude&gt;
```</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230616T093205Z" creationid="jenya" creationdate="20230616T093205Z">
        <seg>Prelude&gt;
```</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Pretty cool, huh?</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230616T095344Z" creationid="jenya" creationdate="20230616T095344Z">
        <seg>Довольно круто, да?</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Right here we introduced Haskell's if statement.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230616T174114Z" creationid="jenya" creationdate="20230616T173855Z">
        <seg>Прямо здесь мы представили оператор `if`.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Save this as `baby.hs` or something.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230616T161021Z" creationid="jenya" creationdate="20230616T161021Z">
        <seg>Сохраните это как "baby.hs" или что-то в этом роде.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Say you have an immutable list of numbers `xs = [1,2,3,4,5,6,7,8]` and a function `doubleMe` which multiplies every element by 2 and then returns a new list.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230615T171742Z" creationid="jenya" creationdate="20230615T171742Z">
        <seg>Допустим, у вас есть неизменяемый список чисел `xs = [1,2,3,4,5,6,7,8]` и функция `doubleMe`, которая умножает каждый элемент на 2, а затем возвращает новый список.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>See for yourself:</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230616T113102Z" creationid="jenya" creationdate="20230616T113102Z">
        <seg>Смотрите сами:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Simple.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230616T162729Z" creationid="jenya" creationdate="20230616T162729Z">
        <seg>Просто.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>So 100.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230616T113503Z" creationid="jenya" creationdate="20230616T113503Z">
        <seg>Итак, 100.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>So if you see something like `bar (bar 3)`, it doesn't mean that `bar` is called with `bar` and `3` as parameters.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230616T130601Z" creationid="jenya" creationdate="20230616T130601Z">
        <seg>Поэтому, если вы видите что-то вроде `bar (bar 3)`, это не означает, что `bar` вызывается с `bar` и `3` в качестве параметров.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>So in purely functional languages, a function has no side-effects.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230615T170538Z" creationid="jenya" creationdate="20230615T170538Z">
        <seg>Таким образом, в чисто функциональных языках функция не имеет побочных эффектов.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>So it only does one pass through the list and only when you really need it.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230615T172605Z" creationid="jenya" creationdate="20230615T172605Z">
        <seg>Таким образом, он выполняет только один проход по списку и только тогда, когда вам это действительно нужно.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>So this is an attempt at adding another useful resource for learning Haskell so you have a bigger chance of finding one you like.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230615T164104Z" creationid="jenya" creationdate="20230615T164104Z">
        <seg>Итак, это попытка добавить еще один полезный ресурс для изучения Haskell, чтобы у вас было больше шансов найти тот, который вам понравится.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>So those functions in Haskell would be `foo`, `bar 1` and `baz 3 "haha"`.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230616T130300Z" creationid="jenya" creationdate="20230616T125613Z">
        <seg>Таким образом, этими функциями в Haskell были бы `foo`, `bar 1` и `baz 3 "ха-ха"`.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>So we can call it as an infix function by doing ``92 `div` 10`` and suddenly it's much clearer.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230616T113857Z" creationid="jenya" creationdate="20230616T113857Z">
        <seg>Таким образом, мы можем вызвать это как инфиксную функцию, выполнив команду ``92 `div` 10``, и внезапно все становится намного понятнее.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Testing for equality is done like so.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230616T095931Z" creationid="jenya" creationdate="20230616T095931Z">
        <seg>Проверка на равенство выполняется следующим образом.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Testing it out produces pretty predictable results (remember to append this function to the `baby.hs` file, save it and then do `:l baby` inside GHCI).</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230616T162807Z" creationid="jenya" creationdate="20230616T162807Z">
        <seg>Тестирование дает довольно предсказуемые результаты (не забудьте добавить эту функцию в файл `baby.hs`, сохранить его, а затем выполнить `:l baby` внутри GHCI).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>That goes well with referential transparency and it allows you to think of programs as a series of **transformations on data**.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230615T171559Z" creationid="jenya" creationdate="20230615T171559Z">
        <seg>Это хорошо сочетается со ссылочной прозрачностью и позволяет вам думать о программах как о серии **преобразований данных**.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>That means that a lot of possible errors are caught at compile time.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230615T172853Z" creationid="jenya" creationdate="20230615T172853Z">
        <seg>Это означает, что во время компиляции обнаруживается множество возможных ошибок.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>That means that unless specifically told otherwise, Haskell won't execute functions and calculate things until it's really forced to show you a result.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230615T171434Z" creationid="jenya" creationdate="20230615T171434Z">
        <seg>Это означает, что, если специально не указано иное, Haskell не будет выполнять функции и вычислять что-либо, пока его действительно не заставят показать вам результат.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>That means that you don't have to explicitly label every piece of code with a type because the type system can intelligently figure out a lot about it.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230615T173015Z" creationid="jenya" creationdate="20230615T173015Z">
        <seg>Это означает, что вам не нужно явно помечать каждый фрагмент кода типом, потому что система типов может разумно многое выяснить об этом.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>That way when you want something from a lazy language you can just take some initial data and efficiently transform and mend it so it resembles what you want at the end.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230615T172749Z" creationid="jenya" creationdate="20230615T172749Z">
        <seg>Таким образом, когда вам нужно что-то из ленивого языка, вы можете просто взять некоторые исходные данные и эффективно преобразовать и исправить их, чтобы они напоминали то, что вы хотите в конце.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>That's called referential transparency and not only does it allow the compiler to reason about the program's behavior, but it also allows you to easily deduce (and even prove) that a function is correct and then build more complex functions by gluing simple functions together.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230615T170846Z" creationid="jenya" creationdate="20230615T170846Z">
        <seg>Это называется прозрачностью ссылок, и она не только позволяет компилятору рассуждать о поведении программы, но и позволяет вам легко вывести (и даже доказать), что функция верна, а затем создавать более сложные функции путем склеивания простых функций вместе.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The `succ` function takes anything that has a defined successor and returns that successor.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230616T112618Z" creationid="jenya" creationdate="20230616T104801Z">
        <seg>Функция `succ` принимает все, что имеет определенного преемника, и возвращает этого преемника.^[Преемник (successor) - это число, следующее после некоторого натурального числа. &lt;br&gt;
Форма: Число + 1 = Преемник &lt;br&gt;
Функция приемника (successor function) - это функция, которая отправляет натуральное число следующему. &lt;br&gt;
Формула: f(x) = x + 1]</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The best way to get started is to download the [Haskell Platform](http://hackage.haskell.org/platform/), which is basically Haskell with batteries included.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230615T173740Z" creationid="jenya" creationdate="20230615T173740Z">
        <seg>Лучший способ начать - это загрузить [Haskell Platform](http://hackage.haskell.org/platform/), который в основном представляет собой Haskell с включенными батарейками.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The channel #haskell on the freenode network is a great place to ask questions if you're feeling stuck.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230615T164359Z" creationid="jenya" creationdate="20230615T164254Z">
        <seg>Канал #haskell в сети freenode - отличное место, чтобы задать вопросы, если вы чувствуете себя застрявшим.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The difference between Haskell's if statement and if statements in imperative languages is that the else part is mandatory in Haskell.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230616T174124Z" creationid="jenya" creationdate="20230616T174107Z">
        <seg>Разница между оператором `if` в Haskell и операторами `if` в императивных языках заключается в том, что часть else является обязательной в Haskell.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The factorial of a number is the product of all the numbers from 1 to that number, the sum of a list of numbers is the first number plus the sum of all the other numbers, and so on.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230615T170232Z" creationid="jenya" creationdate="20230615T165159Z">
        <seg>Факториал числа - это произведение всех чисел от 1 до этого числа, сумма списка чисел - это первое число плюс сумма всех остальных чисел и так далее.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The first one sees that and tells you the first element is 8.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230615T172550Z" creationid="jenya" creationdate="20230615T172550Z">
        <seg>Первая видит это и сообщает вам, что первый элемент равен 8.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The first thing we're going to do is run ghc's interactive mode and call some function to get a very basic feel for haskell.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230616T093007Z" creationid="jenya" creationdate="20230616T093007Z">
        <seg>Первое, что мы собираемся сделать, это запустить интерактивный режим ghc и вызвать какую-нибудь функцию, чтобы получить самое базовое представление о Haskell.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The function name is followed by parameters seperated by spaces.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230616T134625Z" creationid="jenya" creationdate="20230616T134625Z">
        <seg>За именем функции следуют параметры, разделенные пробелами.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The functions `min` and `max` take two things that can be put in an order (like numbers!).</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230616T105333Z" creationid="jenya" creationdate="20230616T105333Z">
        <seg>Функции `min` и `max` используют две вещи, которые можно упорядочить (например, числа!).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The interactive mode is invoked by typing in `ghci` at your prompt.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230615T173915Z" creationid="jenya" creationdate="20230615T173915Z">
        <seg>Интерактивный режим вызывается путем ввода `ghci` в вашей командной строке.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The only thing a function can do is calculate something and return it as a result.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230615T170608Z" creationid="jenya" creationdate="20230615T170608Z">
        <seg>Единственное, что может сделать функция, - это вычислить что-то и вернуть это в результате.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The prompt here is `Prelude&gt;` but because it can get longer when you load stuff into the session, we're going to use `ghci&gt;`.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230616T093818Z" creationid="jenya" creationdate="20230616T093630Z">
        <seg>Подсказка здесь `Prelude&gt;`, но поскольку она может стать длиннее, когда вы загружаете материал в сеанс, мы собираемся использовать `ghci&gt;`.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The second one receives that and gives back 4 to the first one.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230615T172540Z" creationid="jenya" creationdate="20230615T172540Z">
        <seg>Вторая получает это и возвращает 4 первой.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The second one says that to the third one and the third one reluctantly gives back a doubled 1, which is a 2.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230615T172511Z" creationid="jenya" creationdate="20230615T172511Z">
        <seg>Вторая скажет это третьей, и третья неохотно возвращает удвоенную 1, которая равна 2.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The usual workflow for me when playing around in stuff is defining some functions in a .hs file, loading it up and messing around with them and then changing the .hs file, loading it up again and so on.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230615T174144Z" creationid="jenya" creationdate="20230615T174144Z">
        <seg>Обычный рабочий процесс для меня, когда я копаюсь в материалах, - это определение некоторых функций в файле .hs, его загрузка и возня с ними, а затем изменение файла .hs, повторная загрузка и так далее.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>The way I learned it was by reading several different tutorials and articles because each explained something in a different way than the other did.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230612T110623Z" creationid="jenya" creationdate="20230612T110346Z">
        <seg>Я научился, прочитав несколько разных учебников и статей, потому что каждый объяснял что-то по другому, чем другой.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Then it would pass through the list another two times and return the result.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230615T171921Z" creationid="jenya" creationdate="20230615T171921Z">
        <seg>Затем он пройдет по списку еще два раза и вернет результат.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>There are quite a few tutorials on Haskell floating around on the internet.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230612T110414Z" creationid="jenya" creationdate="20230611T225815Z">
        <seg>В Интернете есть довольно много учебных пособий по Haskell.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>This is a very simple example of a common pattern you will see throughout Haskell.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230616T163046Z" creationid="jenya" creationdate="20230616T163046Z">
        <seg>Это очень простой пример общего шаблона, который вы увидите во всем Haskell.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>This is also what we'll be doing here.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230615T174152Z" creationid="jenya" creationdate="20230615T174152Z">
        <seg>Это тоже то, чем мы будем заниматься здесь.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>This is pretty self-explanatory.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230616T095138Z" creationid="jenya" creationdate="20230616T095120Z">
        <seg>Это говорит само за себя.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>This is what we call an _infix_ function.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230616T100905Z" creationid="jenya" creationdate="20230616T100905Z">
        <seg>Это то, что мы называем _инфиксной_ функцией.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>This tutorial is aimed at people who have experience in imperative programming languages (C, C++, Java, Python …) but haven't programmed in a functional language before (Haskell, ML, OCaml …).</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230615T164157Z" creationid="jenya" creationdate="20230615T164157Z">
        <seg>Это руководство предназначено для людей, которые имеют опыт работы с императивными языками программирования (C, C ++, Java, Python ...), но никогда раньше не программировали на функциональном языке (Haskell, ML, OCaml вЂ/).</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>This way you also avoid repetition.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230616T163055Z" creationid="jenya" creationdate="20230616T163055Z">
        <seg>Таким образом, вы также избежите повторения.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Type inference also allows your code to be more general.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230615T173100Z" creationid="jenya" creationdate="20230615T173100Z">
        <seg>Вывод типа также позволяет вашему коду быть более общим.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>We can also use several operators on one line and all the usual precedence rules are obeyed.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230616T095232Z" creationid="jenya" creationdate="20230616T095232Z">
        <seg>Мы также можем использовать несколько операторов в одной строке, и при этом соблюдаются все обычные правила приоритета.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>We can use parentheses to make the precedence explicit or to change it.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230616T095311Z" creationid="jenya" creationdate="20230616T095311Z">
        <seg>Мы можем использовать круглые скобки, чтобы сделать приоритет явным или изменить его.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>We could have also defined it as `doubleUs x y = x + x + y + y`.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230616T162740Z" creationid="jenya" creationdate="20230616T162740Z">
        <seg>Мы могли бы также определить это как `doubleUs x y = x + x + y + y`.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>We'd have to write `succ (9 * 10)` to get 91.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230616T113510Z" creationid="jenya" creationdate="20230616T113510Z">
        <seg>Нам пришлось бы написать `succ (9 * 10)`, чтобы получить 91.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>We'll take a closer look at types a bit later.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230616T100408Z" creationid="jenya" creationdate="20230616T100408Z">
        <seg>Мы подробнее рассмотрим типы чуть позже.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Welcome to **Learn You a Haskell for Great Good**!</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230611T202853Z" creationid="jenya" creationdate="20230611T143314Z">
        <seg>Добро пожаловать в **Выучи Haskell для Великого Блага**!</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Well, if we try the first snippet, we get a big scary error message!</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230616T095958Z" creationid="jenya" creationdate="20230616T095958Z">
        <seg>Что ж, если мы попробуем первый фрагмент, то получим большое пугающее сообщение об ошибке!</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Well, you've come to the right place, but let's talk about this tutorial a bit first.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230611T225601Z" creationid="jenya" creationdate="20230611T225424Z">
        <seg>Что ж, вы обратились по адресу, но давайте немного поговорим об этом уроке.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>What GHCI is telling us here is that `"llama"` is not a number and so it doesn't know how to add it to 5.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230616T100100Z" creationid="jenya" creationdate="20230616T100100Z">
        <seg>GHCI говорит нам здесь, что "llama" - это не число, и поэтому он не знает, как добавить его к 5.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>What about doing `5 + "llama"` or `5 == True`?</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230616T095950Z" creationid="jenya" creationdate="20230616T095950Z">
        <seg>Как насчет того, чтобы сделать `5 + "llama"` или `5 == True`?</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>What are you, some kind of liar?</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230615T170457Z" creationid="jenya" creationdate="20230615T170457Z">
        <seg>Ты что, какой-то лжец?</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>What if some mathematicians figured out that 2 is actually 3 and you had to change your program?</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230616T163105Z" creationid="jenya" creationdate="20230616T163105Z">
        <seg>Что, если бы какие-нибудь математики выяснили, что 2 на самом деле равно 3, и вам пришлось бы изменить свою программу?</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>What that means for us is that these two statements are equivalent.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230616T113148Z" creationid="jenya" creationdate="20230616T113148Z">
        <seg>Для нас это означает, что эти два утверждения эквивалентны.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>When I was starting out in Haskell, I didn't learn from just one resource.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230612T110259Z" creationid="jenya" creationdate="20230612T110259Z">
        <seg>Когда я начинал изучать Haskell, я учился на нескольких ресурсах.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>When you compile your program, the compiler knows which piece of code is a number, which is a string and so on.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230615T172825Z" creationid="jenya" creationdate="20230615T172825Z">
        <seg>Когда вы компилируете свою программу, компилятор знает, какой фрагмент кода является числом, который - строкой и так далее.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Whereas `+` works only on things that are considered numbers, `==` works on any two things that can be compared.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230616T100338Z" creationid="jenya" creationdate="20230616T100338Z">
        <seg>В то время как `+` работает только с теми вещами, которые считаются числами, `==` работает с любыми двумя вещами, которые можно сравнить.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>While executing them, it can change state.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230615T165151Z" creationid="jenya" creationdate="20230615T165151Z">
        <seg>Во время их выполнения он может изменять состояние.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>With that in mind, we could redefine `doubleUs` like this:</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230616T163032Z" creationid="jenya" creationdate="20230616T163032Z">
        <seg>Имея это в виду, мы могли бы переопределить `doubleUs` следующим образом:</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Work on Haskell began in 1987 when a committee of researchers got together to design a kick-ass language.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230615T173549Z" creationid="jenya" creationdate="20230615T173549Z">
        <seg>Работа над Haskell началась в 1987 году, когда комитет исследователей собрался вместе для разработки потрясающего языка.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Yeah, I know it's not but bear with me.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230616T095637Z" creationid="jenya" creationdate="20230616T095637Z">
        <seg>Да, я знаю, что это не так, но потерпи меня.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>Yikes!</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230616T100025Z" creationid="jenya" creationdate="20230616T100025Z">
        <seg>Фу!</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>You also can't set a variable to something and then set it to something else later.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230615T170331Z" creationid="jenya" creationdate="20230615T170331Z">
        <seg>Вы также не можете присвоить переменной значение чего-то, а затем присвоить ей значение чего-то другого позже.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>You can call functions from scripts that you load and the results are displayed immediately.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230615T173840Z" creationid="jenya" creationdate="20230615T173840Z">
        <seg>Вы можете вызывать функции из скриптов, которые вы загружаете, и результаты отображаются немедленно.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>You can't compare apples and oranges.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230616T100356Z" creationid="jenya" creationdate="20230616T100356Z">
        <seg>Вы не можете сравнивать яблоки и апельсины.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>You could just redefine `doubleMe` to be `x + x + x` and since `doubleUs` calls `doubleMe`, it would automatically work in this strange new world where 2 is 3.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230616T173629Z" creationid="jenya" creationdate="20230616T173629Z">
        <seg>Вы могли бы просто переопределить `doubleMe` на `x + x + x`, и поскольку `doubleUs` вызывает `doubleMe`, это автоматически сработало бы в этом странном новом мире, где 2 равно 3.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>You express that in the form of functions.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230615T170250Z" creationid="jenya" creationdate="20230615T170250Z">
        <seg>Вы выражаете это в форме функций.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>You have control flow structures for doing some action several times.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230615T165654Z" creationid="jenya" creationdate="20230615T165153Z">
        <seg>У вас есть структуры потока управления для выполнения какого-либо действия несколько раз.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>You may not have known it but we've been using functions now all along.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230616T100748Z" creationid="jenya" creationdate="20230616T100748Z">
        <seg>Возможно, вы этого не знали, но мы все это время использовали функции.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>You probably already have your favorite text editor installed so we won't waste time on that.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230615T173638Z" creationid="jenya" creationdate="20230615T173638Z">
        <seg>Вероятно, у вас уже установлен ваш любимый текстовый редактор, так что мы не будем тратить на это время.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>You will be greeted with something like this.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230616T093129Z" creationid="jenya" creationdate="20230616T093129Z">
        <seg>Вас встретят чем-то вроде этого.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>You're probably familiar with if statements from other languages.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230616T174117Z" creationid="jenya" creationdate="20230616T174112Z">
        <seg>Вероятно, вы знакомы с операторами `if` из других языков.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>`+` expects its left and right side to be numbers.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230616T100138Z" creationid="jenya" creationdate="20230616T100138Z">
        <seg>`+` ожидает, что его левая и правая стороны будут числами.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>`4.0` can't act like an integer, so `5` is the one that has to adapt.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230616T100735Z" creationid="jenya" creationdate="20230616T100554Z">
        <seg>`4.0` не может действовать как целое число, поэтому `5` - это то, что должно адаптироваться.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>```haskell
GHCi, version 6.8.2: http://www.haskell.org/ghc/  :?</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230616T093200Z" creationid="jenya" creationdate="20230616T093200Z">
        <seg>```haskell
GHCi, version 6.8.2: http://www.haskell.org/ghc/  :?</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>```haskell
No instance for (Num [Char])
arising from a use of `+' at &lt;interactive&gt;:1:0-9
Possible fix: add an instance declaration for (Num [Char])
In the expression: 5 + "llama"
In the definition of `it': it = 5 + "llama" 
```</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230616T100020Z" creationid="jenya" creationdate="20230616T100020Z">
        <seg>```haskell
No instance for (Num [Char])
arising from a use of `+' at &lt;interactive&gt;:1:0-9
Possible fix: add an instance declaration for (Num [Char])
In the expression: 5 + "llama"
In the definition of `it': it = 5 + "llama" 
```</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>```haskell
doubleMe x = x + x
```</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230616T132719Z" creationid="jenya" creationdate="20230616T132719Z">
        <seg>```haskell
doubleMe x = x + x
```</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>```haskell
doubleSmallNumber x = if x &gt; 100</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230616T173828Z" creationid="jenya" creationdate="20230616T173828Z">
        <seg>```haskell
doubleSmallNumber x = if x &gt; 100</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>```haskell
doubleUs x y = doubleMe x + doubleMe y 
```</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230616T163038Z" creationid="jenya" creationdate="20230616T163038Z">
        <seg>```haskell
doubleUs x y = doubleMe x + doubleMe y 
```</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>```haskell
doubleUs x y = x*2 + y*2 
```</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230616T162717Z" creationid="jenya" creationdate="20230616T162717Z">
        <seg>```haskell
doubleUs x y = x*2 + y*2 
```</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>```haskell
ghci&gt; (50 * 100) - 4999
1
ghci&gt; 50 * 100 - 4999
1
ghci&gt; 50 * (100 - 4999)
-244950
```</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230616T095325Z" creationid="jenya" creationdate="20230616T095325Z">
        <seg>```haskell
ghci&gt; (50 * 100) - 4999
1
ghci&gt; 50 * 100 - 4999
1
ghci&gt; 50 * (100 - 4999)
-244950
```</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>```haskell
ghci&gt; 2 + 15
17
ghci&gt; 49 * 100
4900
ghci&gt; 1892 - 1472
420
ghci&gt; 5 / 2
2.5
ghci&gt;
```</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230616T095114Z" creationid="jenya" creationdate="20230616T095114Z">
        <seg>```haskell
ghci&gt; 2 + 15
17
ghci&gt; 49 * 100
4900
ghci&gt; 1892 - 1472
420
ghci&gt; 5 / 2
2.5
ghci&gt;
```</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>```haskell
ghci&gt; 5 == 5
True
ghci&gt; 1 == 0
False
ghci&gt; 5 /= 5
False
ghci&gt; 5 /= 4
True
ghci&gt; "hello" == "hello"
True 
```</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230616T095937Z" creationid="jenya" creationdate="20230616T095937Z">
        <seg>```haskell
ghci&gt; 5 == 5
True
ghci&gt; 1 == 0
False
ghci&gt; 5 /= 5
False
ghci&gt; 5 /= 4
True
ghci&gt; "hello" == "hello"
True 
```</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>```haskell
ghci&gt; :l baby
[1 of 1] Compiling Main             ( baby.hs, interpreted )
Ok, modules loaded: Main.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230616T161053Z" creationid="jenya" creationdate="20230616T161053Z">
        <seg>```haskell
ghci&gt; :l baby
[1 of 1] Compiling Main             ( baby.hs, interpreted )
Ok, modules loaded: Main.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>```haskell
ghci&gt; True &amp;&amp; False
False
ghci&gt; True &amp;&amp; True
True
ghci&gt; False || True
True 
ghci&gt; not False
True
ghci&gt; not (True &amp;&amp; True)
False
```</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230616T095921Z" creationid="jenya" creationdate="20230616T095921Z">
        <seg>```haskell
ghci&gt; True &amp;&amp; False
False
ghci&gt; True &amp;&amp; True
True
ghci&gt; False || True
True 
ghci&gt; not False
True
ghci&gt; not (True &amp;&amp; True)
False
```</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>```haskell
ghci&gt; doubleUs 4 9
26
ghci&gt; doubleUs 2.3 34.2
73.0
ghci&gt; doubleUs 28 88 + doubleMe 123
478
```</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230616T162809Z" creationid="jenya" creationdate="20230616T162809Z">
        <seg>```haskell
ghci&gt; doubleUs 4 9
26
ghci&gt; doubleUs 2.3 34.2
73.0
ghci&gt; doubleUs 28 88 + doubleMe 123
478
```</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>```haskell
ghci&gt; min 9 10
9
ghci&gt; min 3.4 3.2
3.2
ghci&gt; max 100 101
101 
```</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230616T113104Z" creationid="jenya" creationdate="20230616T113104Z">
        <seg>```haskell
ghci&gt; min 9 10
9
ghci&gt; min 3.4 3.2
3.2
ghci&gt; max 100 101
101 
```</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>```haskell
ghci&gt; succ 8
9 
```</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230616T101831Z" creationid="jenya" creationdate="20230616T101831Z">
        <seg>```haskell
ghci&gt; succ 8
9 
```</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>```haskell
ghci&gt; succ 9 + max 5 4 + 1
16
ghci&gt; (succ 9) + (max 5 4) + 1
16
```</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230616T113153Z" creationid="jenya" creationdate="20230616T113153Z">
        <seg>```haskell
ghci&gt; succ 9 + max 5 4 + 1
16
ghci&gt; (succ 9) + (max 5 4) + 1
16
```</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>`min` returns the one that's lesser and `max` returns the one that's greater.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230616T111446Z" creationid="jenya" creationdate="20230616T111446Z">
        <seg>`min` возвращает значение, которое меньше, а `max` возвращает значение, которое больше.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>`not` negates a `True` or a `False`.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230616T095822Z" creationid="jenya" creationdate="20230616T095822Z">
        <seg>`not` отрицает `True` или `False`.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>else x*2 
```</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230616T173852Z" creationid="jenya" creationdate="20230616T173852Z">
        <seg>else x*2 
```</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>for help
Loading package base ... linking ... done.</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230616T093203Z" creationid="jenya" creationdate="20230616T093203Z">
        <seg>for help
Loading package base ... linking ... done.</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>ghci&gt; doubleMe 9
18
ghci&gt; doubleMe 8.3
16.6 
```</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230616T161056Z" creationid="jenya" creationdate="20230616T161056Z">
        <seg>ghci&gt; doubleMe 9
18
ghci&gt; doubleMe 8.3
16.6 
```</seg>
      </tuv>
    </tu>
    <tu>
      <tuv lang="en-US">
        <seg>then x</seg>
      </tuv>
      <tuv lang="ru-RU" changeid="jenya" changedate="20230616T173850Z" creationid="jenya" creationdate="20230616T173850Z">
        <seg>then x</seg>
      </tuv>
    </tu>
<!-- Alternative translations -->
  </body>
</tmx>
