<!DOCTYPE html>
<html><head>
			
		<title>Learn You a Haskell for Great Good! en</title>
		<base href="../../">
		<meta id="root-path" root-path="../../">

		<link rel="icon" sizes="96x96" href="https://publish-01.obsidian.md/access/f786db9fac45774fa4f0d8112e232d67/favicon-96x96.png">
		<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes, minimum-scale=1.0, maximum-scale=5.0">
		<meta charset="UTF-8">
		<script src="https://code.iconify.design/iconify-icon/1.0.3/iconify-icon.min.js"></script>

			<link rel="stylesheet" href="lib/styles/obsidian-styles.css">
			<link rel="stylesheet" href="lib/styles/theme.css">
			<link rel="stylesheet" href="lib/styles/plugin-styles.css">
			<link rel="stylesheet" href="lib/styles/snippets.css">
			<style>  </style>

			
			<!-- Graph View Data -->
			<script>
			let nodes=
{"nodeCount":11,"linkCount":10,"radii":[6,5.353316326530613,4.7602040816326525,3.975765306122449,3.975765306122449,3.975765306122449,3.975765306122449,3.975765306122449,3.975765306122449,3.975765306122449,3.975765306122449],"labels":["Отчеты","README","README","Полезные ресурсы","О Haskell по-человечески (Итого)","О Haskell по-человечески (Оригинал)","Learn You a Haskell for Great Good! ru","Learn You a Haskell for Great Good! en","py Конвертация txt в xlsx","py код оптимизации mdx","nodejs - зло"],"paths":["отчеты.html","курсы/learn-you-a-haskell-for-great-good!/readme.html","readme.html","полезные-ресурсы.html","мои-решения/о-haskell-по-человечески/о-haskell-по-человечески-(итого).html","курсы/о-haskell-по-человечески/о-haskell-по-человечески-(оригинал).html","курсы/learn-you-a-haskell-for-great-good!/learn-you-a-haskell-for-great-good!-ru.html","курсы/learn-you-a-haskell-for-great-good!/learn-you-a-haskell-for-great-good!-en.html","для-отчета/py-конвертация-txt-в-xlsx.html","для-отчета/py-код-оптимизации-mdx.html","для-отчета/nodejs-зло.html"],"linkSources":[2,2,1,1,0,0,0,0,0,0],"linkTargets":[3,0,7,6,5,4,1,10,9,8]};
			let attractionForce = 1;
			let linkLength = 10;
			let repulsionForce = 150;
			let centralForce = 3;
			let edgePruning = 100;
			</script>
			
<script type="module" src="lib/scripts/graph_view.js"></script>

<script src="lib/scripts/graph_wasm.js"></script>

<script src="lib/scripts/tinycolor.js"></script>

<script src="https://cdnjs.cloudflare.com/ajax/libs/pixi.js/7.2.4/pixi.min.js" integrity="sha512-Ch/O6kL8BqUwAfCF7Ie5SX1Hin+BJgYH4pNjRqXdTEqMsis1TUYg+j6nnI9uduPjGaj7DN4UKCZgpvoExt6dkw==" crossorigin="anonymous" referrerpolicy="no-referrer"></script>

<script src="lib/scripts/webpage.js"></script>

			</head><body class="theme-dark mod-windows is-frameless is-maximized is-hidden-frameless obsidian-app show-inline-title show-view-header is-focused" style="--zoom-factor:1; --font-text-size:16px; --line-width:100%; --line-width-adaptive:100%; --file-line-width:100%; --content-width:500em; --sidebar-width:25em; --collapse-arrow-size:0.4em; --tree-horizontal-spacing:1em; --tree-vertical-spacing:0.5em; --sidebar-margin:12px;"><div class="webpage-container"><div class="sidebar-left sidebar"><div class="sidebar-content"><div><label class="theme-toggle-container" for="theme_toggle"><input class="theme-toggle-input" type="checkbox" id="theme_toggle"><div class="toggle-background"></div></label></div><div class="tree-container file-tree mod-nav-indicator" data-depth="0"><div class="tree-header"><span class="sidebar-section-header">learn-haskell-valut</span><button class="clickable-icon collapse-tree-button is-collapsed"><iconify-icon icon="ph:arrows-in-line-horizontal-bold" width="18px" height="18px" rotate="90deg" color="currentColor"></iconify-icon></button></div><div class="tree-scroll-area"><div class="tree-item mod-tree-folder mod-collapsible is-collapsed" data-depth="1"><div class="tree-item-contents"><div class="tree-item-icon collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div><a class="tree-item-link" href="для-отчета"><span class="tree-item-title">Для отчета</span></a></div><div class="tree-item-children"><div class="tree-item mod-tree-file" data-depth="2"><div class="tree-item-contents"><a class="tree-item-link" href="для-отчета/nodejs-зло.html"><span class="tree-item-title">nodejs - зло</span></a></div><div class="tree-item-children"></div></div><div class="tree-item mod-tree-file" data-depth="2"><div class="tree-item-contents"><a class="tree-item-link" href="для-отчета/py-код-оптимизации-mdx.html"><span class="tree-item-title">py код оптимизации mdx</span></a></div><div class="tree-item-children"></div></div><div class="tree-item mod-tree-file" data-depth="2"><div class="tree-item-contents"><a class="tree-item-link" href="для-отчета/py-конвертация-txt-в-xlsx.html"><span class="tree-item-title">py Конвертация txt в xlsx</span></a></div><div class="tree-item-children"></div></div></div></div><div class="tree-item mod-tree-folder mod-collapsible is-collapsed" data-depth="1"><div class="tree-item-contents"><div class="tree-item-icon collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div><a class="tree-item-link" href="курсы"><span class="tree-item-title">Курсы</span></a></div><div class="tree-item-children"><div class="tree-item mod-tree-folder mod-collapsible is-collapsed" data-depth="2"><div class="tree-item-contents"><div class="tree-item-icon collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div><a class="tree-item-link" href="курсы/о-haskell-по-человечески"><span class="tree-item-title">О Haskell по-человечески</span></a></div><div class="tree-item-children"><div class="tree-item mod-tree-file" data-depth="3"><div class="tree-item-contents"><a class="tree-item-link" href="курсы/о-haskell-по-человечески/о-haskell-по-человечески-(оригинал).html"><span class="tree-item-title">О Haskell по-человечески (Оригинал)</span></a></div><div class="tree-item-children"></div></div></div></div><div class="tree-item mod-tree-folder mod-collapsible is-collapsed" data-depth="2"><div class="tree-item-contents"><div class="tree-item-icon collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div><a class="tree-item-link" href="курсы/learn-you-a-haskell-for-great-good!"><span class="tree-item-title">Learn You a Haskell for Great Good!</span></a></div><div class="tree-item-children"><div class="tree-item mod-tree-file" data-depth="3"><div class="tree-item-contents"><a class="tree-item-link" href="курсы/learn-you-a-haskell-for-great-good!/learn-you-a-haskell-for-great-good!-en.html"><span class="tree-item-title">Learn You a Haskell for Great Good! en</span></a></div><div class="tree-item-children"></div></div><div class="tree-item mod-tree-file" data-depth="3"><div class="tree-item-contents"><a class="tree-item-link" href="курсы/learn-you-a-haskell-for-great-good!/learn-you-a-haskell-for-great-good!-ru.html"><span class="tree-item-title">Learn You a Haskell for Great Good! ru</span></a></div><div class="tree-item-children"></div></div><div class="tree-item mod-tree-file" data-depth="3"><div class="tree-item-contents"><a class="tree-item-link" href="курсы/learn-you-a-haskell-for-great-good!/readme.html"><span class="tree-item-title">README</span></a></div><div class="tree-item-children"></div></div></div></div></div></div><div class="tree-item mod-tree-folder mod-collapsible is-collapsed" data-depth="1"><div class="tree-item-contents"><div class="tree-item-icon collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div><a class="tree-item-link" href="мои-решения"><span class="tree-item-title">Мои решения</span></a></div><div class="tree-item-children"><div class="tree-item mod-tree-folder mod-collapsible is-collapsed" data-depth="2"><div class="tree-item-contents"><div class="tree-item-icon collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div><a class="tree-item-link" href="мои-решения/о-haskell-по-человечески"><span class="tree-item-title">О Haskell по-человечески</span></a></div><div class="tree-item-children"><div class="tree-item mod-tree-file" data-depth="3"><div class="tree-item-contents"><a class="tree-item-link" href="мои-решения/о-haskell-по-человечески/о-haskell-по-человечески-(итого).html"><span class="tree-item-title">О Haskell по-человечески (Итого)</span></a></div><div class="tree-item-children"></div></div></div></div></div></div><div class="tree-item mod-tree-file" data-depth="1"><div class="tree-item-contents"><a class="tree-item-link" href="отчеты.html"><span class="tree-item-title">Отчеты</span></a></div><div class="tree-item-children"></div></div><div class="tree-item mod-tree-file" data-depth="1"><div class="tree-item-contents"><a class="tree-item-link" href="полезные-ресурсы.html"><span class="tree-item-title">Полезные ресурсы</span></a></div><div class="tree-item-children"></div></div><div class="tree-item mod-tree-file" data-depth="1"><div class="tree-item-contents"><a class="tree-item-link" href="readme.html"><span class="tree-item-title">README</span></a></div><div class="tree-item-children"></div></div></div></div></div></div><div class="document-container"><div class="markdown-preview-view markdown-rendered node-insert-event allow-fold-headings show-indentation-guide allow-fold-lists show-frontmatter" style="tab-size: 4;" tabindex="-1"><style id="MJX-CHTML-styles">mjx-c.mjx-c28::before { padding: 0.75em 0.389em 0.25em 0px; content: "("; }
mjx-c.mjx-c1D453.TEX-I::before { padding: 0.705em 0.55em 0.205em 0px; content: "f"; }
mjx-c.mjx-c2218::before { padding: 0.444em 0.5em 0px 0px; content: "∘"; }
mjx-c.mjx-c1D454.TEX-I::before { padding: 0.442em 0.477em 0.205em 0px; content: "g"; }
mjx-c.mjx-c29::before { padding: 0.75em 0.389em 0.25em 0px; content: ")"; }
mjx-container[jax="CHTML"] { line-height: 0; }
mjx-container [space="1"] { margin-left: 0.111em; }
mjx-container [space="2"] { margin-left: 0.167em; }
mjx-container [space="3"] { margin-left: 0.222em; }
mjx-container [space="4"] { margin-left: 0.278em; }
mjx-container [space="5"] { margin-left: 0.333em; }
mjx-container [rspace="1"] { margin-right: 0.111em; }
mjx-container [rspace="2"] { margin-right: 0.167em; }
mjx-container [rspace="3"] { margin-right: 0.222em; }
mjx-container [rspace="4"] { margin-right: 0.278em; }
mjx-container [rspace="5"] { margin-right: 0.333em; }
mjx-container [size="s"] { font-size: 70.7%; }
mjx-container [size="ss"] { font-size: 50%; }
mjx-container [size="Tn"] { font-size: 60%; }
mjx-container [size="sm"] { font-size: 85%; }
mjx-container [size="lg"] { font-size: 120%; }
mjx-container [size="Lg"] { font-size: 144%; }
mjx-container [size="LG"] { font-size: 173%; }
mjx-container [size="hg"] { font-size: 207%; }
mjx-container [size="HG"] { font-size: 249%; }
mjx-container [width="full"] { width: 100%; }
mjx-box { display: inline-block; }
mjx-block { display: block; }
mjx-itable { display: inline-table; }
mjx-row { display: table-row; }
mjx-row > * { display: table-cell; }
mjx-mtext { display: inline-block; text-align: left; }
mjx-mstyle { display: inline-block; }
mjx-merror { display: inline-block; color: red; background-color: yellow; }
mjx-mphantom { visibility: hidden; }
mjx-assistive-mml { top: 0px; left: 0px; clip: rect(1px, 1px, 1px, 1px); user-select: none; position: absolute !important; padding: 1px 0px 0px !important; border: 0px !important; display: block !important; width: auto !important; overflow: hidden !important; }
mjx-assistive-mml[display="block"] { width: 100% !important; }
mjx-math { display: inline-block; text-align: left; line-height: 0; text-indent: 0px; font-style: normal; font-weight: normal; font-size: 100%; letter-spacing: normal; border-collapse: collapse; overflow-wrap: normal; word-spacing: normal; white-space: nowrap; direction: ltr; padding: 1px 0px; }
mjx-container[jax="CHTML"][display="true"] { display: block; text-align: center; margin: 1em 0px; }
mjx-container[jax="CHTML"][display="true"][width="full"] { display: flex; }
mjx-container[jax="CHTML"][display="true"] mjx-math { padding: 0px; }
mjx-container[jax="CHTML"][justify="left"] { text-align: left; }
mjx-container[jax="CHTML"][justify="right"] { text-align: right; }
mjx-mi { display: inline-block; text-align: left; }
mjx-c { display: inline-block; }
mjx-utext { display: inline-block; padding: 0.75em 0px 0.2em; }
mjx-mo { display: inline-block; text-align: left; }
mjx-stretchy-h { display: inline-table; width: 100%; }
mjx-stretchy-h > * { display: table-cell; width: 0px; }
mjx-stretchy-h > * > mjx-c { display: inline-block; transform: scaleX(1); }
mjx-stretchy-h > * > mjx-c::before { display: inline-block; width: initial; }
mjx-stretchy-h > mjx-ext { overflow: clip visible; width: 100%; }
mjx-stretchy-h > mjx-ext > mjx-c::before { transform: scaleX(500); }
mjx-stretchy-h > mjx-ext > mjx-c { width: 0px; }
mjx-stretchy-h > mjx-beg > mjx-c { margin-right: -0.1em; }
mjx-stretchy-h > mjx-end > mjx-c { margin-left: -0.1em; }
mjx-stretchy-v { display: inline-block; }
mjx-stretchy-v > * { display: block; }
mjx-stretchy-v > mjx-beg { height: 0px; }
mjx-stretchy-v > mjx-end > mjx-c { display: block; }
mjx-stretchy-v > * > mjx-c { transform: scaleY(1); transform-origin: left center; overflow: hidden; }
mjx-stretchy-v > mjx-ext { display: block; height: 100%; box-sizing: border-box; border: 0px solid transparent; overflow: visible clip; }
mjx-stretchy-v > mjx-ext > mjx-c::before { width: initial; box-sizing: border-box; }
mjx-stretchy-v > mjx-ext > mjx-c { transform: scaleY(500) translateY(0.075em); overflow: visible; }
mjx-mark { display: inline-block; height: 0px; }
mjx-mn { display: inline-block; text-align: left; }
mjx-texatom { display: inline-block; text-align: left; }
mjx-c::before { display: block; width: 0px; }
.MJX-TEX { font-family: MJXZERO, MJXTEX; }
.TEX-B { font-family: MJXZERO, MJXTEX-B; }
.TEX-I { font-family: MJXZERO, MJXTEX-I; }
.TEX-MI { font-family: MJXZERO, MJXTEX-MI; }
.TEX-BI { font-family: MJXZERO, MJXTEX-BI; }
.TEX-S1 { font-family: MJXZERO, MJXTEX-S1; }
.TEX-S2 { font-family: MJXZERO, MJXTEX-S2; }
.TEX-S3 { font-family: MJXZERO, MJXTEX-S3; }
.TEX-S4 { font-family: MJXZERO, MJXTEX-S4; }
.TEX-A { font-family: MJXZERO, MJXTEX-A; }
.TEX-C { font-family: MJXZERO, MJXTEX-C; }
.TEX-CB { font-family: MJXZERO, MJXTEX-CB; }
.TEX-FR { font-family: MJXZERO, MJXTEX-FR; }
.TEX-FRB { font-family: MJXZERO, MJXTEX-FRB; }
.TEX-SS { font-family: MJXZERO, MJXTEX-SS; }
.TEX-SSB { font-family: MJXZERO, MJXTEX-SSB; }
.TEX-SSI { font-family: MJXZERO, MJXTEX-SSI; }
.TEX-SC { font-family: MJXZERO, MJXTEX-SC; }
.TEX-T { font-family: MJXZERO, MJXTEX-T; }
.TEX-V { font-family: MJXZERO, MJXTEX-V; }
.TEX-VB { font-family: MJXZERO, MJXTEX-VB; }
mjx-stretchy-v mjx-c, mjx-stretchy-h mjx-c { font-family: MJXZERO, MJXTEX-S1, MJXTEX-S4, MJXTEX, MJXTEX-A !important; }
@font-face { font-family: MJXZERO; src: url("app://obsidian.md/lib/mathjax/output/chtml/fonts/woff-v2/MathJax_Zero.woff") format("woff"); }
@font-face { font-family: MJXTEX; src: url("app://obsidian.md/lib/mathjax/output/chtml/fonts/woff-v2/MathJax_Main-Regular.woff") format("woff"); }
@font-face { font-family: MJXTEX-B; src: url("app://obsidian.md/lib/mathjax/output/chtml/fonts/woff-v2/MathJax_Main-Bold.woff") format("woff"); }
@font-face { font-family: MJXTEX-I; src: url("app://obsidian.md/lib/mathjax/output/chtml/fonts/woff-v2/MathJax_Math-Italic.woff") format("woff"); }
@font-face { font-family: MJXTEX-MI; src: url("app://obsidian.md/lib/mathjax/output/chtml/fonts/woff-v2/MathJax_Main-Italic.woff") format("woff"); }
@font-face { font-family: MJXTEX-BI; src: url("app://obsidian.md/lib/mathjax/output/chtml/fonts/woff-v2/MathJax_Math-BoldItalic.woff") format("woff"); }
@font-face { font-family: MJXTEX-S1; src: url("app://obsidian.md/lib/mathjax/output/chtml/fonts/woff-v2/MathJax_Size1-Regular.woff") format("woff"); }
@font-face { font-family: MJXTEX-S2; src: url("app://obsidian.md/lib/mathjax/output/chtml/fonts/woff-v2/MathJax_Size2-Regular.woff") format("woff"); }
@font-face { font-family: MJXTEX-S3; src: url("app://obsidian.md/lib/mathjax/output/chtml/fonts/woff-v2/MathJax_Size3-Regular.woff") format("woff"); }
@font-face { font-family: MJXTEX-S4; src: url("app://obsidian.md/lib/mathjax/output/chtml/fonts/woff-v2/MathJax_Size4-Regular.woff") format("woff"); }
@font-face { font-family: MJXTEX-A; src: url("app://obsidian.md/lib/mathjax/output/chtml/fonts/woff-v2/MathJax_AMS-Regular.woff") format("woff"); }
@font-face { font-family: MJXTEX-C; src: url("app://obsidian.md/lib/mathjax/output/chtml/fonts/woff-v2/MathJax_Calligraphic-Regular.woff") format("woff"); }
@font-face { font-family: MJXTEX-CB; src: url("app://obsidian.md/lib/mathjax/output/chtml/fonts/woff-v2/MathJax_Calligraphic-Bold.woff") format("woff"); }
@font-face { font-family: MJXTEX-FR; src: url("app://obsidian.md/lib/mathjax/output/chtml/fonts/woff-v2/MathJax_Fraktur-Regular.woff") format("woff"); }
@font-face { font-family: MJXTEX-FRB; src: url("app://obsidian.md/lib/mathjax/output/chtml/fonts/woff-v2/MathJax_Fraktur-Bold.woff") format("woff"); }
@font-face { font-family: MJXTEX-SS; src: url("app://obsidian.md/lib/mathjax/output/chtml/fonts/woff-v2/MathJax_SansSerif-Regular.woff") format("woff"); }
@font-face { font-family: MJXTEX-SSB; src: url("app://obsidian.md/lib/mathjax/output/chtml/fonts/woff-v2/MathJax_SansSerif-Bold.woff") format("woff"); }
@font-face { font-family: MJXTEX-SSI; src: url("app://obsidian.md/lib/mathjax/output/chtml/fonts/woff-v2/MathJax_SansSerif-Italic.woff") format("woff"); }
@font-face { font-family: MJXTEX-SC; src: url("app://obsidian.md/lib/mathjax/output/chtml/fonts/woff-v2/MathJax_Script-Regular.woff") format("woff"); }
@font-face { font-family: MJXTEX-T; src: url("app://obsidian.md/lib/mathjax/output/chtml/fonts/woff-v2/MathJax_Typewriter-Regular.woff") format("woff"); }
@font-face { font-family: MJXTEX-V; src: url("app://obsidian.md/lib/mathjax/output/chtml/fonts/woff-v2/MathJax_Vector-Regular.woff") format("woff"); }
@font-face { font-family: MJXTEX-VB; src: url("app://obsidian.md/lib/mathjax/output/chtml/fonts/woff-v2/MathJax_Vector-Bold.woff") format("woff"); }
mjx-c.mjx-c1D446.TEX-I::before { padding: 0.705em 0.645em 0.022em 0px; content: "S"; }
mjx-c.mjx-c3D::before { padding: 0.583em 0.778em 0.082em 0px; content: "="; }
mjx-c.mjx-c7B::before { padding: 0.75em 0.5em 0.25em 0px; content: "{"; }
mjx-c.mjx-c32::before { padding: 0.666em 0.5em 0px 0px; content: "2"; }
mjx-c.mjx-cA0::before { padding: 0px 0.25em 0px 0px; content: " "; }
mjx-c.mjx-c22C5::before { padding: 0.31em 0.278em 0px 0px; content: "⋅"; }
mjx-c.mjx-c1D465.TEX-I::before { padding: 0.442em 0.572em 0.011em 0px; content: "x"; }
mjx-c.mjx-c7C::before { padding: 0.75em 0.278em 0.249em 0px; content: "|"; }
mjx-c.mjx-c2208::before { padding: 0.54em 0.667em 0.04em 0px; content: "∈"; }
mjx-c.mjx-c2115.TEX-A::before { padding: 0.683em 0.722em 0.02em 0px; content: "N"; }
mjx-c.mjx-c2C::before { padding: 0.121em 0.278em 0.194em 0px; content: ","; }
mjx-c.mjx-c2A7D.TEX-A::before { padding: 0.636em 0.778em 0.138em 0px; content: "⩽"; }
mjx-c.mjx-c31::before { padding: 0.666em 0.5em 0px 0px; content: "1"; }
mjx-c.mjx-c30::before { padding: 0.666em 0.5em 0.022em 0px; content: "0"; }
mjx-c.mjx-c7D::before { padding: 0.75em 0.5em 0.25em 0px; content: "}"; }
</style><div class="markdown-preview-sizer markdown-preview-section" style="padding-bottom: ; padding-top: var(--file-margins); padding-right: var(--file-margins); padding-left: var(--file-margins); width: 100%; position: absolute;"><div class="markdown-preview-pusher" style="width: 1px; height: 0.1px; margin-bottom: 0px;"></div><div class="mod-header"></div><div><h1 data-heading="Introduction" id="Introduction">Introduction</h1></div><div><h2 data-heading="About this tutorial" id="About_this_tutorial" style="display: flex;"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>About this tutorial</h2></div><div><p>Welcome to <strong>Learn You a Haskell for Great Good</strong>! If you're reading this, chances are you want to learn Haskell. Well, you've come to the right place, but let's talk about this tutorial a bit first.</p></div><div><p>I decided to write this because I wanted to solidify my own knowledge of Haskell and because I thought I could help people new to Haskell learn it from my perspective. There are quite a few tutorials on Haskell floating around on the internet. When I was starting out in Haskell, I didn't learn from just one resource. The way I learned it was by reading several different tutorials and articles because each explained something in a different way than the other did. By going through several resources, I was able put together the pieces and it all just came falling into place. So this is an attempt at adding another useful resource for learning Haskell so you have a bigger chance of finding one you like.</p></div><div><p><span alt="LYHfGG_1_bird.png" src="LYHfGG_1_bird.png" class="internal-embed media-embed image-embed is-loaded"><img alt="LYHfGG_1_bird.png" src="курсы\learn-you-a-haskell-for-great-good!\картинки\lyhfgg_1_bird.png"></span></p></div><div><p>This tutorial is aimed at people who have experience in imperative programming languages (C, C++, Java, Python …) but haven't programmed in a functional language before (Haskell, ML, OCaml …). Although I bet that even if you don't have any significant programming experience, a smart person such as yourself will be able to follow along and learn Haskell.</p></div><div><p>The channel <a href="#haskell" class="tag" target="_blank" rel="noopener">#haskell</a> on the freenode network is a great place to ask questions if you're feeling stuck. People there are extremely nice, patient and understanding to newbies.</p></div><div><p>I failed to learn Haskell approximately 2 times before finally grasping it because it all just seemed too weird to me and I didn't get it. But then once it just "clicked" and after getting over that initial hurdle, it was pretty much smooth sailing. I guess what I'm trying to say is: Haskell is great and if you're interested in programming you should really learn it even if it seems weird at first. Learning Haskell is much like learning to program for the first time — it's fun! It forces you to think differently, which brings us to the next section …</p></div><div><h2 data-heading="So what's Haskell?" id="So_what's_Haskell?" style="display: flex;"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>So what's Haskell?</h2></div><div><p><span alt="LYHfGG_2_fx.png" src="LYHfGG_2_fx.png" class="internal-embed media-embed image-embed is-loaded"><img alt="LYHfGG_2_fx.png" src="курсы\learn-you-a-haskell-for-great-good!\картинки\lyhfgg_2_fx.png"></span></p></div><div><p>Haskell is a <strong>purely functional programming language</strong>. In imperative languages you get things done by giving the computer a sequence of tasks and then it executes them. While executing them, it can change state. For instance, you set variable <code>a</code> to 5 and then do some stuff and then set it to something else. You have control flow structures for doing some action several times. In purely functional programming you don't tell the computer what to do as such but rather you tell it what stuff <em>is</em>. The factorial of a number is the product of all the numbers from 1 to that number, the sum of a list of numbers is the first number plus the sum of all the other numbers, and so on. You express that in the form of functions. You also can't set a variable to something and then set it to something else later. If you say that <code>a</code> is 5, you can't say it's something else later because you just said it was 5. What are you, some kind of liar? So in purely functional languages, a function has no side-effects. The only thing a function can do is calculate something and return it as a result. At first, this seems kind of limiting but it actually has some very nice consequences: if a function is called twice with the same parameters, it's guaranteed to return the same result. That's called referential transparency and not only does it allow the compiler to reason about the program's behavior, but it also allows you to easily deduce (and even prove) that a function is correct and then build more complex functions by gluing simple functions together.</p></div><div><p><span alt="LYHfGG_3_lazy.png" src="LYHfGG_3_lazy.png" class="internal-embed media-embed image-embed is-loaded"><img alt="LYHfGG_3_lazy.png" src="курсы\learn-you-a-haskell-for-great-good!\картинки\lyhfgg_3_lazy.png"></span></p></div><div><p>Haskell is <strong>lazy</strong>. That means that unless specifically told otherwise, Haskell won't execute functions and calculate things until it's really forced to show you a result. That goes well with referential transparency and it allows you to think of programs as a series of <strong>transformations on data</strong>. It also allows cool things such as infinite data structures. Say you have an immutable list of numbers <code>xs = [1,2,3,4,5,6,7,8]</code> and a function <code>doubleMe</code> which multiplies every element by 2 and then returns a new list. If we wanted to multiply our list by 8 in an imperative language and did <code>doubleMe(doubleMe(doubleMe(xs)))</code>, it would probably pass through the list once and make a copy and then return it. Then it would pass through the list another two times and return the result. In a lazy language, calling <code>doubleMe</code> on a list without forcing it to show you the result ends up in the program sort of telling you "Yeah yeah, I'll do it later!". But once you want to see the result, the first <code>doubleMe</code> tells the second one it wants the result, now! The second one says that to the third one and the third one reluctantly gives back a doubled 1, which is a 2. The second one receives that and gives back 4 to the first one. The first one sees that and tells you the first element is 8. So it only does one pass through the list and only when you really need it. That way when you want something from a lazy language you can just take some initial data and efficiently transform and mend it so it resembles what you want at the end.</p></div><div><p><span alt="LYHfGG_4_boat.png" src="LYHfGG_4_boat.png" class="internal-embed media-embed image-embed is-loaded"><img alt="LYHfGG_4_boat.png" src="курсы\learn-you-a-haskell-for-great-good!\картинки\lyhfgg_4_boat.png"></span></p></div><div><p>Haskell is <strong>statically typed</strong>. When you compile your program, the compiler knows which piece of code is a number, which is a string and so on. That means that a lot of possible errors are caught at compile time. If you try to add together a number and a string, the compiler will whine at you. Haskell uses a very good type system that has <strong>type inference</strong>. That means that you don't have to explicitly label every piece of code with a type because the type system can intelligently figure out a lot about it. If you say <code>a = 5 + 4</code>, you don't have to tell Haskell that <code>a</code> is a number, it can figure that out by itself. Type inference also allows your code to be more general. If a function you make takes two parameters and adds them together and you don't explicitly state their type, the function will work on any two parameters that act like numbers.</p></div><div><p>Haskell is <strong>elegant and concise</strong>. Because it uses a lot of high level concepts, Haskell programs are usually shorter than their imperative equivalents. And shorter programs are easier to maintain than longer ones and have less bugs.</p></div><div><p>Haskell was made by some <strong>really smart guys</strong> (with PhDs). Work on Haskell began in 1987 when a committee of researchers got together to design a kick-ass language. In 2003 the Haskell Report was published, which defines a stable version of the language.</p></div><div><h2 data-heading="What you need to dive in" id="What_you_need_to_dive_in" style="display: flex;"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>What you need to dive in</h2></div><div><p>A text editor and a Haskell compiler. You probably already have your favorite text editor installed so we won't waste time on that. For the purposes of this tutorial we'll be using GHC, the most widely used Haskell compiler. The best way to get started is to download the <a data-tooltip-position="top" aria-label="http://hackage.haskell.org/platform/" rel="noopener" class="external-link" href="http://hackage.haskell.org/platform/" target="_blank">Haskell Platform</a>, which is basically Haskell with batteries included.</p></div><div><p>GHC can take a Haskell script (they usually have a .hs extension) and compile it but it also has an interactive mode which allows you to interactively interact with scripts. Interactively. You can call functions from scripts that you load and the results are displayed immediately. For learning it's a lot easier and faster than compiling every time you make a change and then running the program from the prompt. The interactive mode is invoked by typing in <code>ghci</code> at your prompt. If you have defined some functions in a file called, say, <code>myfunctions.hs</code>, you load up those functions by typing in <code>:l myfunctions</code> and then you can play with them, provided <code>myfunctions.hs</code> is in the same folder from which <code>ghci</code> was invoked. If you change the .hs script, just run <code>:l myfunctions</code> again or do <code>:r</code>, which is equivalent because it reloads the current script. The usual workflow for me when playing around in stuff is defining some functions in a .hs file, loading it up and messing around with them and then changing the .hs file, loading it up again and so on. This is also what we'll be doing here.</p></div><div><h1 data-heading="Starting Out" id="Starting_Out">Starting Out</h1></div><div><h2 data-heading="Ready, set, go!" id="Ready,_set,_go!" style="display: flex;"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>Ready, set, go!</h2></div><div><p><span alt="LYHfGG_5_startingout.png" src="LYHfGG_5_startingout.png" class="internal-embed media-embed image-embed is-loaded"><img alt="LYHfGG_5_startingout.png" src="курсы\learn-you-a-haskell-for-great-good!\картинки\lyhfgg_5_startingout.png"></span></p></div><div><p>Alright, let's get started! If you're the sort of horrible person who doesn't read introductions to things and you skipped it, you might want to read the last section in the introduction anyway because it explains what you need to follow this tutorial and how we're going to load functions. The first thing we're going to do is run ghc's interactive mode and call some function to get a very basic feel for haskell. Open your terminal and type in <code>ghci</code>. You will be greeted with something like this.</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token constant">GHCi</span><span class="token punctuation">,</span> <span class="token hvariable">version</span> <span class="token number">6.8</span><span class="token punctuation">.</span><span class="token number">2</span><span class="token operator">:</span> <span class="token hvariable">http</span><span class="token operator">://</span><span class="token hvariable">www</span><span class="token punctuation">.</span><span class="token hvariable">haskell</span><span class="token punctuation">.</span><span class="token hvariable">org</span><span class="token operator">/</span><span class="token hvariable">ghc</span><span class="token operator">/</span>  <span class="token operator">:?</span> <span class="token hvariable">for</span> <span class="token hvariable">help</span>
<span class="token constant">Loading</span> <span class="token hvariable">package</span> <span class="token hvariable">base</span> <span class="token operator">...</span> <span class="token hvariable">linking</span> <span class="token operator">...</span> <span class="token hvariable">done</span><span class="token punctuation">.</span>
<span class="token constant">Prelude</span><span class="token operator">&gt;</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Congratulations, you're in GHCI! The prompt here is <code>Prelude&gt;</code> but because it can get longer when you load stuff into the session, we're going to use <code>ghci&gt;</code>. If you want to have the same prompt, just type in <code>:set prompt "ghci&gt; "</code>.</p></div><div><p>Here's some simple arithmetic.</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token number">2</span> <span class="token operator">+</span> <span class="token number">15</span>
<span class="token number">17</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token number">49</span> <span class="token operator">*</span> <span class="token number">100</span>
<span class="token number">4900</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token number">1892</span> <span class="token operator">-</span> <span class="token number">1472</span>
<span class="token number">420</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token number">5</span> <span class="token operator">/</span> <span class="token number">2</span>
<span class="token number">2.5</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>This is pretty self-explanatory. We can also use several operators on one line and all the usual precedence rules are obeyed. We can use parentheses to make the precedence explicit or to change it.</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token punctuation">(</span><span class="token number">50</span> <span class="token operator">*</span> <span class="token number">100</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token number">4999</span>
<span class="token number">1</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token number">50</span> <span class="token operator">*</span> <span class="token number">100</span> <span class="token operator">-</span> <span class="token number">4999</span>
<span class="token number">1</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token number">50</span> <span class="token operator">*</span> <span class="token punctuation">(</span><span class="token number">100</span> <span class="token operator">-</span> <span class="token number">4999</span><span class="token punctuation">)</span>
<span class="token operator">-</span><span class="token number">244950</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Pretty cool, huh? Yeah, I know it's not but bear with me. A little pitfall to watch out for here is negating numbers. If we want to have a negative number, it's always best to surround it with parentheses. Doing <code>5 * -3</code> will make GHCI yell at you but doing <code>5 * (-3)</code> will work just fine.</p></div><div><p>Boolean algebra is also pretty straightforward. As you probably know, <code>&amp;&amp;</code> means a boolean <em>and</em>, <code>||</code> means a boolean <em>or</em>. <code>not</code> negates a <code>True</code> or a <code>False</code>.</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token constant">True</span> <span class="token operator">&amp;&amp;</span> <span class="token constant">False</span>
<span class="token constant">False</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token constant">True</span> <span class="token operator">&amp;&amp;</span> <span class="token constant">True</span>
<span class="token constant">True</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token constant">False</span> <span class="token operator">||</span> <span class="token constant">True</span>
<span class="token constant">True</span> 
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token builtin">not</span> <span class="token constant">False</span>
<span class="token constant">True</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token builtin">not</span> <span class="token punctuation">(</span><span class="token constant">True</span> <span class="token operator">&amp;&amp;</span> <span class="token constant">True</span><span class="token punctuation">)</span>
<span class="token constant">False</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Testing for equality is done like so.</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token number">5</span> <span class="token operator">==</span> <span class="token number">5</span>
<span class="token constant">True</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token number">1</span> <span class="token operator">==</span> <span class="token number">0</span>
<span class="token constant">False</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token number">5</span> <span class="token operator">/=</span> <span class="token number">5</span>
<span class="token constant">False</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token number">5</span> <span class="token operator">/=</span> <span class="token number">4</span>
<span class="token constant">True</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token string">"hello"</span> <span class="token operator">==</span> <span class="token string">"hello"</span>
<span class="token constant">True</span> 
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>What about doing <code>5 + "llama"</code> or <code>5 == True</code>? Well, if we try the first snippet, we get a big scary error message!</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token constant">No</span> <span class="token keyword">instance</span> <span class="token hvariable">for</span> <span class="token punctuation">(</span><span class="token constant">Num</span> <span class="token punctuation">[</span><span class="token constant">Char</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
<span class="token hvariable">arising</span> <span class="token hvariable">from</span> <span class="token hvariable">a</span> <span class="token hvariable">use</span> <span class="token keyword">of</span> `<span class="token operator">+</span>' <span class="token hvariable">at</span> <span class="token operator">&lt;</span><span class="token hvariable">interactive</span><span class="token operator">&gt;:</span><span class="token number">1</span><span class="token operator">:</span><span class="token number">0</span><span class="token operator">-</span><span class="token number">9</span>
<span class="token constant">Possible</span> <span class="token hvariable">fix</span><span class="token operator">:</span> <span class="token hvariable">add</span> <span class="token hvariable">an</span> <span class="token keyword">instance</span> <span class="token hvariable">declaration</span> <span class="token hvariable">for</span> <span class="token punctuation">(</span><span class="token constant">Num</span> <span class="token punctuation">[</span><span class="token constant">Char</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
<span class="token constant">In</span> <span class="token hvariable">the</span> <span class="token hvariable">expression</span><span class="token operator">:</span> <span class="token number">5</span> <span class="token operator">+</span> <span class="token string">"llama"</span>
<span class="token constant">In</span> <span class="token hvariable">the</span> <span class="token hvariable">definition</span> <span class="token keyword">of</span> `<span class="token hvariable">it'</span><span class="token operator">:</span> <span class="token hvariable">it</span> <span class="token operator">=</span> <span class="token number">5</span> <span class="token operator">+</span> <span class="token string">"llama"</span> 
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Yikes! What GHCI is telling us here is that <code>"llama"</code> is not a number and so it doesn't know how to add it to 5. Even if it wasn't <code>"llama"</code> but <code>"four"</code> or <code>"4"</code>, Haskell still wouldn't consider it to be a number. <code>+</code> expects its left and right side to be numbers. If we tried to do <code>True == 5</code>, GHCI would tell us that the types don't match. Whereas <code>+</code> works only on things that are considered numbers, <code>==</code> works on any two things that can be compared. But the catch is that they both have to be the same type of thing. You can't compare apples and oranges. We'll take a closer look at types a bit later. Note: you can do <code>5 + 4.0</code> because <code>5</code> is sneaky and can act like an integer or a floating-point number. <code>4.0</code> can't act like an integer, so <code>5</code> is the one that has to adapt.</p></div><div><p>You may not have known it but we've been using functions now all along. For instance, <code>*</code> is a function that takes two numbers and multiplies them. As you've seen, we call it by sandwiching it between them. This is what we call an <em>infix</em> function. Most functions that aren't used with numbers are <em>prefix</em> functions. Let's take a look at them.</p></div><div><p><span alt="LYHfGG_6_ringring.png" src="LYHfGG_6_ringring.png" class="internal-embed media-embed image-embed is-loaded"><img alt="LYHfGG_6_ringring.png" src="курсы\learn-you-a-haskell-for-great-good!\картинки\lyhfgg_6_ringring.png"></span></p></div><div><p>Functions are usually prefix so from now on we won't explicitly state that a function is of the prefix form, we'll just assume it. In most imperative languages functions are called by writing the function name and then writing its parameters in parentheses, usually separated by commas. In Haskell, functions are called by writing the function name, a space and then the parameters, separated by spaces. For a start, we'll try calling one of the most boring functions in Haskell.</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token builtin">succ</span> <span class="token number">8</span>
<span class="token number">9</span> 
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>The <code>succ</code> function takes anything that has a defined successor and returns that successor. As you can see, we just separate the function name from the parameter with a space. Calling a function with several parameters is also simple. The functions <code>min</code> and <code>max</code> take two things that can be put in an order (like numbers!). <code>min</code> returns the one that's lesser and <code>max</code> returns the one that's greater. See for yourself:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token builtin">min</span> <span class="token number">9</span> <span class="token number">10</span>
<span class="token number">9</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token builtin">min</span> <span class="token number">3.4</span> <span class="token number">3.2</span>
<span class="token number">3.2</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token builtin">max</span> <span class="token number">100</span> <span class="token number">101</span>
<span class="token number">101</span> 
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Function application (calling a function by putting a space after it and then typing out the parameters) has the highest precedence of them all. What that means for us is that these two statements are equivalent.</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token builtin">succ</span> <span class="token number">9</span> <span class="token operator">+</span> <span class="token builtin">max</span> <span class="token number">5</span> <span class="token number">4</span> <span class="token operator">+</span> <span class="token number">1</span>
<span class="token number">16</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token punctuation">(</span><span class="token builtin">succ</span> <span class="token number">9</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token punctuation">(</span><span class="token builtin">max</span> <span class="token number">5</span> <span class="token number">4</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span>
<span class="token number">16</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>However, if we wanted to get the successor of the product of numbers 9 and 10, we couldn't write <code>succ 9 * 10</code> because that would get the successor of 9, which would then be multiplied by 10. So 100. We'd have to write <code>succ (9 * 10)</code> to get 91.</p></div><div><p>If a function takes two parameters, we can also call it as an infix function by surrounding it with backticks. For instance, the <code>div</code> function takes two integers and does integral division between them. Doing <code>div 92 10</code> results in a 9. But when we call it like that, there may be some confusion as to which number is doing the division and which one is being divided. So we can call it as an infix function by doing <code>92 `div` 10</code> and suddenly it's much clearer.</p></div><div><p>Lots of people who come from imperative languages tend to stick to the notion that parentheses should denote function application. For example, in C, you use parentheses to call functions like <code>foo()</code>, <code>bar(1)</code> or <code>baz(3, "haha")</code>. Like we said, spaces are used for function application in Haskell. So those functions in Haskell would be <code>foo</code>, <code>bar 1</code> and <code>baz 3 "haha"</code>. So if you see something like <code>bar (bar 3)</code>, it doesn't mean that <code>bar</code> is called with <code>bar</code> and <code>3</code> as parameters. It means that we first call the function <code>bar</code> with <code>3</code> as the parameter to get some number and then we call <code>bar</code> again with that number. In C, that would be something like <code>bar(bar(3))</code>.</p></div><div><h2 data-heading="Baby's first functions" id="Baby's_first_functions" style="display: flex;"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>Baby's first functions</h2></div><div><p>In the previous section we got a basic feel for calling functions. Now let's try making our own! Open up your favorite text editor and punch in this function that takes a number and multiplies it by two.</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">doubleMe</span> <span class="token hvariable">x</span> <span class="token operator">=</span> <span class="token hvariable">x</span> <span class="token operator">+</span> <span class="token hvariable">x</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Functions are defined in a similar way that they are called. The function name is followed by parameters seperated by spaces. But when defining functions, there's a <code>=</code> and after that we define what the function does. Save this as <code>baby.hs</code> or something. Now navigate to where it's saved and run <code>ghci</code> from there. Once inside GHCI, do <code>:l baby</code>. Now that our script is loaded, we can play with the function that we defined.</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token operator">:</span><span class="token hvariable">l</span> <span class="token hvariable">baby</span>
<span class="token punctuation">[</span><span class="token number">1</span> <span class="token keyword">of</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token constant">Compiling</span> <span class="token constant">Main</span>             <span class="token punctuation">(</span> <span class="token hvariable">baby</span><span class="token punctuation">.</span><span class="token hvariable">hs</span><span class="token punctuation">,</span> <span class="token hvariable">interpreted</span> <span class="token punctuation">)</span>
<span class="token constant">Ok</span><span class="token punctuation">,</span> <span class="token hvariable">modules</span> <span class="token hvariable">loaded</span><span class="token operator">:</span> <span class="token constant">Main</span><span class="token punctuation">.</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token hvariable">doubleMe</span> <span class="token number">9</span>
<span class="token number">18</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token hvariable">doubleMe</span> <span class="token number">8.3</span>
<span class="token number">16.6</span> 
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Because <code>+</code> works on integers as well as on floating-point numbers (anything that can be considered a number, really), our function also works on any number. Let's make a function that takes two numbers and multiplies each by two and then adds them together.</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">doubleUs</span> <span class="token hvariable">x</span> <span class="token hvariable">y</span> <span class="token operator">=</span> <span class="token hvariable">x</span><span class="token operator">*</span><span class="token number">2</span> <span class="token operator">+</span> <span class="token hvariable">y</span><span class="token operator">*</span><span class="token number">2</span> 
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Simple. We could have also defined it as <code>doubleUs x y = x + x + y + y</code>. Testing it out produces pretty predictable results (remember to append this function to the <code>baby.hs</code> file, save it and then do <code>:l baby</code> inside GHCI).</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token hvariable">doubleUs</span> <span class="token number">4</span> <span class="token number">9</span>
<span class="token number">26</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token hvariable">doubleUs</span> <span class="token number">2.3</span> <span class="token number">34.2</span>
<span class="token number">73.0</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token hvariable">doubleUs</span> <span class="token number">28</span> <span class="token number">88</span> <span class="token operator">+</span> <span class="token hvariable">doubleMe</span> <span class="token number">123</span>
<span class="token number">478</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>As expected, you can call your own functions from other functions that you made. With that in mind, we could redefine <code>doubleUs</code> like this:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">doubleUs</span> <span class="token hvariable">x</span> <span class="token hvariable">y</span> <span class="token operator">=</span> <span class="token hvariable">doubleMe</span> <span class="token hvariable">x</span> <span class="token operator">+</span> <span class="token hvariable">doubleMe</span> <span class="token hvariable">y</span> 
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>This is a very simple example of a common pattern you will see throughout Haskell. Making basic functions that are obviously correct and then combining them into more complex functions. This way you also avoid repetition. What if some mathematicians figured out that 2 is actually 3 and you had to change your program? You could just redefine <code>doubleMe</code> to be <code>x + x + x</code> and since <code>doubleUs</code> calls <code>doubleMe</code>, it would automatically work in this strange new world where 2 is 3.</p></div><div><p>Functions in Haskell don't have to be in any particular order, so it doesn't matter if you define <code>doubleMe</code> first and then <code>doubleUs</code> or if you do it the other way around.</p></div><div><p>Now we're going to make a function that multiplies a number by 2 but only if that number is smaller than or equal to 100 because numbers bigger than 100 are big enough as it is!</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">doubleSmallNumber</span> <span class="token hvariable">x</span> <span class="token operator">=</span> <span class="token keyword">if</span> <span class="token hvariable">x</span> <span class="token operator">&gt;</span> <span class="token number">100</span>
                        <span class="token keyword">then</span> <span class="token hvariable">x</span>
                        <span class="token keyword">else</span> <span class="token hvariable">x</span><span class="token operator">*</span><span class="token number">2</span> 
</code><button class="copy-code-button">Копировать</button></pre></div><div><p><span alt="LYHfGG_7_baby.png" src="LYHfGG_7_baby.png" class="internal-embed media-embed image-embed is-loaded"><img alt="LYHfGG_7_baby.png" src="курсы\learn-you-a-haskell-for-great-good!\картинки\lyhfgg_7_baby.png"></span></p></div><div><p>Right here we introduced Haskell's if statement. You're probably familiar with if statements from other languages. The difference between Haskell's if statement and if statements in imperative languages is that the else part is mandatory in Haskell. In imperative languages you can just skip a couple of steps if the condition isn't satisfied but in Haskell every expression and function must return something. We could have also written that if statement in one line but I find this way more readable. Another thing about the if statement in Haskell is that it is an <em>expression</em>. An expression is basically a piece of code that returns a value. <code>5</code> is an expression because it returns 5, <code>4 + 8</code> is an expression, <code>x + y</code> is an expression because it returns the sum of <code>x</code> and <code>y</code>. Because the else is mandatory, an if statement will always return something and that's why it's an expression. If we wanted to add one to every number that's produced in our previous function, we could have written its body like this.</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">doubleSmallNumber'</span> <span class="token hvariable">x</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">if</span> <span class="token hvariable">x</span> <span class="token operator">&gt;</span> <span class="token number">100</span> <span class="token keyword">then</span> <span class="token hvariable">x</span> <span class="token keyword">else</span> <span class="token hvariable">x</span><span class="token operator">*</span><span class="token number">2</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Had we omitted the parentheses, it would have added one only if <code>x</code> wasn't greater than 100. Note the <code>'</code> at the end of the function name. That apostrophe doesn't have any special meaning in Haskell's syntax. It's a valid character to use in a function name. We usually use <code>'</code> to either denote a strict version of a function (one that isn't lazy) or a slightly modified version of a function or a variable. Because <code>'</code> is a valid character in functions, we can make a function like this.</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">conanO'Brien</span> <span class="token operator">=</span> <span class="token string">"It's a-me, Conan O'Brien!"</span> 
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>There are two noteworthy things here. The first is that in the function name we didn't capitalize Conan's name. That's because functions can't begin with uppercase letters. We'll see why a bit later. The second thing is that this function doesn't take any parameters. When a function doesn't take any parameters, we usually say it's a <em>definition</em> (or a <em>name</em>). Because we can't change what names (and functions) mean once we've defined them, <code>conanO'Brien</code> and the string <code>"It's a-me, Conan O'Brien!"</code> can be used interchangeably.</p></div><div><h2 data-heading="An intro to lists" id="An_intro_to_lists" style="display: flex;"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>An intro to lists</h2></div><div><p><span alt="LYHfGG_8_list.png" src="LYHfGG_8_list.png" class="internal-embed media-embed image-embed is-loaded"><img alt="LYHfGG_8_list.png" src="курсы\learn-you-a-haskell-for-great-good!\картинки\lyhfgg_8_list.png"></span></p></div><div><p>Much like shopping lists in the real world, lists in Haskell are very useful. It's the most used data structure and it can be used in a multitude of different ways to model and solve a whole bunch of problems. Lists are SO awesome. In this section we'll look at the basics of lists, strings (which are lists) and list comprehensions.</p></div><div><p>In Haskell, lists are a <strong>homogenous</strong> data structure. It stores several elements of the same type. That means that we can have a list of integers or a list of characters but we can't have a list that has a few integers and then a few characters. And now, a list!</p></div><div><blockquote>
<p><strong>Note</strong>: We can use the <code>let</code> keyword to define a name right in GHCI. Doing <code>let a = 1</code> inside GHCI is the equivalent of writing <code>a = 1</code> in a script and then loading it.</p>
</blockquote></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token keyword">let</span> <span class="token hvariable">lostNumbers</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">8</span><span class="token punctuation">,</span><span class="token number">15</span><span class="token punctuation">,</span><span class="token number">16</span><span class="token punctuation">,</span><span class="token number">23</span><span class="token punctuation">,</span><span class="token number">42</span><span class="token punctuation">]</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token hvariable">lostNumbers</span>
<span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">8</span><span class="token punctuation">,</span><span class="token number">15</span><span class="token punctuation">,</span><span class="token number">16</span><span class="token punctuation">,</span><span class="token number">23</span><span class="token punctuation">,</span><span class="token number">42</span><span class="token punctuation">]</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>As you can see, lists are denoted by square brackets and the values in the lists are separated by commas. If we tried a list like <code>[1,2,'a',3,'b','c',4]</code>, Haskell would complain that characters (which are, by the way, denoted as a character between single quotes) are not numbers. Speaking of characters, strings are just lists of characters. <code>"hello"</code> is just syntactic sugar for <code>['h','e','l','l','o']</code>. Because strings are lists, we can use list functions on them, which is really handy.</p></div><div><p>A common task is putting two lists together. This is done by using the <code>++</code> operator.</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">]</span> <span class="token operator">++</span> <span class="token punctuation">[</span><span class="token number">9</span><span class="token punctuation">,</span><span class="token number">10</span><span class="token punctuation">,</span><span class="token number">11</span><span class="token punctuation">,</span><span class="token number">12</span><span class="token punctuation">]</span>
<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">9</span><span class="token punctuation">,</span><span class="token number">10</span><span class="token punctuation">,</span><span class="token number">11</span><span class="token punctuation">,</span><span class="token number">12</span><span class="token punctuation">]</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token string">"hello"</span> <span class="token operator">++</span> <span class="token string">" "</span> <span class="token operator">++</span> <span class="token string">"world"</span>
<span class="token string">"hello world"</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token punctuation">[</span><span class="token char string">'w'</span><span class="token punctuation">,</span><span class="token char string">'o'</span><span class="token punctuation">]</span> <span class="token operator">++</span> <span class="token punctuation">[</span><span class="token char string">'o'</span><span class="token punctuation">,</span><span class="token char string">'t'</span><span class="token punctuation">]</span>
<span class="token string">"woot"</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Watch out when repeatedly using the <code>++</code> operator on long strings. When you put together two lists (even if you append a singleton list to a list, for instance: <code>[1,2,3] ++ [4]</code>), internally, Haskell has to walk through the whole list on the left side of <code>++</code>. That's not a problem when dealing with lists that aren't too big. But putting something at the end of a list that's fifty million entries long is going to take a while. However, putting something at the beginning of a list using the <code>:</code> operator (also called the cons operator) is instantaneous.</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token char string">'A'</span><span class="token operator">:</span><span class="token string">" SMALL CAT"</span>
<span class="token string">"A SMALL CAT"</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token number">5</span><span class="token operator">:</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">]</span>
<span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">]</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Notice how <code>:</code> takes a number and a list of numbers or a character and a list of characters, whereas <code>++</code> takes two lists. Even if you're adding an element to the end of a list with <code>++</code>, you have to surround it with square brackets so it becomes a list.</p></div><div><p><code>[1,2,3]</code> is actually just syntactic sugar for <code>1:2:3:[]</code>. <code>[]</code> is an empty list. If we prepend <code>3</code> to it, it becomes <code>[3]</code>. If we prepend <code>2</code> to that, it becomes <code>[2,3]</code>, and so on.</p></div><div><blockquote>
<p><strong>Note:</strong> <code>[]</code>, <code>[[]]</code> and <code>[[],[],[]]</code> are all different things. The first one is an empty list, the seconds one is a list that contains one empty list, the third one is a list that contains three empty lists.</p>
</blockquote></div><div><p>If you want to get an element out of a list by index, use <code>!!</code>. The indices start at 0.</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token string">"Steve Buscemi"</span> <span class="token operator">!!</span> <span class="token number">6</span>
<span class="token char string">'B'</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token punctuation">[</span><span class="token number">9.4</span><span class="token punctuation">,</span><span class="token number">33.2</span><span class="token punctuation">,</span><span class="token number">96.2</span><span class="token punctuation">,</span><span class="token number">11.2</span><span class="token punctuation">,</span><span class="token number">23.25</span><span class="token punctuation">]</span> <span class="token operator">!!</span> <span class="token number">1</span>
<span class="token number">33.2</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>But if you try to get the sixth element from a list that only has four elements, you'll get an error so be careful!</p></div><div><p>Lists can also contain lists. They can also contain lists that contain lists that contain lists …</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token keyword">let</span> <span class="token hvariable">b</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">]</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token hvariable">b</span>
<span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">]</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token hvariable">b</span> <span class="token operator">++</span> <span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">]</span>
<span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">]</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token punctuation">[</span><span class="token number">6</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">]</span><span class="token operator">:</span><span class="token hvariable">b</span>
<span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token number">6</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">]</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token hvariable">b</span> <span class="token operator">!!</span> <span class="token number">2</span>
<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">]</span> 
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>The lists within a list can be of different lengths but they can't be of different types. Just like you can't have a list that has some characters and some numbers, you can't have a list that has some lists of characters and some lists of numbers.</p></div><div><p>Lists can be compared if the stuff they contain can be compared. When using <code>&lt;</code>, <code>&lt;=</code>, <code>&gt;</code> and <code>&gt;=</code> to compare lists, they are compared in lexicographical order. First the heads are compared. If they are equal then the second elements are compared, etc.</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">&gt;</span> <span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">]</span>
<span class="token constant">True</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">&gt;</span> <span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">10</span><span class="token punctuation">,</span><span class="token number">100</span><span class="token punctuation">]</span>
<span class="token constant">True</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">&gt;</span> <span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">]</span>
<span class="token constant">True</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">&gt;</span> <span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">]</span>
<span class="token constant">True</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">==</span> <span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">]</span>
<span class="token constant">True</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>What else can you do with lists? Here are some basic functions that operate on lists.</p></div><div><p><code>head</code> takes a list and returns its head. The head of a list is basically its first element.</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token builtin">head</span> <span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">]</span>
<span class="token number">5</span> 
</code><button class="copy-code-button">Копировать</button></pre></div><div><p><code>tail</code> takes a list and returns its tail. In other words, it chops off a list's head.</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token builtin">tail</span> <span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">]</span>
<span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">]</span> 
</code><button class="copy-code-button">Копировать</button></pre></div><div><p><code>last</code> takes a list and returns its last element.</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token builtin">last</span> <span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">]</span>
<span class="token number">1</span> 
</code><button class="copy-code-button">Копировать</button></pre></div><div><p><code>init</code> takes a list and returns everything except its last element.</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token builtin">init</span> <span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">]</span>
<span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">]</span> 
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>If we think of a list as a monster, here's what's what.</p></div><div><p><span alt="LYHfGG_9_listmonster.png" src="LYHfGG_9_listmonster.png" class="internal-embed media-embed image-embed is-loaded"><img alt="LYHfGG_9_listmonster.png" src="курсы\learn-you-a-haskell-for-great-good!\картинки\lyhfgg_9_listmonster.png"></span></p></div><div><p>But what happens if we try to get the head of an empty list?</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token builtin">head</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
<span class="token operator">***</span> <span class="token constant">Exception</span><span class="token operator">:</span> <span class="token constant">Prelude</span><span class="token punctuation">.</span><span class="token builtin">head</span><span class="token operator">:</span> <span class="token hvariable">empty</span> <span class="token hvariable">list</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Oh my! It all blows up in our face! If there's no monster, it doesn't have a head. When using <code>head</code>, <code>tail</code>, <code>last</code> and <code>init</code>, be careful not to use them on empty lists. This error cannot be caught at compile time so it's always good practice to take precautions against accidentally telling Haskell to give you some elements from an empty list.</p></div><div><p><code>length</code> takes a list and returns its length, obviously.</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token builtin">length</span> <span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">]</span>
<span class="token number">5</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p><code>null</code> checks if a list is empty. If it is, it returns <code>True</code>, otherwise it returns <code>False</code>. Use this function instead of <code>xs == []</code> (if you have a list called <code>xs</code>)</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token builtin">null</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">]</span>
<span class="token constant">False</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token builtin">null</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
<span class="token constant">True</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p><code>reverse</code> reverses a list.</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token builtin">reverse</span> <span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">]</span>
<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">]</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p><code>take</code> takes number and a list. It extracts that many elements from the beginning of the list. Watch.</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token builtin">take</span> <span class="token number">3</span> <span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">]</span>
<span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">]</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token builtin">take</span> <span class="token number">1</span> <span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">9</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">]</span>
<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token builtin">take</span> <span class="token number">5</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">]</span>
<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">]</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token builtin">take</span> <span class="token number">0</span> <span class="token punctuation">[</span><span class="token number">6</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">]</span>
<span class="token punctuation">[</span><span class="token punctuation">]</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>See how if we try to take more elements than there are in the list, it just returns the list. If we try to take 0 elements, we get an empty list.</p></div><div><p><code>drop</code> works in a similar way, only it drops the number of elements from the beginning of a list.</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token builtin">drop</span> <span class="token number">3</span> <span class="token punctuation">[</span><span class="token number">8</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">]</span>
<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">]</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token builtin">drop</span> <span class="token number">0</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">]</span>
<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">]</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token builtin">drop</span> <span class="token number">100</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">]</span>
<span class="token punctuation">[</span><span class="token punctuation">]</span> 
</code><button class="copy-code-button">Копировать</button></pre></div><div><p><code>maximum</code> takes a list of stuff that can be put in some kind of order and returns the biggest element.</p></div><div><p><code>minimum</code> returns the smallest.</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token builtin">minimum</span> <span class="token punctuation">[</span><span class="token number">8</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">]</span>
<span class="token number">1</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token builtin">maximum</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">9</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">]</span>
<span class="token number">9</span> 
</code><button class="copy-code-button">Копировать</button></pre></div><div><p><code>sum</code> takes a list of numbers and returns their sum.</p></div><div><p><code>product</code> takes a list of numbers and returns their product.</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token builtin">sum</span> <span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">7</span><span class="token punctuation">]</span>
<span class="token number">31</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token builtin">product</span> <span class="token punctuation">[</span><span class="token number">6</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">]</span>
<span class="token number">24</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token builtin">product</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">,</span><span class="token number">7</span><span class="token punctuation">,</span><span class="token number">9</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">]</span>
<span class="token number">0</span> 
</code><button class="copy-code-button">Копировать</button></pre></div><div><p><code>elem</code> takes a thing and a list of things and tells us if that thing is an element of the list. It's usually called as an infix function because it's easier to read that way.</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token number">4</span> <span class="token operator">`elem`</span> <span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">]</span>
<span class="token constant">True</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token number">10</span> <span class="token operator">`elem`</span> <span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">]</span>
<span class="token constant">False</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Those were a few basic functions that operate on lists. We'll take a look at more list functions <a data-tooltip-position="top" aria-label="http://learnyouahaskell.com/modules#data-list" rel="noopener" class="external-link" href="http://learnyouahaskell.com/modules#data-list" target="_blank">later</a></p></div><div><h2 data-heading="Texas ranges" id="Texas_ranges" style="display: flex;"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>Texas ranges</h2></div><div><p><span alt="LYHfGG_10_cowboy.png" src="LYHfGG_10_cowboy.png" class="internal-embed media-embed image-embed is-loaded"><img alt="LYHfGG_10_cowboy.png" src="курсы\learn-you-a-haskell-for-great-good!\картинки\lyhfgg_10_cowboy.png"></span></p></div><div><p>What if we want a list of all numbers between 1 and 20? Sure, we could just type them all out but obviously that's not a solution for gentlemen who demand excellence from their programming languages. Instead, we'll use ranges. Ranges are a way of making lists that are arithmetic sequences of elements that can be enumerated. Numbers can be enumerated. One, two, three, four, etc. Characters can also be enumerated. The alphabet is an enumeration of characters from A to Z. Names can't be enumerated. What comes after "John"? I don't know.</p></div><div><p>To make a list containing all the natural numbers from 1 to 20, you just write <code>[1..20]</code>. That is the equivalent of writing <code>[1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20]</code> and there's no difference between writing one or the other except that writing out long enumeration sequences manually is stupid.</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token operator">..</span><span class="token number">20</span><span class="token punctuation">]</span>
<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">,</span><span class="token number">7</span><span class="token punctuation">,</span><span class="token number">8</span><span class="token punctuation">,</span><span class="token number">9</span><span class="token punctuation">,</span><span class="token number">10</span><span class="token punctuation">,</span><span class="token number">11</span><span class="token punctuation">,</span><span class="token number">12</span><span class="token punctuation">,</span><span class="token number">13</span><span class="token punctuation">,</span><span class="token number">14</span><span class="token punctuation">,</span><span class="token number">15</span><span class="token punctuation">,</span><span class="token number">16</span><span class="token punctuation">,</span><span class="token number">17</span><span class="token punctuation">,</span><span class="token number">18</span><span class="token punctuation">,</span><span class="token number">19</span><span class="token punctuation">,</span><span class="token number">20</span><span class="token punctuation">]</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token punctuation">[</span><span class="token char string">'a'</span><span class="token operator">..</span><span class="token char string">'z'</span><span class="token punctuation">]</span>
<span class="token string">"abcdefghijklmnopqrstuvwxyz"</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token punctuation">[</span><span class="token char string">'K'</span><span class="token operator">..</span><span class="token char string">'Z'</span><span class="token punctuation">]</span>
<span class="token string">"KLMNOPQRSTUVWXYZ"</span> 
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Ranges are cool because you can also specify a step. What if we want all even numbers between 1 and 20? Or every third number between 1 and 20?</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token operator">..</span><span class="token number">20</span><span class="token punctuation">]</span>
<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">,</span><span class="token number">8</span><span class="token punctuation">,</span><span class="token number">10</span><span class="token punctuation">,</span><span class="token number">12</span><span class="token punctuation">,</span><span class="token number">14</span><span class="token punctuation">,</span><span class="token number">16</span><span class="token punctuation">,</span><span class="token number">18</span><span class="token punctuation">,</span><span class="token number">20</span><span class="token punctuation">]</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token operator">..</span><span class="token number">20</span><span class="token punctuation">]</span>
<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">,</span><span class="token number">9</span><span class="token punctuation">,</span><span class="token number">12</span><span class="token punctuation">,</span><span class="token number">15</span><span class="token punctuation">,</span><span class="token number">18</span><span class="token punctuation">]</span> 
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>It's simply a matter of separating the first two elements with a comma and then specifying what the upper limit is. While pretty smart, ranges with steps aren't as smart as some people expect them to be. You can't do <code>[1,2,4,8,16..100]</code> and expect to get all the powers of 2. Firstly because you can only specify one step. And secondly because some sequences that aren't arithmetic are ambiguous if given only by a few of their first terms.</p></div><div><p>To make a list with all the numbers from 20 to 1, you can't just do <code>[20..1]</code>, you have to do <code>[20,19..1]</code>.</p></div><div><p>Watch out when using floating point numbers in ranges! Because they are not completely precise (by definition), their use in ranges can yield some pretty funky results.</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token punctuation">[</span><span class="token number">0.1</span><span class="token punctuation">,</span> <span class="token number">0.3</span> <span class="token operator">..</span> <span class="token number">1</span><span class="token punctuation">]</span>
<span class="token punctuation">[</span><span class="token number">0.1</span><span class="token punctuation">,</span><span class="token number">0.3</span><span class="token punctuation">,</span><span class="token number">0.5</span><span class="token punctuation">,</span><span class="token number">0.7</span><span class="token punctuation">,</span><span class="token number">0.8999999999999999</span><span class="token punctuation">,</span><span class="token number">1.0999999999999999</span><span class="token punctuation">]</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>My advice is not to use them in list ranges.</p></div><div><p>You can also use ranges to make infinite lists by just not specifying an upper limit. Later we'll go into more detail on infinite lists. For now, let's examine how you would get the first 24 multiples of 13. Sure, you could do <code>[13,26..24*13]</code>. But there's a better way: <code>take 24 [13,26..]</code>. Because Haskell is lazy, it won't try to evaluate the infinite list immediately because it would never finish. It'll wait to see what you want to get out of that infinite lists. And here it sees you just want the first 24 elements and it gladly obliges.</p></div><div><p>A handful of functions that produce infinite lists:</p></div><div><p><code>cycle</code> takes a list and cycles it into an infinite list. If you just try to display the result, it will go on forever so you have to slice it off somewhere.</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token builtin">take</span> <span class="token number">10</span> <span class="token punctuation">(</span><span class="token builtin">cycle</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">]</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token builtin">take</span> <span class="token number">12</span> <span class="token punctuation">(</span><span class="token builtin">cycle</span> <span class="token string">"LOL "</span><span class="token punctuation">)</span>
<span class="token string">"LOL LOL LOL "</span> 
</code><button class="copy-code-button">Копировать</button></pre></div><div><p><code>repeat</code> takes an element and produces an infinite list of just that element. It's like cycling a list with only one element.</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token builtin">take</span> <span class="token number">10</span> <span class="token punctuation">(</span><span class="token builtin">repeat</span> <span class="token number">5</span><span class="token punctuation">)</span>
<span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">]</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Although it's simpler to just use the <code>replicate</code> function if you want some number of the same element in a list. <code>replicate 3 10</code> returns <code>[10,10,10]</code>.</p></div><div><h2 data-heading="I'm a list comprehension" id="I'm_a_list_comprehension" style="display: flex;"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>I'm a list comprehension</h2></div><div><p><span alt="LYHfGG_11_kermit.png" src="LYHfGG_11_kermit.png" class="internal-embed media-embed image-embed is-loaded"><img alt="LYHfGG_11_kermit.png" src="курсы\learn-you-a-haskell-for-great-good!\картинки\lyhfgg_11_kermit.png"></span></p></div><div><p>If you've ever taken a course in mathematics, you've probably run into <em>set comprehensions</em>. They're normally used for building more specific sets out of general sets. A basic comprehension for a set that contains the first ten even natural numbers is <span class="math math-block is-loaded"><mjx-container class="MathJax" jax="CHTML" display="true"><mjx-math display="true" class="MJX-TEX" style="margin-left: 0px; margin-right: 0px;"><mjx-mi class="mjx-i"><mjx-c class="mjx-c1D446 TEX-I"></mjx-c></mjx-mi><mjx-mo class="mjx-n" space="4"><mjx-c class="mjx-c3D"></mjx-c></mjx-mo><mjx-mo class="mjx-n" space="4"><mjx-c class="mjx-c7B"></mjx-c></mjx-mo><mjx-mn class="mjx-n"><mjx-c class="mjx-c32"></mjx-c></mjx-mn><mjx-mtext class="mjx-n"><mjx-c class="mjx-cA0"></mjx-c></mjx-mtext><mjx-mo class="mjx-n" space="3"><mjx-c class="mjx-c22C5"></mjx-c></mjx-mo><mjx-mtext class="mjx-n" space="3"><mjx-c class="mjx-cA0"></mjx-c></mjx-mtext><mjx-mi class="mjx-i"><mjx-c class="mjx-c1D465 TEX-I"></mjx-c></mjx-mi><mjx-mtext class="mjx-n"><mjx-c class="mjx-cA0"></mjx-c></mjx-mtext><mjx-mo class="mjx-n"><mjx-c class="mjx-c7C"></mjx-c></mjx-mo><mjx-mtext class="mjx-n"><mjx-c class="mjx-cA0"></mjx-c></mjx-mtext><mjx-mi class="mjx-i"><mjx-c class="mjx-c1D465 TEX-I"></mjx-c></mjx-mi><mjx-mo class="mjx-n" space="4"><mjx-c class="mjx-c2208"></mjx-c></mjx-mo><mjx-texatom space="4" texclass="ORD"><mjx-mi class="mjx-ds mjx-b"><mjx-c class="mjx-c2115 TEX-A"></mjx-c></mjx-mi></mjx-texatom><mjx-mo class="mjx-n"><mjx-c class="mjx-c2C"></mjx-c></mjx-mo><mjx-mtext class="mjx-n" space="2"><mjx-c class="mjx-cA0"></mjx-c></mjx-mtext><mjx-mi class="mjx-i"><mjx-c class="mjx-c1D465 TEX-I"></mjx-c></mjx-mi><mjx-mo class="mjx-n" space="4"><mjx-c class="mjx-c2A7D TEX-A"></mjx-c></mjx-mo><mjx-mn class="mjx-n" space="4"><mjx-c class="mjx-c31"></mjx-c><mjx-c class="mjx-c30"></mjx-c></mjx-mn><mjx-mo class="mjx-n"><mjx-c class="mjx-c7D"></mjx-c></mjx-mo></mjx-math></mjx-container></span>. The part before the pipe is called the output function, <code>x</code> is the variable, <code>N</code> is the input set and <code>x &lt;= 10</code> is the predicate. That means that the set contains the doubles of all natural numbers that satisfy the predicate.</p></div><div><p>If we wanted to write that in Haskell, we could do something like <code>take 10 [2,4..]</code>. But what if we didn't want doubles of the first 10 natural numbers but some kind of more complex function applied on them? We could use a list comprehension for that. List comprehensions are very similar to set comprehensions. We'll stick to getting the first 10 even numbers for now. The list comprehension we could use is <code>[x*2 | x &lt;- [1..10]]</code>. <code>x</code> is drawn from <code>[1..10]</code> and for every element in <code>[1..10]</code> (which we have bound to <code>x</code>), we get that element, only doubled. Here's that comprehension in action.</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token punctuation">[</span><span class="token hvariable">x</span><span class="token operator">*</span><span class="token number">2</span> <span class="token operator">|</span> <span class="token hvariable">x</span> <span class="token operator">&lt;-</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token operator">..</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">]</span>
<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">,</span><span class="token number">8</span><span class="token punctuation">,</span><span class="token number">10</span><span class="token punctuation">,</span><span class="token number">12</span><span class="token punctuation">,</span><span class="token number">14</span><span class="token punctuation">,</span><span class="token number">16</span><span class="token punctuation">,</span><span class="token number">18</span><span class="token punctuation">,</span><span class="token number">20</span><span class="token punctuation">]</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>As you can see, we get the desired results. Now let's add a condition (or a predicate) to that comprehension. Predicates go after the binding parts and are separated from them by a comma. Let's say we want only the elements which, doubled, are greater than or equal to 12.</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token punctuation">[</span><span class="token hvariable">x</span><span class="token operator">*</span><span class="token number">2</span> <span class="token operator">|</span> <span class="token hvariable">x</span> <span class="token operator">&lt;-</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token operator">..</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token hvariable">x</span><span class="token operator">*</span><span class="token number">2</span> <span class="token operator">&gt;=</span> <span class="token number">12</span><span class="token punctuation">]</span>
<span class="token punctuation">[</span><span class="token number">12</span><span class="token punctuation">,</span><span class="token number">14</span><span class="token punctuation">,</span><span class="token number">16</span><span class="token punctuation">,</span><span class="token number">18</span><span class="token punctuation">,</span><span class="token number">20</span><span class="token punctuation">]</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Cool, it works. How about if we wanted all numbers from 50 to 100 whose remainder when divided with the number 7 is 3? Easy.</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token punctuation">[</span> <span class="token hvariable">x</span> <span class="token operator">|</span> <span class="token hvariable">x</span> <span class="token operator">&lt;-</span> <span class="token punctuation">[</span><span class="token number">50</span><span class="token operator">..</span><span class="token number">100</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token hvariable">x</span> <span class="token operator">`mod`</span> <span class="token number">7</span> <span class="token operator">==</span> <span class="token number">3</span><span class="token punctuation">]</span>
<span class="token punctuation">[</span><span class="token number">52</span><span class="token punctuation">,</span><span class="token number">59</span><span class="token punctuation">,</span><span class="token number">66</span><span class="token punctuation">,</span><span class="token number">73</span><span class="token punctuation">,</span><span class="token number">80</span><span class="token punctuation">,</span><span class="token number">87</span><span class="token punctuation">,</span><span class="token number">94</span><span class="token punctuation">]</span> 
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Success! Note that weeding out lists by predicates is also called <strong>filtering</strong>. We took a list of numbers and we filtered them by the predicate. Now for another example. Let's say we want a comprehension that replaces each odd number greater than 10 with <code>"BANG!"</code> and each odd number that's less than 10 with <code>"BOOM!"</code>. If a number isn't odd, we throw it out of our list. For convenience, we'll put that comprehension inside a function so we can easily reuse it.</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">boomBangs</span> <span class="token hvariable">xs</span> <span class="token operator">=</span> <span class="token punctuation">[</span> <span class="token keyword">if</span> <span class="token hvariable">x</span> <span class="token operator">&lt;</span> <span class="token number">10</span> <span class="token keyword">then</span> <span class="token string">"BOOM!"</span> <span class="token keyword">else</span> <span class="token string">"BANG!"</span> <span class="token operator">|</span> <span class="token hvariable">x</span> <span class="token operator">&lt;-</span> <span class="token hvariable">xs</span><span class="token punctuation">,</span> <span class="token builtin">odd</span> <span class="token hvariable">x</span><span class="token punctuation">]</span> 
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>The last part of the comprehension is the predicate. The function <code>odd</code> returns <code>True</code> on an odd number and <code>False</code> on an even one. The element is included in the list only if all the predicates evaluate to <code>True</code>.</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token hvariable">boomBangs</span> <span class="token punctuation">[</span><span class="token number">7</span><span class="token operator">..</span><span class="token number">13</span><span class="token punctuation">]</span>
<span class="token punctuation">[</span><span class="token string">"BOOM!"</span><span class="token punctuation">,</span><span class="token string">"BOOM!"</span><span class="token punctuation">,</span><span class="token string">"BANG!"</span><span class="token punctuation">,</span><span class="token string">"BANG!"</span><span class="token punctuation">]</span> 
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>We can include several predicates. If we wanted all numbers from 10 to 20 that are not 13, 15 or 19, we'd do:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token punctuation">[</span> <span class="token hvariable">x</span> <span class="token operator">|</span> <span class="token hvariable">x</span> <span class="token operator">&lt;-</span> <span class="token punctuation">[</span><span class="token number">10</span><span class="token operator">..</span><span class="token number">20</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token hvariable">x</span> <span class="token operator">/=</span> <span class="token number">13</span><span class="token punctuation">,</span> <span class="token hvariable">x</span> <span class="token operator">/=</span> <span class="token number">15</span><span class="token punctuation">,</span> <span class="token hvariable">x</span> <span class="token operator">/=</span> <span class="token number">19</span><span class="token punctuation">]</span>
<span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">,</span><span class="token number">11</span><span class="token punctuation">,</span><span class="token number">12</span><span class="token punctuation">,</span><span class="token number">14</span><span class="token punctuation">,</span><span class="token number">16</span><span class="token punctuation">,</span><span class="token number">17</span><span class="token punctuation">,</span><span class="token number">18</span><span class="token punctuation">,</span><span class="token number">20</span><span class="token punctuation">]</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Not only can we have multiple predicates in list comprehensions (an element must satisfy all the predicates to be included in the resulting list), we can also draw from several lists. When drawing from several lists, comprehensions produce all combinations of the given lists and then join them by the output function we supply. A list produced by a comprehension that draws from two lists of length 4 will have a length of 16, provided we don't filter them. If we have two lists, <code>[2,5,10]</code> and <code>[8,10,11]</code> and we want to get the products of all the possible combinations between numbers in those lists, here's what we'd do.</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token punctuation">[</span> <span class="token hvariable">x</span><span class="token operator">*</span><span class="token hvariable">y</span> <span class="token operator">|</span> <span class="token hvariable">x</span> <span class="token operator">&lt;-</span> <span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token hvariable">y</span> <span class="token operator">&lt;-</span> <span class="token punctuation">[</span><span class="token number">8</span><span class="token punctuation">,</span><span class="token number">10</span><span class="token punctuation">,</span><span class="token number">11</span><span class="token punctuation">]</span><span class="token punctuation">]</span>
<span class="token punctuation">[</span><span class="token number">16</span><span class="token punctuation">,</span><span class="token number">20</span><span class="token punctuation">,</span><span class="token number">22</span><span class="token punctuation">,</span><span class="token number">40</span><span class="token punctuation">,</span><span class="token number">50</span><span class="token punctuation">,</span><span class="token number">55</span><span class="token punctuation">,</span><span class="token number">80</span><span class="token punctuation">,</span><span class="token number">100</span><span class="token punctuation">,</span><span class="token number">110</span><span class="token punctuation">]</span> 
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>As expected, the length of the new list is 9. What if we wanted all possible products that are more than 50?</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token punctuation">[</span> <span class="token hvariable">x</span><span class="token operator">*</span><span class="token hvariable">y</span> <span class="token operator">|</span> <span class="token hvariable">x</span> <span class="token operator">&lt;-</span> <span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token hvariable">y</span> <span class="token operator">&lt;-</span> <span class="token punctuation">[</span><span class="token number">8</span><span class="token punctuation">,</span><span class="token number">10</span><span class="token punctuation">,</span><span class="token number">11</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token hvariable">x</span><span class="token operator">*</span><span class="token hvariable">y</span> <span class="token operator">&gt;</span> <span class="token number">50</span><span class="token punctuation">]</span>
<span class="token punctuation">[</span><span class="token number">55</span><span class="token punctuation">,</span><span class="token number">80</span><span class="token punctuation">,</span><span class="token number">100</span><span class="token punctuation">,</span><span class="token number">110</span><span class="token punctuation">]</span> 
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>How about a list comprehension that combines a list of adjectives and a list of nouns … for epic hilarity.</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token keyword">let</span> <span class="token hvariable">nouns</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">"hobo"</span><span class="token punctuation">,</span><span class="token string">"frog"</span><span class="token punctuation">,</span><span class="token string">"pope"</span><span class="token punctuation">]</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token keyword">let</span> <span class="token hvariable">adjectives</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">"lazy"</span><span class="token punctuation">,</span><span class="token string">"grouchy"</span><span class="token punctuation">,</span><span class="token string">"scheming"</span><span class="token punctuation">]</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token punctuation">[</span><span class="token hvariable">adjective</span> <span class="token operator">++</span> <span class="token string">" "</span> <span class="token operator">++</span> <span class="token hvariable">noun</span> <span class="token operator">|</span> <span class="token hvariable">adjective</span> <span class="token operator">&lt;-</span> <span class="token hvariable">adjectives</span><span class="token punctuation">,</span> <span class="token hvariable">noun</span> <span class="token operator">&lt;-</span> <span class="token hvariable">nouns</span><span class="token punctuation">]</span>
<span class="token punctuation">[</span><span class="token string">"lazy hobo"</span><span class="token punctuation">,</span><span class="token string">"lazy frog"</span><span class="token punctuation">,</span><span class="token string">"lazy pope"</span><span class="token punctuation">,</span><span class="token string">"grouchy hobo"</span><span class="token punctuation">,</span><span class="token string">"grouchy frog"</span><span class="token punctuation">,</span>
<span class="token string">"grouchy pope"</span><span class="token punctuation">,</span><span class="token string">"scheming hobo"</span><span class="token punctuation">,</span><span class="token string">"scheming frog"</span><span class="token punctuation">,</span><span class="token string">"scheming pope"</span><span class="token punctuation">]</span> 
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>I know! Let's write our own version of <code>length</code>! We'll call it <code>length'</code>.</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token builtin">length</span>' <span class="token hvariable">xs</span> <span class="token operator">=</span> <span class="token builtin">sum</span> <span class="token punctuation">[</span><span class="token number">1</span> <span class="token operator">|</span> <span class="token hvariable">_</span> <span class="token operator">&lt;-</span> <span class="token hvariable">xs</span><span class="token punctuation">]</span> 
</code><button class="copy-code-button">Копировать</button></pre></div><div><p><code>_</code> means that we don't care what we'll draw from the list anyway so instead of writing a variable name that we'll never use, we just write <code>_</code>. This function replaces every element of a list with <code>1</code> and then sums that up. This means that the resulting sum will be the length of our list.</p></div><div><p>Just a friendly reminder: because strings are lists, we can use list comprehensions to process and produce strings. Here's a function that takes a string and removes everything except uppercase letters from it.</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">removeNonUppercase</span> <span class="token hvariable">st</span> <span class="token operator">=</span> <span class="token punctuation">[</span> <span class="token hvariable">c</span> <span class="token operator">|</span> <span class="token hvariable">c</span> <span class="token operator">&lt;-</span> <span class="token hvariable">st</span><span class="token punctuation">,</span> <span class="token hvariable">c</span> <span class="token operator">`elem`</span> <span class="token punctuation">[</span><span class="token char string">'A'</span><span class="token operator">..</span><span class="token char string">'Z'</span><span class="token punctuation">]</span><span class="token punctuation">]</span> 
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Testing it out:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token hvariable">removeNonUppercase</span> <span class="token string">"Hahaha! Ahahaha!"</span>
<span class="token string">"HA"</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token hvariable">removeNonUppercase</span> <span class="token string">"IdontLIKEFROGS"</span>
<span class="token string">"ILIKEFROGS"</span> 
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>The predicate here does all the work. It says that the character will be included in the new list only if it's an element of the list <code>['A'..'Z']</code>. Nested list comprehensions are also possible if you're operating on lists that contain lists. A list contains several lists of numbers. Let's remove all odd numbers without flattening the list.</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token keyword">let</span> <span class="token hvariable">xxs</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">,</span><span class="token number">7</span><span class="token punctuation">,</span><span class="token number">8</span><span class="token punctuation">,</span><span class="token number">9</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">]</span><span class="token punctuation">]</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token punctuation">[</span> <span class="token punctuation">[</span> <span class="token hvariable">x</span> <span class="token operator">|</span> <span class="token hvariable">x</span> <span class="token operator">&lt;-</span> <span class="token hvariable">xs</span><span class="token punctuation">,</span> <span class="token builtin">even</span> <span class="token hvariable">x</span> <span class="token punctuation">]</span> <span class="token operator">|</span> <span class="token hvariable">xs</span> <span class="token operator">&lt;-</span> <span class="token hvariable">xxs</span><span class="token punctuation">]</span>
<span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">,</span><span class="token number">8</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">]</span><span class="token punctuation">]</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>You can write list comprehensions across several lines. So if you're not in GHCI, it's better to split longer list comprehensions across multiple lines, especially if they're nested.</p></div><div><h2 data-heading="Tuples" id="Tuples" style="display: flex;"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>Tuples</h2></div><div><p><span alt="LYHfGG_13_tuple.png" src="LYHfGG_13_tuple.png" class="internal-embed media-embed image-embed is-loaded"><img alt="LYHfGG_13_tuple.png" src="курсы\learn-you-a-haskell-for-great-good!\картинки\lyhfgg_13_tuple.png"></span></p></div><div><p>In some ways, tuples are like lists — they are a way to store several values into a single value. However, there are a few fundamental differences. A list of numbers is a list of numbers. That's its type and it doesn't matter if it has only one number in it or an infinite amount of numbers. Tuples, however, are used when you know exactly how many values you want to combine and its type depends on how many components it has and the types of the components. They are denoted with parentheses and their components are separated by commas.</p></div><div><p>Another key difference is that they don't have to be homogenous. Unlike a list, a tuple can contain a combination of several types.</p></div><div><p>Think about how we'd represent a two-dimensional vector in Haskell. One way would be to use a list. That would kind of work. So what if we wanted to put a couple of vectors in a list to represent points of a shape on a two-dimensional plane? We could do something like <code>[[1,2],[8,11],[4,5]]</code>. The problem with that method is that we could also do stuff like <code>[[1,2],[8,11,5],[4,5]]</code>, which Haskell has no problem with since it's still a list of lists with numbers but it kind of doesn't make sense. But a tuple of size two (also called a pair) is its own type, which means that a list can't have a couple of pairs in it and then a triple (a tuple of size three), so let's use that instead. Instead of surrounding the vectors with square brackets, we use parentheses: <code>[(1,2),(8,11),(4,5)]</code>. What if we tried to make a shape like <code>[(1,2),(8,11,5),(4,5)]</code>? Well, we'd get this error:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token constant">Couldn'</span><span class="token hvariable">t</span> <span class="token hvariable">match</span> <span class="token hvariable">expected</span> <span class="token keyword">type</span> `<span class="token punctuation">(</span><span class="token hvariable">t</span><span class="token punctuation">,</span> <span class="token hvariable">t1</span><span class="token punctuation">)</span>'
<span class="token hvariable">against</span> <span class="token hvariable">inferred</span> <span class="token keyword">type</span> `<span class="token punctuation">(</span><span class="token hvariable">t2</span><span class="token punctuation">,</span> <span class="token hvariable">t3</span><span class="token punctuation">,</span> <span class="token hvariable">t4</span><span class="token punctuation">)</span>'
<span class="token constant">In</span> <span class="token hvariable">the</span> <span class="token hvariable">expression</span><span class="token operator">:</span> <span class="token punctuation">(</span><span class="token number">8</span><span class="token punctuation">,</span> <span class="token number">11</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">)</span>
<span class="token constant">In</span> <span class="token hvariable">the</span> <span class="token hvariable">expression</span><span class="token operator">:</span> <span class="token punctuation">[</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token number">8</span><span class="token punctuation">,</span> <span class="token number">11</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">]</span>
<span class="token constant">In</span> <span class="token hvariable">the</span> <span class="token hvariable">definition</span> <span class="token keyword">of</span> `<span class="token hvariable">it'</span><span class="token operator">:</span> <span class="token hvariable">it</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token number">8</span><span class="token punctuation">,</span> <span class="token number">11</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">]</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>It's telling us that we tried to use a pair and a triple in the same list, which is not supposed to happen. You also couldn't make a list like <code>[(1,2),("One",2)]</code> because the first element of the list is a pair of numbers and the second element is a pair consisting of a string and a number. Tuples can also be used to represent a wide variety of data. For instance, if we wanted to represent someone's name and age in Haskell, we could use a triple: <code>("Christopher", "Walken", 55)</code>. As seen in this example, tuples can also contain lists.</p></div><div><p>Use tuples when you know in advance how many components some piece of data should have. Tuples are much more rigid because each different size of tuple is its own type, so you can't write a general function to append an element to a tuple — you'd have to write a function for appending to a pair, one function for appending to a triple, one function for appending to a 4-tuple, etc.</p></div><div><p>While there are singleton lists, there's no such thing as a singleton tuple. It doesn't really make much sense when you think about it. A singleton tuple would just be the value it contains and as such would have no benefit to us.</p></div><div><p>Like lists, tuples can be compared with each other if their components can be compared. Only you can't compare two tuples of different sizes, whereas you can compare two lists of different sizes. Two useful functions that operate on pairs:</p></div><div><p><code>fst</code> takes a pair and returns its first component.</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token builtin">fst</span> <span class="token punctuation">(</span><span class="token number">8</span><span class="token punctuation">,</span><span class="token number">11</span><span class="token punctuation">)</span>
<span class="token number">8</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token builtin">fst</span> <span class="token punctuation">(</span><span class="token string">"Wow"</span><span class="token punctuation">,</span> <span class="token constant">False</span><span class="token punctuation">)</span>
<span class="token string">"Wow"</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p><code>snd</code> takes a pair and returns its second component. Surprise!</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token builtin">snd</span> <span class="token punctuation">(</span><span class="token number">8</span><span class="token punctuation">,</span><span class="token number">11</span><span class="token punctuation">)</span>
<span class="token number">11</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token builtin">snd</span> <span class="token punctuation">(</span><span class="token string">"Wow"</span><span class="token punctuation">,</span> <span class="token constant">False</span><span class="token punctuation">)</span>
<span class="token constant">False</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><blockquote>
<p><strong>Note</strong> these functions operate only on pairs. They won't work on triples, 4-tuples, 5-tuples, etc. We'll go over extracting data from tuples in different ways a bit later.</p>
</blockquote></div><div><p>A cool function that produces a list of pairs: <code>zip</code>. It takes two lists and then zips them together into one list by joining the matching elements into pairs. It's a really simple function but it has loads of uses. It's especially useful for when you want to combine two lists in a way or traverse two lists simultaneously. Here's a demonstration.</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token builtin">zip</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">]</span> <span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">]</span>
<span class="token punctuation">[</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">]</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token builtin">zip</span> <span class="token punctuation">[</span><span class="token number">1</span> <span class="token operator">..</span> <span class="token number">5</span><span class="token punctuation">]</span> <span class="token punctuation">[</span><span class="token string">"one"</span><span class="token punctuation">,</span> <span class="token string">"two"</span><span class="token punctuation">,</span> <span class="token string">"three"</span><span class="token punctuation">,</span> <span class="token string">"four"</span><span class="token punctuation">,</span> <span class="token string">"five"</span><span class="token punctuation">]</span>
<span class="token punctuation">[</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token string">"one"</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token string">"two"</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token string">"three"</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token string">"four"</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token string">"five"</span><span class="token punctuation">)</span><span class="token punctuation">]</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>It pairs up the elements and produces a new list. The first element goes with the first, the second with the second, etc. Notice that because pairs can have different types in them, <code>zip</code> can take two lists that contain different types and zip them up. What happens if the lengths of the lists don't match?</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token builtin">zip</span> <span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">7</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">]</span> <span class="token punctuation">[</span><span class="token string">"im"</span><span class="token punctuation">,</span><span class="token string">"a"</span><span class="token punctuation">,</span><span class="token string">"turtle"</span><span class="token punctuation">]</span>
<span class="token punctuation">[</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token string">"im"</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token string">"a"</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token string">"turtle"</span><span class="token punctuation">)</span><span class="token punctuation">]</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>The longer list simply gets cut off to match the length of the shorter one. Because Haskell is lazy, we can zip finite lists with infinite lists:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token builtin">zip</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token operator">..</span><span class="token punctuation">]</span> <span class="token punctuation">[</span><span class="token string">"apple"</span><span class="token punctuation">,</span> <span class="token string">"orange"</span><span class="token punctuation">,</span> <span class="token string">"cherry"</span><span class="token punctuation">,</span> <span class="token string">"mango"</span><span class="token punctuation">]</span>
<span class="token punctuation">[</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token string">"apple"</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token string">"orange"</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token string">"cherry"</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token string">"mango"</span><span class="token punctuation">)</span><span class="token punctuation">]</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p><span alt="LYHfGG_14_pythag.png" src="LYHfGG_14_pythag.png" class="internal-embed media-embed image-embed is-loaded"><img alt="LYHfGG_14_pythag.png" src="курсы\learn-you-a-haskell-for-great-good!\картинки\lyhfgg_14_pythag.png"></span></p></div><div><p>Here's a problem that combines tuples and list comprehensions: which right triangle that has integers for all sides and all sides equal to or smaller than 10 has a perimeter of 24? First, let's try generating all triangles with sides equal to or smaller than 10:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token keyword">let</span> <span class="token hvariable">triangles</span> <span class="token operator">=</span> <span class="token punctuation">[</span> <span class="token punctuation">(</span><span class="token hvariable">a</span><span class="token punctuation">,</span><span class="token hvariable">b</span><span class="token punctuation">,</span><span class="token hvariable">c</span><span class="token punctuation">)</span> <span class="token operator">|</span> <span class="token hvariable">c</span> <span class="token operator">&lt;-</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token operator">..</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token hvariable">b</span> <span class="token operator">&lt;-</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token operator">..</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token hvariable">a</span> <span class="token operator">&lt;-</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token operator">..</span><span class="token number">10</span><span class="token punctuation">]</span> <span class="token punctuation">]</span> 
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>We're just drawing from three lists and our output function is combining them into a triple. If you evaluate that by typing out <code>triangles</code> in GHCI, you'll get a list of all possible triangles with sides under or equal to 10. Next, we'll add a condition that they all have to be right triangles. We'll also modify this function by taking into consideration that side b isn't larger than the hypothenuse and that side a isn't larger than side b.</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token keyword">let</span> <span class="token hvariable">rightTriangles</span> <span class="token operator">=</span> <span class="token punctuation">[</span> <span class="token punctuation">(</span><span class="token hvariable">a</span><span class="token punctuation">,</span><span class="token hvariable">b</span><span class="token punctuation">,</span><span class="token hvariable">c</span><span class="token punctuation">)</span> <span class="token operator">|</span> <span class="token hvariable">c</span> <span class="token operator">&lt;-</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token operator">..</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token hvariable">b</span> <span class="token operator">&lt;-</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token operator">..</span><span class="token hvariable">c</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token hvariable">a</span> <span class="token operator">&lt;-</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token operator">..</span><span class="token hvariable">b</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token hvariable">a</span><span class="token operator">^</span><span class="token number">2</span> <span class="token operator">+</span> <span class="token hvariable">b</span><span class="token operator">^</span><span class="token number">2</span> <span class="token operator">==</span> <span class="token hvariable">c</span><span class="token operator">^</span><span class="token number">2</span><span class="token punctuation">]</span> 
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>We're almost done. Now, we just modify the function by saying that we want the ones where the perimeter is 24.</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token keyword">let</span> <span class="token hvariable">rightTriangles'</span> <span class="token operator">=</span> <span class="token punctuation">[</span> <span class="token punctuation">(</span><span class="token hvariable">a</span><span class="token punctuation">,</span><span class="token hvariable">b</span><span class="token punctuation">,</span><span class="token hvariable">c</span><span class="token punctuation">)</span> <span class="token operator">|</span> <span class="token hvariable">c</span> <span class="token operator">&lt;-</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token operator">..</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token hvariable">b</span> <span class="token operator">&lt;-</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token operator">..</span><span class="token hvariable">c</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token hvariable">a</span> <span class="token operator">&lt;-</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token operator">..</span><span class="token hvariable">b</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token hvariable">a</span><span class="token operator">^</span><span class="token number">2</span> <span class="token operator">+</span> <span class="token hvariable">b</span><span class="token operator">^</span><span class="token number">2</span> <span class="token operator">==</span> <span class="token hvariable">c</span><span class="token operator">^</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token hvariable">a</span><span class="token operator">+</span><span class="token hvariable">b</span><span class="token operator">+</span><span class="token hvariable">c</span> <span class="token operator">==</span> <span class="token number">24</span><span class="token punctuation">]</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token hvariable">rightTriangles'</span>
<span class="token punctuation">[</span><span class="token punctuation">(</span><span class="token number">6</span><span class="token punctuation">,</span><span class="token number">8</span><span class="token punctuation">,</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">]</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>And there's our answer! This is a common pattern in functional programming. You take a starting set of solutions and then you apply transformations to those solutions and filter them until you get the right ones.</p></div><div><h1 data-heading="Types and Typeclasses" id="Types_and_Typeclasses">Types and Typeclasses</h1></div><div><h2 data-heading="Believe the type" id="Believe_the_type" style="display: flex;"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>Believe the type</h2></div><div><p><span alt="LYHfGG_15_cow.png" src="LYHfGG_15_cow.png" class="internal-embed media-embed image-embed is-loaded"><img alt="LYHfGG_15_cow.png" src="курсы\learn-you-a-haskell-for-great-good!\картинки\lyhfgg_15_cow.png"></span></p></div><div><p>Previously we mentioned that Haskell has a static type system. The type of every expression is known at compile time, which leads to safer code. If you write a program where you try to divide a boolean type with some number, it won't even compile. That's good because it's better to catch such errors at compile time instead of having your program crash. Everything in Haskell has a type, so the compiler can reason quite a lot about your program before compiling it.</p></div><div><p>Unlike Java or Pascal, Haskell has type inference. If we write a number, we don't have to tell Haskell it's a number. It can <em>infer</em> that on its own, so we don't have to explicitly write out the types of our functions and expressions to get things done. We covered some of the basics of Haskell with only a very superficial glance at types. However, understanding the type system is a very important part of learning Haskell.</p></div><div><p>A type is a kind of label that every expression has. It tells us in which category of things that expression fits. The expression <code>True</code> is a boolean, <code>"hello"</code> is a string, etc.</p></div><div><p>Now we'll use GHCI to examine the types of some expressions. We'll do that by using the <code>:t</code> command which, followed by any valid expression, tells us its type. Let's give it a whirl.</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token operator">:</span><span class="token hvariable">t</span> <span class="token char string">'a'</span>
<span class="token char string">'a'</span> <span class="token operator">::</span> <span class="token constant">Char</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token operator">:</span><span class="token hvariable">t</span> <span class="token constant">True</span>
<span class="token constant">True</span> <span class="token operator">::</span> <span class="token constant">Bool</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token operator">:</span><span class="token hvariable">t</span> <span class="token string">"HELLO!"</span>
<span class="token string">"HELLO!"</span> <span class="token operator">::</span> <span class="token punctuation">[</span><span class="token constant">Char</span><span class="token punctuation">]</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token operator">:</span><span class="token hvariable">t</span> <span class="token punctuation">(</span><span class="token constant">True</span><span class="token punctuation">,</span> <span class="token char string">'a'</span><span class="token punctuation">)</span>
<span class="token punctuation">(</span><span class="token constant">True</span><span class="token punctuation">,</span> <span class="token char string">'a'</span><span class="token punctuation">)</span> <span class="token operator">::</span> <span class="token punctuation">(</span><span class="token constant">Bool</span><span class="token punctuation">,</span> <span class="token constant">Char</span><span class="token punctuation">)</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token operator">:</span><span class="token hvariable">t</span> <span class="token number">4</span> <span class="token operator">==</span> <span class="token number">5</span>
<span class="token number">4</span> <span class="token operator">==</span> <span class="token number">5</span> <span class="token operator">::</span> <span class="token constant">Bool</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p><span alt="LYHfGG_16_bomb.png" src="LYHfGG_16_bomb.png" class="internal-embed media-embed image-embed is-loaded"><img alt="LYHfGG_16_bomb.png" src="курсы\learn-you-a-haskell-for-great-good!\картинки\lyhfgg_16_bomb.png"></span></p></div><div><p>Here we see that doing <code>:t</code> on an expression prints out the expression followed by <code>::</code> and its type. <code>::</code> is read as "has type of". Explicit types are always denoted with the first letter in capital case. <code>'a'</code>, as it would seem, has a type of <code>Char</code>. It's not hard to conclude that it stands for <em>character</em>. <code>True</code> is of a <code>Bool</code> type. That makes sense. But what's this? Examining the type of <code>"HELLO!"</code> yields a <code>[Char]</code>. The square brackets denote a list. So we read that as it being <em>a list of characters</em>. Unlike lists, each tuple length has its own type. So the expression of <code>(True, 'a')</code> has a type of <code>(Bool, Char)</code>, whereas an expression such as <code>('a','b','c')</code> would have the type of <code>(Char, Char, Char)</code>. <code>4 == 5</code> will always return <code>False</code>, so its type is <code>Bool</code>.</p></div><div><p>Functions also have types. When writing our own functions, we can choose to give them an explicit type declaration. This is generally considered to be good practice except when writing very short functions. From here on, we'll give all the functions that we make type declarations. Remember the list comprehension we made previously that filters a string so that only caps remain? Here's how it looks like with a type declaration.</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">removeNonUppercase</span> <span class="token operator">::</span> <span class="token punctuation">[</span><span class="token constant">Char</span><span class="token punctuation">]</span> <span class="token operator">-&gt;</span> <span class="token punctuation">[</span><span class="token constant">Char</span><span class="token punctuation">]</span>
<span class="token hvariable">removeNonUppercase</span> <span class="token hvariable">st</span> <span class="token operator">=</span> <span class="token punctuation">[</span> <span class="token hvariable">c</span> <span class="token operator">|</span> <span class="token hvariable">c</span> <span class="token operator">&lt;-</span> <span class="token hvariable">st</span><span class="token punctuation">,</span> <span class="token hvariable">c</span> <span class="token operator">`elem`</span> <span class="token punctuation">[</span><span class="token char string">'A'</span><span class="token operator">..</span><span class="token char string">'Z'</span><span class="token punctuation">]</span><span class="token punctuation">]</span> 
</code><button class="copy-code-button">Копировать</button></pre></div><div><p><code>removeNonUppercase</code> has a type of <code>[Char] -&gt; [Char]</code>, meaning that it maps from a string to a string. That's because it takes one string as a parameter and returns another as a result. The <code>[Char]</code> type is synonymous with <code>String</code> so it's clearer if we write <code>removeNonUppercase :: String -&gt; String</code>. We didn't have to give this function a type declaration because the compiler can infer by itself that it's a function from a string to a string but we did anyway. But how do we write out the type of a function that takes several parameters? Here's a simple function that takes three integers and adds them together:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">addThree</span> <span class="token operator">::</span> <span class="token constant">Int</span> <span class="token operator">-&gt;</span> <span class="token constant">Int</span> <span class="token operator">-&gt;</span> <span class="token constant">Int</span> <span class="token operator">-&gt;</span> <span class="token constant">Int</span>
<span class="token hvariable">addThree</span> <span class="token hvariable">x</span> <span class="token hvariable">y</span> <span class="token hvariable">z</span> <span class="token operator">=</span> <span class="token hvariable">x</span> <span class="token operator">+</span> <span class="token hvariable">y</span> <span class="token operator">+</span> <span class="token hvariable">z</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>The parameters are separated with <code>-&gt;</code> and there's no special distinction between the parameters and the return type. The return type is the last item in the declaration and the parameters are the first three. Later on we'll see why they're all just separated with <code>-&gt;</code> instead of having some more explicit distinction between the return types and the parameters like <code>Int, Int, Int -&gt; Int</code> or something.</p></div><div><p>If you want to give your function a type declaration but are unsure as to what it should be, you can always just write the function without it and then check it with <code>:t</code>. Functions are expressions too, so <code>:t</code> works on them without a problem.</p></div><div><p>Here's an overview of some common types.</p></div><div><p><code>Int</code> stands for integer. It's used for whole numbers. <code>7</code> can be an <code>Int</code> but <code>7.2</code> cannot. <code>Int</code> is bounded, which means that it has a minimum and a maximum value. Usually on 32-bit machines the maximum possible <code>Int</code> is 2147483647 and the minimum is -2147483648.</p></div><div><p><code>Integer</code> stands for, er … also integer. The main difference is that it's not bounded so it can be used to represent really really big numbers. I mean like really big. <code>Int</code>, however, is more efficient.</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">factorial</span> <span class="token operator">::</span> <span class="token constant">Integer</span> <span class="token operator">-&gt;</span> <span class="token constant">Integer</span>
<span class="token hvariable">factorial</span> <span class="token hvariable">n</span> <span class="token operator">=</span> <span class="token builtin">product</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token operator">..</span><span class="token hvariable">n</span><span class="token punctuation">]</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token hvariable">factorial</span> <span class="token number">50</span>
<span class="token number">30414093201713378043612608166064768844377641568960512000000000000</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p><code>Float</code> is a real floating point with single precision.</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">circumference</span> <span class="token operator">::</span> <span class="token constant">Float</span> <span class="token operator">-&gt;</span> <span class="token constant">Float</span>
<span class="token hvariable">circumference</span> <span class="token hvariable">r</span> <span class="token operator">=</span> <span class="token number">2</span> <span class="token operator">*</span> <span class="token builtin">pi</span> <span class="token operator">*</span> <span class="token hvariable">r</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token hvariable">circumference</span> <span class="token number">4.0</span>
<span class="token number">25.132742</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p><code>Double</code> is a real floating point with double the precision!</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">circumference'</span> <span class="token operator">::</span> <span class="token constant">Double</span> <span class="token operator">-&gt;</span> <span class="token constant">Double</span>
<span class="token hvariable">circumference'</span> <span class="token hvariable">r</span> <span class="token operator">=</span> <span class="token number">2</span> <span class="token operator">*</span> <span class="token builtin">pi</span> <span class="token operator">*</span> <span class="token hvariable">r</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token hvariable">circumference'</span> <span class="token number">4.0</span>
<span class="token number">25.132741228718345</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p><code>Bool</code> is a boolean type. It can have only two values: <code>True</code> and <code>False</code>.</p></div><div><p><code>Char</code> represents a character. It's denoted by single quotes. A list of characters is a string.</p></div><div><p>Tuples are types but they are dependent on their length as well as the types of their components, so there is theoretically an infinite number of tuple types, which is too many to cover in this tutorial. Note that the empty tuple <code>()</code> is also a type which can only have a single value: <code>()</code></p></div><div><h2 data-heading="Type variables" id="Type_variables" style="display: flex;"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>Type variables</h2></div><div><p>What do you think is the type of the <code>head</code> function? Because <code>head</code> takes a list of any type and returns the first element, so what could it be? Let's check!</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token operator">:</span><span class="token hvariable">t</span> <span class="token builtin">head</span>
<span class="token builtin">head</span> <span class="token operator">::</span> <span class="token punctuation">[</span><span class="token hvariable">a</span><span class="token punctuation">]</span> <span class="token operator">-&gt;</span> <span class="token hvariable">a</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p><span alt="LYHfGG_17_box.png" src="LYHfGG_17_box.png" class="internal-embed media-embed image-embed is-loaded"><img alt="LYHfGG_17_box.png" src="курсы\learn-you-a-haskell-for-great-good!\картинки\lyhfgg_17_box.png"></span></p></div><div><p>Hmmm! What is this <code>a</code>? Is it a type? Remember that we previously stated that types are written in capital case, so it can't exactly be a type. Because it's not in capital case it's actually a <strong>type variable</strong>. That means that <code>a</code> can be of any type. This is much like generics in other languages, only in Haskell it's much more powerful because it allows us to easily write very general functions if they don't use any specific behavior of the types in them. Functions that have type variables are called <strong>polymorphic functions</strong>. The type declaration of <code>head</code> states that it takes a list of any type and returns one element of that type.</p></div><div><p>Although type variables can have names longer than one character, we usually give them names of a, b, c, d …</p></div><div><p>Remember <code>fst</code>? It returns the first component of a pair. Let's examine its type.</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token operator">:</span><span class="token hvariable">t</span> <span class="token builtin">fst</span>
<span class="token builtin">fst</span> <span class="token operator">::</span> <span class="token punctuation">(</span><span class="token hvariable">a</span><span class="token punctuation">,</span> <span class="token hvariable">b</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token hvariable">a</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>We see that <code>fst</code> takes a tuple which contains two types and returns an element which is of the same type as the pair's first component. That's why we can use <code>fst</code> on a pair that contains any two types. Note that just because <code>a</code> and <code>b</code> are different type variables, they don't have to be different types. It just states that the first component's type and the return value's type are the same.</p></div><div><h2 data-heading="Typeclasses 101" id="Typeclasses_101" style="display: flex;"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>Typeclasses 101</h2></div><div><p><span alt="LYHfGG_18_classes.png" src="LYHfGG_18_classes.png" class="internal-embed media-embed image-embed is-loaded"><img alt="LYHfGG_18_classes.png" src="курсы\learn-you-a-haskell-for-great-good!\картинки\lyhfgg_18_classes.png"></span></p></div><div><p>A typeclass is a sort of interface that defines some behavior. If a type is a part of a typeclass, that means that it supports and implements the behavior the typeclass describes. A lot of people coming from OOP get confused by typeclasses because they think they are like classes in object oriented languages. Well, they're not. You can think of them kind of as Java interfaces, only better.</p></div><div><p>What's the type signature of the <code>==</code> function?</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token operator">:</span><span class="token hvariable">t</span> <span class="token punctuation">(</span><span class="token operator">==</span><span class="token punctuation">)</span>
<span class="token punctuation">(</span><span class="token operator">==</span><span class="token punctuation">)</span> <span class="token operator">::</span> <span class="token punctuation">(</span><span class="token constant">Eq</span> <span class="token hvariable">a</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token hvariable">a</span> <span class="token operator">-&gt;</span> <span class="token hvariable">a</span> <span class="token operator">-&gt;</span> <span class="token constant">Bool</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><blockquote>
<p><strong>Note</strong>: the equality operator, <code>==</code> is a function. So are <code>+</code>, <code>*</code>, <code>-</code>, <code>/</code> and pretty much all operators. If a function is comprised only of special characters, it's considered an infix function by default. If we want to examine its type, pass it to another function or call it as a prefix function, we have to surround it in parentheses.</p>
</blockquote></div><div><p>Interesting. We see a new thing here, the <code>=&gt;</code> symbol. Everything before the <code>=&gt;</code> symbol is called a <strong>class constraint</strong>. We can read the previous type declaration like this: the equality function takes any two values that are of the same type and returns a <code>Bool</code>. The type of those two values must be a member of the <code>Eq</code> class (this was the class constraint).</p></div><div><p>The <code>Eq</code> typeclass provides an interface for testing for equality. Any type where it makes sense to test for equality between two values of that type should be a member of the <code>Eq</code> class. All standard Haskell types except for IO (the type for dealing with input and output) and functions are a part of the <code>Eq</code> typeclass.</p></div><div><p>The <code>elem</code> function has a type of <code>(Eq a) =&gt; a -&gt; [a] -&gt; Bool</code> because it uses <code>==</code> over a list to check whether some value we're looking for is in it.</p></div><div><p>Some basic typeclasses:</p></div><div><p><code>Eq</code> is used for types that support equality testing. The functions its members implement are <code>==</code> and <code>/=</code>. So if there's an <code>Eq</code> class constraint for a type variable in a function, it uses <code>==</code> or <code>/=</code> somewhere inside its definition. All the types we mentioned previously except for functions are part of <code>Eq</code>, so they can be tested for equality.</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token number">5</span> <span class="token operator">==</span> <span class="token number">5</span>
<span class="token constant">True</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token number">5</span> <span class="token operator">/=</span> <span class="token number">5</span>
<span class="token constant">False</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token char string">'a'</span> <span class="token operator">==</span> <span class="token char string">'a'</span>
<span class="token constant">True</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token string">"Ho Ho"</span> <span class="token operator">==</span> <span class="token string">"Ho Ho"</span>
<span class="token constant">True</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token number">3.432</span> <span class="token operator">==</span> <span class="token number">3.432</span>
<span class="token constant">True</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p><code>Ord</code> is for types that have an ordering.</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token operator">:</span><span class="token hvariable">t</span> <span class="token punctuation">(</span><span class="token operator">&gt;</span><span class="token punctuation">)</span>
<span class="token punctuation">(</span><span class="token operator">&gt;</span><span class="token punctuation">)</span> <span class="token operator">::</span> <span class="token punctuation">(</span><span class="token constant">Ord</span> <span class="token hvariable">a</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token hvariable">a</span> <span class="token operator">-&gt;</span> <span class="token hvariable">a</span> <span class="token operator">-&gt;</span> <span class="token constant">Bool</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>All the types we covered so far except for functions are part of <code>Ord</code>. <code>Ord</code> covers all the standard comparing functions such as <code>&gt;</code>, <code>&lt;</code>, <code>&gt;=</code> and <code>&lt;=</code>. The <code>compare</code> function takes two <code>Ord</code> members of the same type and returns an ordering. <code>Ordering</code> is a type that can be <code>GT</code>, <code>LT</code> or <code>EQ</code>, meaning <em>greater than</em>, <em>lesser than</em> and <em>equal</em>, respectively.</p></div><div><p>To be a member of <code>Ord</code>, a type must first have membership in the prestigious and exclusive <code>Eq</code> club.</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token string">"Abrakadabra"</span> <span class="token operator">&lt;</span> <span class="token string">"Zebra"</span>
<span class="token constant">True</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token string">"Abrakadabra"</span> <span class="token operator">`compare`</span> <span class="token string">"Zebra"</span>
<span class="token constant">LT</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token number">5</span> <span class="token operator">&gt;=</span> <span class="token number">2</span>
<span class="token constant">True</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token number">5</span> <span class="token operator">`compare`</span> <span class="token number">3</span>
<span class="token constant">GT</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Members of <code>Show</code> can be presented as strings. All types covered so far except for functions are a part of <code>Show</code>. The most used function that deals with the <code>Show</code> typeclass is <code>show</code>. It takes a value whose type is a member of <code>Show</code> and presents it to us as a string.</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token builtin">show</span> <span class="token number">3</span>
<span class="token string">"3"</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token builtin">show</span> <span class="token number">5.334</span>
<span class="token string">"5.334"</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token builtin">show</span> <span class="token constant">True</span>
<span class="token string">"True"</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p><code>Read</code> is sort of the opposite typeclass of <code>Show</code>. The <code>read</code> function takes a string and returns a type which is a member of <code>Read</code>.</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token builtin">read</span> <span class="token string">"True"</span> <span class="token operator">||</span> <span class="token constant">False</span>
<span class="token constant">True</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token builtin">read</span> <span class="token string">"8.2"</span> <span class="token operator">+</span> <span class="token number">3.8</span>
<span class="token number">12.0</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token builtin">read</span> <span class="token string">"5"</span> <span class="token operator">-</span> <span class="token number">2</span>
<span class="token number">3</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token builtin">read</span> <span class="token string">"[1,2,3,4]"</span> <span class="token operator">++</span> <span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span>
<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">]</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>So far so good. Again, all types covered so far are in this typeclass. But what happens if we try to do just <code>read "4"</code>?</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token builtin">read</span> <span class="token string">"4"</span>
<span class="token operator">&lt;</span><span class="token hvariable">interactive</span><span class="token operator">&gt;:</span><span class="token number">1</span><span class="token operator">:</span><span class="token number">0</span><span class="token operator">:</span>
    <span class="token constant">Ambiguous</span> <span class="token keyword">type</span> <span class="token hvariable">variable</span> `<span class="token hvariable">a'</span> <span class="token keyword">in</span> <span class="token hvariable">the</span> <span class="token hvariable">constraint</span><span class="token operator">:</span>
      `<span class="token constant">Read</span> <span class="token hvariable">a'</span> <span class="token hvariable">arising</span> <span class="token hvariable">from</span> <span class="token hvariable">a</span> <span class="token hvariable">use</span> <span class="token keyword">of</span> `<span class="token builtin">read</span>' <span class="token hvariable">at</span> <span class="token operator">&lt;</span><span class="token hvariable">interactive</span><span class="token operator">&gt;:</span><span class="token number">1</span><span class="token operator">:</span><span class="token number">0</span><span class="token operator">-</span><span class="token number">7</span>
    <span class="token constant">Probable</span> <span class="token hvariable">fix</span><span class="token operator">:</span> <span class="token hvariable">add</span> <span class="token hvariable">a</span> <span class="token keyword">type</span> <span class="token hvariable">signature</span> <span class="token hvariable">that</span> <span class="token hvariable">fixes</span> <span class="token hvariable">these</span> <span class="token keyword">type</span> <span class="token hvariable">variable</span><span class="token punctuation">(</span><span class="token hvariable">s</span><span class="token punctuation">)</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>What GHCI is telling us here is that it doesn't know what we want in return. Notice that in the previous uses of <code>read</code> we did something with the result afterwards. That way, GHCI could infer what kind of result we wanted out of our <code>read</code>. If we used it as a boolean, it knew it had to return a <code>Bool</code>. But now, it knows we want some type that is part of the <code>Read</code> class, it just doesn't know which one. Let's take a look at the type signature of <code>read</code>.</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token operator">:</span><span class="token hvariable">t</span> <span class="token builtin">read</span>
<span class="token builtin">read</span> <span class="token operator">::</span> <span class="token punctuation">(</span><span class="token constant">Read</span> <span class="token hvariable">a</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token constant">String</span> <span class="token operator">-&gt;</span> <span class="token hvariable">a</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>See? It returns a type that's part of <code>Read</code> but if we don't try to use it in some way later, it has no way of knowing which type. That's why we can use explicit <strong>type annotations</strong>. Type annotations are a way of explicitly saying what the type of an expression should be. We do that by adding <code>::</code> at the end of the expression and then specifying a type. Observe:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token builtin">read</span> <span class="token string">"5"</span> <span class="token operator">::</span> <span class="token constant">Int</span>
<span class="token number">5</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token builtin">read</span> <span class="token string">"5"</span> <span class="token operator">::</span> <span class="token constant">Float</span>
<span class="token number">5.0</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token punctuation">(</span><span class="token builtin">read</span> <span class="token string">"5"</span> <span class="token operator">::</span> <span class="token constant">Float</span><span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token number">4</span>
<span class="token number">20.0</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token builtin">read</span> <span class="token string">"[1,2,3,4]"</span> <span class="token operator">::</span> <span class="token punctuation">[</span><span class="token constant">Int</span><span class="token punctuation">]</span>
<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">]</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token builtin">read</span> <span class="token string">"(3, 'a')"</span> <span class="token operator">::</span> <span class="token punctuation">(</span><span class="token constant">Int</span><span class="token punctuation">,</span> <span class="token constant">Char</span><span class="token punctuation">)</span>
<span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token char string">'a'</span><span class="token punctuation">)</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Most expressions are such that the compiler can infer what their type is by itself. But sometimes, the compiler doesn't know whether to return a value of type <code>Int</code> or <code>Float</code> for an expression like <code>read "5"</code>. To see what the type is, Haskell would have to actually evaluate <code>read "5"</code>. But since Haskell is a statically typed language, it has to know all the types before the code is compiled (or in the case of GHCI, evaluated). So we have to tell Haskell: "Hey, this expression should have this type, in case you don't know!".</p></div><div><p><code>Enum</code> members are sequentially ordered types — they can be enumerated. The main advantage of the <code>Enum</code> typeclass is that we can use its types in list ranges. They also have defined successors and predecesors, which you can get with the <code>succ</code> and <code>pred</code> functions. Types in this class: <code>()</code>, <code>Bool</code>, <code>Char</code>, <code>Ordering</code>, <code>Int</code>, <code>Integer</code>, <code>Float</code> and <code>Double</code>.</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token punctuation">[</span><span class="token char string">'a'</span><span class="token operator">..</span><span class="token char string">'e'</span><span class="token punctuation">]</span>
<span class="token string">"abcde"</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token punctuation">[</span><span class="token constant">LT</span> <span class="token operator">..</span> <span class="token constant">GT</span><span class="token punctuation">]</span>
<span class="token punctuation">[</span><span class="token constant">LT</span><span class="token punctuation">,</span><span class="token constant">EQ</span><span class="token punctuation">,</span><span class="token constant">GT</span><span class="token punctuation">]</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token punctuation">[</span><span class="token number">3</span> <span class="token operator">..</span> <span class="token number">5</span><span class="token punctuation">]</span>
<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">]</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token builtin">succ</span> <span class="token char string">'B'</span>
<span class="token char string">'C'</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p><code>Bounded</code> members have an upper and a lower bound.</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token builtin">minBound</span> <span class="token operator">::</span> <span class="token constant">Int</span>
<span class="token operator">-</span><span class="token number">2147483648</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token builtin">maxBound</span> <span class="token operator">::</span> <span class="token constant">Char</span>
<span class="token char string">'\1114111'</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token builtin">maxBound</span> <span class="token operator">::</span> <span class="token constant">Bool</span>
<span class="token constant">True</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token builtin">minBound</span> <span class="token operator">::</span> <span class="token constant">Bool</span>
<span class="token constant">False</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p><code>minBound</code> and <code>maxBound</code> are interesting because they have a type of <code>(Bounded a) =&gt; a</code>. In a sense they are polymorphic constants.</p></div><div><p>All tuples are also part of <code>Bounded</code> if the components are also in it.</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token builtin">maxBound</span> <span class="token operator">::</span> <span class="token punctuation">(</span><span class="token constant">Bool</span><span class="token punctuation">,</span> <span class="token constant">Int</span><span class="token punctuation">,</span> <span class="token constant">Char</span><span class="token punctuation">)</span>
<span class="token punctuation">(</span><span class="token constant">True</span><span class="token punctuation">,</span><span class="token number">2147483647</span><span class="token punctuation">,</span><span class="token char string">'\1114111'</span><span class="token punctuation">)</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p><code>Num</code> is a numeric typeclass. Its members have the property of being able to act like numbers. Let's examine the type of a number.</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token operator">:</span><span class="token hvariable">t</span> <span class="token number">20</span>
<span class="token number">20</span> <span class="token operator">::</span> <span class="token punctuation">(</span><span class="token constant">Num</span> <span class="token hvariable">t</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token hvariable">t</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>It appears that whole numbers are also polymorphic constants. They can act like any type that's a member of the <code>Num</code> typeclass.</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token number">20</span> <span class="token operator">::</span> <span class="token constant">Int</span>
<span class="token number">20</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token number">20</span> <span class="token operator">::</span> <span class="token constant">Integer</span>
<span class="token number">20</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token number">20</span> <span class="token operator">::</span> <span class="token constant">Float</span>
<span class="token number">20.0</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token number">20</span> <span class="token operator">::</span> <span class="token constant">Double</span>
<span class="token number">20.0</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Those are types that are in the <code>Num</code> typeclass. If we examine the type of <code>*</code>, we'll see that it accepts all numbers.</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token operator">:</span><span class="token hvariable">t</span> <span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">)</span>
<span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">)</span> <span class="token operator">::</span> <span class="token punctuation">(</span><span class="token constant">Num</span> <span class="token hvariable">a</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token hvariable">a</span> <span class="token operator">-&gt;</span> <span class="token hvariable">a</span> <span class="token operator">-&gt;</span> <span class="token hvariable">a</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>It takes two numbers of the same type and returns a number of that type. That's why <code>(5 :: Int) * (6 :: Integer)</code> will result in a type error whereas <code>5 * (6 :: Integer)</code> will work just fine and produce an <code>Integer</code> because <code>5</code> can act like an <code>Integer</code> or an <code>Int</code>.</p></div><div><p>To join <code>Num</code>, a type must already be friends with <code>Show</code> and <code>Eq</code>.</p></div><div><p><code>Integral</code> is also a numeric typeclass. <code>Num</code> includes all numbers, including real numbers and integral numbers, <code>Integral</code> includes only integral (whole) numbers. In this typeclass are <code>Int</code> and <code>Integer</code>.</p></div><div><p><code>Floating</code> includes only floating point numbers, so <code>Float</code> and <code>Double</code>.</p></div><div><p>A very useful function for dealing with numbers is <code>fromIntegral</code>. It has a type declaration of <code>fromIntegral :: (Num b, Integral a) =&gt; a -&gt; b</code>. From its type signature we see that it takes an integral number and turns it into a more general number. That's useful when you want integral and floating point types to work together nicely. For instance, the <code>length</code> function has a type declaration of <code>length :: [a] -&gt; Int</code> instead of having a more general type of <code>(Num b) =&gt; length :: [a] -&gt; b</code>. I think that's there for historical reasons or something, although in my opinion, it's pretty stupid. Anyway, if we try to get a length of a list and then add it to <code>3.2</code>, we'll get an error because we tried to add together an <code>Int</code> and a floating point number. So to get around this, we do <code>fromIntegral (length [1,2,3,4]) + 3.2</code> and it all works out.</p></div><div><p>Notice that <code>fromIntegral</code> has several class constraints in its type signature. That's completely valid and as you can see, the class constraints are separated by commas inside the parentheses.</p></div><div><h1 data-heading="Syntax in Functions" id="Syntax_in_Functions">Syntax in Functions</h1></div><div><h2 data-heading="Pattern matching" id="Pattern_matching" style="display: flex;"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>Pattern matching</h2></div><div><p><span alt="LYHfGG_19_pattern.png" src="LYHfGG_19_pattern.png" class="internal-embed media-embed image-embed is-loaded"><img alt="LYHfGG_19_pattern.png" src="курсы\learn-you-a-haskell-for-great-good!\картинки\lyhfgg_19_pattern.png"></span></p></div><div><p>This chapter will cover some of Haskell's cool syntactic constructs and we'll start with pattern matching. Pattern matching consists of specifying patterns to which some data should conform and then checking to see if it does and deconstructing the data according to those patterns.</p></div><div><p>When defining functions, you can define separate function bodies for different patterns. This leads to really neat code that's simple and readable. You can pattern match on any data type — numbers, characters, lists, tuples, etc. Let's make a really trivial function that checks if the number we supplied to it is a seven or not.</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">lucky</span> <span class="token operator">::</span> <span class="token punctuation">(</span><span class="token constant">Integral</span> <span class="token hvariable">a</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token hvariable">a</span> <span class="token operator">-&gt;</span> <span class="token constant">String</span>
<span class="token hvariable">lucky</span> <span class="token number">7</span> <span class="token operator">=</span> <span class="token string">"LUCKY NUMBER SEVEN!"</span>
<span class="token hvariable">lucky</span> <span class="token hvariable">x</span> <span class="token operator">=</span> <span class="token string">"Sorry, you're out of luck, pal!"</span> 
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>When you call <code>lucky</code>, the patterns will be checked from top to bottom and when it conforms to a pattern, the corresponding function body will be used. The only way a number can conform to the first pattern here is if it is 7. If it's not, it falls through to the second pattern, which matches anything and binds it to <code>x</code>. This function could have also been implemented by using an if statement. But what if we wanted a function that says the numbers from 1 to 5 and says <code>"Not between 1 and 5"</code> for any other number? Without pattern matching, we'd have to make a pretty convoluted if then else tree. However, with it:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">sayMe</span> <span class="token operator">::</span> <span class="token punctuation">(</span><span class="token constant">Integral</span> <span class="token hvariable">a</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token hvariable">a</span> <span class="token operator">-&gt;</span> <span class="token constant">String</span>
<span class="token hvariable">sayMe</span> <span class="token number">1</span> <span class="token operator">=</span> <span class="token string">"One!"</span>
<span class="token hvariable">sayMe</span> <span class="token number">2</span> <span class="token operator">=</span> <span class="token string">"Two!"</span>
<span class="token hvariable">sayMe</span> <span class="token number">3</span> <span class="token operator">=</span> <span class="token string">"Three!"</span>
<span class="token hvariable">sayMe</span> <span class="token number">4</span> <span class="token operator">=</span> <span class="token string">"Four!"</span>
<span class="token hvariable">sayMe</span> <span class="token number">5</span> <span class="token operator">=</span> <span class="token string">"Five!"</span>
<span class="token hvariable">sayMe</span> <span class="token hvariable">x</span> <span class="token operator">=</span> <span class="token string">"Not between 1 and 5"</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Note that if we moved the last pattern (the catch-all one) to the top, it would always say <code>"Not between 1 and 5"</code>, because it would catch all the numbers and they wouldn't have a chance to fall through and be checked for any other patterns.</p></div><div><p>Remember the factorial function we implemented previously? We defined the factorial of a number <code>n</code> as <code>product [1..n]</code>. We can also define a factorial function <em>recursively</em>, the way it is usually defined in mathematics. We start by saying that the factorial of 0 is 1. Then we state that the factorial of any positive integer is that integer multiplied by the factorial of its predecessor. Here's how that looks like translated in Haskell terms.</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">factorial</span> <span class="token operator">::</span> <span class="token punctuation">(</span><span class="token constant">Integral</span> <span class="token hvariable">a</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token hvariable">a</span> <span class="token operator">-&gt;</span> <span class="token hvariable">a</span>
<span class="token hvariable">factorial</span> <span class="token number">0</span> <span class="token operator">=</span> <span class="token number">1</span>
<span class="token hvariable">factorial</span> <span class="token hvariable">n</span> <span class="token operator">=</span> <span class="token hvariable">n</span> <span class="token operator">*</span> <span class="token hvariable">factorial</span> <span class="token punctuation">(</span><span class="token hvariable">n</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>This is the first time we've defined a function recursively. Recursion is important in Haskell and we'll take a closer look at it later. But in a nutshell, this is what happens if we try to get the factorial of, say, 3. It tries to compute <code>3 * factorial 2</code>. The factorial of 2 is <code>2 * factorial 1</code>, so for now we have <code>3 * (2 * factorial 1)</code>. <code>factorial 1</code> is <code>1 * factorial 0</code>, so we have <code>3 * (2 * (1 * factorial 0))</code>. Now here comes the trick — we've defined the factorial of 0 to be just 1 and because it encounters that pattern before the catch-all one, it just returns 1. So the final result is equivalent to <code>3 * (2 * (1 * 1))</code>. Had we written the second pattern on top of the first one, it would catch all numbers, including 0 and our calculation would never terminate. That's why order is important when specifying patterns and it's always best to specify the most specific ones first and then the more general ones later.</p></div><div><p>Pattern matching can also fail. If we define a function like this:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">charName</span> <span class="token operator">::</span> <span class="token constant">Char</span> <span class="token operator">-&gt;</span> <span class="token constant">String</span>
<span class="token hvariable">charName</span> <span class="token char string">'a'</span> <span class="token operator">=</span> <span class="token string">"Albert"</span>
<span class="token hvariable">charName</span> <span class="token char string">'b'</span> <span class="token operator">=</span> <span class="token string">"Broseph"</span>
<span class="token hvariable">charName</span> <span class="token char string">'c'</span> <span class="token operator">=</span> <span class="token string">"Cecil"</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>and then try to call it with an input that we didn't expect, this is what happens:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token hvariable">charName</span> <span class="token char string">'a'</span>
<span class="token string">"Albert"</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token hvariable">charName</span> <span class="token char string">'b'</span>
<span class="token string">"Broseph"</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token hvariable">charName</span> <span class="token char string">'h'</span>
"<span class="token operator">***</span> <span class="token constant">Exception</span><span class="token operator">:</span> <span class="token hvariable">tut</span><span class="token punctuation">.</span><span class="token hvariable">hs</span><span class="token operator">:</span><span class="token punctuation">(</span><span class="token number">53</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token operator">-</span><span class="token punctuation">(</span><span class="token number">55</span><span class="token punctuation">,</span><span class="token number">21</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token constant">Non</span><span class="token operator">-</span><span class="token hvariable">exhaustive</span> <span class="token hvariable">patterns</span> <span class="token keyword">in</span> <span class="token hvariable">function</span> <span class="token hvariable">charName</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>It complains that we have non-exhaustive patterns, and rightfully so. When making patterns, we should always include a catch-all pattern so that our program doesn't crash if we get some unexpected input.</p></div><div><p>Pattern matching can also be used on tuples. What if we wanted to make a function that takes two vectors in a 2D space (that are in the form of pairs) and adds them together? To add together two vectors, we add their x components separately and then their y components separately. Here's how we would have done it if we didn't know about pattern matching:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">addVectors</span> <span class="token operator">::</span> <span class="token punctuation">(</span><span class="token constant">Num</span> <span class="token hvariable">a</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">(</span><span class="token hvariable">a</span><span class="token punctuation">,</span> <span class="token hvariable">a</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token punctuation">(</span><span class="token hvariable">a</span><span class="token punctuation">,</span> <span class="token hvariable">a</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token punctuation">(</span><span class="token hvariable">a</span><span class="token punctuation">,</span> <span class="token hvariable">a</span><span class="token punctuation">)</span>
<span class="token hvariable">addVectors</span> <span class="token hvariable">a</span> <span class="token hvariable">b</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token builtin">fst</span> <span class="token hvariable">a</span> <span class="token operator">+</span> <span class="token builtin">fst</span> <span class="token hvariable">b</span><span class="token punctuation">,</span> <span class="token builtin">snd</span> <span class="token hvariable">a</span> <span class="token operator">+</span> <span class="token builtin">snd</span> <span class="token hvariable">b</span><span class="token punctuation">)</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Well, that works, but there's a better way to do it. Let's modify the function so that it uses pattern matching.</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">addVectors</span> <span class="token operator">::</span> <span class="token punctuation">(</span><span class="token constant">Num</span> <span class="token hvariable">a</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">(</span><span class="token hvariable">a</span><span class="token punctuation">,</span> <span class="token hvariable">a</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token punctuation">(</span><span class="token hvariable">a</span><span class="token punctuation">,</span> <span class="token hvariable">a</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token punctuation">(</span><span class="token hvariable">a</span><span class="token punctuation">,</span> <span class="token hvariable">a</span><span class="token punctuation">)</span>
<span class="token hvariable">addVectors</span> <span class="token punctuation">(</span><span class="token hvariable">x1</span><span class="token punctuation">,</span> <span class="token hvariable">y1</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token hvariable">x2</span><span class="token punctuation">,</span> <span class="token hvariable">y2</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token hvariable">x1</span> <span class="token operator">+</span> <span class="token hvariable">x2</span><span class="token punctuation">,</span> <span class="token hvariable">y1</span> <span class="token operator">+</span> <span class="token hvariable">y2</span><span class="token punctuation">)</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>There we go! Much better. Note that this is already a catch-all pattern. The type of <code>addVectors</code> (in both cases) is <code>addVectors :: (Num a) =&gt; (a, a) -&gt; (a, a) - &gt; (a, a)</code>, so we are guaranteed to get two pairs as parameters.</p></div><div><p><code>fst</code> and <code>snd</code> extract the components of pairs. But what about triples? Well, there are no provided functions that do that but we can make our own.</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">first</span> <span class="token operator">::</span> <span class="token punctuation">(</span><span class="token hvariable">a</span><span class="token punctuation">,</span> <span class="token hvariable">b</span><span class="token punctuation">,</span> <span class="token hvariable">c</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token hvariable">a</span>
<span class="token hvariable">first</span> <span class="token punctuation">(</span><span class="token hvariable">x</span><span class="token punctuation">,</span> <span class="token hvariable">_</span><span class="token punctuation">,</span> <span class="token hvariable">_</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token hvariable">x</span>

<span class="token hvariable">second</span> <span class="token operator">::</span> <span class="token punctuation">(</span><span class="token hvariable">a</span><span class="token punctuation">,</span> <span class="token hvariable">b</span><span class="token punctuation">,</span> <span class="token hvariable">c</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token hvariable">b</span>
<span class="token hvariable">second</span> <span class="token punctuation">(</span><span class="token hvariable">_</span><span class="token punctuation">,</span> <span class="token hvariable">y</span><span class="token punctuation">,</span> <span class="token hvariable">_</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token hvariable">y</span>

<span class="token hvariable">third</span> <span class="token operator">::</span> <span class="token punctuation">(</span><span class="token hvariable">a</span><span class="token punctuation">,</span> <span class="token hvariable">b</span><span class="token punctuation">,</span> <span class="token hvariable">c</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token hvariable">c</span>
<span class="token hvariable">third</span> <span class="token punctuation">(</span><span class="token hvariable">_</span><span class="token punctuation">,</span> <span class="token hvariable">_</span><span class="token punctuation">,</span> <span class="token hvariable">z</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token hvariable">z</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>The <code>_</code> means the same thing as it does in list comprehensions. It means that we really don't care what that part is, so we just write a <code>_</code>.</p></div><div><p>Which reminds me, you can also pattern match in list comprehensions. Check this out:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token keyword">let</span> <span class="token hvariable">xs</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">]</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token punctuation">[</span><span class="token hvariable">a</span><span class="token operator">+</span><span class="token hvariable">b</span> <span class="token operator">|</span> <span class="token punctuation">(</span><span class="token hvariable">a</span><span class="token punctuation">,</span><span class="token hvariable">b</span><span class="token punctuation">)</span> <span class="token operator">&lt;-</span> <span class="token hvariable">xs</span><span class="token punctuation">]</span>
<span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">7</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">,</span><span class="token number">8</span><span class="token punctuation">,</span><span class="token number">11</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">]</span> 
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Should a pattern match fail, it will just move on to the next element.</p></div><div><p>Lists themselves can also be used in pattern matching. You can match with the empty list <code>[]</code> or any pattern that involves <code>:</code> and the empty list. But since <code>[1,2,3]</code> is just syntactic sugar for <code>1:2:3:[]</code>, you can also use the former pattern. A pattern like <code>x:xs</code> will bind the head of the list to <code>x</code> and the rest of it to <code>xs</code>, even if there's only one element so <code>xs</code> ends up being an empty list.</p></div><div><blockquote>
<p><strong>Note</strong>: The <code>x:xs</code> pattern is used a lot, especially with recursive functions. But patterns that have <code>:</code> in them only match against lists of length 1 or more.</p>
</blockquote></div><div><p>If you want to bind, say, the first three elements to variables and the rest of the list to another variable, you can use something like <code>x:y:z:zs</code>. It will only match against lists that have three elements or more.</p></div><div><p>Now that we know how to pattern match against list, let's make our own implementation of the <code>head</code> function.</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token builtin">head</span>' <span class="token operator">::</span> <span class="token punctuation">[</span><span class="token hvariable">a</span><span class="token punctuation">]</span> <span class="token operator">-&gt;</span> <span class="token hvariable">a</span>
<span class="token builtin">head</span>' <span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token builtin">error</span> <span class="token string">"Can't call head on an empty list, dummy!"</span>
<span class="token builtin">head</span>' <span class="token punctuation">(</span><span class="token hvariable">x</span><span class="token operator">:</span><span class="token hvariable">_</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token hvariable">x</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Checking if it works:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token builtin">head</span>' <span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">]</span>
<span class="token number">4</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token builtin">head</span>' <span class="token string">"Hello"</span>
<span class="token char string">'H'</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Nice! Notice that if you want to bind to several variables (even if one of them is just <code>_</code> and doesn't actually bind at all), we have to surround them in parentheses. Also notice the <code>error</code> function that we used. It takes a string and generates a runtime error, using that string as information about what kind of error occurred. It causes the program to crash, so it's not good to use it too much. But calling <code>head</code> on an empty list doesn't make sense.</p></div><div><p>Let's make a trivial function that tells us some of the first elements of the list in (in)convenient English form.</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">tell</span> <span class="token operator">::</span> <span class="token punctuation">(</span><span class="token constant">Show</span> <span class="token hvariable">a</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">[</span><span class="token hvariable">a</span><span class="token punctuation">]</span> <span class="token operator">-&gt;</span> <span class="token constant">String</span>
<span class="token hvariable">tell</span> <span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">"The list is empty"</span>
<span class="token hvariable">tell</span> <span class="token punctuation">(</span><span class="token hvariable">x</span><span class="token operator">:</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token string">"The list has one element: "</span> <span class="token operator">++</span> <span class="token builtin">show</span> <span class="token hvariable">x</span>
<span class="token hvariable">tell</span> <span class="token punctuation">(</span><span class="token hvariable">x</span><span class="token operator">:</span><span class="token hvariable">y</span><span class="token operator">:</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token string">"The list has two elements: "</span> <span class="token operator">++</span> <span class="token builtin">show</span> <span class="token hvariable">x</span> <span class="token operator">++</span> <span class="token string">" and "</span> <span class="token operator">++</span> <span class="token builtin">show</span> <span class="token hvariable">y</span>
<span class="token hvariable">tell</span> <span class="token punctuation">(</span><span class="token hvariable">x</span><span class="token operator">:</span><span class="token hvariable">y</span><span class="token operator">:</span><span class="token hvariable">_</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token string">"This list is long. The first two elements are: "</span> <span class="token operator">++</span> <span class="token builtin">show</span> <span class="token hvariable">x</span> <span class="token operator">++</span> <span class="token string">" and "</span> <span class="token operator">++</span> <span class="token builtin">show</span> <span class="token hvariable">y</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>This function is safe because it takes care of the empty list, a singleton list, a list with two elements and a list with more than two elements. Note that <code>(x:[])</code> and <code>(x:y:[])</code> could be rewriten as <code>[x]</code> and <code>[x,y]</code> (because its syntatic sugar, we don't need the parentheses). We can't rewrite <code>(x:y:_)</code> with square brackets because it matches any list of length 2 or more.</p></div><div><p>We already implemented our own <code>length</code> function using list comprehension. Now we'll do it by using pattern matching and a little recursion:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token builtin">length</span>' <span class="token operator">::</span> <span class="token punctuation">(</span><span class="token constant">Num</span> <span class="token hvariable">b</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">[</span><span class="token hvariable">a</span><span class="token punctuation">]</span> <span class="token operator">-&gt;</span> <span class="token hvariable">b</span>
<span class="token builtin">length</span>' <span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span>
<span class="token builtin">length</span>' <span class="token punctuation">(</span><span class="token hvariable">_</span><span class="token operator">:</span><span class="token hvariable">xs</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token number">1</span> <span class="token operator">+</span> <span class="token builtin">length</span>' <span class="token hvariable">xs</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>This is similar to the factorial function we wrote earlier. First we defined the result of a known input — the empty list. This is also known as the edge condition. Then in the second pattern we take the list apart by splitting it into a head and a tail. We say that the length is equal to 1 plus the length of the tail. We use <code>_</code> to match the head because we don't actually care what it is. Also note that we've taken care of all possible patterns of a list. The first pattern matches an empty list and the second one matches anything that isn't an empty list.</p></div><div><p>Let's see what happens if we call <code>length'</code> on <code>"ham"</code>. First, it will check if it's an empty list. Because it isn't, it falls through to the second pattern. It matches on the second pattern and there it says that the length is <code>1 + length' "am"</code>, because we broke it into a head and a tail and discarded the head. O-kay. The <code>length'</code> of <code>"am"</code> is, similarly, <code>1 + length' "m"</code>. So right now we have <code>1 + (1 + length' "m")</code>. <code>length' "m"</code> is <code>1 + length' ""</code> (could also be written as <code>1 + length' []</code>). And we've defined <code>length' []</code> to be <code>0</code>. So in the end we have <code>1 + (1 + (1 + 0))</code>.</p></div><div><p>Let's implement <code>sum</code>. We know that the sum of an empty list is 0. We write that down as a pattern. And we also know that the sum of a list is the head plus the sum of the rest of the list. So if we write that down, we get:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token builtin">sum</span>' <span class="token operator">::</span> <span class="token punctuation">(</span><span class="token constant">Num</span> <span class="token hvariable">a</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">[</span><span class="token hvariable">a</span><span class="token punctuation">]</span> <span class="token operator">-&gt;</span> <span class="token hvariable">a</span>
<span class="token builtin">sum</span>' <span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span>
<span class="token builtin">sum</span>' <span class="token punctuation">(</span><span class="token hvariable">x</span><span class="token operator">:</span><span class="token hvariable">xs</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token hvariable">x</span> <span class="token operator">+</span> <span class="token builtin">sum</span>' <span class="token hvariable">xs</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>There's also a thing called <em>as patterns</em>. Those are a handy way of breaking something up according to a pattern and binding it to names whilst still keeping a reference to the whole thing. You do that by putting a name and an <code>@</code> in front of a pattern. For instance, the pattern <code>xs@(x:y:ys)</code>. This pattern will match exactly the same thing as <code>x:y:ys</code> but you can easily get the whole list via <code>xs</code> instead of repeating yourself by typing out <code>x:y:ys</code> in the function body again. Here's a quick and dirty example:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">capital</span> <span class="token operator">::</span> <span class="token constant">String</span> <span class="token operator">-&gt;</span> <span class="token constant">String</span>
<span class="token hvariable">capital</span> <span class="token string">""</span> <span class="token operator">=</span> <span class="token string">"Empty string, whoops!"</span>
<span class="token hvariable">capital</span> <span class="token builtin">all</span><span class="token operator">@</span><span class="token punctuation">(</span><span class="token hvariable">x</span><span class="token operator">:</span><span class="token hvariable">xs</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token string">"The first letter of "</span> <span class="token operator">++</span> <span class="token builtin">all</span> <span class="token operator">++</span> <span class="token string">" is "</span> <span class="token operator">++</span> <span class="token punctuation">[</span><span class="token hvariable">x</span><span class="token punctuation">]</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token hvariable">capital</span> <span class="token string">"Dracula"</span>
<span class="token string">"The first letter of Dracula is D"</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Normally we use as patterns to avoid repeating ourselves when matching against a bigger pattern when we have to use the whole thing again in the function body.</p></div><div><p>One more thing — you can't use <code>++</code> in pattern matches. If you tried to pattern match against <code>(xs ++ ys)</code>, what would be in the first and what would be in the second list? It doesn't make much sense. It would make sense to match stuff against <code>(xs ++ [x,y,z])</code> or just <code>(xs ++ [x])</code>, but because of the nature of lists, you can't do that.</p></div><div><h2 data-heading="Guards, guards!" id="Guards,_guards!" style="display: flex;"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>Guards, guards!</h2></div><div><p><span alt="LYHfGG_20_guards.png" src="LYHfGG_20_guards.png" class="internal-embed media-embed image-embed is-loaded"><img alt="LYHfGG_20_guards.png" src="курсы\learn-you-a-haskell-for-great-good!\картинки\lyhfgg_20_guards.png"></span></p></div><div><p>Whereas patterns are a way of making sure a value conforms to some form and deconstructing it, guards are a way of testing whether some property of a value (or several of them) are true or false. That sounds a lot like an if statement and it's very similar. The thing is that guards are a lot more readable when you have several conditions and they play really nicely with patterns.</p></div><div><p>Instead of explaining their syntax, let's just dive in and make a function using guards. We're going to make a simple function that berates you differently depending on your <a data-tooltip-position="top" aria-label="http://en.wikipedia.org/wiki/Body_mass_index" rel="noopener" class="external-link" href="http://en.wikipedia.org/wiki/Body_mass_index" target="_blank">BMI</a> (body mass index). Your BMI equals your weight divided by your height squared. If your BMI is less than 18.5, you're considered underweight. If it's anywhere from 18.5 to 25 then you're considered normal. 25 to 30 is overweight and more than 30 is obese. So here's the function (we won't be calculating it right now, this function just gets a BMI and tells you off)</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">bmiTell</span> <span class="token operator">::</span> <span class="token punctuation">(</span><span class="token constant">RealFloat</span> <span class="token hvariable">a</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token hvariable">a</span> <span class="token operator">-&gt;</span> <span class="token constant">String</span>
<span class="token hvariable">bmiTell</span> <span class="token hvariable">bmi</span>
    <span class="token operator">|</span> <span class="token hvariable">bmi</span> <span class="token operator">&lt;=</span> <span class="token number">18.5</span> <span class="token operator">=</span> <span class="token string">"You're underweight, you emo, you!"</span>
    <span class="token operator">|</span> <span class="token hvariable">bmi</span> <span class="token operator">&lt;=</span> <span class="token number">25.0</span> <span class="token operator">=</span> <span class="token string">"You're supposedly normal. Pffft, I bet you're ugly!"</span>
    <span class="token operator">|</span> <span class="token hvariable">bmi</span> <span class="token operator">&lt;=</span> <span class="token number">30.0</span> <span class="token operator">=</span> <span class="token string">"You're fat! Lose some weight, fatty!"</span>
    <span class="token operator">|</span> <span class="token builtin">otherwise</span>   <span class="token operator">=</span> <span class="token string">"You're a whale, congratulations!"</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Guards are indicated by pipes that follow a function's name and its parameters. Usually, they're indented a bit to the right and lined up. A guard is basically a boolean expression. If it evaluates to <code>True</code>, then the corresponding function body is used. If it evaluates to <code>False</code>, checking drops through to the next guard and so on. If we call this function with <code>24.3</code>, it will first check if that's smaller than or equal to <code>18.5</code>. Because it isn't, it falls through to the next guard. The check is carried out with the second guard and because 24.3 is less than 25.0, the second string is returned.</p></div><div><p>This is very reminiscent of a big if else tree in imperative languages, only this is far better and more readable. While big if else trees are usually frowned upon, sometimes a problem is defined in such a discrete way that you can't get around them. Guards are a very nice alternative for this.</p></div><div><p>Many times, the last guard is <code>otherwise</code>. <code>otherwise</code> is defined simply as <code>otherwise = True</code> and catches everything. This is very similar to patterns, only they check if the input satisfies a pattern but guards check for boolean conditions. If all the guards of a function evaluate to <code>False</code> (and we haven't provided an <code>otherwise</code> catch-all guard), evaluation falls through to the next <strong>pattern</strong>. That's how patterns and guards play nicely together. If no suitable guards or patterns are found, an error is thrown.</p></div><div><p>Of course we can use guards with functions that take as many parameters as we want. Instead of having the user calculate his own BMI before calling the function, let's modify this function so that it takes a height and weight and calculates it for us.</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">bmiTell</span> <span class="token operator">::</span> <span class="token punctuation">(</span><span class="token constant">RealFloat</span> <span class="token hvariable">a</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token hvariable">a</span> <span class="token operator">-&gt;</span> <span class="token hvariable">a</span> <span class="token operator">-&gt;</span> <span class="token constant">String</span>
<span class="token hvariable">bmiTell</span> <span class="token hvariable">weight</span> <span class="token hvariable">height</span>
    <span class="token operator">|</span> <span class="token hvariable">weight</span> <span class="token operator">/</span> <span class="token hvariable">height</span> <span class="token operator">^</span> <span class="token number">2</span> <span class="token operator">&lt;=</span> <span class="token number">18.5</span> <span class="token operator">=</span> <span class="token string">"You're underweight, you emo, you!"</span>
    <span class="token operator">|</span> <span class="token hvariable">weight</span> <span class="token operator">/</span> <span class="token hvariable">height</span> <span class="token operator">^</span> <span class="token number">2</span> <span class="token operator">&lt;=</span> <span class="token number">25.0</span> <span class="token operator">=</span> <span class="token string">"You're supposedly normal. Pffft, I bet you're ugly!"</span>
    <span class="token operator">|</span> <span class="token hvariable">weight</span> <span class="token operator">/</span> <span class="token hvariable">height</span> <span class="token operator">^</span> <span class="token number">2</span> <span class="token operator">&lt;=</span> <span class="token number">30.0</span> <span class="token operator">=</span> <span class="token string">"You're fat! Lose some weight, fatty!"</span>
    <span class="token operator">|</span> <span class="token builtin">otherwise</span>                 <span class="token operator">=</span> <span class="token string">"You're a whale, congratulations!"</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Let's see if I'm fat ...</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token hvariable">bmiTell</span> <span class="token number">85</span> <span class="token number">1.90</span>
<span class="token string">"You're supposedly normal. Pffft, I bet you're ugly!"</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Yay! I'm not fat! But Haskell just called me ugly. Whatever!</p></div><div><p>Note that there's no <code>=</code> right after the function name and its parameters, before the first guard. Many newbies get syntax errors because they sometimes put it there.</p></div><div><p>Another very simple example: let's implement our own <code>max</code> function. If you remember, it takes two things that can be compared and returns the larger of them.</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token builtin">max</span>' <span class="token operator">::</span> <span class="token punctuation">(</span><span class="token constant">Ord</span> <span class="token hvariable">a</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token hvariable">a</span> <span class="token operator">-&gt;</span> <span class="token hvariable">a</span> <span class="token operator">-&gt;</span> <span class="token hvariable">a</span>
<span class="token builtin">max</span>' <span class="token hvariable">a</span> <span class="token hvariable">b</span> 
    <span class="token operator">|</span> <span class="token hvariable">a</span> <span class="token operator">&gt;</span> <span class="token hvariable">b</span>     <span class="token operator">=</span> <span class="token hvariable">a</span>
    <span class="token operator">|</span> <span class="token builtin">otherwise</span> <span class="token operator">=</span> <span class="token hvariable">b</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Guards can also be written inline, although I'd advise against that because it's less readable, even for very short functions. But to demonstrate, we could write <code>max'</code> like this:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token builtin">max</span>' <span class="token operator">::</span> <span class="token punctuation">(</span><span class="token constant">Ord</span> <span class="token hvariable">a</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token hvariable">a</span> <span class="token operator">-&gt;</span> <span class="token hvariable">a</span> <span class="token operator">-&gt;</span> <span class="token hvariable">a</span>
<span class="token builtin">max</span>' <span class="token hvariable">a</span> <span class="token hvariable">b</span> <span class="token operator">|</span> <span class="token hvariable">a</span> <span class="token operator">&gt;</span> <span class="token hvariable">b</span> <span class="token operator">=</span> <span class="token hvariable">a</span> <span class="token operator">|</span> <span class="token builtin">otherwise</span> <span class="token operator">=</span> <span class="token hvariable">b</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Ugh! Not very readable at all! Moving on: let's implement our own <code>compare</code> by using guards.</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">myCompare</span> <span class="token operator">::</span> <span class="token punctuation">(</span><span class="token constant">Ord</span> <span class="token hvariable">a</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token hvariable">a</span> <span class="token operator">-&gt;</span> <span class="token hvariable">a</span> <span class="token operator">-&gt;</span> <span class="token constant">Ordering</span>
<span class="token hvariable">a</span> <span class="token operator">`myCompare`</span> <span class="token hvariable">b</span>
    <span class="token operator">|</span> <span class="token hvariable">a</span> <span class="token operator">&gt;</span> <span class="token hvariable">b</span>     <span class="token operator">=</span> <span class="token constant">GT</span>
    <span class="token operator">|</span> <span class="token hvariable">a</span> <span class="token operator">==</span> <span class="token hvariable">b</span>    <span class="token operator">=</span> <span class="token constant">EQ</span>
    <span class="token operator">|</span> <span class="token builtin">otherwise</span> <span class="token operator">=</span> <span class="token constant">LT</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token number">3</span> <span class="token operator">`myCompare`</span> <span class="token number">2</span>
<span class="token constant">GT</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><blockquote>
<p><strong>Note</strong> Not only can we call functions as infix with backticks, we can also define them using backticks. Sometimes it's easier to read that way.</p>
</blockquote></div><div><h2 data-heading="Where!?" id="Where!?" style="display: flex;"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>Where!?</h2></div><div><p>In the previous section, we defined a BMI calculator function and berator like this:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">bmiTell</span> <span class="token operator">::</span> <span class="token punctuation">(</span><span class="token constant">RealFloat</span> <span class="token hvariable">a</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token hvariable">a</span> <span class="token operator">-&gt;</span> <span class="token hvariable">a</span> <span class="token operator">-&gt;</span> <span class="token constant">String</span>
<span class="token hvariable">bmiTell</span> <span class="token hvariable">weight</span> <span class="token hvariable">height</span>
    <span class="token operator">|</span> <span class="token hvariable">weight</span> <span class="token operator">/</span> <span class="token hvariable">height</span> <span class="token operator">^</span> <span class="token number">2</span> <span class="token operator">&lt;=</span> <span class="token number">18.5</span> <span class="token operator">=</span> <span class="token string">"You're underweight, you emo, you!"</span>
    <span class="token operator">|</span> <span class="token hvariable">weight</span> <span class="token operator">/</span> <span class="token hvariable">height</span> <span class="token operator">^</span> <span class="token number">2</span> <span class="token operator">&lt;=</span> <span class="token number">25.0</span> <span class="token operator">=</span> <span class="token string">"You're supposedly normal. Pffft, I bet you're ugly!"</span>
    <span class="token operator">|</span> <span class="token hvariable">weight</span> <span class="token operator">/</span> <span class="token hvariable">height</span> <span class="token operator">^</span> <span class="token number">2</span> <span class="token operator">&lt;=</span> <span class="token number">30.0</span> <span class="token operator">=</span> <span class="token string">"You're fat! Lose some weight, fatty!"</span>
    <span class="token operator">|</span> <span class="token builtin">otherwise</span>                   <span class="token operator">=</span> <span class="token string">"You're a whale, congratulations!"</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Notice that we repeat ourselves here three times. We repeat ourselves three times. Repeating yourself (three times) while programming is about as desirable as getting kicked inna head. Since we repeat the same expression three times, it would be ideal if we could calculate it once, bind it to a name and then use that name instead of the expression. Well, we can modify our function like this:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">bmiTell</span> <span class="token operator">::</span> <span class="token punctuation">(</span><span class="token constant">RealFloat</span> <span class="token hvariable">a</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token hvariable">a</span> <span class="token operator">-&gt;</span> <span class="token hvariable">a</span> <span class="token operator">-&gt;</span> <span class="token constant">String</span>
<span class="token hvariable">bmiTell</span> <span class="token hvariable">weight</span> <span class="token hvariable">height</span>
    <span class="token operator">|</span> <span class="token hvariable">bmi</span> <span class="token operator">&lt;=</span> <span class="token number">18.5</span> <span class="token operator">=</span> <span class="token string">"You're underweight, you emo, you!"</span>
    <span class="token operator">|</span> <span class="token hvariable">bmi</span> <span class="token operator">&lt;=</span> <span class="token number">25.0</span> <span class="token operator">=</span> <span class="token string">"You're supposedly normal. Pffft, I bet you're ugly!"</span>
    <span class="token operator">|</span> <span class="token hvariable">bmi</span> <span class="token operator">&lt;=</span> <span class="token number">30.0</span> <span class="token operator">=</span> <span class="token string">"You're fat! Lose some weight, fatty!"</span>
    <span class="token operator">|</span> <span class="token builtin">otherwise</span>   <span class="token operator">=</span> <span class="token string">"You're a whale, congratulations!"</span>
    <span class="token keyword">where</span> <span class="token hvariable">bmi</span> <span class="token operator">=</span> <span class="token hvariable">weight</span> <span class="token operator">/</span> <span class="token hvariable">height</span> <span class="token operator">^</span> <span class="token number">2</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>We put the keyword <code>where</code> after the guards (usually it's best to indent it as much as the pipes are indented) and then we define several names or functions. These names are visible across the guards and give us the advantage of not having to repeat ourselves. If we decide that we want to calculate BMI a bit differently, we only have to change it once. It also improves readability by giving names to things and can make our programs faster since stuff like our <code>bmi</code> variable here is calculated only once. We could go a bit overboard and present our function like this:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">bmiTell</span> <span class="token operator">::</span> <span class="token punctuation">(</span><span class="token constant">RealFloat</span> <span class="token hvariable">a</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token hvariable">a</span> <span class="token operator">-&gt;</span> <span class="token hvariable">a</span> <span class="token operator">-&gt;</span> <span class="token constant">String</span>
<span class="token hvariable">bmiTell</span> <span class="token hvariable">weight</span> <span class="token hvariable">height</span>
    <span class="token operator">|</span> <span class="token hvariable">bmi</span> <span class="token operator">&lt;=</span> <span class="token hvariable">skinny</span> <span class="token operator">=</span> <span class="token string">"You're underweight, you emo, you!"</span>
    <span class="token operator">|</span> <span class="token hvariable">bmi</span> <span class="token operator">&lt;=</span> <span class="token hvariable">normal</span> <span class="token operator">=</span> <span class="token string">"You're supposedly normal. Pffft, I bet you're ugly!"</span>
    <span class="token operator">|</span> <span class="token hvariable">bmi</span> <span class="token operator">&lt;=</span> <span class="token hvariable">fat</span>    <span class="token operator">=</span> <span class="token string">"You're fat! Lose some weight, fatty!"</span>
    <span class="token operator">|</span> <span class="token builtin">otherwise</span>     <span class="token operator">=</span> <span class="token string">"You're a whale, congratulations!"</span>
    <span class="token keyword">where</span> <span class="token hvariable">bmi</span> <span class="token operator">=</span> <span class="token hvariable">weight</span> <span class="token operator">/</span> <span class="token hvariable">height</span> <span class="token operator">^</span> <span class="token number">2</span>
          <span class="token hvariable">skinny</span> <span class="token operator">=</span> <span class="token number">18.5</span>
          <span class="token hvariable">normal</span> <span class="token operator">=</span> <span class="token number">25.0</span>
          <span class="token hvariable">fat</span> <span class="token operator">=</span> <span class="token number">30.0</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>The names we define in the where section of a function are only visible to that function, so we don't have to worry about them polluting the namespace of other functions. Notice that all the names are aligned at a single column. If we don't align them nice and proper, Haskell gets confused because then it doesn't know they're all part of the same block.</p></div><div><p><em>where</em> bindings aren't shared across function bodies of different patterns. If you want several patterns of one function to access some shared name, you have to define it globally.</p></div><div><p>You can also use where bindings to <strong>pattern match</strong>! We could have rewritten the where section of our previous function as:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded">    <span class="token operator">...</span>
    <span class="token keyword">where</span> <span class="token hvariable">bmi</span> <span class="token operator">=</span> <span class="token hvariable">weight</span> <span class="token operator">/</span> <span class="token hvariable">height</span> <span class="token operator">^</span> <span class="token number">2</span>
          <span class="token punctuation">(</span><span class="token hvariable">skinny</span><span class="token punctuation">,</span> <span class="token hvariable">normal</span><span class="token punctuation">,</span> <span class="token hvariable">fat</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token number">18.5</span><span class="token punctuation">,</span> <span class="token number">25.0</span><span class="token punctuation">,</span> <span class="token number">30.0</span><span class="token punctuation">)</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Let's make another fairly trivial function where we get a first and a last name and give someone back their initials.</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">initials</span> <span class="token operator">::</span> <span class="token constant">String</span> <span class="token operator">-&gt;</span> <span class="token constant">String</span> <span class="token operator">-&gt;</span> <span class="token constant">String</span>
<span class="token hvariable">initials</span> <span class="token hvariable">firstname</span> <span class="token hvariable">lastname</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token hvariable">f</span><span class="token punctuation">]</span> <span class="token operator">++</span> <span class="token string">". "</span> <span class="token operator">++</span> <span class="token punctuation">[</span><span class="token hvariable">l</span><span class="token punctuation">]</span> <span class="token operator">++</span> <span class="token string">"."</span>
    <span class="token keyword">where</span> <span class="token punctuation">(</span><span class="token hvariable">f</span><span class="token operator">:</span><span class="token hvariable">_</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token hvariable">firstname</span>
          <span class="token punctuation">(</span><span class="token hvariable">l</span><span class="token operator">:</span><span class="token hvariable">_</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token hvariable">lastname</span>  
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>We could have done this pattern matching directly in the function's parameters (it would have been shorter and clearer actually) but this just goes to show that it's possible to do it in where bindings as well.</p></div><div><p>Just like we've defined constants in where blocks, you can also define functions. Staying true to our healthy programming theme, let's make a function that takes a list of weight-height pairs and returns a list of BMIs.</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">calcBmis</span> <span class="token operator">::</span> <span class="token punctuation">(</span><span class="token constant">RealFloat</span> <span class="token hvariable">a</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">[</span><span class="token punctuation">(</span><span class="token hvariable">a</span><span class="token punctuation">,</span> <span class="token hvariable">a</span><span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token operator">-&gt;</span> <span class="token punctuation">[</span><span class="token hvariable">a</span><span class="token punctuation">]</span>
<span class="token hvariable">calcBmis</span> <span class="token hvariable">xs</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token hvariable">bmi</span> <span class="token hvariable">w</span> <span class="token hvariable">h</span> <span class="token operator">|</span> <span class="token punctuation">(</span><span class="token hvariable">w</span><span class="token punctuation">,</span> <span class="token hvariable">h</span><span class="token punctuation">)</span> <span class="token operator">&lt;-</span> <span class="token hvariable">xs</span><span class="token punctuation">]</span>
    <span class="token keyword">where</span> <span class="token hvariable">bmi</span> <span class="token hvariable">weight</span> <span class="token hvariable">height</span> <span class="token operator">=</span> <span class="token hvariable">weight</span> <span class="token operator">/</span> <span class="token hvariable">height</span> <span class="token operator">^</span> <span class="token number">2</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>And that's all there is to it! The reason we had to introduce <code>bmi</code> as a function in this example is because we can't just calculate one BMI from the function's parameters. We have to examine the list passed to the function and there's a different BMI for every pair in there.</p></div><div><p><em>where</em> bindings can also be nested. It's a common idiom to make a function and define some helper function in its <em>where</em> clause and then to give those functions helper functions as well, each with its own <em>where</em> clause.</p></div><div><h2 data-heading="Let it be" id="Let_it_be" style="display: flex;"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>Let it be</h2></div><div><p>Very similar to where bindings are let bindings. Where bindings are a syntactic construct that let you bind to variables at the end of a function and the whole function can see them, including all the guards. Let bindings let you bind to variables anywhere and are expressions themselves, but are very local, so they don't span across guards. Just like any construct in Haskell that is used to bind values to names, let bindings can be used for pattern matching. Let's see them in action! This is how we could define a function that gives us a cylinder's surface area based on its height and radius:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">cylinder</span> <span class="token operator">::</span> <span class="token punctuation">(</span><span class="token constant">RealFloat</span> <span class="token hvariable">a</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token hvariable">a</span> <span class="token operator">-&gt;</span> <span class="token hvariable">a</span> <span class="token operator">-&gt;</span> <span class="token hvariable">a</span>
<span class="token hvariable">cylinder</span> <span class="token hvariable">r</span> <span class="token hvariable">h</span> <span class="token operator">=</span>
    <span class="token keyword">let</span> <span class="token hvariable">sideArea</span> <span class="token operator">=</span> <span class="token number">2</span> <span class="token operator">*</span> <span class="token builtin">pi</span> <span class="token operator">*</span> <span class="token hvariable">r</span> <span class="token operator">*</span> <span class="token hvariable">h</span>
        <span class="token hvariable">topArea</span> <span class="token operator">=</span> <span class="token builtin">pi</span> <span class="token operator">*</span> <span class="token hvariable">r</span> <span class="token operator">^</span><span class="token number">2</span>
    <span class="token keyword">in</span>  <span class="token hvariable">sideArea</span> <span class="token operator">+</span> <span class="token number">2</span> <span class="token operator">*</span> <span class="token hvariable">topArea</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p><span alt="LYHfGG_21_letitbe.png" src="LYHfGG_21_letitbe.png" class="internal-embed media-embed image-embed is-loaded"><img alt="LYHfGG_21_letitbe.png" src="курсы\learn-you-a-haskell-for-great-good!\картинки\lyhfgg_21_letitbe.png"></span></p></div><div><p>The form is <code>let &lt;bindings&gt; in &lt;expression&gt;</code>. The names that you define in the <em>let</em> part are accessible to the expression after the <em>in</em> part. As you can see, we could have also defined this with a <em>where</em> binding. Notice that the names are also aligned in a single column. So what's the difference between the two? For now it just seems that <em>let</em> puts the bindings first and the expression that uses them later whereas <em>where</em> is the other way around.</p></div><div><p>The difference is that <em>let</em> bindings are expressions themselves. <em>where</em> bindings are just syntactic constructs. Remember when we did the if statement and it was explained that an if else statement is an expression and you can cram it in almost anywhere?</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token punctuation">[</span><span class="token keyword">if</span> <span class="token number">5</span> <span class="token operator">&gt;</span> <span class="token number">3</span> <span class="token keyword">then</span> <span class="token string">"Woo"</span> <span class="token keyword">else</span> <span class="token string">"Boo"</span><span class="token punctuation">,</span> <span class="token keyword">if</span> <span class="token char string">'a'</span> <span class="token operator">&gt;</span> <span class="token char string">'b'</span> <span class="token keyword">then</span> <span class="token string">"Foo"</span> <span class="token keyword">else</span> <span class="token string">"Bar"</span><span class="token punctuation">]</span>
<span class="token punctuation">[</span><span class="token string">"Woo"</span><span class="token punctuation">,</span> <span class="token string">"Bar"</span><span class="token punctuation">]</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token number">4</span> <span class="token operator">*</span> <span class="token punctuation">(</span><span class="token keyword">if</span> <span class="token number">10</span> <span class="token operator">&gt;</span> <span class="token number">5</span> <span class="token keyword">then</span> <span class="token number">10</span> <span class="token keyword">else</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">2</span>
<span class="token number">42</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>You can also do that with let bindings.</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token number">4</span> <span class="token operator">*</span> <span class="token punctuation">(</span><span class="token keyword">let</span> <span class="token hvariable">a</span> <span class="token operator">=</span> <span class="token number">9</span> <span class="token keyword">in</span> <span class="token hvariable">a</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">2</span>
<span class="token number">42</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>They can also be used to introduce functions in a local scope:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token punctuation">[</span><span class="token keyword">let</span> <span class="token hvariable">square</span> <span class="token hvariable">x</span> <span class="token operator">=</span> <span class="token hvariable">x</span> <span class="token operator">*</span> <span class="token hvariable">x</span> <span class="token keyword">in</span> <span class="token punctuation">(</span><span class="token hvariable">square</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token hvariable">square</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token hvariable">square</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">]</span>
<span class="token punctuation">[</span><span class="token punctuation">(</span><span class="token number">25</span><span class="token punctuation">,</span><span class="token number">9</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">]</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>If we want to bind to several variables inline, we obviously can't align them at columns. That's why we can separate them with semicolons.</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token punctuation">(</span><span class="token keyword">let</span> <span class="token hvariable">a</span> <span class="token operator">=</span> <span class="token number">100</span><span class="token punctuation">;</span> <span class="token hvariable">b</span> <span class="token operator">=</span> <span class="token number">200</span><span class="token punctuation">;</span> <span class="token hvariable">c</span> <span class="token operator">=</span> <span class="token number">300</span> <span class="token keyword">in</span> <span class="token hvariable">a</span><span class="token operator">*</span><span class="token hvariable">b</span><span class="token operator">*</span><span class="token hvariable">c</span><span class="token punctuation">,</span> <span class="token keyword">let</span> <span class="token hvariable">foo</span><span class="token operator">=</span><span class="token string">"Hey "</span><span class="token punctuation">;</span> <span class="token hvariable">bar</span> <span class="token operator">=</span> <span class="token string">"there!"</span> <span class="token keyword">in</span> <span class="token hvariable">foo</span> <span class="token operator">++</span> <span class="token hvariable">bar</span><span class="token punctuation">)</span>
<span class="token punctuation">(</span><span class="token number">6000000</span><span class="token punctuation">,</span><span class="token string">"Hey there!"</span><span class="token punctuation">)</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>You don't have to put a semicolon after the last binding but you can if you want. Like we said before, you can pattern match with <em>let</em> bindings. They're very useful for quickly dismantling a tuple into components and binding them to names and such.</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token punctuation">(</span><span class="token keyword">let</span> <span class="token punctuation">(</span><span class="token hvariable">a</span><span class="token punctuation">,</span><span class="token hvariable">b</span><span class="token punctuation">,</span><span class="token hvariable">c</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">)</span> <span class="token keyword">in</span> <span class="token hvariable">a</span><span class="token operator">+</span><span class="token hvariable">b</span><span class="token operator">+</span><span class="token hvariable">c</span><span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token number">100</span>
<span class="token number">600</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>You can also put <em>let</em> bindings inside list comprehensions. Let's rewrite our previous example of calculating lists of weight-height pairs to use a <em>let</em> inside a list comprehension instead of defining an auxiliary function with a <em>where</em>.</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">calcBmis</span> <span class="token operator">::</span> <span class="token punctuation">(</span><span class="token constant">RealFloat</span> <span class="token hvariable">a</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">[</span><span class="token punctuation">(</span><span class="token hvariable">a</span><span class="token punctuation">,</span> <span class="token hvariable">a</span><span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token operator">-&gt;</span> <span class="token punctuation">[</span><span class="token hvariable">a</span><span class="token punctuation">]</span>
<span class="token hvariable">calcBmis</span> <span class="token hvariable">xs</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token hvariable">bmi</span> <span class="token operator">|</span> <span class="token punctuation">(</span><span class="token hvariable">w</span><span class="token punctuation">,</span> <span class="token hvariable">h</span><span class="token punctuation">)</span> <span class="token operator">&lt;-</span> <span class="token hvariable">xs</span><span class="token punctuation">,</span> <span class="token keyword">let</span> <span class="token hvariable">bmi</span> <span class="token operator">=</span> <span class="token hvariable">w</span> <span class="token operator">/</span> <span class="token hvariable">h</span> <span class="token operator">^</span> <span class="token number">2</span><span class="token punctuation">]</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>We include a <em>let</em> inside a list comprehension much like we would a predicate, only it doesn't filter the list, it only binds to names. The names defined in a <em>let</em> inside a list comprehension are visible to the output function (the part before the <code>|</code>) and all predicates and sections that come after of the binding. So we could make our function return only the BMIs of fat people:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">calcBmis</span> <span class="token operator">::</span> <span class="token punctuation">(</span><span class="token constant">RealFloat</span> <span class="token hvariable">a</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">[</span><span class="token punctuation">(</span><span class="token hvariable">a</span><span class="token punctuation">,</span> <span class="token hvariable">a</span><span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token operator">-&gt;</span> <span class="token punctuation">[</span><span class="token hvariable">a</span><span class="token punctuation">]</span>
<span class="token hvariable">calcBmis</span> <span class="token hvariable">xs</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token hvariable">bmi</span> <span class="token operator">|</span> <span class="token punctuation">(</span><span class="token hvariable">w</span><span class="token punctuation">,</span> <span class="token hvariable">h</span><span class="token punctuation">)</span> <span class="token operator">&lt;-</span> <span class="token hvariable">xs</span><span class="token punctuation">,</span> <span class="token keyword">let</span> <span class="token hvariable">bmi</span> <span class="token operator">=</span> <span class="token hvariable">w</span> <span class="token operator">/</span> <span class="token hvariable">h</span> <span class="token operator">^</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token hvariable">bmi</span> <span class="token operator">&gt;=</span> <span class="token number">25.0</span><span class="token punctuation">]</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>We can't use the <code>bmi</code> name in the <code>(w, h) &lt;- xs</code> part because it's defined prior to the <em>let</em> binding.</p></div><div><p>We omitted the <em>in</em> part of the <em>let</em> binding when we used them in list comprehensions because the visibility of the names is already predefined there. However, we could use a <em>let in</em> binding in a predicate and the names defined would only be visible to that predicate. The <em>in</em> part can also be omitted when defining functions and constants directly in GHCi. If we do that, then the names will be visible throughout the entire interactive session.</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token keyword">let</span> <span class="token hvariable">zoot</span> <span class="token hvariable">x</span> <span class="token hvariable">y</span> <span class="token hvariable">z</span> <span class="token operator">=</span> <span class="token hvariable">x</span> <span class="token operator">*</span> <span class="token hvariable">y</span> <span class="token operator">+</span> <span class="token hvariable">z</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token hvariable">zoot</span> <span class="token number">3</span> <span class="token number">9</span> <span class="token number">2</span>
<span class="token number">29</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token keyword">let</span> <span class="token hvariable">boot</span> <span class="token hvariable">x</span> <span class="token hvariable">y</span> <span class="token hvariable">z</span> <span class="token operator">=</span> <span class="token hvariable">x</span> <span class="token operator">*</span> <span class="token hvariable">y</span> <span class="token operator">+</span> <span class="token hvariable">z</span> <span class="token keyword">in</span> <span class="token hvariable">boot</span> <span class="token number">3</span> <span class="token number">4</span> <span class="token number">2</span>
<span class="token number">14</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token hvariable">boot</span>
<span class="token operator">&lt;</span><span class="token hvariable">interactive</span><span class="token operator">&gt;:</span><span class="token number">1</span><span class="token operator">:</span><span class="token number">0</span><span class="token operator">:</span> <span class="token constant">Not</span> <span class="token keyword">in</span> <span class="token hvariable">scope</span><span class="token operator">:</span> `<span class="token hvariable">boot'</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>If <em>let</em> bindings are so cool, why not use them all the time instead of <em>where</em> bindings, you ask? Well, since <em>let</em> bindings are expressions and are fairly local in their scope, they can't be used across guards. Some people prefer <em>where</em> bindings because the names come after the function they're being used in. That way, the function body is closer to its name and type declaration and to some that's more readable.</p></div><div><h2 data-heading="Case expressions" id="Case_expressions" style="display: flex;"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>Case expressions</h2></div><div><p><span alt="LYHfGG_22_case.png" src="LYHfGG_22_case.png" class="internal-embed media-embed image-embed is-loaded"><img alt="LYHfGG_22_case.png" src="курсы\learn-you-a-haskell-for-great-good!\картинки\lyhfgg_22_case.png"></span></p></div><div><p>Many imperative languages (C, C++, Java, etc.) have case syntax and if you've ever programmed in them, you probably know what it's about. It's about taking a variable and then executing blocks of code for specific values of that variable and then maybe including a catch-all block of code in case the variable has some value for which we didn't set up a case.</p></div><div><p>Haskell takes that concept and one-ups it. Like the name implies, case expressions are, well, expressions, much like if else expressions and <em>let</em> bindings. Not only can we evaluate expressions based on the possible cases of the value of a variable, we can also do pattern matching. Hmmm, taking a variable, pattern matching it, evaluating pieces of code based on its value, where have we heard this before? Oh yeah, pattern matching on parameters in function definitions! Well, that's actually just syntactic sugar for case expressions. These two pieces of code do the same thing and are interchangeable:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token builtin">head</span>' <span class="token operator">::</span> <span class="token punctuation">[</span><span class="token hvariable">a</span><span class="token punctuation">]</span> <span class="token operator">-&gt;</span> <span class="token hvariable">a</span>
<span class="token builtin">head</span>' <span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token builtin">error</span> <span class="token string">"No head for empty lists!"</span>
<span class="token builtin">head</span>' <span class="token punctuation">(</span><span class="token hvariable">x</span><span class="token operator">:</span><span class="token hvariable">_</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token hvariable">x</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token builtin">head</span>' <span class="token operator">::</span> <span class="token punctuation">[</span><span class="token hvariable">a</span><span class="token punctuation">]</span> <span class="token operator">-&gt;</span> <span class="token hvariable">a</span>
<span class="token builtin">head</span>' <span class="token hvariable">xs</span> <span class="token operator">=</span> <span class="token keyword">case</span> <span class="token hvariable">xs</span> <span class="token keyword">of</span> <span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">-&gt;</span> <span class="token builtin">error</span> <span class="token string">"No head for empty lists!"</span>
                      <span class="token punctuation">(</span><span class="token hvariable">x</span><span class="token operator">:</span><span class="token hvariable">_</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token hvariable">x</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>As you can see, the syntax for case expressions is pretty simple:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token keyword">case</span> <span class="token hvariable">expression</span> <span class="token keyword">of</span> <span class="token hvariable">pattern</span> <span class="token operator">-&gt;</span> <span class="token hvariable">result</span>
                   <span class="token hvariable">pattern</span> <span class="token operator">-&gt;</span> <span class="token hvariable">result</span>
                   <span class="token hvariable">pattern</span> <span class="token operator">-&gt;</span> <span class="token hvariable">result</span>
                   <span class="token operator">...</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p><code>expression</code> is matched against the patterns. The pattern matching action is the same as expected: the first pattern that matches the expression is used. If it falls through the whole case expression and no suitable pattern is found, a runtime error occurs.</p></div><div><p>Whereas pattern matching on function parameters can only be done when defining functions, case expressions can be used pretty much anywhere. For instance:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">describeList</span> <span class="token operator">::</span> <span class="token punctuation">[</span><span class="token hvariable">a</span><span class="token punctuation">]</span> <span class="token operator">-&gt;</span> <span class="token constant">String</span>
<span class="token hvariable">describeList</span> <span class="token hvariable">xs</span> <span class="token operator">=</span> <span class="token string">"The list is "</span> <span class="token operator">++</span> <span class="token keyword">case</span> <span class="token hvariable">xs</span> <span class="token keyword">of</span> <span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">-&gt;</span> <span class="token string">"empty."</span>
                                               <span class="token punctuation">[</span><span class="token hvariable">x</span><span class="token punctuation">]</span> <span class="token operator">-&gt;</span> <span class="token string">"a singleton list."</span> 
                                               <span class="token hvariable">xs</span> <span class="token operator">-&gt;</span> <span class="token string">"a longer list."</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>They are useful for pattern matching against something in the middle of an expression. Because pattern matching in function definitions is syntactic sugar for case expressions, we could have also defined this like so:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">describeList</span> <span class="token operator">::</span> <span class="token punctuation">[</span><span class="token hvariable">a</span><span class="token punctuation">]</span> <span class="token operator">-&gt;</span> <span class="token constant">String</span>
<span class="token hvariable">describeList</span> <span class="token hvariable">xs</span> <span class="token operator">=</span> <span class="token string">"The list is "</span> <span class="token operator">++</span> <span class="token hvariable">what</span> <span class="token hvariable">xs</span>
    <span class="token keyword">where</span> <span class="token hvariable">what</span> <span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">"empty."</span>
          <span class="token hvariable">what</span> <span class="token punctuation">[</span><span class="token hvariable">x</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">"a singleton list."</span>
          <span class="token hvariable">what</span> <span class="token hvariable">xs</span> <span class="token operator">=</span> <span class="token string">"a longer list."</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><h1 data-heading="Recursion" id="Recursion">Recursion</h1></div><div><h2 data-heading="Hello recursion!" id="Hello_recursion!" style="display: flex;"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>Hello recursion!</h2></div><div><p><span alt="LYHfGG_23_recursion.png" src="LYHfGG_23_recursion.png" class="internal-embed media-embed image-embed is-loaded"><img alt="LYHfGG_23_recursion.png" src="курсы\learn-you-a-haskell-for-great-good!\картинки\lyhfgg_23_recursion.png"></span></p></div><div><p>We mention recursion briefly in the previous chapter. In this chapter, we'll take a closer look at recursion, why it's important to Haskell and how we can work out very concise and elegant solutions to problems by thinking recursively.</p></div><div><p>If you still don't know what recursion is, read this sentence. Haha! Just kidding! Recursion is actually a way of defining functions in which the function is applied inside its own definition. Definitions in mathematics are often given recursively. For instance, the fibonacci sequence is defined recursively. First, we define the first two fibonacci numbers non-recursively. We say that <em>F(0) = 0</em> and <em>F(1) = 1</em>, meaning that the 0th and 1st fibonacci numbers are 0 and 1, respectively. Then we say that for any other natural number, that fibonacci number is the sum of the previous two fibonacci numbers. So <em>F(n) = F(n-1) + F(n-2)</em>. That way, <em>F(3)</em> is <em>F(2) + F(1)</em>, which is <em>(F(1) + F(0)) + F(1)</em>. Because we've now come down to only non-recursively defined fibonacci numbers, we can safely say that <em>F(3)</em> is 2. Having an element or two in a recursion definition defined non-recursively (like <em>F(0)</em> and <em>F(1)</em> here) is also called the <strong>edge condition</strong> and is important if you want your recursive function to terminate. If we hadn't defined <em>F(0)</em> and <em>F(1)</em> non recursively, you'd never get a solution any number because you'd reach 0 and then you'd go into negative numbers. All of a sudden, you'd be saying that <em>F(-2000)</em> is <em>F(-2001) + F(-2002)</em> and there still wouldn't be an end in sight!</p></div><div><p>Recursion is important to Haskell because unlike imperative languages, you do computations in Haskell by declaring what something <em>is</em> instead of declaring <em>how</em> you get it. That's why there are no while loops or for loops in Haskell and instead we many times have to use recursion to declare what something is.</p></div><div><h2 data-heading="Maximum awesome" id="Maximum_awesome" style="display: flex;"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>Maximum awesome</h2></div><div><p>The <code>maximum</code> function takes a list of things that can be ordered (e.g. instances of the <code>Ord</code> typeclass) and returns the biggest of them. Think about how you'd implement that in an imperative fashion. You'd probably set up a variable to hold the maximum value so far and then you'd loop through the elements of a list and if an element is bigger than then the current maximum value, you'd replace it with that element. The maximum value that remains at the end is the result. Whew! That's quite a lot of words to describe such a simple algorithm!</p></div><div><p>Now let's see how we'd define it recursively. We could first set up an edge condition and say that the maximum of a singleton list is equal to the only element in it. Then we can say that the maximum of a longer list is the head if the head is bigger than the maximum of the tail. If the maximum of the tail is bigger, well, then it's the maximum of the tail. That's it! Now let's implement that in Haskell.</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token builtin">maximum</span>' <span class="token operator">::</span> <span class="token punctuation">(</span><span class="token constant">Ord</span> <span class="token hvariable">a</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">[</span><span class="token hvariable">a</span><span class="token punctuation">]</span> <span class="token operator">-&gt;</span> <span class="token hvariable">a</span>
<span class="token builtin">maximum</span>' <span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token builtin">error</span> <span class="token string">"maximum of empty list"</span>
<span class="token builtin">maximum</span>' <span class="token punctuation">[</span><span class="token hvariable">x</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token hvariable">x</span>
<span class="token builtin">maximum</span>' <span class="token punctuation">(</span><span class="token hvariable">x</span><span class="token operator">:</span><span class="token hvariable">xs</span><span class="token punctuation">)</span> 
    <span class="token operator">|</span> <span class="token hvariable">x</span> <span class="token operator">&gt;</span> <span class="token hvariable">maxTail</span> <span class="token operator">=</span> <span class="token hvariable">x</span>
    <span class="token operator">|</span> <span class="token builtin">otherwise</span> <span class="token operator">=</span> <span class="token hvariable">maxTail</span>
    <span class="token keyword">where</span> <span class="token hvariable">maxTail</span> <span class="token operator">=</span> <span class="token builtin">maximum</span>' <span class="token hvariable">xs</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>As you can see, pattern matching goes great with recursion! Most imperative languages don't have pattern matching so you have to make a lot of if else statements to test for edge conditions. Here, we simply put them out as patterns. So the first edge condition says that if the list is empty, crash! Makes sense because what's the maximum of an empty list? I don't know. The second pattern also lays out an edge condition. It says that if it's the singleton list, just give back the only element.</p></div><div><p>Now the third pattern is where the action happens. We use pattern matching to split a list into a head and a tail. This is a very common idiom when doing recursion with lists, so get used to it. We use a <em>where</em> binding to define <code>maxTail</code> as the maximum of the rest of the list. Then we check if the head is greater than the maximum of the rest of the list. If it is, we return the head. Otherwise, we return the maximum of the rest of the list.</p></div><div><p>Let's take an example list of numbers and check out how this would work on them: <code>[2,5,1]</code>. If we call <code>maximum'</code> on that, the first two patterns won't match. The third one will and the list is split into <code>2</code> and <code>[5,1]</code>. The <em>where</em> clause wants to know the maximum of <code>[5,1]</code>, so we follow that route. It matches the third pattern again and <code>[5,1]</code> is split into <code>5</code> and <code>[1]</code>. Again, the <code>where</code> clause wants to know the maximum of <code>[1]</code>. Because that's the edge condition, it returns <code>1</code>. Finally! So going up one step, comparing <code>5</code> to the maximum of <code>[1]</code> (which is <code>1</code>), we obviously get back <code>5</code>. So now we know that the maximum of <code>[5,1]</code> is <code>5</code>. We go up one step again where we had <code>2</code> and <code>[5,1]</code>. Comparing <code>2</code> with the maximum of <code>[5,1]</code>, which is <code>5</code>, we choose <code>5</code>.</p></div><div><p>An even clearer way to write this function is to use <code>max</code>. If you remember, <code>max</code> is a function that takes two numbers and returns the bigger of them. Here's how we could rewrite <code>maximum'</code> by using <code>max</code>:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token builtin">maximum</span>' <span class="token operator">::</span> <span class="token punctuation">(</span><span class="token constant">Ord</span> <span class="token hvariable">a</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">[</span><span class="token hvariable">a</span><span class="token punctuation">]</span> <span class="token operator">-&gt;</span> <span class="token hvariable">a</span>
<span class="token builtin">maximum</span>' <span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token builtin">error</span> <span class="token string">"maximum of empty list"</span>
<span class="token builtin">maximum</span>' <span class="token punctuation">[</span><span class="token hvariable">x</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token hvariable">x</span>
<span class="token builtin">maximum</span>' <span class="token punctuation">(</span><span class="token hvariable">x</span><span class="token operator">:</span><span class="token hvariable">xs</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token builtin">max</span> <span class="token hvariable">x</span> <span class="token punctuation">(</span><span class="token builtin">maximum</span>' <span class="token hvariable">xs</span><span class="token punctuation">)</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>How's that for elegant! In essence, the maximum of a list is the max of the first element and the maximum of the tail.</p></div><div><p><span alt="LYHfGG_24_maxs.png" src="LYHfGG_24_maxs.png" class="internal-embed media-embed image-embed is-loaded"><img alt="LYHfGG_24_maxs.png" src="курсы\learn-you-a-haskell-for-great-good!\картинки\lyhfgg_24_maxs.png"></span></p></div><div><h2 data-heading="A few more recursive functions" id="A_few_more_recursive_functions" style="display: flex;"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>A few more recursive functions</h2></div><div><p>Now that we know how to generally think recursively, let's implement a few functions using recursion. First off, we'll implement <code>replicate</code>. <code>replicate</code> takes an <code>Int</code> and some element and returns a list that has several repetitions of the same element. For instance, <code>replicate 3 5</code> returns <code>[5,5,5]</code>. Let's think about the edge condition. My guess is that the edge condition is 0 or less. If we try to replicate something zero times, it should return an empty list. Also for negative numbers, because it doesn't really make sense.</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token builtin">replicate</span>' <span class="token operator">::</span> <span class="token punctuation">(</span><span class="token constant">Num</span> <span class="token hvariable">i</span><span class="token punctuation">,</span> <span class="token constant">Ord</span> <span class="token hvariable">i</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token hvariable">i</span> <span class="token operator">-&gt;</span> <span class="token hvariable">a</span> <span class="token operator">-&gt;</span> <span class="token punctuation">[</span><span class="token hvariable">a</span><span class="token punctuation">]</span>
<span class="token builtin">replicate</span>' <span class="token hvariable">n</span> <span class="token hvariable">x</span>
    <span class="token operator">|</span> <span class="token hvariable">n</span> <span class="token operator">&lt;=</span> <span class="token number">0</span>    <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
    <span class="token operator">|</span> <span class="token builtin">otherwise</span> <span class="token operator">=</span> <span class="token hvariable">x</span><span class="token operator">:</span><span class="token builtin">replicate</span>' <span class="token punctuation">(</span><span class="token hvariable">n</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token hvariable">x</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>We used guards here instead of patterns because we're testing for a boolean condition. If <code>n</code> is less than or equal to 0, return an empty list. Otherwise return a list that has <code>x</code> as the first element and then <code>x</code> replicated n-1 times as the tail. Eventually, the <code>(n-1)</code> part will cause our function to reach the edge condition.</p></div><div><blockquote>
<p><strong>Note</strong> <code>Num</code> is not a subclass of <code>Ord</code>. That means that what constitutes for a number doesn't really have to adhere to an ordering. So that's why we have to specify both the <code>Num</code> and <code>Ord</code> class constraints when doing addition or subtraction and also comparison.</p>
</blockquote></div><div><p>Next up, we'll implement <code>take</code>. It takes a certain number of elements from a list. For instance, <code>take 3 [5,4,3,2,1]</code> will return <code>[5,4,3]</code>. If we try to take 0 or less elements from a list, we get an empty list. Also if we try to take anything from an empty list, we get an empty list. Notice that those are two edge conditions right there. So let's write that out:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token builtin">take</span>' <span class="token operator">::</span> <span class="token punctuation">(</span><span class="token constant">Num</span> <span class="token hvariable">i</span><span class="token punctuation">,</span> <span class="token constant">Ord</span> <span class="token hvariable">i</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token hvariable">i</span> <span class="token operator">-&gt;</span> <span class="token punctuation">[</span><span class="token hvariable">a</span><span class="token punctuation">]</span> <span class="token operator">-&gt;</span> <span class="token punctuation">[</span><span class="token hvariable">a</span><span class="token punctuation">]</span>
<span class="token builtin">take</span>' <span class="token hvariable">n</span> <span class="token hvariable">_</span>
    <span class="token operator">|</span> <span class="token hvariable">n</span> <span class="token operator">&lt;=</span> <span class="token number">0</span>   <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
<span class="token builtin">take</span>' <span class="token hvariable">_</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>     <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
<span class="token builtin">take</span>' <span class="token hvariable">n</span> <span class="token punctuation">(</span><span class="token hvariable">x</span><span class="token operator">:</span><span class="token hvariable">xs</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token hvariable">x</span> <span class="token operator">:</span> <span class="token builtin">take</span>' <span class="token punctuation">(</span><span class="token hvariable">n</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token hvariable">xs</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p><span alt="LYHfGG_25_painter.png" src="LYHfGG_25_painter.png" class="internal-embed media-embed image-embed is-loaded"><img alt="LYHfGG_25_painter.png" src="курсы\learn-you-a-haskell-for-great-good!\картинки\lyhfgg_25_painter.png"></span></p></div><div><p>The first pattern specifies that if we try to take a 0 or negative number of elements, we get an empty list. Notice that we're using <code>_</code> to match the list because we don't really care what it is in this case. Also notice that we use a guard, but without an <code>otherwise</code> part. That means that if <code>n</code> turns out to be more than 0, the matching will fall through to the next pattern. The second pattern indicates that if we try to take anything from an empty list, we get an empty list. The third pattern breaks the list into a head and a tail. And then we state that taking <code>n</code> elements from a list equals a list that has <code>x</code> as the head and then a list that takes <code>n-1</code> elements from the tail as a tail. Try using a piece of paper to write down how the evaluation would look like if we try to take, say, 3 from <code>[4,3,2,1]</code>.</p></div><div><p><code>reverse</code> simply reverses a list. Think about the edge condition. What is it? Come on ... it's the empty list! An empty list reversed equals the empty list itself. O-kay. What about the rest of it? Well, you could say that if we split a list to a head and a tail, the reversed list is equal to the reversed tail and then the head at the end.</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token builtin">reverse</span>' <span class="token operator">::</span> <span class="token punctuation">[</span><span class="token hvariable">a</span><span class="token punctuation">]</span> <span class="token operator">-&gt;</span> <span class="token punctuation">[</span><span class="token hvariable">a</span><span class="token punctuation">]</span>
<span class="token builtin">reverse</span>' <span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
<span class="token builtin">reverse</span>' <span class="token punctuation">(</span><span class="token hvariable">x</span><span class="token operator">:</span><span class="token hvariable">xs</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token builtin">reverse</span>' <span class="token hvariable">xs</span> <span class="token operator">++</span> <span class="token punctuation">[</span><span class="token hvariable">x</span><span class="token punctuation">]</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>There we go!</p></div><div><p>Because Haskell supports infinite lists, our recursion doesn't really have to have an edge condition. But if it doesn't have it, it will either keep churning at something infinitely or produce an infinite data structure, like an infinite list. The good thing about infinite lists though is that we can cut them where we want. <code>repeat</code> takes an element and returns an infinite list that just has that element. A recursive implementation of that is really easy, watch.</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token builtin">repeat</span>' <span class="token operator">::</span> <span class="token hvariable">a</span> <span class="token operator">-&gt;</span> <span class="token punctuation">[</span><span class="token hvariable">a</span><span class="token punctuation">]</span>
<span class="token builtin">repeat</span>' <span class="token hvariable">x</span> <span class="token operator">=</span> <span class="token hvariable">x</span><span class="token operator">:</span><span class="token builtin">repeat</span>' <span class="token hvariable">x</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Calling <code>repeat 3</code> will give us a list that starts with <code>3</code> and then has an infinite amount of 3's as a tail. So calling <code>repeat 3</code> would evaluate like <code>3:repeat 3</code>, which is <code>3:(3:repeat 3)</code>, which is <code>3:(3:(3:repeat 3))</code>, etc. <code>repeat 3</code> will never finish evaluating, whereas <code>take 5 (repeat 3)</code> will give us a list of five 3's. So essentially it's like doing <code>replicate 5 3</code>.</p></div><div><p><code>zip</code> takes two lists and zips them together. <code>zip [1,2,3] [2,3]</code> returns <code>[(1,2),(2,3)]</code>, because it truncates the longer list to match the length of the shorter one. How about if we zip something with an empty list? Well, we get an empty list back then. So there's our edge condition. However, <code>zip</code> takes two lists as parameters, so there are actually two edge conditions.</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token builtin">zip</span>' <span class="token operator">::</span> <span class="token punctuation">[</span><span class="token hvariable">a</span><span class="token punctuation">]</span> <span class="token operator">-&gt;</span> <span class="token punctuation">[</span><span class="token hvariable">b</span><span class="token punctuation">]</span> <span class="token operator">-&gt;</span> <span class="token punctuation">[</span><span class="token punctuation">(</span><span class="token hvariable">a</span><span class="token punctuation">,</span><span class="token hvariable">b</span><span class="token punctuation">)</span><span class="token punctuation">]</span>
<span class="token builtin">zip</span>' <span class="token hvariable">_</span> <span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
<span class="token builtin">zip</span>' <span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token hvariable">_</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
<span class="token builtin">zip</span>' <span class="token punctuation">(</span><span class="token hvariable">x</span><span class="token operator">:</span><span class="token hvariable">xs</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token hvariable">y</span><span class="token operator">:</span><span class="token hvariable">ys</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token hvariable">x</span><span class="token punctuation">,</span><span class="token hvariable">y</span><span class="token punctuation">)</span><span class="token operator">:</span><span class="token builtin">zip</span>' <span class="token hvariable">xs</span> <span class="token hvariable">ys</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>First two patterns say that if the first list or second list is empty, we get an empty list. The third one says that two lists zipped are equal to pairing up their heads and then tacking on the zipped tails. Zipping <code>[1,2,3]</code> and <code>['a','b']</code> will eventually try to zip <code>[3]</code> with <code>[]</code>. The edge condition patterns kick in and so the result is <code>(1,'a'):(2,'b'):[]</code>, which is exactly the same as <code>[(1,'a'),(2,'b')]</code>.</p></div><div><p>Let's implement one more standard library function — <code>elem</code>. It takes an element and a list and sees if that element is in the list. The edge condition, as is most of the times with lists, is the empty list. We know that an empty list contains no elements, so it certainly doesn't have the droids we're looking for.</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token builtin">elem</span>' <span class="token operator">::</span> <span class="token punctuation">(</span><span class="token constant">Eq</span> <span class="token hvariable">a</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token hvariable">a</span> <span class="token operator">-&gt;</span> <span class="token punctuation">[</span><span class="token hvariable">a</span><span class="token punctuation">]</span> <span class="token operator">-&gt;</span> <span class="token constant">Bool</span>
<span class="token builtin">elem</span>' <span class="token hvariable">a</span> <span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token constant">False</span>
<span class="token builtin">elem</span>' <span class="token hvariable">a</span> <span class="token punctuation">(</span><span class="token hvariable">x</span><span class="token operator">:</span><span class="token hvariable">xs</span><span class="token punctuation">)</span>
    <span class="token operator">|</span> <span class="token hvariable">a</span> <span class="token operator">==</span> <span class="token hvariable">x</span>    <span class="token operator">=</span> <span class="token constant">True</span>
    <span class="token operator">|</span> <span class="token builtin">otherwise</span> <span class="token operator">=</span> <span class="token hvariable">a</span> <span class="token operator">`elem'`</span> <span class="token hvariable">xs</span> 
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Pretty simple and expected. If the head isn't the element then we check the tail. If we reach an empty list, the result is <code>False</code>.</p></div><div><h2 data-heading="Quick, sort!" id="Quick,_sort!" style="display: flex;"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>Quick, sort!</h2></div><div><p>We have a list of items that can be sorted. Their type is an instance of the <code>Ord</code> typeclass. And now, we want to sort them! There's a very cool algoritm for sorting called quicksort. It's a very clever way of sorting items. While it takes upwards of 10 lines to implement quicksort in imperative languages, the implementation is much shorter and elegant in Haskell. Quicksort has become a sort of poster child for Haskell. Therefore, let's implement it here, even though implementing quicksort in Haskell is considered really cheesy because everyone does it to showcase how elegant Haskell is.</p></div><div><p><span alt="LYHfGG_26_quickman.png" src="LYHfGG_26_quickman.png" class="internal-embed media-embed image-embed is-loaded"><img alt="LYHfGG_26_quickman.png" src="курсы\learn-you-a-haskell-for-great-good!\картинки\lyhfgg_26_quickman.png"></span></p></div><div><p>So, the type signature is going to be <code>quicksort :: (Ord a) =&gt; [a] -&gt; [a]</code>. No surprises there. The edge condition? Empty list, as is expected. A sorted empty list is an empty list. Now here comes the main algorithm: <strong>a sorted list is a list that has all the values smaller than (or equal to) the head of the list in front (and those values are sorted), then comes the head of the list in the middle and then come all the values that are bigger than the head (they're also sorted).</strong> Notice that we said <em>sorted</em> two times in this definition, so we'll probably have to make the recursive call twice! Also notice that we defined it using the verb <em>is</em> to define the algorithm instead of saying <em>do this, do that, then do that ...</em>. That's the beauty of functional programming! How are we going to filter the list so that we get only the elements smaller than the head of our list and only elements that are bigger? List comprehensions. So, let's dive in and define this function.</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">quicksort</span> <span class="token operator">::</span> <span class="token punctuation">(</span><span class="token constant">Ord</span> <span class="token hvariable">a</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">[</span><span class="token hvariable">a</span><span class="token punctuation">]</span> <span class="token operator">-&gt;</span> <span class="token punctuation">[</span><span class="token hvariable">a</span><span class="token punctuation">]</span>
<span class="token hvariable">quicksort</span> <span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
<span class="token hvariable">quicksort</span> <span class="token punctuation">(</span><span class="token hvariable">x</span><span class="token operator">:</span><span class="token hvariable">xs</span><span class="token punctuation">)</span> <span class="token operator">=</span> 
    <span class="token keyword">let</span> <span class="token hvariable">smallerSorted</span> <span class="token operator">=</span> <span class="token hvariable">quicksort</span> <span class="token punctuation">[</span><span class="token hvariable">a</span> <span class="token operator">|</span> <span class="token hvariable">a</span> <span class="token operator">&lt;-</span> <span class="token hvariable">xs</span><span class="token punctuation">,</span> <span class="token hvariable">a</span> <span class="token operator">&lt;=</span> <span class="token hvariable">x</span><span class="token punctuation">]</span>
        <span class="token hvariable">biggerSorted</span> <span class="token operator">=</span> <span class="token hvariable">quicksort</span> <span class="token punctuation">[</span><span class="token hvariable">a</span> <span class="token operator">|</span> <span class="token hvariable">a</span> <span class="token operator">&lt;-</span> <span class="token hvariable">xs</span><span class="token punctuation">,</span> <span class="token hvariable">a</span> <span class="token operator">&gt;</span> <span class="token hvariable">x</span><span class="token punctuation">]</span>
    <span class="token keyword">in</span>  <span class="token hvariable">smallerSorted</span> <span class="token operator">++</span> <span class="token punctuation">[</span><span class="token hvariable">x</span><span class="token punctuation">]</span> <span class="token operator">++</span> <span class="token hvariable">biggerSorted</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Let's give it a small test run to see if it appears to behave correctly.</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token hvariable">quicksort</span> <span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">,</span><span class="token number">7</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">8</span><span class="token punctuation">,</span><span class="token number">9</span><span class="token punctuation">]</span>
<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">,</span><span class="token number">7</span><span class="token punctuation">,</span><span class="token number">8</span><span class="token punctuation">,</span><span class="token number">9</span><span class="token punctuation">,</span><span class="token number">10</span><span class="token punctuation">]</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token hvariable">quicksort</span> <span class="token string">"the quick brown fox jumps over the lazy dog"</span>
<span class="token string">"        abcdeeefghhijklmnoooopqrrsttuuvwxyz"</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Booyah! That's what I'm talking about! So if we have, say <code>[5,1,9,4,6,7,3]</code> and we want to sort it, this algorithm will first take the head, which is <code>5</code> and then put it in the middle of two lists that are smaller and bigger than it. So at one point, you'll have <code>[1,4,3] ++ [5] ++ [9,6,7]</code>. We know that once the list is sorted completely, the number <code>5</code> will stay in the fourth place since there are 3 numbers lower than it and 3 numbers higher than it. Now, if we sort <code>[1,4,3]</code> and <code>[9,6,7]</code>, we have a sorted list! We sort the two lists using the same function. Eventually, we'll break it up so much that we reach empty lists and an empty list is already sorted in a way, by virtue of being empty. Here's an illustration:</p></div><div><p><span alt="LYHfGG_27_quicksort.png" src="LYHfGG_27_quicksort.png" class="internal-embed media-embed image-embed is-loaded"><img alt="LYHfGG_27_quicksort.png" src="курсы\learn-you-a-haskell-for-great-good!\картинки\lyhfgg_27_quicksort.png"></span></p></div><div><p>An element that is in place and won't move anymore is represented in <code>orange</code>. If you read them from left to right, you'll see the sorted list. Although we chose to compare all the elements to the heads, we could have used any element to compare against. In quicksort, an element that you compare against is called a pivot. They're in <code>green</code> here. We chose the head because it's easy to get by pattern matching. The elements that are smaller than the pivot are <code>light green</code> and elements larger than the pivot are <code>dark green</code>. The yellowish gradient thing represents an application of quicksort.</p></div><div><h2 data-heading="Thinking recursively" id="Thinking_recursively" style="display: flex;"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>Thinking recursively</h2></div><div><p>We did quite a bit of recursion so far and as you've probably noticed, there's a pattern here. Usually you define an edge case and then you define a function that does something between some element and the function applied to the rest. It doesn't matter if it's a list, a tree or any other data structure. A sum is the first element of a list plus the sum of the rest of the list. A product of a list is the first element of the list times the product of the rest of the list. The length of a list is one plus the length of the tail of the list. Ekcetera, ekcetera ...</p></div><div><p><span alt="LYHfGG_28_brain.png" src="LYHfGG_28_brain.png" class="internal-embed media-embed image-embed is-loaded"><img alt="LYHfGG_28_brain.png" src="курсы\learn-you-a-haskell-for-great-good!\картинки\lyhfgg_28_brain.png"></span></p></div><div><p>Of course, these also have edge cases. Usually the edge case is some scenario where a recursive application doesn't make sense. When dealing with lists, the edge case is most often the empty list. If you're dealing with trees, the edge case is usually a node that doesn't have any children.</p></div><div><p>It's similar when you're dealing with numbers recursively. Usually it has to do with some number and the function applied to that number modified. We did the factorial function earlier and it's the product of a number and the factorial of that number minus one. Such a recursive application doesn't make sense with zero, because factorials are defined only for positive integers. Often the edge case value turns out to be an identity. The identity for multiplication is 1 because if you multiply something by 1, you get that something back. Also when doing sums of lists, we define the sum of an empty list as 0 and 0 is the identity for addition. In quicksort, the edge case is the empty list and the identity is also the empty list, because if you add an empty list to a list, you just get the original list back.</p></div><div><p>So when trying to think of a recursive way to solve a problem, try to think of when a recursive solution doesn't apply and see if you can use that as an edge case, think about identities and think about whether you'll break apart the parameters of the function (for instance, lists are usually broken into a head and a tail via pattern matching) and on which part you'll use the recursive call.</p></div><div><h1 data-heading="Higher order functions" id="Higher_order_functions">Higher order functions</h1></div><div><p><span alt="LYHfGG_29_sun.png" src="LYHfGG_29_sun.png" class="internal-embed media-embed image-embed is-loaded"><img alt="LYHfGG_29_sun.png" src="курсы\learn-you-a-haskell-for-great-good!\картинки\lyhfgg_29_sun.png"></span></p></div><div><p>Haskell functions can take functions as parameters and return functions as return values. A function that does either of those is called a higher order function. Higher order functions aren't just a part of the Haskell experience, they pretty much are the Haskell experience. It turns out that if you want to define computations by defining what stuff <em>is</em> instead of defining steps that change some state and maybe looping them, higher order functions are indispensable. They're a really powerful way of solving problems and thinking about programs.</p></div><div><h2 data-heading="Curried functions" id="Curried_functions" style="display: flex;"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>Curried functions</h2></div><div><p>Every function in Haskell officially only takes one parameter. So how is it possible that we defined and used several functions that take more than one parameter so far? Well, it's a clever trick! All the functions that accepted <em>several parameters</em> so far have been <strong>curried functions</strong>. What does that mean? You'll understand it best on an example. Let's take our good friend, the <code>max</code> function. It looks like it takes two parameters and returns the one that's bigger. Doing <code>max 4 5</code> first creates a function that takes a parameter and returns either <code>4</code> or that parameter, depending on which is bigger. Then, <code>5</code> is applied to that function and that function produces our desired result. That sounds like a mouthful but it's actually a really cool concept. The following two calls are equivalent:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token builtin">max</span> <span class="token number">4</span> <span class="token number">5</span>
<span class="token number">5</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token punctuation">(</span><span class="token builtin">max</span> <span class="token number">4</span><span class="token punctuation">)</span> <span class="token number">5</span>
<span class="token number">5</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p><span alt="LYHfGG_30_curry.png" src="LYHfGG_30_curry.png" class="internal-embed media-embed image-embed is-loaded"><img alt="LYHfGG_30_curry.png" src="курсы\learn-you-a-haskell-for-great-good!\картинки\lyhfgg_30_curry.png"></span></p></div><div><p>Putting a space between two things is simply <strong>function application</strong>. The space is sort of like an operator and it has the highest precedence. Let's examine the type of <code>max</code>. It's <code>max :: (Ord a) =&gt; a -&gt; a -&gt; a</code>. That can also be written as <code>max :: (Ord a) =&gt; a -&gt; (a -&gt; a)</code>. That could be read as: <code>max</code> takes an <code>a</code> and returns (that's the <code>-&gt;</code>) a function that takes an <code>a</code> and returns an <code>a</code>. That's why the return type and the parameters of functions are all simply separated with arrows.</p></div><div><p>So how is that beneficial to us? Simply speaking, if we call a function with too few parameters, we get back a <strong>partially applied</strong> function, meaning a function that takes as many parameters as we left out. Using partial application (calling functions with too few parameters, if you will) is a neat way to create functions on the fly so we can pass them to another function or to seed them with some data.</p></div><div><p>Take a look at this offensively simple function:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">multThree</span> <span class="token operator">::</span> <span class="token punctuation">(</span><span class="token constant">Num</span> <span class="token hvariable">a</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token hvariable">a</span> <span class="token operator">-&gt;</span> <span class="token hvariable">a</span> <span class="token operator">-&gt;</span> <span class="token hvariable">a</span> <span class="token operator">-&gt;</span> <span class="token hvariable">a</span>
<span class="token hvariable">multThree</span> <span class="token hvariable">x</span> <span class="token hvariable">y</span> <span class="token hvariable">z</span> <span class="token operator">=</span> <span class="token hvariable">x</span> <span class="token operator">*</span> <span class="token hvariable">y</span> <span class="token operator">*</span> <span class="token hvariable">z</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>What really happens when we do <code>multThree 3 5 9</code> or <code>((multThree 3) 5) 9</code>? First, <code>3</code> is applied to <code>multThree</code>, because they're separated by a space. That creates a function that takes one parameter and returns a function. So then <code>5</code> is applied to that, which creates a function that will take a parameter and multiply it by 15. <code>9</code> is applied to that function and the result is 135 or something. Remember that this function's type could also be written as <code>multThree :: (Num a) =&gt; a -&gt; (a -&gt; (a -&gt; a))</code>. The thing before the <code>-&gt;</code> is the parameter that a function takes and the thing after it is what it returns. So our function takes an <code>a</code> and returns a function of type <code>(Num a) =&gt; a -&gt; (a -&gt; a)</code>. Similarly, this function takes an <code>a</code> and returns a function of type <code>(Num a) =&gt; a -&gt; a</code>. And this function, finally, just takes an <code>a</code> and returns an <code>a</code>. Take a look at this:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token keyword">let</span> <span class="token hvariable">multTwoWithNine</span> <span class="token operator">=</span> <span class="token hvariable">multThree</span> <span class="token number">9</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token hvariable">multTwoWithNine</span> <span class="token number">2</span> <span class="token number">3</span>
<span class="token number">54</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token keyword">let</span> <span class="token hvariable">multWithEighteen</span> <span class="token operator">=</span> <span class="token hvariable">multTwoWithNine</span> <span class="token number">2</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token hvariable">multWithEighteen</span> <span class="token number">10</span>
<span class="token number">180</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>By calling functions with too few parameters, so to speak, we're creating new functions on the fly. What if we wanted to create a function that takes a number and compares it to <code>100</code>? We could do something like this:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">compareWithHundred</span> <span class="token operator">::</span> <span class="token punctuation">(</span><span class="token constant">Num</span> <span class="token hvariable">a</span><span class="token punctuation">,</span> <span class="token constant">Ord</span> <span class="token hvariable">a</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token hvariable">a</span> <span class="token operator">-&gt;</span> <span class="token constant">Ordering</span>
<span class="token hvariable">compareWithHundred</span> <span class="token hvariable">x</span> <span class="token operator">=</span> <span class="token builtin">compare</span> <span class="token number">100</span> <span class="token hvariable">x</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>If we call it with <code>99</code>, it returns a <code>GT</code>. Simple stuff. Notice that the <code>x</code> is on the right hand side on both sides of the equation. Now let's think about what <code>compare 100</code> returns. It returns a function that takes a number and compares it with <code>100</code>. Wow! Isn't that the function we wanted? We can rewrite this as:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">compareWithHundred</span> <span class="token operator">::</span> <span class="token punctuation">(</span><span class="token constant">Num</span> <span class="token hvariable">a</span><span class="token punctuation">,</span> <span class="token constant">Ord</span> <span class="token hvariable">a</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token hvariable">a</span> <span class="token operator">-&gt;</span> <span class="token constant">Ordering</span>
<span class="token hvariable">compareWithHundred</span> <span class="token operator">=</span> <span class="token builtin">compare</span> <span class="token number">100</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>The type declaration stays the same, because <code>compare 100</code> returns a function. Compare has a type of <code>(Ord a) =&gt; a -&gt; (a -&gt; Ordering)</code> and calling it with <code>100</code> returns a <code>(Num a, Ord a) =&gt; a -&gt; Ordering</code>. The additional class constraint sneaks up there because <code>100</code> is also part of the <code>Num</code> typeclass.</p></div><div><blockquote>
<p><strong>Yo!</strong>  Make sure you really understand how curried functions and partial application work because they're really important!</p>
</blockquote></div><div><p>Infix functions can also be partially applied by using sections. To section an infix function, simply surround it with parentheses and only supply a parameter on one side. That creates a function that takes one parameter and then applies it to the side that's missing an operand. An insultingly trivial function:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">divideByTen</span> <span class="token operator">::</span> <span class="token punctuation">(</span><span class="token constant">Floating</span> <span class="token hvariable">a</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token hvariable">a</span> <span class="token operator">-&gt;</span> <span class="token hvariable">a</span>
<span class="token hvariable">divideByTen</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token operator">/</span><span class="token number">10</span><span class="token punctuation">)</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Calling, say, <code>divideByTen 200</code> is equivalent to doing <code>200 / 10</code>, as is doing <code>(/10) 200</code>. A function that checks if a character supplied to it is an uppercase letter:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">isUpperAlphanum</span> <span class="token operator">::</span> <span class="token constant">Char</span> <span class="token operator">-&gt;</span> <span class="token constant">Bool</span>
<span class="token hvariable">isUpperAlphanum</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token operator">`elem`</span> <span class="token punctuation">[</span><span class="token char string">'A'</span><span class="token operator">..</span><span class="token char string">'Z'</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>The only special thing about sections is using <code>-</code>. From the definition of sections, <code>(-4)</code> would result in a function that takes a number and subtracts 4 from it. However, for convenience, <code>(-4)</code> means minus four. So if you want to make a function that subtracts 4 from the number it gets as a parameter, partially apply the <code>subtract</code> function like so: <code>(subtract 4)</code>.</p></div><div><p>What happens if we try to just do <code>multThree 3 4</code> in GHCI instead of binding it to a name with a <em>let</em> or passing it to another function?</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token hvariable">multThree</span> <span class="token number">3</span> <span class="token number">4</span>
<span class="token operator">&lt;</span><span class="token hvariable">interactive</span><span class="token operator">&gt;:</span><span class="token number">1</span><span class="token operator">:</span><span class="token number">0</span><span class="token operator">:</span>
    <span class="token constant">No</span> <span class="token keyword">instance</span> <span class="token hvariable">for</span> <span class="token punctuation">(</span><span class="token constant">Show</span> <span class="token punctuation">(</span><span class="token hvariable">t</span> <span class="token operator">-&gt;</span> <span class="token hvariable">t</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
      <span class="token hvariable">arising</span> <span class="token hvariable">from</span> <span class="token hvariable">a</span> <span class="token hvariable">use</span> <span class="token keyword">of</span> `<span class="token builtin">print</span>' <span class="token hvariable">at</span> <span class="token operator">&lt;</span><span class="token hvariable">interactive</span><span class="token operator">&gt;:</span><span class="token number">1</span><span class="token operator">:</span><span class="token number">0</span><span class="token operator">-</span><span class="token number">12</span>
    <span class="token constant">Possible</span> <span class="token hvariable">fix</span><span class="token operator">:</span> <span class="token hvariable">add</span> <span class="token hvariable">an</span> <span class="token keyword">instance</span> <span class="token hvariable">declaration</span> <span class="token hvariable">for</span> <span class="token punctuation">(</span><span class="token constant">Show</span> <span class="token punctuation">(</span><span class="token hvariable">t</span> <span class="token operator">-&gt;</span> <span class="token hvariable">t</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token constant">In</span> <span class="token hvariable">the</span> <span class="token hvariable">expression</span><span class="token operator">:</span> <span class="token builtin">print</span> <span class="token hvariable">it</span>
    <span class="token constant">In</span> <span class="token hvariable">a</span> '<span class="token keyword">do</span>' <span class="token hvariable">expression</span><span class="token operator">:</span> <span class="token builtin">print</span> <span class="token hvariable">it</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>GHCI is telling us that the expression produced a function of type <code>a -&gt; a</code> but it doesn't know how to print it to the screen. Functions aren't instances of the <code>Show</code> typeclass, so we can't get a neat string representation of a function. When we do, say, <code>1 + 1</code> at the GHCI prompt, it first calculates that to <code>2</code> and then calls <code>show</code> on <code>2</code> to get a textual representation of that number. And the textual representation of <code>2</code> is just the string <code>"2"</code>, which then gets printed to our screen.</p></div><div><h2 data-heading="Some higher-orderism is in order" id="Some_higher-orderism_is_in_order" style="display: flex;"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>Some higher-orderism is in order</h2></div><div><p>Functions can take functions as parameters and also return functions. To illustrate this, we're going to make a function that takes a function and then applies it twice to something!</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">applyTwice</span> <span class="token operator">::</span> <span class="token punctuation">(</span><span class="token hvariable">a</span> <span class="token operator">-&gt;</span> <span class="token hvariable">a</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token hvariable">a</span> <span class="token operator">-&gt;</span> <span class="token hvariable">a</span>
<span class="token hvariable">applyTwice</span> <span class="token hvariable">f</span> <span class="token hvariable">x</span> <span class="token operator">=</span> <span class="token hvariable">f</span> <span class="token punctuation">(</span><span class="token hvariable">f</span> <span class="token hvariable">x</span><span class="token punctuation">)</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p><span alt="LYHfGG_31_bonus.png" src="LYHfGG_31_bonus.png" class="internal-embed media-embed image-embed is-loaded"><img alt="LYHfGG_31_bonus.png" src="курсы\learn-you-a-haskell-for-great-good!\картинки\lyhfgg_31_bonus.png"></span></p></div><div><p>First of all, notice the type declaration. Before, we didn't need parentheses because <code>-&gt;</code> is naturally right-associative. However, here, they're mandatory. They indicate that the first parameter is a function that takes something and returns that same thing. The second parameter is something of that type also and the return value is also of the same type. We could read this type declaration in the curried way, but to save ourselves a headache, we'll just say that this function takes two parameters and returns one thing. The first parameter is a function (of type <code>a -&gt; a</code>) and the second is that same <code>a</code>. The function can also be <code>Int -&gt; Int</code> or <code>String -&gt; String</code> or whatever. But then, the second parameter to also has to be of that type.</p></div><div><blockquote>
<p><strong>Note</strong> From now on, we'll say that functions take several parameters despite each function actually taking only one parameter and returning partially applied functions until we reach a function that returns a solid value. So for simplicity's sake, we'll say that <code>a -&gt; a -&gt; a</code> takes two parameters, even though we know what's really going on under the hood.</p>
</blockquote></div><div><p>The body of the function is pretty simple. We just use the parameter <code>f</code> as a function, applying <code>x</code> to it by separating them with a space and then applying the result to <code>f</code> again. Anyway, playing around with the function:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token hvariable">applyTwice</span> <span class="token punctuation">(</span><span class="token operator">+</span><span class="token number">3</span><span class="token punctuation">)</span> <span class="token number">10</span>
<span class="token number">16</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token hvariable">applyTwice</span> <span class="token punctuation">(</span><span class="token operator">++</span> <span class="token string">" HAHA"</span><span class="token punctuation">)</span> <span class="token string">"HEY"</span>
<span class="token string">"HEY HAHA HAHA"</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token hvariable">applyTwice</span> <span class="token punctuation">(</span><span class="token string">"HAHA "</span> <span class="token operator">++</span><span class="token punctuation">)</span> <span class="token string">"HEY"</span>
<span class="token string">"HAHA HAHA HEY"</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token hvariable">applyTwice</span> <span class="token punctuation">(</span><span class="token hvariable">multThree</span> <span class="token number">2</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token number">9</span>
<span class="token number">144</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token hvariable">applyTwice</span> <span class="token punctuation">(</span><span class="token number">3</span><span class="token operator">:</span><span class="token punctuation">)</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span>
<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">]</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>The awesomeness and usefulness of partial application is evident. If our function requires us to pass it a function that takes only one parameter, we can just partially apply a function to the point where it takes only one parameter and then pass it.</p></div><div><p>Now we're going to use higher order programming to implement a really useful function that's in the standard library. It's called <code>zipWith</code>. It takes a function and two lists as parameters and then joins the two lists by applying the function between corresponding elements. Here's how we'll implement it:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token builtin">zipWith</span>' <span class="token operator">::</span> <span class="token punctuation">(</span><span class="token hvariable">a</span> <span class="token operator">-&gt;</span> <span class="token hvariable">b</span> <span class="token operator">-&gt;</span> <span class="token hvariable">c</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token punctuation">[</span><span class="token hvariable">a</span><span class="token punctuation">]</span> <span class="token operator">-&gt;</span> <span class="token punctuation">[</span><span class="token hvariable">b</span><span class="token punctuation">]</span> <span class="token operator">-&gt;</span> <span class="token punctuation">[</span><span class="token hvariable">c</span><span class="token punctuation">]</span>
<span class="token builtin">zipWith</span>' <span class="token hvariable">_</span> <span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token hvariable">_</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
<span class="token builtin">zipWith</span>' <span class="token hvariable">_</span> <span class="token hvariable">_</span> <span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
<span class="token builtin">zipWith</span>' <span class="token hvariable">f</span> <span class="token punctuation">(</span><span class="token hvariable">x</span><span class="token operator">:</span><span class="token hvariable">xs</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token hvariable">y</span><span class="token operator">:</span><span class="token hvariable">ys</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token hvariable">f</span> <span class="token hvariable">x</span> <span class="token hvariable">y</span> <span class="token operator">:</span> <span class="token builtin">zipWith</span>' <span class="token hvariable">f</span> <span class="token hvariable">xs</span> <span class="token hvariable">ys</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Look at the type declaration. The first parameter is a function that takes two things and produces a third thing. They don't have to be of the same type, but they can. The second and third parameter are lists. The result is also a list. The first has to be a list of <code>a</code>'s, because the joining function takes <code>a</code>'s as its first argument. The second has to be a list of <code>b</code>'s, because the second parameter of the joining function is of type <code>b</code>. The result is a list of <code>c</code>'s. If the type declaration of a function says it accepts an <code>a -&gt; b -&gt; c</code> function as a parameter, it will also accept an <code>a -&gt; a -&gt; a</code> function, but not the other way around! Remember that when you're making functions, especially higher order ones, and you're unsure of the type, you can just try omitting the type declaration and then checking what Haskell infers it to be by using <code>:t</code>.</p></div><div><p>The action in the function is pretty similar to the normal <code>zip</code>. The edge conditions are the same, only there's an extra argument, the joining function, but that argument doesn't matter in the edge conditions, so we just use a <code>_</code> for it. And function body at the last pattern is also similar to <code>zip</code>, only it doesn't do <code>(x,y)</code>, but <code>f x y</code>. A single higher order function can be used for a multitude of different tasks if it's general enough. Here's a little demonstration of all the different things our <code>zipWith'</code> function can do:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token builtin">zipWith</span>' <span class="token punctuation">(</span><span class="token operator">+</span><span class="token punctuation">)</span> <span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">]</span> <span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">]</span>
<span class="token punctuation">[</span><span class="token number">6</span><span class="token punctuation">,</span><span class="token number">8</span><span class="token punctuation">,</span><span class="token number">7</span><span class="token punctuation">,</span><span class="token number">9</span><span class="token punctuation">]</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token builtin">zipWith</span>' <span class="token builtin">max</span> <span class="token punctuation">[</span><span class="token number">6</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token punctuation">[</span><span class="token number">7</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">]</span>
<span class="token punctuation">[</span><span class="token number">7</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">]</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token builtin">zipWith</span>' <span class="token punctuation">(</span><span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">[</span><span class="token string">"foo "</span><span class="token punctuation">,</span> <span class="token string">"bar "</span><span class="token punctuation">,</span> <span class="token string">"baz "</span><span class="token punctuation">]</span> <span class="token punctuation">[</span><span class="token string">"fighters"</span><span class="token punctuation">,</span> <span class="token string">"hoppers"</span><span class="token punctuation">,</span> <span class="token string">"aldrin"</span><span class="token punctuation">]</span>
<span class="token punctuation">[</span><span class="token string">"foo fighters"</span><span class="token punctuation">,</span><span class="token string">"bar hoppers"</span><span class="token punctuation">,</span><span class="token string">"baz aldrin"</span><span class="token punctuation">]</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token builtin">zipWith</span>' <span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token builtin">replicate</span> <span class="token number">5</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token operator">..</span><span class="token punctuation">]</span>
<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">,</span><span class="token number">8</span><span class="token punctuation">,</span><span class="token number">10</span><span class="token punctuation">]</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token builtin">zipWith</span>' <span class="token punctuation">(</span><span class="token builtin">zipWith</span>' <span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">]</span>
<span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token number">9</span><span class="token punctuation">,</span><span class="token number">20</span><span class="token punctuation">,</span><span class="token number">30</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">,</span><span class="token number">12</span><span class="token punctuation">,</span><span class="token number">12</span><span class="token punctuation">]</span><span class="token punctuation">]</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>As you can see, a single higher order function can be used in very versatile ways. Imperative programming usually uses stuff like for loops, while loops, setting something to a variable, checking its state, etc. to achieve some behavior and then wrap it around an interface, like a function. Functional programming uses higher order functions to abstract away common patterns, like examining two lists in pairs and doing something with those pairs or getting a set of solutions and eliminating the ones you don't need.</p></div><div><p>We'll implement another function that's already in the standard library, called <code>flip</code>. Flip simply takes a function and returns a function that is like our original function, only the first two arguments are flipped. We can implement it like so:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token builtin">flip</span>' <span class="token operator">::</span> <span class="token punctuation">(</span><span class="token hvariable">a</span> <span class="token operator">-&gt;</span> <span class="token hvariable">b</span> <span class="token operator">-&gt;</span> <span class="token hvariable">c</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token punctuation">(</span><span class="token hvariable">b</span> <span class="token operator">-&gt;</span> <span class="token hvariable">a</span> <span class="token operator">-&gt;</span> <span class="token hvariable">c</span><span class="token punctuation">)</span>
<span class="token builtin">flip</span>' <span class="token hvariable">f</span> <span class="token operator">=</span> <span class="token hvariable">g</span>
    <span class="token keyword">where</span> <span class="token hvariable">g</span> <span class="token hvariable">x</span> <span class="token hvariable">y</span> <span class="token operator">=</span> <span class="token hvariable">f</span> <span class="token hvariable">y</span> <span class="token hvariable">x</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Reading the type declaration, we say that it takes a function that takes an <code>a</code> and a <code>b</code> and returns a function that takes a <code>b</code> and an <code>a</code>. But because functions are curried by default, the second pair of parentheses is really unnecessary, because <code>-&gt;</code> is right associative by default. <code>(a -&gt; b -&gt; c) -&gt; (b -&gt; a -&gt; c)</code> is the same as <code>(a -&gt; b -&gt; c) -&gt; (b -&gt; (a -&gt; c))</code>, which is the same as <code>(a -&gt; b -&gt; c) -&gt; b -&gt; a -&gt; c</code>. We wrote that <code>g x y = f y x</code>. If that's true, then <code>f y x = g x y</code> must also hold, right? Keeping that in mind, we can define this function in an even simpler manner.</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token builtin">flip</span>' <span class="token operator">::</span> <span class="token punctuation">(</span><span class="token hvariable">a</span> <span class="token operator">-&gt;</span> <span class="token hvariable">b</span> <span class="token operator">-&gt;</span> <span class="token hvariable">c</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token hvariable">b</span> <span class="token operator">-&gt;</span> <span class="token hvariable">a</span> <span class="token operator">-&gt;</span> <span class="token hvariable">c</span>
<span class="token builtin">flip</span>' <span class="token hvariable">f</span> <span class="token hvariable">y</span> <span class="token hvariable">x</span> <span class="token operator">=</span> <span class="token hvariable">f</span> <span class="token hvariable">x</span> <span class="token hvariable">y</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Here, we take advantage of the fact that functions are curried. When we call <code>flip' f</code> without the parameters <code>y</code> and <code>x</code>, it will return an <code>f</code> that takes those two parameters but calls them flipped. Even though flipped functions are usually passed to other functions, we can take advantage of currying when making higher-order functions by thinking ahead and writing what their end result would be if they were called fully applied.</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token builtin">flip</span>' <span class="token builtin">zip</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">]</span> <span class="token string">"hello"</span>
<span class="token punctuation">[</span><span class="token punctuation">(</span><span class="token char string">'h'</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token char string">'e'</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token char string">'l'</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token char string">'l'</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token char string">'o'</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">]</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token builtin">zipWith</span> <span class="token punctuation">(</span><span class="token builtin">flip</span>' <span class="token builtin">div</span><span class="token punctuation">)</span> <span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token operator">..</span><span class="token punctuation">]</span> <span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">,</span><span class="token number">8</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">]</span>
<span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">]</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><h2 data-heading="Maps and filters" id="Maps_and_filters" style="display: flex;"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>Maps and filters</h2></div><div><p><code>map</code> takes a function and a list and applies that function to every element in the list, producing a new list. Let's see what its type signature is and how it's defined.</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token builtin">map</span> <span class="token operator">::</span> <span class="token punctuation">(</span><span class="token hvariable">a</span> <span class="token operator">-&gt;</span> <span class="token hvariable">b</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token punctuation">[</span><span class="token hvariable">a</span><span class="token punctuation">]</span> <span class="token operator">-&gt;</span> <span class="token punctuation">[</span><span class="token hvariable">b</span><span class="token punctuation">]</span>
<span class="token builtin">map</span> <span class="token hvariable">_</span> <span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
<span class="token builtin">map</span> <span class="token hvariable">f</span> <span class="token punctuation">(</span><span class="token hvariable">x</span><span class="token operator">:</span><span class="token hvariable">xs</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token hvariable">f</span> <span class="token hvariable">x</span> <span class="token operator">:</span> <span class="token builtin">map</span> <span class="token hvariable">f</span> <span class="token hvariable">xs</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>The type signature says that it takes a function that takes an <code>a</code> and returns a <code>b</code>, a list of <code>a</code>'s and returns a list of <code>b</code>'s. It's interesting that just by looking at a function's type signature, you can sometimes tell what it does. <code>map</code> is one of those really versatile higher-order functions that can be used in millions of different ways. Here it is in action:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token builtin">map</span> <span class="token punctuation">(</span><span class="token operator">+</span><span class="token number">3</span><span class="token punctuation">)</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">]</span>
<span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">8</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">9</span><span class="token punctuation">]</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token builtin">map</span> <span class="token punctuation">(</span><span class="token operator">++</span> <span class="token string">"!"</span><span class="token punctuation">)</span> <span class="token punctuation">[</span><span class="token string">"BIFF"</span><span class="token punctuation">,</span> <span class="token string">"BANG"</span><span class="token punctuation">,</span> <span class="token string">"POW"</span><span class="token punctuation">]</span>
<span class="token punctuation">[</span><span class="token string">"BIFF!"</span><span class="token punctuation">,</span><span class="token string">"BANG!"</span><span class="token punctuation">,</span><span class="token string">"POW!"</span><span class="token punctuation">]</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token builtin">map</span> <span class="token punctuation">(</span><span class="token builtin">replicate</span> <span class="token number">3</span><span class="token punctuation">)</span> <span class="token punctuation">[</span><span class="token number">3</span><span class="token operator">..</span><span class="token number">6</span><span class="token punctuation">]</span>
<span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token number">6</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">]</span><span class="token punctuation">]</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token builtin">map</span> <span class="token punctuation">(</span><span class="token builtin">map</span> <span class="token punctuation">(</span><span class="token operator">^</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token number">7</span><span class="token punctuation">,</span><span class="token number">8</span><span class="token punctuation">]</span><span class="token punctuation">]</span>
<span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token number">9</span><span class="token punctuation">,</span><span class="token number">16</span><span class="token punctuation">,</span><span class="token number">25</span><span class="token punctuation">,</span><span class="token number">36</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token number">49</span><span class="token punctuation">,</span><span class="token number">64</span><span class="token punctuation">]</span><span class="token punctuation">]</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token builtin">map</span> <span class="token builtin">fst</span> <span class="token punctuation">[</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token number">6</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">]</span>
<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">]</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>You've probably noticed that each of these could be achieved with a list comprehension. <code>map (+3) [1,5,3,1,6]</code> is the same as writing <code>[x+3 | x &lt;- [1,5,3,1,6]]</code>. However, using <code>map</code> is much more readable for cases where you only apply some function to the elements of a list, especially once you're dealing with maps of maps and then the whole thing with a lot of brackets can get a bit messy.</p></div><div><p><code>filter</code> is a function that takes a predicate (a predicate is a function that tells whether something is true or not, so in our case, a function that returns a boolean value) and a list and then returns the list of elements that satisfy the predicate. The type signature and implementation go like this:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token builtin">filter</span> <span class="token operator">::</span> <span class="token punctuation">(</span><span class="token hvariable">a</span> <span class="token operator">-&gt;</span> <span class="token constant">Bool</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token punctuation">[</span><span class="token hvariable">a</span><span class="token punctuation">]</span> <span class="token operator">-&gt;</span> <span class="token punctuation">[</span><span class="token hvariable">a</span><span class="token punctuation">]</span>
<span class="token builtin">filter</span> <span class="token hvariable">_</span> <span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
<span class="token builtin">filter</span> <span class="token hvariable">p</span> <span class="token punctuation">(</span><span class="token hvariable">x</span><span class="token operator">:</span><span class="token hvariable">xs</span><span class="token punctuation">)</span> 
    <span class="token operator">|</span> <span class="token hvariable">p</span> <span class="token hvariable">x</span>       <span class="token operator">=</span> <span class="token hvariable">x</span> <span class="token operator">:</span> <span class="token builtin">filter</span> <span class="token hvariable">p</span> <span class="token hvariable">xs</span>
    <span class="token operator">|</span> <span class="token builtin">otherwise</span> <span class="token operator">=</span> <span class="token builtin">filter</span> <span class="token hvariable">p</span> <span class="token hvariable">xs</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Pretty simple stuff. If <code>p x</code> evaluates to <code>True</code>, the element gets included in the new list. If it doesn't, it stays out. Some usage examples:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token builtin">filter</span> <span class="token punctuation">(</span><span class="token operator">&gt;</span><span class="token number">3</span><span class="token punctuation">)</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">]</span>
<span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">]</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token builtin">filter</span> <span class="token punctuation">(</span><span class="token operator">==</span><span class="token number">3</span><span class="token punctuation">)</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">]</span>
<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token builtin">filter</span> <span class="token builtin">even</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token operator">..</span><span class="token number">10</span><span class="token punctuation">]</span>
<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">,</span><span class="token number">8</span><span class="token punctuation">,</span><span class="token number">10</span><span class="token punctuation">]</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token keyword">let</span> <span class="token hvariable">notNull</span> <span class="token hvariable">x</span> <span class="token operator">=</span> <span class="token builtin">not</span> <span class="token punctuation">(</span><span class="token builtin">null</span> <span class="token hvariable">x</span><span class="token punctuation">)</span> <span class="token keyword">in</span> <span class="token builtin">filter</span> <span class="token hvariable">notNull</span> <span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">]</span>
<span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">]</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token builtin">filter</span> <span class="token punctuation">(</span><span class="token operator">`elem`</span> <span class="token punctuation">[</span><span class="token char string">'a'</span><span class="token operator">..</span><span class="token char string">'z'</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token string">"u LaUgH aT mE BeCaUsE I aM diFfeRent"</span>
<span class="token string">"uagameasadifeent"</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token builtin">filter</span> <span class="token punctuation">(</span><span class="token operator">`elem`</span> <span class="token punctuation">[</span><span class="token char string">'A'</span><span class="token operator">..</span><span class="token char string">'Z'</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token string">"i lauGh At You BecAuse u r aLL the Same"</span>
<span class="token string">"GAYBALLS"</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>All of this could also be achived with list comprehensions by the use of predicates. There's no set rule for when to use <code>map</code> and <code>filter</code> versus using list comprehension, you just have to decide what's more readable depending on the code and the context. The <code>filter</code> equivalent of applying several predicates in a list comprehension is either filtering something several times or joining the predicates with the logical <code>&amp;&amp;</code> function.</p></div><div><p>Remember our quicksort function from the <a data-tooltip-position="top" aria-label="http://learnyouahaskell.com/recursion" rel="noopener" class="external-link" href="http://learnyouahaskell.com/recursion" target="_blank">previous chapter</a>? We used list comprehensions to filter out the list elements that are smaller than (or equal to) and larger than the pivot. We can achieve the same functionality in a more readable way by using <code>filter</code>:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">quicksort</span> <span class="token operator">::</span> <span class="token punctuation">(</span><span class="token constant">Ord</span> <span class="token hvariable">a</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">[</span><span class="token hvariable">a</span><span class="token punctuation">]</span> <span class="token operator">-&gt;</span> <span class="token punctuation">[</span><span class="token hvariable">a</span><span class="token punctuation">]</span>  
<span class="token hvariable">quicksort</span> <span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>  
<span class="token hvariable">quicksort</span> <span class="token punctuation">(</span><span class="token hvariable">x</span><span class="token operator">:</span><span class="token hvariable">xs</span><span class="token punctuation">)</span> <span class="token operator">=</span>   
    <span class="token keyword">let</span> <span class="token hvariable">smallerSorted</span> <span class="token operator">=</span> <span class="token hvariable">quicksort</span> <span class="token punctuation">(</span><span class="token builtin">filter</span> <span class="token punctuation">(</span><span class="token operator">&lt;=</span><span class="token hvariable">x</span><span class="token punctuation">)</span> <span class="token hvariable">xs</span><span class="token punctuation">)</span>
        <span class="token hvariable">biggerSorted</span> <span class="token operator">=</span> <span class="token hvariable">quicksort</span> <span class="token punctuation">(</span><span class="token builtin">filter</span> <span class="token punctuation">(</span><span class="token operator">&gt;</span><span class="token hvariable">x</span><span class="token punctuation">)</span> <span class="token hvariable">xs</span><span class="token punctuation">)</span> 
    <span class="token keyword">in</span>  <span class="token hvariable">smallerSorted</span> <span class="token operator">++</span> <span class="token punctuation">[</span><span class="token hvariable">x</span><span class="token punctuation">]</span> <span class="token operator">++</span> <span class="token hvariable">biggerSorted</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p><span alt="LYHfGG_32_map.png" src="LYHfGG_32_map.png" class="internal-embed media-embed image-embed is-loaded"><img alt="LYHfGG_32_map.png" src="курсы\learn-you-a-haskell-for-great-good!\картинки\lyhfgg_32_map.png"></span></p></div><div><p>Mapping and filtering is the bread and butter of every functional programmer's toolbox. Uh. It doesn't matter if you do it with the <code>map</code> and <code>filter</code> functions or list comprehensions. Recall how we solved the problem of finding right triangles with a certain circumference. With imperative programming, we would have solved it by nesting three loops and then testing if the current combination satisfies a right triangle and if it has the right perimeter. If that's the case, we would have printed it out to the screen or something. In functional programming, that pattern is achieved with mapping and filtering. You make a function that takes a value and produces some result. We map that function over a list of values and then we filter the resulting list out for the results that satisfy our search. Thanks to Haskell's laziness, even if you map something over a list several times and filter it several times, it will only pass over the list once.</p></div><div><p>Let's <strong>find the largest number under 100,000 that's divisible by 3829</strong>. To do that, we'll just filter a set of possibilities in which we know the solution lies.</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">largestDivisible</span> <span class="token operator">::</span> <span class="token punctuation">(</span><span class="token constant">Integral</span> <span class="token hvariable">a</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token hvariable">a</span>
<span class="token hvariable">largestDivisible</span> <span class="token operator">=</span> <span class="token builtin">head</span> <span class="token punctuation">(</span><span class="token builtin">filter</span> <span class="token hvariable">p</span> <span class="token punctuation">[</span><span class="token number">100000</span><span class="token punctuation">,</span><span class="token number">99999</span><span class="token operator">..</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
    <span class="token keyword">where</span> <span class="token hvariable">p</span> <span class="token hvariable">x</span> <span class="token operator">=</span> <span class="token hvariable">x</span> <span class="token operator">`mod`</span> <span class="token number">3829</span> <span class="token operator">==</span> <span class="token number">0</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>We first make a list of all numbers lower than 100,000, descending. Then we filter it by our predicate and because the numbers are sorted in a descending manner, the largest number that satisfies our predicate is the first element of the filtered list. We didn't even need to use a finite list for our starting set. That's laziness in action again. Because we only end up using the head of the filtered list, it doesn't matter if the filtered list is finite or infinite. The evaluation stops when the first adequate solution is found.</p></div><div><p>Next up, we're going to <strong>find the sum of all odd squares that are smaller than 10,000</strong>. But first, because we'll be using it in our solution, we're going to introduce the <code>takeWhile</code> function. It takes a predicate and a list and then goes from the beginning of the list and returns its elements while the predicate holds true. Once an element is found for which the predicate doesn't hold, it stops. If we wanted to get the first word of the string <code>"elephants know how to party"</code>, we could do <code>takeWhile (/=' ') "elephants know how to party"</code> and it would return <code>"elephants"</code>. Okay. The sum of all odd squares that are smaller than 10,000. First, we'll begin by mapping the <code>(^2)</code> function to the infinite list <code>[1..]</code>. Then we filter them so we only get the odd ones. And then, we'll take elements from that list while they are smaller than 10,000. Finally, we'll get the sum of that list. We don't even have to define a function for that, we can do it in one line in GHCI:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token builtin">sum</span> <span class="token punctuation">(</span><span class="token builtin">takeWhile</span> <span class="token punctuation">(</span><span class="token operator">&lt;</span><span class="token number">10000</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token builtin">filter</span> <span class="token builtin">odd</span> <span class="token punctuation">(</span><span class="token builtin">map</span> <span class="token punctuation">(</span><span class="token operator">^</span><span class="token number">2</span><span class="token punctuation">)</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token operator">..</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token number">166650</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Awesome! We start with some initial data (the infinite list of all natural numbers) and then we map over it, filter it and cut it until it suits our needs and then we just sum it up. We could have also written this using list comprehensions:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token builtin">sum</span> <span class="token punctuation">(</span><span class="token builtin">takeWhile</span> <span class="token punctuation">(</span><span class="token operator">&lt;</span><span class="token number">10000</span><span class="token punctuation">)</span> <span class="token punctuation">[</span><span class="token hvariable">n</span><span class="token operator">^</span><span class="token number">2</span> <span class="token operator">|</span> <span class="token hvariable">n</span> <span class="token operator">&lt;-</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token operator">..</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token builtin">odd</span> <span class="token punctuation">(</span><span class="token hvariable">n</span><span class="token operator">^</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
<span class="token number">166650</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>It's a matter of taste as to which one you find prettier. Again, Haskell's property of laziness is what makes this possible. We can map over and filter an infinite list, because it won't actually map and filter it right away, it'll delay those actions. Only when we force Haskell to show us the sum does the <code>sum</code> function say to the <code>takeWhile</code> that it needs those numbers. <code>takeWhile</code> forces the filtering and mapping to occur, but only until a number greater than or equal to 10,000 is encountered.</p></div><div><p>For our next problem, we'll be dealing with Collatz sequences. We take a natural number. If that number is even, we divide it by two. If it's odd, we multiply it by 3 and then add 1 to that. We take the resulting number and apply the same thing to it, which produces a new number and so on. In essence, we get a chain of numbers. It is thought that for all starting numbers, the chains finish at the number 1. So if we take the starting number 13, we get this sequence: <em>13, 40, 20, 10, 5, 16, 8, 4, 2, 1</em>. 13*3 + 1 equals 40. 40 divided by 2 is 20, etc. We see that the chain has 10 terms.</p></div><div><p>Now what we want to know is this: <strong>for all starting numbers between 1 and 100, how many chains have a length greater than 15?</strong> First off, we'll write a function that produces a chain:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">chain</span> <span class="token operator">::</span> <span class="token punctuation">(</span><span class="token constant">Integral</span> <span class="token hvariable">a</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token hvariable">a</span> <span class="token operator">-&gt;</span> <span class="token punctuation">[</span><span class="token hvariable">a</span><span class="token punctuation">]</span>
<span class="token hvariable">chain</span> <span class="token number">1</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span>
<span class="token hvariable">chain</span> <span class="token hvariable">n</span>
    <span class="token operator">|</span> <span class="token builtin">even</span> <span class="token hvariable">n</span> <span class="token operator">=</span>  <span class="token hvariable">n</span><span class="token operator">:</span><span class="token hvariable">chain</span> <span class="token punctuation">(</span><span class="token hvariable">n</span> <span class="token operator">`div`</span> <span class="token number">2</span><span class="token punctuation">)</span>
    <span class="token operator">|</span> <span class="token builtin">odd</span> <span class="token hvariable">n</span>  <span class="token operator">=</span>  <span class="token hvariable">n</span><span class="token operator">:</span><span class="token hvariable">chain</span> <span class="token punctuation">(</span><span class="token hvariable">n</span><span class="token operator">*</span><span class="token number">3</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Because the chains end at 1, that's the edge case. This is a pretty standard recursive function.</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token hvariable">chain</span> <span class="token number">10</span>
<span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">16</span><span class="token punctuation">,</span><span class="token number">8</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">]</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token hvariable">chain</span> <span class="token number">1</span>
<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token hvariable">chain</span> <span class="token number">30</span>
<span class="token punctuation">[</span><span class="token number">30</span><span class="token punctuation">,</span><span class="token number">15</span><span class="token punctuation">,</span><span class="token number">46</span><span class="token punctuation">,</span><span class="token number">23</span><span class="token punctuation">,</span><span class="token number">70</span><span class="token punctuation">,</span><span class="token number">35</span><span class="token punctuation">,</span><span class="token number">106</span><span class="token punctuation">,</span><span class="token number">53</span><span class="token punctuation">,</span><span class="token number">160</span><span class="token punctuation">,</span><span class="token number">80</span><span class="token punctuation">,</span><span class="token number">40</span><span class="token punctuation">,</span><span class="token number">20</span><span class="token punctuation">,</span><span class="token number">10</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">16</span><span class="token punctuation">,</span><span class="token number">8</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">]</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Yay! It seems to be working correctly. And now, the function that tells us the answer to our question:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">numLongChains</span> <span class="token operator">::</span> <span class="token constant">Int</span>
<span class="token hvariable">numLongChains</span> <span class="token operator">=</span> <span class="token builtin">length</span> <span class="token punctuation">(</span><span class="token builtin">filter</span> <span class="token hvariable">isLong</span> <span class="token punctuation">(</span><span class="token builtin">map</span> <span class="token hvariable">chain</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token operator">..</span><span class="token number">100</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token keyword">where</span> <span class="token hvariable">isLong</span> <span class="token hvariable">xs</span> <span class="token operator">=</span> <span class="token builtin">length</span> <span class="token hvariable">xs</span> <span class="token operator">&gt;</span> <span class="token number">15</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>We map the <code>chain</code> function to <code>[1..100]</code> to get a list of chains, which are themselves represented as lists. Then, we filter them by a predicate that just checks whether a list's length is longer than 15. Once we've done the filtering, we see how many chains are left in the resulting list.</p></div><div><blockquote>
<p><strong>Note</strong> This function has a type of <code>numLongChains :: Int</code> because <code>length</code> returns an <code>Int</code> instead of a <code>Num a</code> for historical reasons. If we wanted to return a more general <code>Num a</code>, we could have used <code>fromIntegral</code> on the resulting length.</p>
</blockquote></div><div><p>Using <code>map</code>, we can also do stuff like <code>map (*) [0..]</code>, if not for any other reason than to illustrate how currying works and how (partially applied) functions are real values that you can pass around to other functions or put into lists (you just can't turn them to strings). So far, we've only mapped functions that take one parameter over lists, like <code>map (*2) [0..]</code> to get a list of type <code>(Num a) =&gt; [a]</code>, but we can also do <code>map (*) [0..]</code> without a problem. What happens here is that the number in the list is applied to the function <code>*</code>, which has a type of <code>(Num a) =&gt; a -&gt; a -&gt; a</code>. Applying only one parameter to a function that takes two parameters returns a function that takes one parameter. If we map <code>*</code> over the list <code>[0..]</code>, we get back a list of functions that only take one parameter, so <code>(Num a) =&gt; [a -&gt; a]</code>. <code>map (*) [0..]</code> produces a list like the one we'd get by writing <code>[(0*),(1*),(2*),(3*),(4*),(5*)..</code>.</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token keyword">let</span> <span class="token hvariable">listOfFuns</span> <span class="token operator">=</span> <span class="token builtin">map</span> <span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">)</span> <span class="token punctuation">[</span><span class="token number">0</span><span class="token operator">..</span><span class="token punctuation">]</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token punctuation">(</span><span class="token hvariable">listOfFuns</span> <span class="token operator">!!</span> <span class="token number">4</span><span class="token punctuation">)</span> <span class="token number">5</span>
<span class="token number">20</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Getting the element with the index <code>4</code> from our list returns a function that's equivalent to <code>(4*)</code>. And then, we just apply <code>5</code> to that function. So that's like writing <code>(4*) 5</code> or just <code>4 * 5</code>.</p></div><div><h2 data-heading="Lambdas" id="Lambdas" style="display: flex;"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>Lambdas</h2></div><div><p><span alt="LYHfGG_33_lambda.png" src="LYHfGG_33_lambda.png" class="internal-embed media-embed image-embed is-loaded"><img alt="LYHfGG_33_lambda.png" src="курсы\learn-you-a-haskell-for-great-good!\картинки\lyhfgg_33_lambda.png"></span></p></div><div><p>Lambdas are basically anonymous functions that are used because we need some functions only once. Normally, we make a lambda with the sole purpose of passing it to a higher-order function. To make a lambda, we write a <code>\</code> (because it kind of looks like the greek letter lambda if you squint hard enough) and then we write the parameters, separated by spaces. After that comes a <code>-&gt;</code> and then the function body. We usually surround them by parentheses, because otherwise they extend all the way to the right.</p></div><div><p>If you look about 5 inches up, you'll see that we used a <em>where</em> binding in our <code>numLongChains</code> function to make the <code>isLong</code> function for the sole purpose of passing it to <code>filter</code>. Well, instead of doing that, we can use a lambda:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">numLongChains</span> <span class="token operator">::</span> <span class="token constant">Int</span>
<span class="token hvariable">numLongChains</span> <span class="token operator">=</span> <span class="token builtin">length</span> <span class="token punctuation">(</span><span class="token builtin">filter</span> <span class="token punctuation">(</span><span class="token operator">\</span><span class="token hvariable">xs</span> <span class="token operator">-&gt;</span> <span class="token builtin">length</span> <span class="token hvariable">xs</span> <span class="token operator">&gt;</span> <span class="token number">15</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token builtin">map</span> <span class="token hvariable">chain</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token operator">..</span><span class="token number">100</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Lambdas are expressions, that's why we can just pass them like that. The expression <code>(\xs -&gt; length xs &gt; 15)</code> returns a function that tells us whether the length of the list passed to it is greater than 15.</p></div><div><p><span alt="LYHfGG_34_lamb.png" src="LYHfGG_34_lamb.png" class="internal-embed media-embed image-embed is-loaded"><img alt="LYHfGG_34_lamb.png" src="курсы\learn-you-a-haskell-for-great-good!\картинки\lyhfgg_34_lamb.png"></span></p></div><div><p>People who are not well acquainted with how currying and partial application works often use lambdas where they don't need to. For instance, the expressions <code>map (+3) [1,6,3,2]</code> and <code>map (\x -&gt; x + 3) [1,6,3,2]</code> are equivalent since both <code>(+3)</code> and <code>(\x -&gt; x + 3)</code> are functions that take a number and add 3 to it. Needless to say, making a lambda in this case is stupid since using partial application is much more readable.</p></div><div><p>Like normal functions, lambdas can take any number of parameters:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token builtin">zipWith</span> <span class="token punctuation">(</span><span class="token operator">\</span><span class="token hvariable">a</span> <span class="token hvariable">b</span> <span class="token operator">-&gt;</span> <span class="token punctuation">(</span><span class="token hvariable">a</span> <span class="token operator">*</span> <span class="token number">30</span> <span class="token operator">+</span> <span class="token number">3</span><span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token hvariable">b</span><span class="token punctuation">)</span> <span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">]</span>
<span class="token punctuation">[</span><span class="token number">153.0</span><span class="token punctuation">,</span><span class="token number">61.5</span><span class="token punctuation">,</span><span class="token number">31.0</span><span class="token punctuation">,</span><span class="token number">15.75</span><span class="token punctuation">,</span><span class="token number">6.6</span><span class="token punctuation">]</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>And like normal functions, you can pattern match in lambdas. The only difference is that you can't define several patterns for one parameter, like making a <code>[]</code> and a <code>(x:xs)</code> pattern for the same parameter and then having values fall through. If a pattern matching fails in a lambda, a runtime error occurs, so be careful when pattern matching in lambdas!</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token builtin">map</span> <span class="token punctuation">(</span><span class="token operator">\</span><span class="token punctuation">(</span><span class="token hvariable">a</span><span class="token punctuation">,</span><span class="token hvariable">b</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token hvariable">a</span> <span class="token operator">+</span> <span class="token hvariable">b</span><span class="token punctuation">)</span> <span class="token punctuation">[</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token number">6</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">]</span>
<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">8</span><span class="token punctuation">,</span><span class="token number">9</span><span class="token punctuation">,</span><span class="token number">8</span><span class="token punctuation">,</span><span class="token number">7</span><span class="token punctuation">]</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Lambdas are normally surrounded by parentheses unless we mean for them to extend all the way to the right. Here's something interesting: due to the way functions are curried by default, these two are equivalent:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">addThree</span> <span class="token operator">::</span> <span class="token punctuation">(</span><span class="token constant">Num</span> <span class="token hvariable">a</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token hvariable">a</span> <span class="token operator">-&gt;</span> <span class="token hvariable">a</span> <span class="token operator">-&gt;</span> <span class="token hvariable">a</span> <span class="token operator">-&gt;</span> <span class="token hvariable">a</span>
<span class="token hvariable">addThree</span> <span class="token hvariable">x</span> <span class="token hvariable">y</span> <span class="token hvariable">z</span> <span class="token operator">=</span> <span class="token hvariable">x</span> <span class="token operator">+</span> <span class="token hvariable">y</span> <span class="token operator">+</span> <span class="token hvariable">z</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">addThree</span> <span class="token operator">::</span> <span class="token punctuation">(</span><span class="token constant">Num</span> <span class="token hvariable">a</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token hvariable">a</span> <span class="token operator">-&gt;</span> <span class="token hvariable">a</span> <span class="token operator">-&gt;</span> <span class="token hvariable">a</span> <span class="token operator">-&gt;</span> <span class="token hvariable">a</span>
<span class="token hvariable">addThree</span> <span class="token operator">=</span> <span class="token operator">\</span><span class="token hvariable">x</span> <span class="token operator">-&gt;</span> <span class="token operator">\</span><span class="token hvariable">y</span> <span class="token operator">-&gt;</span> <span class="token operator">\</span><span class="token hvariable">z</span> <span class="token operator">-&gt;</span> <span class="token hvariable">x</span> <span class="token operator">+</span> <span class="token hvariable">y</span> <span class="token operator">+</span> <span class="token hvariable">z</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>If we define a function like this, it's obvious why the type declaration is what it is. There are three <code>-&gt;</code>'s in both the type declaration and the equation. But of course, the first way to write functions is far more readable, the second one is pretty much a gimmick to illustrate currying.</p></div><div><p>However, there are times when using this notation is cool. I think that the <code>flip</code> function is the most readable when defined like so:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token builtin">flip</span>' <span class="token operator">::</span> <span class="token punctuation">(</span><span class="token hvariable">a</span> <span class="token operator">-&gt;</span> <span class="token hvariable">b</span> <span class="token operator">-&gt;</span> <span class="token hvariable">c</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token hvariable">b</span> <span class="token operator">-&gt;</span> <span class="token hvariable">a</span> <span class="token operator">-&gt;</span> <span class="token hvariable">c</span>
<span class="token builtin">flip</span>' <span class="token hvariable">f</span> <span class="token operator">=</span> <span class="token operator">\</span><span class="token hvariable">x</span> <span class="token hvariable">y</span> <span class="token operator">-&gt;</span> <span class="token hvariable">f</span> <span class="token hvariable">y</span> <span class="token hvariable">x</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Even though that's the same as writing <code>flip' f x y = f y x</code>, we make it obvious that this will be used for producing a new function most of the time. The most common use case with <code>flip</code> is calling it with just the function parameter and then passing the resulting function on to a map or a filter. So use lambdas in this way when you want to make it explicit that your function is mainly meant to be partially applied and passed on to a function as a parameter.</p></div><div><h2 data-heading="Only folds and horses" id="Only_folds_and_horses" style="display: flex;"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>Only folds and horses</h2></div><div><p><span alt="LYHfGG_35_origami.png" src="LYHfGG_35_origami.png" class="internal-embed media-embed image-embed is-loaded"><img alt="LYHfGG_35_origami.png" src="курсы\learn-you-a-haskell-for-great-good!\картинки\lyhfgg_35_origami.png"></span></p></div><div><p>Back when we were dealing with recursion, we noticed a theme throughout many of the recursive functions that operated on lists. Usually, we'd have an edge case for the empty list. We'd introduce the <code>x:xs</code> pattern and then we'd do some action that involves a single element and the rest of the list. It turns out this is a very common pattern, so a couple of very useful functions were introduced to encapsulate it. These functions are called folds. They're sort of like the <code>map</code> function, only they reduce the list to some single value.</p></div><div><p>A fold takes a binary function, a starting value (I like to call it the accumulator) and a list to fold up. The binary function itself takes two parameters. The binary function is called with the accumulator and the first (or last) element and produces a new accumulator. Then, the binary function is called again with the new accumulator and the now new first (or last) element, and so on. Once we've walked over the whole list, only the accumulator remains, which is what we've reduced the list to.</p></div><div><p>First let's take a look at the <code>foldl</code> function, also called the left fold. It folds the list up from the left side. The binary function is applied between the starting value and the head of the list. That produces a new accumulator value and the binary function is called with that value and the next element, etc.</p></div><div><p>Let's implement <code>sum</code> again, only this time, we'll use a fold instead of explicit recursion.</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token builtin">sum</span>' <span class="token operator">::</span> <span class="token punctuation">(</span><span class="token constant">Num</span> <span class="token hvariable">a</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">[</span><span class="token hvariable">a</span><span class="token punctuation">]</span> <span class="token operator">-&gt;</span> <span class="token hvariable">a</span>
<span class="token builtin">sum</span>' <span class="token hvariable">xs</span> <span class="token operator">=</span> <span class="token builtin">foldl</span> <span class="token punctuation">(</span><span class="token operator">\</span><span class="token hvariable">acc</span> <span class="token hvariable">x</span> <span class="token operator">-&gt;</span> <span class="token hvariable">acc</span> <span class="token operator">+</span> <span class="token hvariable">x</span><span class="token punctuation">)</span> <span class="token number">0</span> <span class="token hvariable">xs</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Testing, one two three:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token builtin">sum</span>' <span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">]</span>
<span class="token number">11</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p><span alt="LYHfGG_36_foldl.png" src="LYHfGG_36_foldl.png" class="internal-embed media-embed image-embed is-loaded"><img alt="LYHfGG_36_foldl.png" src="курсы\learn-you-a-haskell-for-great-good!\картинки\lyhfgg_36_foldl.png"></span></p></div><div><p>Let's take an in-depth look into how this fold happens. <code>\acc x -&gt; acc + x</code> is the binary function. <code>0</code> is the starting value and <code>xs</code> is the list to be folded up. Now first, <code>0</code> is used as the <code>acc</code> parameter to the binary function and <code>3</code> is used as the <code>x</code> (or the current element) parameter. <code>0 + 3</code> produces a <code>3</code> and it becomes the new accumulator value, so to speak. Next up, <code>3</code> is used as the accumulator value and <code>5</code> as the current element and <code>8</code> becomes the new accumulator value. Moving forward, <code>8</code> is the accumulator value, <code>2</code> is the current element, the new accumulator value is <code>10</code>. Finally, that <code>10</code> is used as the accumulator value and <code>1</code> as the current element, producing an <code>11</code>. Congratulations, you've done a fold!</p></div><div><p>This professional diagram on the left illustrates how a fold happens, step by step (day by day!). The greenish brown number is the accumulator value. You can see how the list is sort of consumed up from the left side by the accumulator. Om nom nom nom! If we take into account that functions are curried, we can write this implementation ever more succinctly, like so:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token builtin">sum</span>' <span class="token operator">::</span> <span class="token punctuation">(</span><span class="token constant">Num</span> <span class="token hvariable">a</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">[</span><span class="token hvariable">a</span><span class="token punctuation">]</span> <span class="token operator">-&gt;</span> <span class="token hvariable">a</span>
<span class="token builtin">sum</span>' <span class="token operator">=</span> <span class="token builtin">foldl</span> <span class="token punctuation">(</span><span class="token operator">+</span><span class="token punctuation">)</span> <span class="token number">0</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>The lambda function <code>(\acc x -&gt; acc + x)</code> is the same as <code>(+)</code>. We can omit the <code>xs</code> as the parameter because calling <code>foldl (+) 0</code> will return a function that takes a list. Generally, if you have a function like <code>foo a = bar b a</code>, you can rewrite it as <code>foo = bar b</code>, because of currying.</p></div><div><p>Anyhoo, let's implement another function with a left fold before moving on to right folds. I'm sure you all know that <code>elem</code> checks whether a value is part of a list so I won't go into that again (whoops, just did!). Let's implement it with a left fold.</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token builtin">elem</span>' <span class="token operator">::</span> <span class="token punctuation">(</span><span class="token constant">Eq</span> <span class="token hvariable">a</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token hvariable">a</span> <span class="token operator">-&gt;</span> <span class="token punctuation">[</span><span class="token hvariable">a</span><span class="token punctuation">]</span> <span class="token operator">-&gt;</span> <span class="token constant">Bool</span>
<span class="token builtin">elem</span>' <span class="token hvariable">y</span> <span class="token hvariable">ys</span> <span class="token operator">=</span> <span class="token builtin">foldl</span> <span class="token punctuation">(</span><span class="token operator">\</span><span class="token hvariable">acc</span> <span class="token hvariable">x</span> <span class="token operator">-&gt;</span> <span class="token keyword">if</span> <span class="token hvariable">x</span> <span class="token operator">==</span> <span class="token hvariable">y</span> <span class="token keyword">then</span> <span class="token constant">True</span> <span class="token keyword">else</span> <span class="token hvariable">acc</span><span class="token punctuation">)</span> <span class="token constant">False</span> <span class="token hvariable">ys</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Well, well, well, what do we have here? The starting value and accumulator here is a boolean value. The type of the accumulator value and the end result is always the same when dealing with folds. Remember that if you ever don't know what to use as a starting value, it'll give you some idea. We start off with <code>False</code>. It makes sense to use <code>False</code> as a starting value. We assume it isn't there. Also, if we call a fold on an empty list, the result will just be the starting value. Then we check the current element is the element we're looking for. If it is, we set the accumulator to <code>True</code>. If it's not, we just leave the accumulator unchanged. If it was <code>False</code> before, it stays that way because this current element is not it. If it was <code>True</code>, we leave it at that.</p></div><div><p>The right fold, <code>foldr</code> works in a similar way to the left fold, only the accumulator eats up the values from the right. Also, the left fold's binary function has the accumulator as the first parameter and the current value as the second one (so <code>\acc x -&gt; ...</code>), the right fold's binary function has the current value as the first parameter and the accumulator as the second one (so <code>\x acc -&gt; ...</code>). It kind of makes sense that the right fold has the accumulator on the right, because it folds from the right side.</p></div><div><p>The accumulator value (and hence, the result) of a fold can be of any type. It can be a number, a boolean or even a new list. We'll be implementing the map function with a right fold. The accumulator will be a list, we'll be accumulating the mapped list element by element. From that, it's obvious that the starting element will be an empty list.</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token builtin">map</span>' <span class="token operator">::</span> <span class="token punctuation">(</span><span class="token hvariable">a</span> <span class="token operator">-&gt;</span> <span class="token hvariable">b</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token punctuation">[</span><span class="token hvariable">a</span><span class="token punctuation">]</span> <span class="token operator">-&gt;</span> <span class="token punctuation">[</span><span class="token hvariable">b</span><span class="token punctuation">]</span>
<span class="token builtin">map</span>' <span class="token hvariable">f</span> <span class="token hvariable">xs</span> <span class="token operator">=</span> <span class="token builtin">foldr</span> <span class="token punctuation">(</span><span class="token operator">\</span><span class="token hvariable">x</span> <span class="token hvariable">acc</span> <span class="token operator">-&gt;</span> <span class="token hvariable">f</span> <span class="token hvariable">x</span> <span class="token operator">:</span> <span class="token hvariable">acc</span><span class="token punctuation">)</span> <span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token hvariable">xs</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>If we're mapping <code>(+3)</code> to <code>[1,2,3]</code>, we approach the list from the right side. We take the last element, which is <code>3</code> and apply the function to it, which ends up being <code>6</code>. Then, we prepend it to the accumulator, which is was <code>[]</code>. <code>6:[]</code> is <code>[6]</code> and that's now the accumulator. We apply <code>(+3)</code> to <code>2</code>, that's <code>5</code> and we prepend (<code>:</code>) it to the accumulator, so the accumulator is now <code>[5,6]</code>. We apply <code>(+3)</code> to <code>1</code> and prepend that to the accumulator and so the end value is <code>[4,5,6]</code>.</p></div><div><p>Of course, we could have implemented this function with a left fold too. It would be <code>map' f xs = foldl (\acc x -&gt; acc ++ [f x]) [] xs</code>, but the thing is that the <code>++</code> function is much more expensive than <code>:</code>, so we usually use right folds when we're building up new lists from a list.</p></div><div><p><span alt="LYHfGG_37_washmachine.png" src="LYHfGG_37_washmachine.png" class="internal-embed media-embed image-embed is-loaded"><img alt="LYHfGG_37_washmachine.png" src="курсы\learn-you-a-haskell-for-great-good!\картинки\lyhfgg_37_washmachine.png"></span></p></div><div><p>If you reverse a list, you can do a right fold on it just like you would have done a left fold and vice versa. Sometimes you don't even have to do that. The <code>sum</code> function can be implemented pretty much the same with a left and right fold. One big difference is that right folds work on infinite lists, whereas left ones don't! To put it plainly, if you take an infinite list at some point and you fold it up from the right, you'll eventually reach the beginning of the list. However, if you take an infinite list at a point and you try to fold it up from the left, you'll never reach an end!</p></div><div><p><strong>Folds can be used to implstrongent any function where you traverse a list once, elstrongent by elstrongent, and then return something based on that. Whenever you want to traverse a list to return something, chances are you want a fold.</strong> That's why folds are, along with maps and filters, one of the most useful types of functions in functional programming.</p></div><div><p>The <code>foldl1</code> and <code>foldr1</code> functions work much like <code>foldl</code> and <code>foldr</code>, only you don't need to provide them with an explicit starting value. They assume the first (or last) element of the list to be the starting value and then start the fold with the element next to it. With that in mind, the <code>sum</code> function can be implemented like so: <code>sum = foldl1 (+)</code>. Because they depend on the lists they fold up having at least one element, they cause runtime errors if called with empty lists. <code>foldl</code> and <code>foldr</code>, on the other hand, work fine with empty lists. When making a fold, think about how it acts on an empty list. If the function doesn't make sense when given an empty list, you can probably use a <code>foldl1</code> or <code>foldr1</code> to implement it.</p></div><div><p>Just to show you how powerful folds are, we're going to implement a bunch of standard library functions by using folds:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token builtin">maximum</span>' <span class="token operator">::</span> <span class="token punctuation">(</span><span class="token constant">Ord</span> <span class="token hvariable">a</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">[</span><span class="token hvariable">a</span><span class="token punctuation">]</span> <span class="token operator">-&gt;</span> <span class="token hvariable">a</span>
<span class="token builtin">maximum</span>' <span class="token operator">=</span> <span class="token builtin">foldr1</span> <span class="token punctuation">(</span><span class="token operator">\</span><span class="token hvariable">x</span> <span class="token hvariable">acc</span> <span class="token operator">-&gt;</span> <span class="token keyword">if</span> <span class="token hvariable">x</span> <span class="token operator">&gt;</span> <span class="token hvariable">acc</span> <span class="token keyword">then</span> <span class="token hvariable">x</span> <span class="token keyword">else</span> <span class="token hvariable">acc</span><span class="token punctuation">)</span>

<span class="token builtin">reverse</span>' <span class="token operator">::</span> <span class="token punctuation">[</span><span class="token hvariable">a</span><span class="token punctuation">]</span> <span class="token operator">-&gt;</span> <span class="token punctuation">[</span><span class="token hvariable">a</span><span class="token punctuation">]</span>
<span class="token builtin">reverse</span>' <span class="token operator">=</span> <span class="token builtin">foldl</span> <span class="token punctuation">(</span><span class="token operator">\</span><span class="token hvariable">acc</span> <span class="token hvariable">x</span> <span class="token operator">-&gt;</span> <span class="token hvariable">x</span> <span class="token operator">:</span> <span class="token hvariable">acc</span><span class="token punctuation">)</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>

<span class="token builtin">product</span>' <span class="token operator">::</span> <span class="token punctuation">(</span><span class="token constant">Num</span> <span class="token hvariable">a</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">[</span><span class="token hvariable">a</span><span class="token punctuation">]</span> <span class="token operator">-&gt;</span> <span class="token hvariable">a</span>
<span class="token builtin">product</span>' <span class="token operator">=</span> <span class="token builtin">foldr1</span> <span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">)</span>

<span class="token builtin">filter</span>' <span class="token operator">::</span> <span class="token punctuation">(</span><span class="token hvariable">a</span> <span class="token operator">-&gt;</span> <span class="token constant">Bool</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token punctuation">[</span><span class="token hvariable">a</span><span class="token punctuation">]</span> <span class="token operator">-&gt;</span> <span class="token punctuation">[</span><span class="token hvariable">a</span><span class="token punctuation">]</span>
<span class="token builtin">filter</span>' <span class="token hvariable">p</span> <span class="token operator">=</span> <span class="token builtin">foldr</span> <span class="token punctuation">(</span><span class="token operator">\</span><span class="token hvariable">x</span> <span class="token hvariable">acc</span> <span class="token operator">-&gt;</span> <span class="token keyword">if</span> <span class="token hvariable">p</span> <span class="token hvariable">x</span> <span class="token keyword">then</span> <span class="token hvariable">x</span> <span class="token operator">:</span> <span class="token hvariable">acc</span> <span class="token keyword">else</span> <span class="token hvariable">acc</span><span class="token punctuation">)</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>

<span class="token builtin">head</span>' <span class="token operator">::</span> <span class="token punctuation">[</span><span class="token hvariable">a</span><span class="token punctuation">]</span> <span class="token operator">-&gt;</span> <span class="token hvariable">a</span>
<span class="token builtin">head</span>' <span class="token operator">=</span> <span class="token builtin">foldr1</span> <span class="token punctuation">(</span><span class="token operator">\</span><span class="token hvariable">x</span> <span class="token hvariable">_</span> <span class="token operator">-&gt;</span> <span class="token hvariable">x</span><span class="token punctuation">)</span>

<span class="token builtin">last</span>' <span class="token operator">::</span> <span class="token punctuation">[</span><span class="token hvariable">a</span><span class="token punctuation">]</span> <span class="token operator">-&gt;</span> <span class="token hvariable">a</span>
<span class="token builtin">last</span>' <span class="token operator">=</span> <span class="token builtin">foldl1</span> <span class="token punctuation">(</span><span class="token operator">\</span><span class="token hvariable">_</span> <span class="token hvariable">x</span> <span class="token operator">-&gt;</span> <span class="token hvariable">x</span><span class="token punctuation">)</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p><code>head</code> is better implemented by pattern matching, but this just goes to show, you can still achieve it by using folds. Our <code>reverse'</code> definition is pretty clever, I think. We take a starting value of an empty list and then approach our list from the left and just prepend to our accumulator. In the end, we build up a reversed list. <code>\acc x -&gt; x : acc</code> kind of looks like the <code>:</code> function, only the parameters are flipped. That's why we could have also written our reverse as <code>foldl (flip (:)) []</code>.</p></div><div><p>Another way to picture right and left folds is like this: say we have a right fold and the binary function is <code>f</code> and the starting value is <code>z</code>. If we're right folding over the list <code>[3,4,5,6]</code>, we're essentially doing this: <code>f 3 (f 4 (f 5 (f 6 z)))</code>. <code>f</code> is called with the last element in the list and the accumulator, that value is given as the accumulator to the next to last value and so on. If we take <code>f</code> to be <code>+</code> and the starting accumulator value to be <code>0</code>, that's <code>3 + (4 + (5 + (6 + 0)))</code>. Or if we write <code>+</code> as a prefix function, that's <code>(+) 3 ((+) 4 ((+) 5 ((+) 6 0)))</code>. Similarly, doing a left fold over that list with <code>g</code> as the binary function and <code>z</code> as the accumulator is the equivalent of <code>g (g (g (g z 3) 4) 5) 6</code>. If we use <code>flip (:)</code> as the binary function and <code>[]</code> as the accumulator (so we're reversing the list), then that's the equivalent of <code>flip (:) (flip (:) (flip (:) (flip (:) [] 3) 4) 5) 6</code>. And sure enough, if you evaluate that expression, you get <code>[6,5,4,3]</code>.</p></div><div><p><code>scanl</code> and <code>scanr</code> are like <code>foldl</code> and <code>foldr</code>, only they report all the intermediate accumulator states in the form of a list. There are also <code>scanl1</code> and <code>scanr1</code>, which are analogous to <code>foldl1</code> and <code>foldr1</code>.</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token builtin">scanl</span> <span class="token punctuation">(</span><span class="token operator">+</span><span class="token punctuation">)</span> <span class="token number">0</span> <span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">]</span>
<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">8</span><span class="token punctuation">,</span><span class="token number">10</span><span class="token punctuation">,</span><span class="token number">11</span><span class="token punctuation">]</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token builtin">scanr</span> <span class="token punctuation">(</span><span class="token operator">+</span><span class="token punctuation">)</span> <span class="token number">0</span> <span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">]</span>
<span class="token punctuation">[</span><span class="token number">11</span><span class="token punctuation">,</span><span class="token number">8</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">]</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token builtin">scanl1</span> <span class="token punctuation">(</span><span class="token operator">\</span><span class="token hvariable">acc</span> <span class="token hvariable">x</span> <span class="token operator">-&gt;</span> <span class="token keyword">if</span> <span class="token hvariable">x</span> <span class="token operator">&gt;</span> <span class="token hvariable">acc</span> <span class="token keyword">then</span> <span class="token hvariable">x</span> <span class="token keyword">else</span> <span class="token hvariable">acc</span><span class="token punctuation">)</span> <span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">7</span><span class="token punctuation">,</span><span class="token number">9</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">]</span>
<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">7</span><span class="token punctuation">,</span><span class="token number">9</span><span class="token punctuation">,</span><span class="token number">9</span><span class="token punctuation">,</span><span class="token number">9</span><span class="token punctuation">]</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token builtin">scanl</span> <span class="token punctuation">(</span><span class="token builtin">flip</span> <span class="token punctuation">(</span><span class="token operator">:</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">]</span>
<span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">]</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>When using a <code>scanl</code>, the final result will be in the last element of the resulting list while a <code>scanr</code> will place the result in the head.</p></div><div><p>Scans are used to monitor the progression of a function that can be implemented as a fold. Let's answer us this question: <strong>How many elstrongents does it take for the sum of the roots of all natural numbers to exceed 1000?</strong> To get the squares of all natural numbers, we just do <code>map sqrt [1..]</code>. Now, to get the sum, we could do a fold, but because we're interested in how the sum progresses, we're going to do a scan. Once we've done the scan, we just see how many sums are under 1000. The first sum in the scanlist will be 1, normally. The second will be 1 plus the square root of 2. The third will be that plus the square root of 3. If there are X sums under 1000, then it takes X+1 elements for the sum to exceed 1000.</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">sqrtSums</span> <span class="token operator">::</span> <span class="token constant">Int</span>
<span class="token hvariable">sqrtSums</span> <span class="token operator">=</span> <span class="token builtin">length</span> <span class="token punctuation">(</span><span class="token builtin">takeWhile</span> <span class="token punctuation">(</span><span class="token operator">&lt;</span><span class="token number">1000</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token builtin">scanl1</span> <span class="token punctuation">(</span><span class="token operator">+</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token builtin">map</span> <span class="token builtin">sqrt</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token operator">..</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token hvariable">sqrtSums</span>
<span class="token number">131</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token builtin">sum</span> <span class="token punctuation">(</span><span class="token builtin">map</span> <span class="token builtin">sqrt</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token operator">..</span><span class="token number">131</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
<span class="token number">1005.0942035344083</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token builtin">sum</span> <span class="token punctuation">(</span><span class="token builtin">map</span> <span class="token builtin">sqrt</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token operator">..</span><span class="token number">130</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
<span class="token number">993.6486803921487</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>We use <code>takeWhile</code> here instead of <code>filter</code> because <code>filter</code> doesn't work on infinite lists. Even though we know the list is ascending, <code>filter</code> doesn't, so we use <code>takeWhile</code> to cut the scanlist off at the first occurence of a sum greater than 1000.</p></div><div><h2 data-heading="Function application with $" id="Function_application_with_$" style="display: flex;"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>Function application with $</h2></div><div><p>Alright, next up, we'll take a look at the <code>$</code> function, also called <em>function application</em>. First of all, let's check out how it's defined:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token punctuation">(</span><span class="token operator">$</span><span class="token punctuation">)</span> <span class="token operator">::</span> <span class="token punctuation">(</span><span class="token hvariable">a</span> <span class="token operator">-&gt;</span> <span class="token hvariable">b</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token hvariable">a</span> <span class="token operator">-&gt;</span> <span class="token hvariable">b</span>
<span class="token hvariable">f</span> <span class="token operator">$</span> <span class="token hvariable">x</span> <span class="token operator">=</span> <span class="token hvariable">f</span> <span class="token hvariable">x</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p><span alt="LYHfGG_38_dollar.png" src="LYHfGG_38_dollar.png" class="internal-embed media-embed image-embed is-loaded"><img alt="LYHfGG_38_dollar.png" src="курсы\learn-you-a-haskell-for-great-good!\картинки\lyhfgg_38_dollar.png"></span></p></div><div><p>What the heck? What is this useless operator? It's just function application! Well, almost, but not quite! Whereas normal function application (putting a space between two things) has a really high precedence, the <code>$</code> function has the lowest precedence. Function application with a space is left-associative (so <code>f a b c</code> is the same as <code>((f a) b) c)</code>), function application with <code>$</code> is right-associative.</p></div><div><p>That's all very well, but how does this help us? Most of the time, it's a convenience function so that we don't have to write so many parentheses. Consider the expression <code>sum (map sqrt [1..130])</code>. Because <code>$</code> has such a low precedence, we can rewrite that expression as <code>sum $ map sqrt [1..130]</code>, saving ourselves precious keystrokes! When a <code>$</code> is encountered, the expression on its right is applied as the parameter to the function on its left. How about <code>sqrt 3 + 4 + 9</code>? This adds together 9, 4 and the square root of 3. If we want get the square root of <em>3 + 4 + 9</em>, we'd have to write <code>sqrt (3 + 4 + 9)</code> or if we use <code>$</code> we can write it as <code>sqrt $ 3 + 4 + 9</code> because <code>$</code> has the lowest precedence of any operator. That's why you can imagine a <code>$</code> being sort of the equivalent of writing an opening parentheses and then writing a closing one on the far right side of the expression.</p></div><div><p>How about <code>sum (filter (&gt; 10) (map (*2) [2..10]))</code>? Well, because <code>$</code> is right-associative, <code>f (g (z x))</code> is equal to <code>f $ g $ z x</code>. And so, we can rewrite <code>sum (filter (&gt; 10) (map (*2) [2..10]))</code> as <code>sum $ filter (&gt; 10) $ map (*2) [2..10]</code>.</p></div><div><p>But apart from getting rid of parentheses, <code>$</code> means that function application can be treated just like another function. That way, we can, for instance, map function application over a list of functions.</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token builtin">map</span> <span class="token punctuation">(</span><span class="token operator">$</span> <span class="token number">3</span><span class="token punctuation">)</span> <span class="token punctuation">[</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token operator">+</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token number">10</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token operator">^</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token builtin">sqrt</span><span class="token punctuation">]</span>
<span class="token punctuation">[</span><span class="token number">7.0</span><span class="token punctuation">,</span><span class="token number">30.0</span><span class="token punctuation">,</span><span class="token number">9.0</span><span class="token punctuation">,</span><span class="token number">1.7320508075688772</span><span class="token punctuation">]</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><h2 data-heading="Function composition" id="Function_composition" style="display: flex;"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>Function composition</h2></div><div><p>In mathematics, function composition is defined like this: <span class="math math-block is-loaded"><mjx-container class="MathJax" jax="CHTML" display="true"><mjx-math display="true" class="MJX-TEX" style="margin-left: 0px; margin-right: 0px;"><mjx-mo class="mjx-n"><mjx-c class="mjx-c28"></mjx-c></mjx-mo><mjx-mi class="mjx-i"><mjx-c class="mjx-c1D453 TEX-I"></mjx-c></mjx-mi><mjx-mtext class="mjx-n"><mjx-c class="mjx-cA0"></mjx-c></mjx-mtext><mjx-mo class="mjx-n" space="3"><mjx-c class="mjx-c2218"></mjx-c></mjx-mo><mjx-mtext class="mjx-n" space="3"><mjx-c class="mjx-cA0"></mjx-c></mjx-mtext><mjx-mi class="mjx-i"><mjx-c class="mjx-c1D454 TEX-I"></mjx-c></mjx-mi><mjx-mo class="mjx-n"><mjx-c class="mjx-c29"></mjx-c></mjx-mo><mjx-mo class="mjx-n"><mjx-c class="mjx-c28"></mjx-c></mjx-mo><mjx-mi class="mjx-i"><mjx-c class="mjx-c1D465 TEX-I"></mjx-c></mjx-mi><mjx-mo class="mjx-n"><mjx-c class="mjx-c29"></mjx-c></mjx-mo><mjx-mo class="mjx-n" space="4"><mjx-c class="mjx-c3D"></mjx-c></mjx-mo><mjx-mi class="mjx-i" space="4"><mjx-c class="mjx-c1D453 TEX-I"></mjx-c></mjx-mi><mjx-mo class="mjx-n"><mjx-c class="mjx-c28"></mjx-c></mjx-mo><mjx-mi class="mjx-i"><mjx-c class="mjx-c1D454 TEX-I"></mjx-c></mjx-mi><mjx-mo class="mjx-n"><mjx-c class="mjx-c28"></mjx-c></mjx-mo><mjx-mi class="mjx-i"><mjx-c class="mjx-c1D465 TEX-I"></mjx-c></mjx-mi><mjx-mo class="mjx-n"><mjx-c class="mjx-c29"></mjx-c></mjx-mo><mjx-mo class="mjx-n"><mjx-c class="mjx-c29"></mjx-c></mjx-mo></mjx-math></mjx-container></span>, meaning that composing two functions produces a new function that, when called with a parameter, say, <em>x</em> is the equivalent of calling <em>g</em> with the parameter <em>x</em> and then calling the <em>f</em> with that result.</p></div><div><p>In Haskell, function composition is pretty much the same thing. We do function composition with the <code>.</code> function, which is defined like so:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token punctuation">(</span><span class="token punctuation">.</span><span class="token punctuation">)</span> <span class="token operator">::</span> <span class="token punctuation">(</span><span class="token hvariable">b</span> <span class="token operator">-&gt;</span> <span class="token hvariable">c</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token punctuation">(</span><span class="token hvariable">a</span> <span class="token operator">-&gt;</span> <span class="token hvariable">b</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token hvariable">a</span> <span class="token operator">-&gt;</span> <span class="token hvariable">c</span>
<span class="token hvariable">f</span> <span class="token operator">.</span> <span class="token hvariable">g</span> <span class="token operator">=</span> <span class="token operator">\</span><span class="token hvariable">x</span> <span class="token operator">-&gt;</span> <span class="token hvariable">f</span> <span class="token punctuation">(</span><span class="token hvariable">g</span> <span class="token hvariable">x</span><span class="token punctuation">)</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p><span alt="LYHfGG_40_notes.png" src="LYHfGG_40_notes.png" class="internal-embed media-embed image-embed is-loaded"><img alt="LYHfGG_40_notes.png" src="курсы\learn-you-a-haskell-for-great-good!\картинки\lyhfgg_40_notes.png"></span></p></div><div><p>Mind the type declaration. <code>f</code> must take as its parameter a value that has the same type as <code>g</code>'s return value. So the resulting function takes a parameter of the same type that <code>g</code> takes and returns a value of the same type that <code>f</code> returns. The expression <code>negate . (* 3)</code> returns a function that takes a number, multiplies it by 3 and then negates it.</p></div><div><p>One of the uses for function composition is making functions on the fly to pass to other functions. Sure, can use lambdas for that, but many times, function composition is clearer and more concise. Say we have a list of numbers and we want to turn them all into negative numbers. One way to do that would be to get each number's absolute value and then negate it, like so:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token builtin">map</span> <span class="token punctuation">(</span><span class="token operator">\</span><span class="token hvariable">x</span> <span class="token operator">-&gt;</span> <span class="token builtin">negate</span> <span class="token punctuation">(</span><span class="token builtin">abs</span> <span class="token hvariable">x</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">6</span><span class="token punctuation">,</span><span class="token number">7</span><span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">19</span><span class="token punctuation">,</span><span class="token number">24</span><span class="token punctuation">]</span>
<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">6</span><span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">7</span><span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">19</span><span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">24</span><span class="token punctuation">]</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Notice the lambda and how it looks like the result function composition. Using function composition, we can rewrite that as:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token builtin">map</span> <span class="token punctuation">(</span><span class="token builtin">negate</span> <span class="token operator">.</span> <span class="token builtin">abs</span><span class="token punctuation">)</span> <span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">6</span><span class="token punctuation">,</span><span class="token number">7</span><span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">19</span><span class="token punctuation">,</span><span class="token number">24</span><span class="token punctuation">]</span>
<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">6</span><span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">7</span><span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">19</span><span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">24</span><span class="token punctuation">]</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Fabulous! Function composition is right-associative, so we can compose many functions at a time. The expression <code>f (g (z x))</code> is equivalent to <code>(f . g . z) x</code>. With that in mind, we can turn</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token builtin">map</span> <span class="token punctuation">(</span><span class="token operator">\</span><span class="token hvariable">xs</span> <span class="token operator">-&gt;</span> <span class="token builtin">negate</span> <span class="token punctuation">(</span><span class="token builtin">sum</span> <span class="token punctuation">(</span><span class="token builtin">tail</span> <span class="token hvariable">xs</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token operator">..</span><span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token number">3</span><span class="token operator">..</span><span class="token number">6</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token operator">..</span><span class="token number">7</span><span class="token punctuation">]</span><span class="token punctuation">]</span>
<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">14</span><span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">15</span><span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">27</span><span class="token punctuation">]</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>into</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token builtin">map</span> <span class="token punctuation">(</span><span class="token builtin">negate</span> <span class="token operator">.</span> <span class="token builtin">sum</span> <span class="token operator">.</span> <span class="token builtin">tail</span><span class="token punctuation">)</span> <span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token operator">..</span><span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token number">3</span><span class="token operator">..</span><span class="token number">6</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token operator">..</span><span class="token number">7</span><span class="token punctuation">]</span><span class="token punctuation">]</span>
<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">14</span><span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">15</span><span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">27</span><span class="token punctuation">]</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>But what about functions that take several parameters? Well, if we want to use them in function composition, we usually have to partially apply them just so much that each function takes just one parameter. <code>sum (replicate 5 (max 6.7 8.9))</code> can be rewritten as <code>(sum . replicate 5 . max 6.7) 8.9</code> or as <code>sum . replicate 5 . max 6.7 $ 8.9</code>. What goes on in here is this: a function that takes what <code>max 6.7</code> takes and applies <code>replicate 5</code> to it is created. Then, a function that takes the result of that and does a sum of it is created. Finally, that function is called with <code>8.9</code>. But normally, you just read that as: apply <code>8.9</code> to <code>max 6.7</code>, then apply <code>replicate 5</code> to that and then apply <code>sum</code> to that. If you want to rewrite an expression with a lot of parentheses by using function composition, you can start by putting the last parameter of the innermost function after a <code>$</code> and then just composing all the other function calls, writing them without their last parameter and putting dots between them. If you have <code>replicate 100 (product (map (*3) (zipWith max [1,2,3,4,5] [4,5,6,7,8])))</code>, you can write it as <code>replicate 100 . product . map (*3) . zipWith max [1,2,3,4,5] $ [4,5,6,7,8]</code>. If the expression ends with three parentheses, chances are that if you translate it into function composition, it'll have three composition operators.</p></div><div><p>Another common use of function composition is defining functions in the so-called point free style (also called the point<em>less</em> style). Take for example this function that we wrote earlier:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token builtin">sum</span>' <span class="token operator">::</span> <span class="token punctuation">(</span><span class="token constant">Num</span> <span class="token hvariable">a</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">[</span><span class="token hvariable">a</span><span class="token punctuation">]</span> <span class="token operator">-&gt;</span> <span class="token hvariable">a</span>   
<span class="token builtin">sum</span>' <span class="token hvariable">xs</span> <span class="token operator">=</span> <span class="token builtin">foldl</span> <span class="token punctuation">(</span><span class="token operator">+</span><span class="token punctuation">)</span> <span class="token number">0</span> <span class="token hvariable">xs</span>   
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>The <code>xs</code> is exposed on both right sides. Because of currying, we can omit the <code>xs</code> on both sides, because calling <code>foldl (+) 0</code> creates a function that takes a list. Writing the function as <code>sum' = foldl (+) 0</code> is called writing it in point free style. How would we write this in point free style?</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">fn</span> <span class="token hvariable">x</span> <span class="token operator">=</span> <span class="token builtin">ceiling</span> <span class="token punctuation">(</span><span class="token builtin">negate</span> <span class="token punctuation">(</span><span class="token builtin">tan</span> <span class="token punctuation">(</span><span class="token builtin">cos</span> <span class="token punctuation">(</span><span class="token builtin">max</span> <span class="token number">50</span> <span class="token hvariable">x</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>We can't just get rid of the <code>x</code> on both right right sides. The <code>x</code> in the function body has parentheses after it. <code>cos (max 50)</code> wouldn't make sense. You can't get the cosine of a function. What we can do is express <code>fn</code> as a composition of functions.</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">fn</span> <span class="token operator">=</span> <span class="token builtin">ceiling</span> <span class="token operator">.</span> <span class="token builtin">negate</span> <span class="token operator">.</span> <span class="token builtin">tan</span> <span class="token operator">.</span> <span class="token builtin">cos</span> <span class="token operator">.</span> <span class="token builtin">max</span> <span class="token number">50</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Excellent! Many times, a point free style is more readable and concise, because it makes you think about functions and what kind of functions composing them results in instead of thinking about data and how it's shuffled around. You can take simple functions and use composition as glue to form more complex functions. However, many times, writing a function in point free style can be less readable if a function is too complex. That's why making long chains of function composition is discouraged, although I plead guilty of sometimes being too composition-happy. The prefered style is to use <em>let</em> bindings to give labels to intermediary results or split the problem into sub-problems and then put it together so that the function makes sense to someone reading it instead of just making a huge composition chain.</p></div><div><p>In the section about maps and filters, we solved a problem of finding the sum of all odd squares that are smaller than 10,000. Here's what the solution looks like when put into a function.</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">oddSquareSum</span> <span class="token operator">::</span> <span class="token constant">Integer</span>
<span class="token hvariable">oddSquareSum</span> <span class="token operator">=</span> <span class="token builtin">sum</span> <span class="token punctuation">(</span><span class="token builtin">takeWhile</span> <span class="token punctuation">(</span><span class="token operator">&lt;</span><span class="token number">10000</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token builtin">filter</span> <span class="token builtin">odd</span> <span class="token punctuation">(</span><span class="token builtin">map</span> <span class="token punctuation">(</span><span class="token operator">^</span><span class="token number">2</span><span class="token punctuation">)</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token operator">..</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>   
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Being such a fan of function composition, I would have probably written that like this:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">oddSquareSum</span> <span class="token operator">::</span> <span class="token constant">Integer</span>
<span class="token hvariable">oddSquareSum</span> <span class="token operator">=</span> <span class="token builtin">sum</span> <span class="token operator">.</span> <span class="token builtin">takeWhile</span> <span class="token punctuation">(</span><span class="token operator">&lt;</span><span class="token number">10000</span><span class="token punctuation">)</span> <span class="token operator">.</span> <span class="token builtin">filter</span> <span class="token builtin">odd</span> <span class="token operator">.</span> <span class="token builtin">map</span> <span class="token punctuation">(</span><span class="token operator">^</span><span class="token number">2</span><span class="token punctuation">)</span> <span class="token operator">$</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token operator">..</span><span class="token punctuation">]</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>However, if there was a chance of someone else reading that code, I would have written it like this:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">oddSquareSum</span> <span class="token operator">::</span> <span class="token constant">Integer</span>
<span class="token hvariable">oddSquareSum</span> <span class="token operator">=</span> 
    <span class="token keyword">let</span> <span class="token hvariable">oddSquares</span> <span class="token operator">=</span> <span class="token builtin">filter</span> <span class="token builtin">odd</span> <span class="token operator">$</span> <span class="token builtin">map</span> <span class="token punctuation">(</span><span class="token operator">^</span><span class="token number">2</span><span class="token punctuation">)</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token operator">..</span><span class="token punctuation">]</span>
        <span class="token hvariable">belowLimit</span> <span class="token operator">=</span> <span class="token builtin">takeWhile</span> <span class="token punctuation">(</span><span class="token operator">&lt;</span><span class="token number">10000</span><span class="token punctuation">)</span> <span class="token hvariable">oddSquares</span>
    <span class="token keyword">in</span>  <span class="token builtin">sum</span> <span class="token hvariable">belowLimit</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>It wouldn't win any code golf competition, but someone reading the function will probably find it easier to read than a composition chain.</p></div><div><h1 data-heading="Modules" id="Modules">Modules</h1></div><div><h2 data-heading="Loading modules" id="Loading_modules" style="display: flex;"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>Loading modules</h2></div><div><p><span alt="LYHfGG_41_modules.png" src="LYHfGG_41_modules.png" class="internal-embed media-embed image-embed is-loaded"><img alt="LYHfGG_41_modules.png" src="курсы\learn-you-a-haskell-for-great-good!\картинки\lyhfgg_41_modules.png"></span></p></div><div><p>A Haskell module is a collection of related functions, types and typeclasses. A Haskell program is a collection of modules where the main module loads up the other modules and then uses the functions defined in them to do something. Having code split up into several modules has quite a lot of advantages. If a module is generic enough, the functions it exports can be used in a multitude of different programs. If your own code is separated into self-contained modules which don't rely on each other too much (we also say they are loosely coupled), you can reuse them later on. It makes the whole deal of writing code more manageable by having it split into several parts, each of which has some sort of purpose.</p></div><div><p>The Haskell standard library is split into modules, each of them contains functions and types that are somehow related and serve some common purpose. There's a module for manipulating lists, a module for concurrent programming, a module for dealing with complex numbers, etc. All the functions, types and typeclasses that we've dealt with so far were part of the <code>Prelude</code> module, which is imported by default. In this chapter, we're going to examine a few useful modules and the functions that they have. But first, we're going to see how to import modules.</p></div><div><p>The syntax for importing modules in a Haskell script is <code>import &lt;module name&gt;</code>. This must be done before defining any functions, so imports are usually done at the top of the file. One script can, of course, import several modules. Just put each import statement into a separate line. Let's import the <code>Data.List</code> module, which has a bunch of useful functions for working with lists and use a function that it exports to create a function that tells us how many unique elements a list has.</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token import-statement"><span class="token keyword">import</span> Data<span class="token punctuation">.</span>List</span>

<span class="token hvariable">numUniques</span> <span class="token operator">::</span> <span class="token punctuation">(</span><span class="token constant">Eq</span> <span class="token hvariable">a</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">[</span><span class="token hvariable">a</span><span class="token punctuation">]</span> <span class="token operator">-&gt;</span> <span class="token constant">Int</span>
<span class="token hvariable">numUniques</span> <span class="token operator">=</span> <span class="token builtin">length</span> <span class="token operator">.</span> <span class="token hvariable">nub</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>When you do <code>import Data.List</code>, all the functions that <code>Data.List</code> exports become available in the global namespace, meaning that you can call them from wherever in the script. <code>nub</code> is a function defined in <code>Data.List</code> that takes a list and weeds out duplicate elements. Composing <code>length</code> and <code>nub</code> by doing <code>length . nub</code> produces a function that's the equivalent of <code>\xs -&gt; length (nub xs)</code>.</p></div><div><p>You can also put the functions of modules into the global namespace when using GHCI. If you're in GHCI and you want to be able to call the functions exported by <code>Data.List</code>, do this:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token operator">:</span><span class="token hvariable">m</span> <span class="token operator">+</span> <span class="token constant">Data<span class="token punctuation">.</span>List</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>If we want to load up the names from several modules inside GHCI, we don't have to do <code>:m +</code> several times, we can just load up several modules at once.</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token operator">:</span><span class="token hvariable">m</span> <span class="token operator">+</span> <span class="token constant">Data<span class="token punctuation">.</span>List</span> <span class="token constant">Data<span class="token punctuation">.</span>Map</span> <span class="token constant">Data<span class="token punctuation">.</span>Set</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>However, if you've loaded a script that already imports a module, you don't need to use <code>:m +</code> to get access to it.</p></div><div><p>If you just need a couple of functions from a module, you can selectively import just those functions. If we wanted to import only the <code>nub</code> and <code>sort</code> functions from <code>Data.List</code>, we'd do this:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token import-statement"><span class="token keyword">import</span> Data<span class="token punctuation">.</span>List</span> <span class="token punctuation">(</span><span class="token hvariable">nub</span><span class="token punctuation">,</span> <span class="token builtin">sort</span><span class="token punctuation">)</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>You can also choose to import all of the functions of a module except a few select ones. That's often useful when several modules export functions with the same name and you want to get rid of the offending ones. Say we already have our own function that's called <code>nub</code> and we want to import all the functions from <code>Data.List</code> except the <code>nub</code> function:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token import-statement"><span class="token keyword">import</span> Data<span class="token punctuation">.</span>List <span class="token keyword">hiding</span></span> <span class="token punctuation">(</span><span class="token hvariable">nub</span><span class="token punctuation">)</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Another way of dealing with name clashes is to do qualified imports. The <code>Data.Map</code> module, which offers a data structure for looking up values by key, exports a bunch of functions with the same name as <code>Prelude</code> functions, like <code>filter</code> or <code>null</code>. So when we import <code>Data.Map</code> and then call <code>filter</code>, Haskell won't know which function to use. Here's how we solve this:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token import-statement"><span class="token keyword">import</span> <span class="token keyword">qualified</span> Data<span class="token punctuation">.</span>Map</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>This makes it so that if we want to reference <code>Data.Map</code>'s <code>filter</code> function, we have to do <code>Data.Map.filter</code>, whereas just <code>filter</code> still refers to the normal <code>filter</code> we all know and love. But typing out <code>Data.Map</code> in front of every function from that module is kind of tedious. That's why we can rename the qualified import to something shorter:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token import-statement"><span class="token keyword">import</span> <span class="token keyword">qualified</span> Data<span class="token punctuation">.</span>Map <span class="token keyword">as</span> M</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Now, to reference <code>Data.Map</code>'s <code>filter</code> function, we just use <code>M.filter</code>.</p></div><div><p>Use <a data-tooltip-position="top" aria-label="http://www.haskell.org/ghc/docs/latest/html/libraries/" rel="noopener" class="external-link" href="http://www.haskell.org/ghc/docs/latest/html/libraries/" target="_blank">this handy reference</a> to see which modules are in the standard library. A great way to pick up new Haskell knowledge is to just click through the standard library reference and explore the modules and their functions. You can also view the Haskell source code for each module. Reading the source code of some modules is a really good way to learn Haskell and get a solid feel for it.</p></div><div><p>To search for functions or to find out where they're located, use <a data-tooltip-position="top" aria-label="http://haskell.org/hoogle" rel="noopener" class="external-link" href="http://haskell.org/hoogle" target="_blank">Hoogle</a>. It's a really awesome Haskell search engine, you can search by name, module name or even type signature.</p></div><div><h2 data-heading="Data.List" id="Data.List" style="display: flex;"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>Data.List</h2></div><div><p>The <code>Data.List</code> module is all about lists, obviously. It provides some very useful functions for dealing with them. We've already met some of its functions (like <code>map</code> and <code>filter</code>) because the <code>Prelude</code> module exports some functions from <code>Data.List</code> for convenience. You don't have to import <code>Data.List</code> via a qualified import because it doesn't clash with any <code>Prelude</code> names except for those that <code>Prelude</code> already steals from <code>Data.List</code>. Let's take a look at some of the functions that we haven't met before.</p></div><div><p><code>intersperse</code> takes an element and a list and then puts that element in between each pair of elements in the list. Here's a demonstration:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token hvariable">intersperse</span> <span class="token char string">'.'</span> <span class="token string">"MONKEY"</span>
<span class="token string">"M.O.N.K.E.Y"</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token hvariable">intersperse</span> <span class="token number">0</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">]</span>
<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">]</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p><code>intercalate</code> takes a list of lists and a list. It then inserts that list in between all those lists and then flattens the result.</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token hvariable">intercalate</span> <span class="token string">" "</span> <span class="token punctuation">[</span><span class="token string">"hey"</span><span class="token punctuation">,</span><span class="token string">"there"</span><span class="token punctuation">,</span><span class="token string">"guys"</span><span class="token punctuation">]</span>
<span class="token string">"hey there guys"</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token hvariable">intercalate</span> <span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token number">7</span><span class="token punctuation">,</span><span class="token number">8</span><span class="token punctuation">,</span><span class="token number">9</span><span class="token punctuation">]</span><span class="token punctuation">]</span>
<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">7</span><span class="token punctuation">,</span><span class="token number">8</span><span class="token punctuation">,</span><span class="token number">9</span><span class="token punctuation">]</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p><code>transpose</code> transposes a list of lists. If you look at a list of lists as a 2D matrix, the columns become the rows and vice versa.</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token hvariable">transpose</span> <span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token number">7</span><span class="token punctuation">,</span><span class="token number">8</span><span class="token punctuation">,</span><span class="token number">9</span><span class="token punctuation">]</span><span class="token punctuation">]</span>
<span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">7</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">8</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">,</span><span class="token number">9</span><span class="token punctuation">]</span><span class="token punctuation">]</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token hvariable">transpose</span> <span class="token punctuation">[</span><span class="token string">"hey"</span><span class="token punctuation">,</span><span class="token string">"there"</span><span class="token punctuation">,</span><span class="token string">"guys"</span><span class="token punctuation">]</span>
<span class="token punctuation">[</span><span class="token string">"htg"</span><span class="token punctuation">,</span><span class="token string">"ehu"</span><span class="token punctuation">,</span><span class="token string">"yey"</span><span class="token punctuation">,</span><span class="token string">"rs"</span><span class="token punctuation">,</span><span class="token string">"e"</span><span class="token punctuation">]</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Say we have the polynomials <em>3x2 + 5x + 9</em>, <em>10x3 + 9</em> and <em>8x3 + 5x2 + x - 1</em> and we want to add them together. We can use the lists <code>[0,3,5,9]</code>, <code>[10,0,0,9]</code> and <code>[8,5,1,-1]</code> to represent them in Haskell. Now, to add them, all we have to do is this:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token builtin">map</span> <span class="token builtin">sum</span> <span class="token operator">$</span> <span class="token hvariable">transpose</span> <span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">9</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">9</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token number">8</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">]</span>
<span class="token punctuation">[</span><span class="token number">18</span><span class="token punctuation">,</span><span class="token number">8</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">,</span><span class="token number">17</span><span class="token punctuation">]</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>When we transpose these three lists, the third powers are then in the first row, the second powers in the second one and so on. Mapping <code>sum</code> to that produces our desired result.</p></div><div><p><span alt="LYHfGG_42_legolists.png" src="LYHfGG_42_legolists.png" class="internal-embed media-embed image-embed is-loaded"><img alt="LYHfGG_42_legolists.png" src="курсы\learn-you-a-haskell-for-great-good!\картинки\lyhfgg_42_legolists.png"></span></p></div><div><p><code>foldl'</code> and <code>foldl1'</code> are stricter versions of their respective lazy incarnations. When using lazy folds on really big lists, you might often get a stack overflow error. The culprit for that is that due to the lazy nature of the folds, the accumulator value isn't actually updated as the folding happens. What actually happens is that the accumulator kind of makes a promise that it will compute its value when asked to actually produce the result (also called a thunk). That happens for every intermediate accumulator and all those thunks overflow your stack. The strict folds aren't lazy buggers and actually compute the intermediate values as they go along instead of filling up your stack with thunks. So if you ever get stack overflow errors when doing lazy folds, try switching to their strict versions.</p></div><div><p><code>concat</code> flattens a list of lists into just a list of elements.</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token builtin">concat</span> <span class="token punctuation">[</span><span class="token string">"foo"</span><span class="token punctuation">,</span><span class="token string">"bar"</span><span class="token punctuation">,</span><span class="token string">"car"</span><span class="token punctuation">]</span>
<span class="token string">"foobarcar"</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token builtin">concat</span> <span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">]</span>
<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">]</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>It will just remove one level of nesting. So if you want to completely flatten <code>[[[2,3],[3,4,5],[2]],[[2,3],[3,4]]]</code>, which is a list of lists of lists, you have to concatenate it twice.</p></div><div><p>Doing <code>concatMap</code> is the same as first mapping a function to a list and then concatenating the list with <code>concat</code>.</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token builtin">concatMap</span> <span class="token punctuation">(</span><span class="token builtin">replicate</span> <span class="token number">4</span><span class="token punctuation">)</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token operator">..</span><span class="token number">3</span><span class="token punctuation">]</span>
<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">]</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p><code>and</code> takes a list of boolean values and returns <code>True</code> only if all the values in the list are <code>True</code>.</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token builtin">and</span> <span class="token operator">$</span> <span class="token builtin">map</span> <span class="token punctuation">(</span><span class="token operator">&gt;</span><span class="token number">4</span><span class="token punctuation">)</span> <span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">,</span><span class="token number">7</span><span class="token punctuation">,</span><span class="token number">8</span><span class="token punctuation">]</span>
<span class="token constant">True</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token builtin">and</span> <span class="token operator">$</span> <span class="token builtin">map</span> <span class="token punctuation">(</span><span class="token operator">==</span><span class="token number">4</span><span class="token punctuation">)</span> <span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">]</span>
<span class="token constant">False</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p><code>or</code> is like <code>and</code>, only it returns <code>True</code> if any of the boolean values in a list is <code>True</code>.</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token builtin">or</span> <span class="token operator">$</span> <span class="token builtin">map</span> <span class="token punctuation">(</span><span class="token operator">==</span><span class="token number">4</span><span class="token punctuation">)</span> <span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">]</span>
<span class="token constant">True</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token builtin">or</span> <span class="token operator">$</span> <span class="token builtin">map</span> <span class="token punctuation">(</span><span class="token operator">&gt;</span><span class="token number">4</span><span class="token punctuation">)</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">]</span>
<span class="token constant">False</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p><code>any</code> and <code>all</code> take a predicate and then check if any or all the elements in a list satisfy the predicate, respectively. Usually we use these two functions instead of mapping over a list and then doing <code>and</code> or <code>or</code>.</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token builtin">any</span> <span class="token punctuation">(</span><span class="token operator">==</span><span class="token number">4</span><span class="token punctuation">)</span> <span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">]</span>
<span class="token constant">True</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token builtin">all</span> <span class="token punctuation">(</span><span class="token operator">&gt;</span><span class="token number">4</span><span class="token punctuation">)</span> <span class="token punctuation">[</span><span class="token number">6</span><span class="token punctuation">,</span><span class="token number">9</span><span class="token punctuation">,</span><span class="token number">10</span><span class="token punctuation">]</span>
<span class="token constant">True</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token builtin">all</span> <span class="token punctuation">(</span><span class="token operator">`elem`</span> <span class="token punctuation">[</span><span class="token char string">'A'</span><span class="token operator">..</span><span class="token char string">'Z'</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token string">"HEYGUYSwhatsup"</span>
<span class="token constant">False</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token builtin">any</span> <span class="token punctuation">(</span><span class="token operator">`elem`</span> <span class="token punctuation">[</span><span class="token char string">'A'</span><span class="token operator">..</span><span class="token char string">'Z'</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token string">"HEYGUYSwhatsup"</span>
<span class="token constant">True</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p><code>iterate</code> takes a function and a starting value. It applies the function to the starting value, then it applies that function to the result, then it applies the function to that result again, etc. It returns all the results in the form of an infinite list.</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token builtin">take</span> <span class="token number">10</span> <span class="token operator">$</span> <span class="token builtin">iterate</span> <span class="token punctuation">(</span><span class="token operator">*</span><span class="token number">2</span><span class="token punctuation">)</span> <span class="token number">1</span>
<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">8</span><span class="token punctuation">,</span><span class="token number">16</span><span class="token punctuation">,</span><span class="token number">32</span><span class="token punctuation">,</span><span class="token number">64</span><span class="token punctuation">,</span><span class="token number">128</span><span class="token punctuation">,</span><span class="token number">256</span><span class="token punctuation">,</span><span class="token number">512</span><span class="token punctuation">]</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token builtin">take</span> <span class="token number">3</span> <span class="token operator">$</span> <span class="token builtin">iterate</span> <span class="token punctuation">(</span><span class="token operator">++</span> <span class="token string">"haha"</span><span class="token punctuation">)</span> <span class="token string">"haha"</span>
<span class="token punctuation">[</span><span class="token string">"haha"</span><span class="token punctuation">,</span><span class="token string">"hahahaha"</span><span class="token punctuation">,</span><span class="token string">"hahahahahaha"</span><span class="token punctuation">]</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p><code>splitAt</code> takes a number and a list. It then splits the list at that many elements, returning the resulting two lists in a tuple.</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token builtin">splitAt</span> <span class="token number">3</span> <span class="token string">"heyman"</span>
<span class="token punctuation">(</span><span class="token string">"hey"</span><span class="token punctuation">,</span><span class="token string">"man"</span><span class="token punctuation">)</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token builtin">splitAt</span> <span class="token number">100</span> <span class="token string">"heyman"</span>
<span class="token punctuation">(</span><span class="token string">"heyman"</span><span class="token punctuation">,</span><span class="token string">""</span><span class="token punctuation">)</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token builtin">splitAt</span> <span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">3</span><span class="token punctuation">)</span> <span class="token string">"heyman"</span>
<span class="token punctuation">(</span><span class="token string">""</span><span class="token punctuation">,</span><span class="token string">"heyman"</span><span class="token punctuation">)</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token keyword">let</span> <span class="token punctuation">(</span><span class="token hvariable">a</span><span class="token punctuation">,</span><span class="token hvariable">b</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token builtin">splitAt</span> <span class="token number">3</span> <span class="token string">"foobar"</span> <span class="token keyword">in</span> <span class="token hvariable">b</span> <span class="token operator">++</span> <span class="token hvariable">a</span>
<span class="token string">"barfoo"</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p><code>takeWhile</code> is a really useful little function. It takes elements from a list while the predicate holds and then when an element is encountered that doesn't satisfy the predicate, it's cut off. It turns out this is very useful.</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token builtin">takeWhile</span> <span class="token punctuation">(</span><span class="token operator">&gt;</span><span class="token number">3</span><span class="token punctuation">)</span> <span class="token punctuation">[</span><span class="token number">6</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">]</span>
<span class="token punctuation">[</span><span class="token number">6</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">]</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token builtin">takeWhile</span> <span class="token punctuation">(</span><span class="token operator">/=</span><span class="token char string">' '</span><span class="token punctuation">)</span> <span class="token string">"This is a sentence"</span>
<span class="token string">"This"</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Say we wanted to know the sum of all third powers that are under 10,000. We can't map <code>(^3)</code> to <code>[1..]</code>, apply a filter and then try to sum that up because filtering an infinite list never finishes. You may know that all the elements here are ascending but Haskell doesn't. That's why we can do this:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token builtin">sum</span> <span class="token operator">$</span> <span class="token builtin">takeWhile</span> <span class="token punctuation">(</span><span class="token operator">&lt;</span><span class="token number">10000</span><span class="token punctuation">)</span> <span class="token operator">$</span> <span class="token builtin">map</span> <span class="token punctuation">(</span><span class="token operator">^</span><span class="token number">3</span><span class="token punctuation">)</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token operator">..</span><span class="token punctuation">]</span>
<span class="token number">53361</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>We apply <code>(^3)</code> to an infinite list and then once an element that's over 10,000 is encountered, the list is cut off. Now we can sum it up easily.</p></div><div><p><code>dropWhile</code> is similar, only it drops all the elements while the predicate is true. Once predicate equates to <code>False</code>, it returns the rest of the list. An extremely useful and lovely function!</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token builtin">dropWhile</span> <span class="token punctuation">(</span><span class="token operator">/=</span><span class="token char string">' '</span><span class="token punctuation">)</span> <span class="token string">"This is a sentence"</span>
<span class="token string">" is a sentence"</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token builtin">dropWhile</span> <span class="token punctuation">(</span><span class="token operator">&lt;</span><span class="token number">3</span><span class="token punctuation">)</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">]</span>
<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">]</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>We're given a list that represents the value of a stock by date. The list is made of tuples whose first component is the stock value, the second is the year, the third is the month and the fourth is the date. We want to know when the stock value first exceeded one thousand dollars!</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token keyword">let</span> <span class="token hvariable">stock</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">(</span><span class="token number">994.4</span><span class="token punctuation">,</span><span class="token number">2008</span><span class="token punctuation">,</span><span class="token number">9</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token number">995.2</span><span class="token punctuation">,</span><span class="token number">2008</span><span class="token punctuation">,</span><span class="token number">9</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token number">999.2</span><span class="token punctuation">,</span><span class="token number">2008</span><span class="token punctuation">,</span><span class="token number">9</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token number">1001.4</span><span class="token punctuation">,</span><span class="token number">2008</span><span class="token punctuation">,</span><span class="token number">9</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token number">998.3</span><span class="token punctuation">,</span><span class="token number">2008</span><span class="token punctuation">,</span><span class="token number">9</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">]</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token builtin">head</span> <span class="token punctuation">(</span><span class="token builtin">dropWhile</span> <span class="token punctuation">(</span><span class="token operator">\</span><span class="token punctuation">(</span><span class="token hvariable">val</span><span class="token punctuation">,</span><span class="token hvariable">y</span><span class="token punctuation">,</span><span class="token hvariable">m</span><span class="token punctuation">,</span><span class="token hvariable">d</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token hvariable">val</span> <span class="token operator">&lt;</span> <span class="token number">1000</span><span class="token punctuation">)</span> <span class="token hvariable">stock</span><span class="token punctuation">)</span>
<span class="token punctuation">(</span><span class="token number">1001.4</span><span class="token punctuation">,</span><span class="token number">2008</span><span class="token punctuation">,</span><span class="token number">9</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">)</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p><code>span</code> is kind of like <code>takeWhile</code>, only it returns a pair of lists. The first list contains everything the resulting list from <code>takeWhile</code> would contain if it were called with the same predicate and the same list. The second list contains the part of the list that would have been dropped.</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token keyword">let</span> <span class="token punctuation">(</span><span class="token hvariable">fw</span><span class="token punctuation">,</span> <span class="token hvariable">rest</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token builtin">span</span> <span class="token punctuation">(</span><span class="token operator">/=</span><span class="token char string">' '</span><span class="token punctuation">)</span> <span class="token string">"This is a sentence"</span> <span class="token keyword">in</span> <span class="token string">"First word:"</span> <span class="token operator">++</span> <span class="token hvariable">fw</span> <span class="token operator">++</span> <span class="token string">", the rest:"</span> <span class="token operator">++</span> <span class="token hvariable">rest</span>
<span class="token string">"First word: This, the rest: is a sentence"</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Whereas <code>span</code> spans the list while the predicate is true, <code>break</code> breaks it when the predicate is first true. Doing <code>break p</code> is the equivalent of doing <code>span (not . p)</code>.</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token builtin">break</span> <span class="token punctuation">(</span><span class="token operator">==</span><span class="token number">4</span><span class="token punctuation">)</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">,</span><span class="token number">7</span><span class="token punctuation">]</span>
<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">,</span><span class="token number">7</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token builtin">span</span> <span class="token punctuation">(</span><span class="token operator">/=</span><span class="token number">4</span><span class="token punctuation">)</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">,</span><span class="token number">7</span><span class="token punctuation">]</span>
<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">,</span><span class="token number">7</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>When using <code>break</code>, the second list in the result will start with the first element that satisfies the predicate.</p></div><div><p><code>sort</code> simply sorts a list. The type of the elements in the list has to be part of the <code>Ord</code> typeclass, because if the elements of a list can't be put in some kind of order, then the list can't be sorted.</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token builtin">sort</span> <span class="token punctuation">[</span><span class="token number">8</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">]</span>
<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">,</span><span class="token number">8</span><span class="token punctuation">]</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token builtin">sort</span> <span class="token string">"This will be sorted soon"</span>
<span class="token string">"    Tbdeehiillnooorssstw"</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p><code>group</code> takes a list and groups adjacent elements into sublists if they are equal.</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token builtin">group</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">,</span><span class="token number">7</span><span class="token punctuation">]</span>
<span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token number">6</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token number">7</span><span class="token punctuation">]</span><span class="token punctuation">]</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>If we sort a list before grouping it, we can find out how many times each element appears in the list.</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token builtin">map</span> <span class="token punctuation">(</span><span class="token operator">\</span><span class="token hvariable">l</span><span class="token operator">@</span><span class="token punctuation">(</span><span class="token hvariable">x</span><span class="token operator">:</span><span class="token hvariable">xs</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token punctuation">(</span><span class="token hvariable">x</span><span class="token punctuation">,</span><span class="token builtin">length</span> <span class="token hvariable">l</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">.</span> <span class="token builtin">group</span> <span class="token operator">.</span> <span class="token builtin">sort</span> <span class="token operator">$</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">,</span><span class="token number">7</span><span class="token punctuation">]</span>
<span class="token punctuation">[</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">7</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token number">6</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token number">7</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">]</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p><code>inits</code> and <code>tails</code> are like <code>init</code> and <code>tail</code>, only they recursively apply that to a list until there's nothing left. Observe.</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token hvariable">inits</span> <span class="token string">"w00t"</span>
<span class="token punctuation">[</span><span class="token string">""</span><span class="token punctuation">,</span><span class="token string">"w"</span><span class="token punctuation">,</span><span class="token string">"w0"</span><span class="token punctuation">,</span><span class="token string">"w00"</span><span class="token punctuation">,</span><span class="token string">"w00t"</span><span class="token punctuation">]</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token hvariable">tails</span> <span class="token string">"w00t"</span>
<span class="token punctuation">[</span><span class="token string">"w00t"</span><span class="token punctuation">,</span><span class="token string">"00t"</span><span class="token punctuation">,</span><span class="token string">"0t"</span><span class="token punctuation">,</span><span class="token string">"t"</span><span class="token punctuation">,</span><span class="token string">""</span><span class="token punctuation">]</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token keyword">let</span> <span class="token hvariable">w</span> <span class="token operator">=</span> <span class="token string">"w00t"</span> <span class="token keyword">in</span> <span class="token builtin">zip</span> <span class="token punctuation">(</span><span class="token hvariable">inits</span> <span class="token hvariable">w</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token hvariable">tails</span> <span class="token hvariable">w</span><span class="token punctuation">)</span>
<span class="token punctuation">[</span><span class="token punctuation">(</span><span class="token string">""</span><span class="token punctuation">,</span><span class="token string">"w00t"</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token string">"w"</span><span class="token punctuation">,</span><span class="token string">"00t"</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token string">"w0"</span><span class="token punctuation">,</span><span class="token string">"0t"</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token string">"w00"</span><span class="token punctuation">,</span><span class="token string">"t"</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token string">"w00t"</span><span class="token punctuation">,</span><span class="token string">""</span><span class="token punctuation">)</span><span class="token punctuation">]</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Let's use a fold to implement searching a list for a sublist.</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">search</span> <span class="token operator">::</span> <span class="token punctuation">(</span><span class="token constant">Eq</span> <span class="token hvariable">a</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">[</span><span class="token hvariable">a</span><span class="token punctuation">]</span> <span class="token operator">-&gt;</span> <span class="token punctuation">[</span><span class="token hvariable">a</span><span class="token punctuation">]</span> <span class="token operator">-&gt;</span> <span class="token constant">Bool</span>
<span class="token hvariable">search</span> <span class="token hvariable">needle</span> <span class="token hvariable">haystack</span> <span class="token operator">=</span> 
    <span class="token keyword">let</span> <span class="token hvariable">nlen</span> <span class="token operator">=</span> <span class="token builtin">length</span> <span class="token hvariable">needle</span>
    <span class="token keyword">in</span>  <span class="token builtin">foldl</span> <span class="token punctuation">(</span><span class="token operator">\</span><span class="token hvariable">acc</span> <span class="token hvariable">x</span> <span class="token operator">-&gt;</span> <span class="token keyword">if</span> <span class="token builtin">take</span> <span class="token hvariable">nlen</span> <span class="token hvariable">x</span> <span class="token operator">==</span> <span class="token hvariable">needle</span> <span class="token keyword">then</span> <span class="token constant">True</span> <span class="token keyword">else</span> <span class="token hvariable">acc</span><span class="token punctuation">)</span> <span class="token constant">False</span> <span class="token punctuation">(</span><span class="token hvariable">tails</span> <span class="token hvariable">haystack</span><span class="token punctuation">)</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>First we call <code>tails</code> with the list in which we're searching. Then we go over each tail and see if it starts with what we're looking for.</p></div><div><p>With that, we actually just made a function that behaves like <code>isInfixOf</code>. <code>isInfixOf</code> searches for a sublist within a list and returns <code>True</code> if the sublist we're looking for is somewhere inside the target list.</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token string">"cat"</span> <span class="token operator">`isInfixOf`</span> <span class="token string">"im a cat burglar"</span>
<span class="token constant">True</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token string">"Cat"</span> <span class="token operator">`isInfixOf`</span> <span class="token string">"im a cat burglar"</span>
<span class="token constant">False</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token string">"cats"</span> <span class="token operator">`isInfixOf`</span> <span class="token string">"im a cat burglar"</span>
<span class="token constant">False</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p><code>isPrefixOf</code> and <code>isSuffixOf</code> search for a sublist at the beginning and at the end of a list, respectively.</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token string">"hey"</span> <span class="token operator">`isPrefixOf`</span> <span class="token string">"hey there!"</span>
<span class="token constant">True</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token string">"hey"</span> <span class="token operator">`isPrefixOf`</span> <span class="token string">"oh hey there!"</span>
<span class="token constant">False</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token string">"there!"</span> <span class="token operator">`isSuffixOf`</span> <span class="token string">"oh hey there!"</span>
<span class="token constant">True</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token string">"there!"</span> <span class="token operator">`isSuffixOf`</span> <span class="token string">"oh hey there"</span>
<span class="token constant">False</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p><code>elem</code> and <code>notElem</code> check if an element is or isn't inside a list.</p></div><div><p><code>partition</code> takes a list and a predicate and returns a pair of lists. The first list in the result contains all the elements that satisfy the predicate, the second contains all the ones that don't.</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token hvariable">partition</span> <span class="token punctuation">(</span><span class="token operator">`elem`</span> <span class="token punctuation">[</span><span class="token char string">'A'</span><span class="token operator">..</span><span class="token char string">'Z'</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token string">"BOBsidneyMORGANeddy"</span>
<span class="token punctuation">(</span><span class="token string">"BOBMORGAN"</span><span class="token punctuation">,</span><span class="token string">"sidneyeddy"</span><span class="token punctuation">)</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token hvariable">partition</span> <span class="token punctuation">(</span><span class="token operator">&gt;</span><span class="token number">3</span><span class="token punctuation">)</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">7</span><span class="token punctuation">]</span>
<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">,</span><span class="token number">7</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>It's important to understand how this is different from <code>span</code> and <code>break</code>:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token builtin">span</span> <span class="token punctuation">(</span><span class="token operator">`elem`</span> <span class="token punctuation">[</span><span class="token char string">'A'</span><span class="token operator">..</span><span class="token char string">'Z'</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token string">"BOBsidneyMORGANeddy"</span>
<span class="token punctuation">(</span><span class="token string">"BOB"</span><span class="token punctuation">,</span><span class="token string">"sidneyMORGANeddy"</span><span class="token punctuation">)</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>While <code>span</code> and <code>break</code> are done once they encounter the first element that doesn't and does satisfy the predicate, <code>partition</code> goes through the whole list and splits it up according to the predicate.</p></div><div><p><code>find</code> takes a list and a predicate and returns the first element that satisfies the predicate. But it returns that element wrapped in a <code>Maybe</code> value. We'll be covering algebraic data types more in depth in the next chapter but for now, this is what you need to know: a <code>Maybe</code> value can either be <code>Just something</code> or <code>Nothing</code>. Much like a list can be either an empty list or a list with some elements, a <code>Maybe</code> value can be either no elements or a single element. And like the type of a list of, say, integers is <code>[Int]</code>, the type of maybe having an integer is <code>Maybe Int</code>. Anyway, let's take our <code>find</code> function for a spin.</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token hvariable">find</span> <span class="token punctuation">(</span><span class="token operator">&gt;</span><span class="token number">4</span><span class="token punctuation">)</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">]</span>
<span class="token constant">Just</span> <span class="token number">5</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token hvariable">find</span> <span class="token punctuation">(</span><span class="token operator">&gt;</span><span class="token number">9</span><span class="token punctuation">)</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">]</span>
<span class="token constant">Nothing</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token operator">:</span><span class="token hvariable">t</span> <span class="token hvariable">find</span>
<span class="token hvariable">find</span> <span class="token operator">::</span> <span class="token punctuation">(</span><span class="token hvariable">a</span> <span class="token operator">-&gt;</span> <span class="token constant">Bool</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token punctuation">[</span><span class="token hvariable">a</span><span class="token punctuation">]</span> <span class="token operator">-&gt;</span> <span class="token constant">Maybe</span> <span class="token hvariable">a</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Notice the type of <code>find</code>. Its result is <code>Maybe a</code>. That's kind of like having the type of <code>[a]</code>, only a value of the type <code>Maybe</code> can contain either no elements or one element, whereas a list can contain no elements, one element or several elements.</p></div><div><p>Remember when we were searching for the first time our stock went over $1000. We did <code>head (dropWhile (\(val,y,m,d) -&gt; val &lt; 1000) stock)</code>. Remember that <code>head</code> is not really safe. What would happen if our stock never went over $1000? Our application of <code>dropWhile</code> would return an empty list and getting the head of an empty list would result in an error. However, if we rewrote that as <code>find (\(val,y,m,d) -&gt; val &gt; 1000) stock</code>, we'd be much safer. If our stock never went over $1000 (so if no element satisfied the predicate), we'd get back a <code>Nothing</code>. But there was a valid answer in that list, we'd get, say, <code>Just (1001.4,2008,9,4)</code>.</p></div><div><p><code>elemIndex</code> is kind of like <code>elem</code>, only it doesn't return a boolean value. It maybe returns the index of the element we're looking for. If that element isn't in our list, it returns a <code>Nothing</code>.</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token operator">:</span><span class="token hvariable">t</span> <span class="token hvariable">elemIndex</span>
<span class="token hvariable">elemIndex</span> <span class="token operator">::</span> <span class="token punctuation">(</span><span class="token constant">Eq</span> <span class="token hvariable">a</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token hvariable">a</span> <span class="token operator">-&gt;</span> <span class="token punctuation">[</span><span class="token hvariable">a</span><span class="token punctuation">]</span> <span class="token operator">-&gt;</span> <span class="token constant">Maybe</span> <span class="token constant">Int</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token number">4</span> <span class="token operator">`elemIndex`</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">]</span>
<span class="token constant">Just</span> <span class="token number">3</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token number">10</span> <span class="token operator">`elemIndex`</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">]</span>
<span class="token constant">Nothing</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p><code>elemIndices</code> is like <code>elemIndex</code>, only it returns a list of indices, in case the element we're looking for crops up in our list several times. Because we're using a list to represent the indices, we don't need a <code>Maybe</code> type, because failure can be represented as the empty list, which is very much synonymous to <code>Nothing</code>.</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token char string">' '</span> <span class="token operator">`elemIndices`</span> <span class="token string">"Where are the spaces?"</span>
<span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">9</span><span class="token punctuation">,</span><span class="token number">13</span><span class="token punctuation">]</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p><code>findIndex</code> is like find, but it maybe returns the index of the first element that satisfies the predicate. <code>findIndices</code> returns the indices of all elements that satisfy the predicate in the form of a list.</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token hvariable">findIndex</span> <span class="token punctuation">(</span><span class="token operator">==</span><span class="token number">4</span><span class="token punctuation">)</span> <span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">]</span>
<span class="token constant">Just</span> <span class="token number">5</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token hvariable">findIndex</span> <span class="token punctuation">(</span><span class="token operator">==</span><span class="token number">7</span><span class="token punctuation">)</span> <span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">]</span>
<span class="token constant">Nothing</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token hvariable">findIndices</span> <span class="token punctuation">(</span><span class="token operator">`elem`</span> <span class="token punctuation">[</span><span class="token char string">'A'</span><span class="token operator">..</span><span class="token char string">'Z'</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token string">"Where Are The Caps?"</span>
<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">,</span><span class="token number">10</span><span class="token punctuation">,</span><span class="token number">14</span><span class="token punctuation">]</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>We already covered <code>zip</code> and <code>zipWith</code>. We noted that they zip together two lists, either in a tuple or with a binary function (meaning such a function that takes two parameters). But what if we want to zip together three lists? Or zip three lists with a function that takes three parameters? Well, for that, we have <code>zip3</code>, <code>zip4</code>, etc. and <code>zipWith3</code>, <code>zipWith4</code>, etc. These variants go up to 7. While this may look like a hack, it works out pretty fine, because there aren't many times when you want to zip 8 lists together. There's also a very clever way for zipping infinite numbers of lists, but we're not advanced enough to cover that just yet.</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token builtin">zipWith3</span> <span class="token punctuation">(</span><span class="token operator">\</span><span class="token hvariable">x</span> <span class="token hvariable">y</span> <span class="token hvariable">z</span> <span class="token operator">-&gt;</span> <span class="token hvariable">x</span> <span class="token operator">+</span> <span class="token hvariable">y</span> <span class="token operator">+</span> <span class="token hvariable">z</span><span class="token punctuation">)</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">]</span> <span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">]</span> <span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">]</span>
<span class="token punctuation">[</span><span class="token number">7</span><span class="token punctuation">,</span><span class="token number">9</span><span class="token punctuation">,</span><span class="token number">8</span><span class="token punctuation">]</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token hvariable">zip4</span> <span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">]</span> <span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">]</span> <span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">]</span> <span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">]</span>
<span class="token punctuation">[</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">]</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Just like with normal zipping, lists that are longer than the shortest list that's being zipped are cut down to size.</p></div><div><p><code>lines</code> is a useful function when dealing with files or input from somewhere. It takes a string and returns every line of that string in a separate list.</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token builtin">lines</span> <span class="token string">"first line\nsecond line\nthird line"</span>
<span class="token punctuation">[</span><span class="token string">"first line"</span><span class="token punctuation">,</span><span class="token string">"second line"</span><span class="token punctuation">,</span><span class="token string">"third line"</span><span class="token punctuation">]</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p><code>'\n'</code> is the character for a unix newline. Backslashes have special meaning in Haskell strings and characters.</p></div><div><p><code>unlines</code> is the inverse function of <code>lines</code>. It takes a list of strings and joins them together using a <code>'\n'</code>.</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token builtin">unlines</span> <span class="token punctuation">[</span><span class="token string">"first line"</span><span class="token punctuation">,</span> <span class="token string">"second line"</span><span class="token punctuation">,</span> <span class="token string">"third line"</span><span class="token punctuation">]</span>
<span class="token string">"first line\nsecond line\nthird line\n"</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p><code>words</code> and <code>unwords</code> are for splitting a line of text into words or joining a list of words into a text. Very useful.</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token builtin">words</span> <span class="token string">"hey these are the words in this sentence"</span>
<span class="token punctuation">[</span><span class="token string">"hey"</span><span class="token punctuation">,</span><span class="token string">"these"</span><span class="token punctuation">,</span><span class="token string">"are"</span><span class="token punctuation">,</span><span class="token string">"the"</span><span class="token punctuation">,</span><span class="token string">"words"</span><span class="token punctuation">,</span><span class="token string">"in"</span><span class="token punctuation">,</span><span class="token string">"this"</span><span class="token punctuation">,</span><span class="token string">"sentence"</span><span class="token punctuation">]</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token builtin">words</span> <span class="token string">"hey these           are    the words in this\nsentence"</span>
<span class="token punctuation">[</span><span class="token string">"hey"</span><span class="token punctuation">,</span><span class="token string">"these"</span><span class="token punctuation">,</span><span class="token string">"are"</span><span class="token punctuation">,</span><span class="token string">"the"</span><span class="token punctuation">,</span><span class="token string">"words"</span><span class="token punctuation">,</span><span class="token string">"in"</span><span class="token punctuation">,</span><span class="token string">"this"</span><span class="token punctuation">,</span><span class="token string">"sentence"</span><span class="token punctuation">]</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token builtin">unwords</span> <span class="token punctuation">[</span><span class="token string">"hey"</span><span class="token punctuation">,</span><span class="token string">"there"</span><span class="token punctuation">,</span><span class="token string">"mate"</span><span class="token punctuation">]</span>
<span class="token string">"hey there mate"</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>We've already mentioned <code>nub</code>. It takes a list and weeds out the duplicate elements, returning a list whose every element is a unique snowflake! The function does have a kind of strange name. It turns out that "nub" means a small lump or essential part of something. In my opinion, they should use real words for function names instead of old-people words.</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token hvariable">nub</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">]</span>
<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">]</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token hvariable">nub</span> <span class="token string">"Lots of words and stuff"</span>
<span class="token string">"Lots fwrdanu"</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p><code>delete</code> takes an element and a list and deletes the first occurence of that element in the list.</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token hvariable">delete</span> <span class="token char string">'h'</span> <span class="token string">"hey there ghang!"</span>
<span class="token string">"ey there ghang!"</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token hvariable">delete</span> <span class="token char string">'h'</span> <span class="token operator">.</span> <span class="token hvariable">delete</span> <span class="token char string">'h'</span> <span class="token operator">$</span> <span class="token string">"hey there ghang!"</span>
<span class="token string">"ey tere ghang!"</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token hvariable">delete</span> <span class="token char string">'h'</span> <span class="token operator">.</span> <span class="token hvariable">delete</span> <span class="token char string">'h'</span> <span class="token operator">.</span> <span class="token hvariable">delete</span> <span class="token char string">'h'</span> <span class="token operator">$</span> <span class="token string">"hey there ghang!"</span>
<span class="token string">"ey tere gang!"</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p><code>\\</code> is the list difference function. It acts like a set difference, basically. For every element in the right-hand list, it removes a matching element in the left one.</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token operator">..</span><span class="token number">10</span><span class="token punctuation">]</span> <span class="token operator">\\</span> <span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">9</span><span class="token punctuation">]</span>
<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">,</span><span class="token number">7</span><span class="token punctuation">,</span><span class="token number">8</span><span class="token punctuation">,</span><span class="token number">10</span><span class="token punctuation">]</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token string">"Im a big baby"</span> <span class="token operator">\\</span> <span class="token string">"big"</span>
<span class="token string">"Im a  baby"</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Doing <code>[1..10] \\ [2,5,9]</code> is like doing <code>delete 2 . delete 5 . delete 9 $ [1..10]</code>.</p></div><div><p><code>union</code> also acts like a function on sets. It returns the union of two lists. It pretty much goes over every element in the second list and appends it to the first one if it isn't already in yet. Watch out though, duplicates are removed from the second list!</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token string">"hey man"</span> <span class="token operator">`union`</span> <span class="token string">"man what's up"</span>
<span class="token string">"hey manwt'sup"</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token operator">..</span><span class="token number">7</span><span class="token punctuation">]</span> <span class="token operator">`union`</span> <span class="token punctuation">[</span><span class="token number">5</span><span class="token operator">..</span><span class="token number">10</span><span class="token punctuation">]</span>
<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">,</span><span class="token number">7</span><span class="token punctuation">,</span><span class="token number">8</span><span class="token punctuation">,</span><span class="token number">9</span><span class="token punctuation">,</span><span class="token number">10</span><span class="token punctuation">]</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p><code>intersect</code> works like set intersection. It returns only the elements that are found in both lists.</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token operator">..</span><span class="token number">7</span><span class="token punctuation">]</span> <span class="token operator">`intersect`</span> <span class="token punctuation">[</span><span class="token number">5</span><span class="token operator">..</span><span class="token number">10</span><span class="token punctuation">]</span>
<span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">,</span><span class="token number">7</span><span class="token punctuation">]</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p><code>insert</code> takes an element and a list of elements that can be sorted and inserts it into the last position where it's still less than or equal to the next element. In other words, <code>insert</code> will start at the beginning of the list and then keep going until it finds an element that's equal to or greater than the element that we're inserting and it will insert it just before the element.</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token hvariable">insert</span> <span class="token number">4</span> <span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">8</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">]</span>
<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">8</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">]</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token hvariable">insert</span> <span class="token number">4</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">]</span>
<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">]</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>The <code>4</code> is inserted right after the <code>3</code> and before the <code>5</code> in the first example and in between the <code>3</code> and <code>4</code> in the second example.</p></div><div><p>If we use insert to insert into a sorted list, the resulting list will be kept sorted.</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token hvariable">insert</span> <span class="token number">4</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">,</span><span class="token number">7</span><span class="token punctuation">]</span>
<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">,</span><span class="token number">7</span><span class="token punctuation">]</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token hvariable">insert</span> <span class="token char string">'g'</span> <span class="token operator">$</span> <span class="token punctuation">[</span><span class="token char string">'a'</span><span class="token operator">..</span><span class="token char string">'f'</span><span class="token punctuation">]</span> <span class="token operator">++</span> <span class="token punctuation">[</span><span class="token char string">'h'</span><span class="token operator">..</span><span class="token char string">'z'</span><span class="token punctuation">]</span>
<span class="token string">"abcdefghijklmnopqrstuvwxyz"</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token hvariable">insert</span> <span class="token number">3</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">]</span>
<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">]</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>What <code>length</code>, <code>take</code>, <code>drop</code>, <code>splitAt</code>, <code>!!</code> and <code>replicate</code> have in common is that they take an <code>Int</code> as one of their parameters (or return an <code>Int</code>), even though they could be more generic and usable if they just took any type that's part of the <code>Integral</code> or <code>Num</code> typeclasses (depending on the functions). They do that for historical reasons. However, fixing that would probably break a lot of existing code. That's why <code>Data.List</code> has their more generic equivalents, named <code>genericLength</code>, <code>genericTake</code>, <code>genericDrop</code>, <code>genericSplitAt</code>, <code>genericIndex</code> and <code>genericReplicate</code>. For instance, <code>length</code> has a type signature of <code>length :: [a] -&gt; Int</code>. If we try to get the average of a list of numbers by doing <code>let xs = [1..6] in sum xs / length xs</code>, we get a type error, because you can't use <code>/</code> with an <code>Int</code>. <code>genericLength</code>, on the other hand, has a type signature of <code>genericLength :: (Num a) =&gt; [b] -&gt; a</code>. Because a <code>Num</code> can act like a floating point number, getting the average by doing <code>let xs = [1..6] in sum xs / genericLength xs</code> works out just fine.</p></div><div><p>The <code>nub</code>, <code>delete</code>, <code>union</code>, <code>intersect</code> and <code>group</code> functions all have their more general counterparts called <code>nubBy</code>, <code>deleteBy</code>, <code>unionBy</code>, <code>intersectBy</code> and <code>groupBy</code>. The difference between them is that the first set of functions use <code>==</code> to test for equality, whereas the <em>By</em> ones also take an equality function and then compare them by using that equality function. <code>group</code> is the same as <code>groupBy (==)</code>.</p></div><div><p>For instance, say we have a list that describes the value of a function for every second. We want to segment it into sublists based on when the value was below zero and when it went above. If we just did a normal <code>group</code>, it would just group the equal adjacent values together. But what we want is to group them by whether they are negative or not. That's where <code>groupBy</code> comes in! The equality function supplied to the <em>By</em> functions should take two elements of the same type and return <code>True</code> if it considers them equal by its standards.</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token keyword">let</span> <span class="token hvariable">values</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">4.3</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">2.4</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">1.2</span><span class="token punctuation">,</span> <span class="token number">0.4</span><span class="token punctuation">,</span> <span class="token number">2.3</span><span class="token punctuation">,</span> <span class="token number">5.9</span><span class="token punctuation">,</span> <span class="token number">10.5</span><span class="token punctuation">,</span> <span class="token number">29.1</span><span class="token punctuation">,</span> <span class="token number">5.3</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">2.4</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">14.5</span><span class="token punctuation">,</span> <span class="token number">2.9</span><span class="token punctuation">,</span> <span class="token number">2.3</span><span class="token punctuation">]</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token hvariable">groupBy</span> <span class="token punctuation">(</span><span class="token operator">\</span><span class="token hvariable">x</span> <span class="token hvariable">y</span> <span class="token operator">-&gt;</span> <span class="token punctuation">(</span><span class="token hvariable">x</span> <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">==</span> <span class="token punctuation">(</span><span class="token hvariable">y</span> <span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token hvariable">values</span>
<span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">4.3</span><span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">2.4</span><span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">1.2</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token number">0.4</span><span class="token punctuation">,</span><span class="token number">2.3</span><span class="token punctuation">,</span><span class="token number">5.9</span><span class="token punctuation">,</span><span class="token number">10.5</span><span class="token punctuation">,</span><span class="token number">29.1</span><span class="token punctuation">,</span><span class="token number">5.3</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">2.4</span><span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">14.5</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token number">2.9</span><span class="token punctuation">,</span><span class="token number">2.3</span><span class="token punctuation">]</span><span class="token punctuation">]</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>From this, we clearly see which sections are positive and which are negative. The equality function supplied takes two elements and then returns <code>True</code> only if they're both negative or if they're both positive. This equality function can also be written as <code>\x y -&gt; (x &gt; 0) &amp;&amp; (y &gt; 0) || (x &lt;= 0) &amp;&amp; (y &lt;= 0)</code>, although I think the first way is more readable. An even clearer way to write equality functions for the <em>By</em> functions is if you import the <code>on</code> function from <code>Data.Function</code>. <code>on</code> is defined like this:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">on</span> <span class="token operator">::</span> <span class="token punctuation">(</span><span class="token hvariable">b</span> <span class="token operator">-&gt;</span> <span class="token hvariable">b</span> <span class="token operator">-&gt;</span> <span class="token hvariable">c</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token punctuation">(</span><span class="token hvariable">a</span> <span class="token operator">-&gt;</span> <span class="token hvariable">b</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token hvariable">a</span> <span class="token operator">-&gt;</span> <span class="token hvariable">a</span> <span class="token operator">-&gt;</span> <span class="token hvariable">c</span>
<span class="token hvariable">f</span> <span class="token operator">`on`</span> <span class="token hvariable">g</span> <span class="token operator">=</span> <span class="token operator">\</span><span class="token hvariable">x</span> <span class="token hvariable">y</span> <span class="token operator">-&gt;</span> <span class="token hvariable">f</span> <span class="token punctuation">(</span><span class="token hvariable">g</span> <span class="token hvariable">x</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token hvariable">g</span> <span class="token hvariable">y</span><span class="token punctuation">)</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>So doing <code>(==) `on` (&gt; 0)</code> returns an equality function that looks like <code>\x y -&gt; (x &gt; 0) == (y &gt; 0)</code>. <code>on</code> is used a lot with the <em>By</em> functions because with it, we can do:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token hvariable">groupBy</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token operator">==</span><span class="token punctuation">)</span> <span class="token operator">`on`</span> <span class="token punctuation">(</span><span class="token operator">&gt;</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token hvariable">values</span>
<span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">4.3</span><span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">2.4</span><span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">1.2</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token number">0.4</span><span class="token punctuation">,</span><span class="token number">2.3</span><span class="token punctuation">,</span><span class="token number">5.9</span><span class="token punctuation">,</span><span class="token number">10.5</span><span class="token punctuation">,</span><span class="token number">29.1</span><span class="token punctuation">,</span><span class="token number">5.3</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">2.4</span><span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">14.5</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token number">2.9</span><span class="token punctuation">,</span><span class="token number">2.3</span><span class="token punctuation">]</span><span class="token punctuation">]</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Very readable indeed! You can read it out loud: Group this by equality on whether the elements are greater than zero.</p></div><div><p>Similarly, the <code>sort</code>, <code>insert</code>, <code>maximum</code> and <code>minimum</code> also have their more general equivalents. Functions like <code>groupBy</code> take a function that determines when two elements are equal. <code>sortBy</code>, <code>insertBy</code>, <code>maximumBy</code> and <code>minimumBy</code> take a function that determine if one element is greater, smaller or equal to the other. The type signature of <code>sortBy</code> is <code>sortBy :: (a -&gt; a -&gt; Ordering) -&gt; [a] -&gt; [a]</code>. If you remember from before, the <code>Ordering</code> type can have a value of <code>LT</code>, <code>EQ</code> or <code>GT</code>. <code>sort</code> is the equivalent of <code>sortBy compare</code>, because compare just takes two elements whose type is in the <code>Ord</code> typeclass and returns their ordering relationship.</p></div><div><p>Lists can be compared, but when they are, they are compared lexicographically. What if we have a list of lists and we want to sort it not based on the inner lists' contents but on their lengths? Well, as you've probably guessed, we'll use the <code>sortBy</code> function.</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token keyword">let</span> <span class="token hvariable">xs</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">]</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token hvariable">sortBy</span> <span class="token punctuation">(</span><span class="token builtin">compare</span> <span class="token operator">`on`</span> <span class="token builtin">length</span><span class="token punctuation">)</span> <span class="token hvariable">xs</span>
<span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">]</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Awesome! <code>compare `on` length</code> ... man, that reads almost like real English! If you're not sure how exactly the <code>on</code> works here, <code>compare `on` length</code> is the equivalent of <code>\x y -&gt; length x `compare` length y</code>. When you're dealing with <em>By</em> functions that take an equality function, you usually do <code>(==) `on` something</code> and when you're dealing with <em>By</em> functions that take an ordering function, you usually do <code>compare `on` something</code>.</p></div><div><h2 data-heading="Data.Char" id="Data.Char" style="display: flex;"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>Data.Char</h2></div><div><p><span alt="LYHfGG_43_legochar.png" src="LYHfGG_43_legochar.png" class="internal-embed media-embed image-embed is-loaded"><img alt="LYHfGG_43_legochar.png" src="курсы\learn-you-a-haskell-for-great-good!\картинки\lyhfgg_43_legochar.png"></span></p></div><div><p>The <code>Data.Char</code> module does what its name suggests. It exports functions that deal with characters. It's also helpful when filtering and mapping over strings because they're just lists of characters.</p></div><div><p><code>Data.Char</code> exports a bunch of predicates over characters. That is, functions that take a character and tell us whether some assumption about it is true or false. Here's what they are:</p></div><div><p><code>isControl</code> checks whether a character is a control character.</p></div><div><p><code>isSpace</code> checks whether a character is a white-space characters. That includes spaces, tab characters, newlines, etc.</p></div><div><p><code>isLower</code> checks whether a character is lower-cased.</p></div><div><p><code>isUpper</code> checks whether a character is upper-cased.</p></div><div><p><code>isAlpha</code> checks whether a character is a letter.</p></div><div><p><code>isAlphaNum</code> checks whether a character is a letter or a number.</p></div><div><p><code>isPrint</code> checks whether a character is printable. Control characters, for instance, are not printable.</p></div><div><p><code>isDigit</code> checks whether a character is a digit.</p></div><div><p><code>isOctDigit</code> checks whether a character is an octal digit.</p></div><div><p><code>isHexDigit</code> checks whether a character is a hex digit.</p></div><div><p><code>isLetter</code> checks whether a character is a letter.</p></div><div><p><code>isMark</code> checks for Unicode mark characters. Those are characters that combine with preceding letters to form latters with accents. Use this if you are French.</p></div><div><p><code>isNumber</code> checks whether a character is numeric.</p></div><div><p><code>isPunctuation</code> checks whether a character is punctuation.</p></div><div><p><code>isSymbol</code> checks whether a character is a fancy mathematical or currency symbol.</p></div><div><p><code>isSeparator</code> checks for Unicode spaces and separators.</p></div><div><p><code>isAscii</code> checks whether a character falls into the first 128 characters of the Unicode character set.</p></div><div><p><code>isLatin1</code> checks whether a character falls into the first 256 characters of Unicode.</p></div><div><p><code>isAsciiUpper</code> checks whether a character is ASCII and upper-case.</p></div><div><p><code>isAsciiLower</code> checks whether a character is ASCII and lower-case.</p></div><div><p>All these predicates have a type signature of <code>Char -&gt; Bool</code>. Most of the time you'll use this to filter out strings or something like that. For instance, let's say we're making a program that takes a username and the username can only be comprised of alphanumeric characters. We can use the <code>Data.List</code> function <code>all</code> in combination with the <code>Data.Char</code> predicates to determine if the username is alright.</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token builtin">all</span> <span class="token builtin">isAlphaNum</span> <span class="token string">"bobby283"</span>
<span class="token constant">True</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token builtin">all</span> <span class="token builtin">isAlphaNum</span> <span class="token string">"eddy the fish!"</span>
<span class="token constant">False</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Kewl. In case you don't remember, <code>all</code> takes a predicate and a list and returns <code>True</code> only if that predicate holds for every element in the list.</p></div><div><p>We can also use <code>isSpace</code> to simulate the <code>Data.List</code> function <code>words</code>.</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token builtin">words</span> <span class="token string">"hey guys its me"</span>
<span class="token punctuation">[</span><span class="token string">"hey"</span><span class="token punctuation">,</span><span class="token string">"guys"</span><span class="token punctuation">,</span><span class="token string">"its"</span><span class="token punctuation">,</span><span class="token string">"me"</span><span class="token punctuation">]</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token hvariable">groupBy</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token operator">==</span><span class="token punctuation">)</span> <span class="token operator">`on`</span> <span class="token builtin">isSpace</span><span class="token punctuation">)</span> <span class="token string">"hey guys its me"</span>
<span class="token punctuation">[</span><span class="token string">"hey"</span><span class="token punctuation">,</span><span class="token string">" "</span><span class="token punctuation">,</span><span class="token string">"guys"</span><span class="token punctuation">,</span><span class="token string">" "</span><span class="token punctuation">,</span><span class="token string">"its"</span><span class="token punctuation">,</span><span class="token string">" "</span><span class="token punctuation">,</span><span class="token string">"me"</span><span class="token punctuation">]</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Hmmm, well, it kind of does what <code>words</code> does but we're left with elements of only spaces. Hmm, whatever shall we do? I know, let's filter that sucker.</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token builtin">filter</span> <span class="token punctuation">(</span><span class="token builtin">not</span> <span class="token operator">.</span> <span class="token builtin">any</span> <span class="token builtin">isSpace</span><span class="token punctuation">)</span> <span class="token operator">.</span> <span class="token hvariable">groupBy</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token operator">==</span><span class="token punctuation">)</span> <span class="token operator">`on`</span> <span class="token builtin">isSpace</span><span class="token punctuation">)</span> <span class="token operator">$</span> <span class="token string">"hey guys its me"</span>
<span class="token punctuation">[</span><span class="token string">"hey"</span><span class="token punctuation">,</span><span class="token string">"guys"</span><span class="token punctuation">,</span><span class="token string">"its"</span><span class="token punctuation">,</span><span class="token string">"me"</span><span class="token punctuation">]</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Ah.</p></div><div><p>The <code>Data.Char</code> also exports a datatype that's kind of like <code>Ordering</code>. The <code>Ordering</code> type can have a value of <code>LT</code>, <code>EQ</code> or <code>GT</code>. It's a sort of enumeration. It describes a few possible results that can arise from comparing two elements. The <code>GeneralCategory</code> type is also an enumeration. It presents us with a few possible categories that a character can fall into. The main function for getting the general category of a character is <code>generalCategory</code>. It has a type of <code>generalCategory :: Char -&gt; GeneralCategory</code>. There are about 31 categories so we won't list them all here, but let's play around with the function.</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token hvariable">generalCategory</span> <span class="token char string">' '</span>
<span class="token constant">Space</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token hvariable">generalCategory</span> <span class="token char string">'A'</span>
<span class="token constant">UppercaseLetter</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token hvariable">generalCategory</span> <span class="token char string">'a'</span>
<span class="token constant">LowercaseLetter</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token hvariable">generalCategory</span> <span class="token char string">'.'</span>
<span class="token constant">OtherPunctuation</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token hvariable">generalCategory</span> <span class="token char string">'9'</span>
<span class="token constant">DecimalNumber</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token builtin">map</span> <span class="token hvariable">generalCategory</span> <span class="token string">" \t\nA9?|"</span>
<span class="token punctuation">[</span><span class="token constant">Space</span><span class="token punctuation">,</span><span class="token constant">Control</span><span class="token punctuation">,</span><span class="token constant">Control</span><span class="token punctuation">,</span><span class="token constant">UppercaseLetter</span><span class="token punctuation">,</span><span class="token constant">DecimalNumber</span><span class="token punctuation">,</span><span class="token constant">OtherPunctuation</span><span class="token punctuation">,</span><span class="token constant">MathSymbol</span><span class="token punctuation">]</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Since the <code>GeneralCategory</code> type is part of the <code>Eq</code> typeclass, we can also test for stuff like <code>generalCategory c == Space</code>.</p></div><div><p><code>toUpper</code> converts a character to upper-case. Spaces, numbers, and the like remain unchanged.</p></div><div><p><code>toLower</code> converts a character to lower-case.</p></div><div><p><code>toTitle</code> converts a character to title-case. For most characters, title-case is the same as upper-case.</p></div><div><p><code>digitToInt</code> converts a character to an <code>Int</code>. To succeed, the character must be in the ranges <code>'0'..'9'</code>, <code>'a'..'f'</code> or <code>'A'..'F'</code>.</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token builtin">map</span> <span class="token builtin">digitToInt</span> <span class="token string">"34538"</span>
<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">8</span><span class="token punctuation">]</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token builtin">map</span> <span class="token builtin">digitToInt</span> <span class="token string">"FF85AB"</span>
<span class="token punctuation">[</span><span class="token number">15</span><span class="token punctuation">,</span><span class="token number">15</span><span class="token punctuation">,</span><span class="token number">8</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">10</span><span class="token punctuation">,</span><span class="token number">11</span><span class="token punctuation">]</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p><code>intToDigit</code> is the inverse function of <code>digitToInt</code>. It takes an <code>Int</code> in the range of <code>0..15</code> and converts it to a lower-case character.</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token builtin">intToDigit</span> <span class="token number">15</span>
<span class="token char string">'f'</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token builtin">intToDigit</span> <span class="token number">5</span>
<span class="token char string">'5'</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>The <code>ord</code> and <code>chr</code> functions convert characters to their corresponding numbers and vice versa:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token builtin">ord</span> <span class="token char string">'a'</span>
<span class="token number">97</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token builtin">chr</span> <span class="token number">97</span>
<span class="token char string">'a'</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token builtin">map</span> <span class="token builtin">ord</span> <span class="token string">"abcdefgh"</span>
<span class="token punctuation">[</span><span class="token number">97</span><span class="token punctuation">,</span><span class="token number">98</span><span class="token punctuation">,</span><span class="token number">99</span><span class="token punctuation">,</span><span class="token number">100</span><span class="token punctuation">,</span><span class="token number">101</span><span class="token punctuation">,</span><span class="token number">102</span><span class="token punctuation">,</span><span class="token number">103</span><span class="token punctuation">,</span><span class="token number">104</span><span class="token punctuation">]</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>The difference between the <code>ord</code> values of two characters is equal to how far apart they are in the Unicode table.</p></div><div><p>The Caesar cipher is a primitive method of encoding messages by shifting each character in them by a fixed number of positions in the alphabet. We can easily create a sort of Caesar cipher of our own, only we won't constrict ourselves to the alphabet.</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">encode</span> <span class="token operator">::</span> <span class="token constant">Int</span> <span class="token operator">-&gt;</span> <span class="token constant">String</span> <span class="token operator">-&gt;</span> <span class="token constant">String</span>
<span class="token hvariable">encode</span> <span class="token hvariable">shift</span> <span class="token hvariable">msg</span> <span class="token operator">=</span>
    <span class="token keyword">let</span> <span class="token hvariable">ords</span> <span class="token operator">=</span> <span class="token builtin">map</span> <span class="token builtin">ord</span> <span class="token hvariable">msg</span>
        <span class="token hvariable">shifted</span> <span class="token operator">=</span> <span class="token builtin">map</span> <span class="token punctuation">(</span><span class="token operator">+</span> <span class="token hvariable">shift</span><span class="token punctuation">)</span> <span class="token hvariable">ords</span>
    <span class="token keyword">in</span>  <span class="token builtin">map</span> <span class="token builtin">chr</span> <span class="token hvariable">shifted</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Here, we first convert the string to a list of numbers. Then we add the shift amount to each number before converting the list of numbers back to characters. If you're a composition cowboy, you could write the body of this function as <code>map (chr . (+ shift) . ord) msg</code>. Let's try encoding a few messages.</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token hvariable">encode</span> <span class="token number">3</span> <span class="token string">"Heeeeey"</span>
<span class="token string">"Khhhhh|"</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token hvariable">encode</span> <span class="token number">4</span> <span class="token string">"Heeeeey"</span>
<span class="token string">"Liiiii}"</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token hvariable">encode</span> <span class="token number">1</span> <span class="token string">"abcd"</span>
<span class="token string">"bcde"</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token hvariable">encode</span> <span class="token number">5</span> <span class="token string">"Marry Christmas! Ho ho ho!"</span>
<span class="token string">"Rfww~%Hmwnxyrfx&amp;%Mt%mt%mt&amp;"</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>That's encoded alright. Decoding a message is basically just shifting it back by the number of places it was shifted by in the first place.</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">decode</span> <span class="token operator">::</span> <span class="token constant">Int</span> <span class="token operator">-&gt;</span> <span class="token constant">String</span> <span class="token operator">-&gt;</span> <span class="token constant">String</span>
<span class="token hvariable">decode</span> <span class="token hvariable">shift</span> <span class="token hvariable">msg</span> <span class="token operator">=</span> <span class="token hvariable">encode</span> <span class="token punctuation">(</span><span class="token builtin">negate</span> <span class="token hvariable">shift</span><span class="token punctuation">)</span> <span class="token hvariable">msg</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token hvariable">encode</span> <span class="token number">3</span> <span class="token string">"Im a little teapot"</span>
<span class="token string">"Lp#d#olwwoh#whdsrw"</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token hvariable">decode</span> <span class="token number">3</span> <span class="token string">"Lp#d#olwwoh#whdsrw"</span>
<span class="token string">"Im a little teapot"</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token hvariable">decode</span> <span class="token number">5</span> <span class="token operator">.</span> <span class="token hvariable">encode</span> <span class="token number">5</span> <span class="token operator">$</span> <span class="token string">"This is a sentence"</span>
<span class="token string">"This is a sentence"</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><h2 data-heading="Data.Map" id="Data.Map" style="display: flex;"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>Data.Map</h2></div><div><p>Association lists (also called dictionaries) are lists that are used to store key-value pairs where ordering doesn't matter. For instance, we might use an association list to store phone numbers, where phone numbers would be the values and people's names would be the keys. We don't care in which order they're stored, we just want to get the right phone number for the right person.</p></div><div><p>The most obvious way to represent association lists in Haskell would be by having a list of pairs. The first component in the pair would be the key, the second component the value. Here's an example of an association list with phone numbers:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">phoneBook</span> <span class="token operator">=</span> 
    <span class="token punctuation">[</span><span class="token punctuation">(</span><span class="token string">"betty"</span><span class="token punctuation">,</span><span class="token string">"555-2938"</span><span class="token punctuation">)</span>
    <span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token string">"bonnie"</span><span class="token punctuation">,</span><span class="token string">"452-2928"</span><span class="token punctuation">)</span>
    <span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token string">"patsy"</span><span class="token punctuation">,</span><span class="token string">"493-2928"</span><span class="token punctuation">)</span>
    <span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token string">"lucille"</span><span class="token punctuation">,</span><span class="token string">"205-2928"</span><span class="token punctuation">)</span>
    <span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token string">"wendy"</span><span class="token punctuation">,</span><span class="token string">"939-8282"</span><span class="token punctuation">)</span>
    <span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token string">"penny"</span><span class="token punctuation">,</span><span class="token string">"853-2492"</span><span class="token punctuation">)</span>
    <span class="token punctuation">]</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Despite this seemingly odd indentation, this is just a list of pairs of strings. The most common task when dealing with association lists is looking up some value by key. Let's make a function that looks up some value given a key.</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">findKey</span> <span class="token operator">::</span> <span class="token punctuation">(</span><span class="token constant">Eq</span> <span class="token hvariable">k</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token hvariable">k</span> <span class="token operator">-&gt;</span> <span class="token punctuation">[</span><span class="token punctuation">(</span><span class="token hvariable">k</span><span class="token punctuation">,</span><span class="token hvariable">v</span><span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token operator">-&gt;</span> <span class="token hvariable">v</span>
<span class="token hvariable">findKey</span> <span class="token hvariable">key</span> <span class="token hvariable">xs</span> <span class="token operator">=</span> <span class="token builtin">snd</span> <span class="token operator">.</span> <span class="token builtin">head</span> <span class="token operator">.</span> <span class="token builtin">filter</span> <span class="token punctuation">(</span><span class="token operator">\</span><span class="token punctuation">(</span><span class="token hvariable">k</span><span class="token punctuation">,</span><span class="token hvariable">v</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token hvariable">key</span> <span class="token operator">==</span> <span class="token hvariable">k</span><span class="token punctuation">)</span> <span class="token operator">$</span> <span class="token hvariable">xs</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Pretty simple. The function that takes a key and a list, filters the list so that only matching keys remain, gets the first key-value that matches and returns the value. But what happens if the key we're looking for isn't in the association list? Hmm. Here, if a key isn't in the association list, we'll end up trying to get the head of an empty list, which throws a runtime error. However, we should avoid making our programs so easy to crash, so let's use the <code>Maybe</code> data type. If we don't find the key, we'll return a <code>Nothing</code>. If we find it, we'll return <code>Just something</code>, where something is the value corresponding to that key.</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">findKey</span> <span class="token operator">::</span> <span class="token punctuation">(</span><span class="token constant">Eq</span> <span class="token hvariable">k</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token hvariable">k</span> <span class="token operator">-&gt;</span> <span class="token punctuation">[</span><span class="token punctuation">(</span><span class="token hvariable">k</span><span class="token punctuation">,</span><span class="token hvariable">v</span><span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token operator">-&gt;</span> <span class="token constant">Maybe</span> <span class="token hvariable">v</span>
<span class="token hvariable">findKey</span> <span class="token hvariable">key</span> <span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token constant">Nothing</span>
<span class="token hvariable">findKey</span> <span class="token hvariable">key</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token hvariable">k</span><span class="token punctuation">,</span><span class="token hvariable">v</span><span class="token punctuation">)</span><span class="token operator">:</span><span class="token hvariable">xs</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token keyword">if</span> <span class="token hvariable">key</span> <span class="token operator">==</span> <span class="token hvariable">k</span>
                            <span class="token keyword">then</span> <span class="token constant">Just</span> <span class="token hvariable">v</span>
                            <span class="token keyword">else</span> <span class="token hvariable">findKey</span> <span class="token hvariable">key</span> <span class="token hvariable">xs</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Look at the type declaration. It takes a key that can be equated, an association list and then it maybe produces a value. Sounds about right.</p></div><div><p>This is a textbook recursive function that operates on a list. Edge case, splitting a list into a head and a tail, recursive calls, they're all there. This is the classic fold pattern, so let's see how this would be implemented as a fold.</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">findKey</span> <span class="token operator">::</span> <span class="token punctuation">(</span><span class="token constant">Eq</span> <span class="token hvariable">k</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token hvariable">k</span> <span class="token operator">-&gt;</span> <span class="token punctuation">[</span><span class="token punctuation">(</span><span class="token hvariable">k</span><span class="token punctuation">,</span><span class="token hvariable">v</span><span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token operator">-&gt;</span> <span class="token constant">Maybe</span> <span class="token hvariable">v</span>
<span class="token hvariable">findKey</span> <span class="token hvariable">key</span> <span class="token operator">=</span> <span class="token builtin">foldr</span> <span class="token punctuation">(</span><span class="token operator">\</span><span class="token punctuation">(</span><span class="token hvariable">k</span><span class="token punctuation">,</span><span class="token hvariable">v</span><span class="token punctuation">)</span> <span class="token hvariable">acc</span> <span class="token operator">-&gt;</span> <span class="token keyword">if</span> <span class="token hvariable">key</span> <span class="token operator">==</span> <span class="token hvariable">k</span> <span class="token keyword">then</span> <span class="token constant">Just</span> <span class="token hvariable">v</span> <span class="token keyword">else</span> <span class="token hvariable">acc</span><span class="token punctuation">)</span> <span class="token constant">Nothing</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><blockquote>
<p><strong>Note</strong> It's usually better to use folds for this standard list recursion pattern instead of explicitly writing the recursion because they're easier to read and identify. Everyone knows it's a fold when they see the <code>foldr</code> call, but it takes some more thinking to read explicit recursion.</p>
</blockquote></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token hvariable">findKey</span> <span class="token string">"penny"</span> <span class="token hvariable">phoneBook</span>
<span class="token constant">Just</span> <span class="token string">"853-2492"</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token hvariable">findKey</span> <span class="token string">"betty"</span> <span class="token hvariable">phoneBook</span>
<span class="token constant">Just</span> <span class="token string">"555-2938"</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token hvariable">findKey</span> <span class="token string">"wilma"</span> <span class="token hvariable">phoneBook</span>
<span class="token constant">Nothing</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p><span alt="LYHfGG_44_legomap.png" src="LYHfGG_44_legomap.png" class="internal-embed media-embed image-embed is-loaded"><img alt="LYHfGG_44_legomap.png" src="курсы\learn-you-a-haskell-for-great-good!\картинки\lyhfgg_44_legomap.png"></span></p></div><div><p>Works like a charm! If we have the girl's phone number, we <code>Just</code> get the number, otherwise we get <code>Nothing</code>.</p></div><div><p>We just implemented the <code>lookup</code> function from <code>Data.List</code>. If we want to find the corresponding value to a key, we have to traverse all the elements of the list until we find it. The <code>Data.Map</code> module offers association lists that are much faster (because they're internally implemented with trees) and also it provides a lot of utility functions. From now on, we'll say we're working with maps instead of association lists.</p></div><div><p>Because <code>Data.Map</code> exports functions that clash with the <code>Prelude</code> and <code>Data.List</code> ones, we'll do a qualified import.</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token import-statement"><span class="token keyword">import</span> <span class="token keyword">qualified</span> Data<span class="token punctuation">.</span>Map <span class="token keyword">as</span> Map</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Put this import statement into a script and then load the script via GHCI.</p></div><div><p>Let's go ahead and see what <code>Data.Map</code> has in store for us! Here's the basic rundown of its functions.</p></div><div><p>The <code>fromList</code> function takes an association list (in the form of a list) and returns a map with the same associations.</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token hvariable">Map<span class="token punctuation">.</span>fromList</span> <span class="token punctuation">[</span><span class="token punctuation">(</span><span class="token string">"betty"</span><span class="token punctuation">,</span><span class="token string">"555-2938"</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token string">"bonnie"</span><span class="token punctuation">,</span><span class="token string">"452-2928"</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token string">"lucille"</span><span class="token punctuation">,</span><span class="token string">"205-2928"</span><span class="token punctuation">)</span><span class="token punctuation">]</span>
<span class="token hvariable">fromList</span> <span class="token punctuation">[</span><span class="token punctuation">(</span><span class="token string">"betty"</span><span class="token punctuation">,</span><span class="token string">"555-2938"</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token string">"bonnie"</span><span class="token punctuation">,</span><span class="token string">"452-2928"</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token string">"lucille"</span><span class="token punctuation">,</span><span class="token string">"205-2928"</span><span class="token punctuation">)</span><span class="token punctuation">]</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token hvariable">Map<span class="token punctuation">.</span>fromList</span> <span class="token punctuation">[</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">]</span>
<span class="token hvariable">fromList</span> <span class="token punctuation">[</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">]</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>If there are duplicate keys in the original association list, the duplicates are just discarded. This is the type signature of <code>fromList</code></p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">Map<span class="token punctuation">.</span>fromList</span> <span class="token operator">::</span> <span class="token punctuation">(</span><span class="token constant">Ord</span> <span class="token hvariable">k</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">[</span><span class="token punctuation">(</span><span class="token hvariable">k</span><span class="token punctuation">,</span> <span class="token hvariable">v</span><span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token operator">-&gt;</span> <span class="token constant">Map<span class="token punctuation">.</span>Map</span> <span class="token hvariable">k</span> <span class="token hvariable">v</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>It says that it takes a list of pairs of type <code>k</code> and <code>v</code> and returns a map that maps from keys of type <code>k</code> to type <code>v</code>. Notice that when we were doing association lists with normal lists, the keys only had to be equatable (their type belonging to the <code>Eq</code> typeclass) but now they have to be orderable. That's an essential constraint in the <code>Data.Map</code> module. It needs the keys to be orderable so it can arrange them in a tree.</p></div><div><p>You should always use <code>Data.Map</code> for key-value associations unless you have keys that aren't part of the <code>Ord</code> typeclass.</p></div><div><p><code>empty</code> represents an empty map. It takes no arguments, it just returns an empty map.</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token hvariable">Map<span class="token punctuation">.</span>empty</span>
<span class="token hvariable">fromList</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p><code>insert</code> takes a key, a value and a map and returns a new map that's just like the old one, only with the key and value inserted.</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token hvariable">Map<span class="token punctuation">.</span>empty</span>
<span class="token hvariable">fromList</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token hvariable">Map<span class="token punctuation">.</span>insert</span> <span class="token number">3</span> <span class="token number">100</span> <span class="token hvariable">Map<span class="token punctuation">.</span>empty</span>
<span class="token hvariable">fromList</span> <span class="token punctuation">[</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">]</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token hvariable">Map<span class="token punctuation">.</span>insert</span> <span class="token number">5</span> <span class="token number">600</span> <span class="token punctuation">(</span><span class="token hvariable">Map<span class="token punctuation">.</span>insert</span> <span class="token number">4</span> <span class="token number">200</span> <span class="token punctuation">(</span> <span class="token hvariable">Map<span class="token punctuation">.</span>insert</span> <span class="token number">3</span> <span class="token number">100</span>  <span class="token hvariable">Map<span class="token punctuation">.</span>empty</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token hvariable">fromList</span> <span class="token punctuation">[</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">200</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">600</span><span class="token punctuation">)</span><span class="token punctuation">]</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token hvariable">Map<span class="token punctuation">.</span>insert</span> <span class="token number">5</span> <span class="token number">600</span> <span class="token operator">.</span> <span class="token hvariable">Map<span class="token punctuation">.</span>insert</span> <span class="token number">4</span> <span class="token number">200</span> <span class="token operator">.</span> <span class="token hvariable">Map<span class="token punctuation">.</span>insert</span> <span class="token number">3</span> <span class="token number">100</span> <span class="token operator">$</span> <span class="token hvariable">Map<span class="token punctuation">.</span>empty</span>
<span class="token hvariable">fromList</span> <span class="token punctuation">[</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">200</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">600</span><span class="token punctuation">)</span><span class="token punctuation">]</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>We can implement our own <code>fromList</code> by using the empty map, <code>insert</code> and a fold. Watch:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">fromList'</span> <span class="token operator">::</span> <span class="token punctuation">(</span><span class="token constant">Ord</span> <span class="token hvariable">k</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">[</span><span class="token punctuation">(</span><span class="token hvariable">k</span><span class="token punctuation">,</span><span class="token hvariable">v</span><span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token operator">-&gt;</span> <span class="token constant">Map<span class="token punctuation">.</span>Map</span> <span class="token hvariable">k</span> <span class="token hvariable">v</span>
<span class="token hvariable">fromList'</span> <span class="token operator">=</span> <span class="token builtin">foldr</span> <span class="token punctuation">(</span><span class="token operator">\</span><span class="token punctuation">(</span><span class="token hvariable">k</span><span class="token punctuation">,</span><span class="token hvariable">v</span><span class="token punctuation">)</span> <span class="token hvariable">acc</span> <span class="token operator">-&gt;</span> <span class="token hvariable">Map<span class="token punctuation">.</span>insert</span> <span class="token hvariable">k</span> <span class="token hvariable">v</span> <span class="token hvariable">acc</span><span class="token punctuation">)</span> <span class="token hvariable">Map<span class="token punctuation">.</span>empty</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>It's a pretty straightforward fold. We start of with an empty map and we fold it up from the right, inserting the key value pairs into the accumulator as we go along.</p></div><div><p><code>null</code> checks if a map is empty.</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token constant">Map</span><span class="token punctuation">.</span><span class="token builtin">null</span> <span class="token hvariable">Map<span class="token punctuation">.</span>empty</span>
<span class="token constant">True</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token constant">Map</span><span class="token punctuation">.</span><span class="token builtin">null</span> <span class="token operator">$</span> <span class="token hvariable">Map<span class="token punctuation">.</span>fromList</span> <span class="token punctuation">[</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">]</span>
<span class="token constant">False</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p><code>size</code> reports the size of a map.</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token hvariable">Map<span class="token punctuation">.</span>size</span> <span class="token hvariable">Map<span class="token punctuation">.</span>empty</span>
<span class="token number">0</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token hvariable">Map<span class="token punctuation">.</span>size</span> <span class="token operator">$</span> <span class="token hvariable">Map<span class="token punctuation">.</span>fromList</span> <span class="token punctuation">[</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token number">6</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">]</span>
<span class="token number">5</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p><code>singleton</code> takes a key and a value and creates a map that has exactly one mapping.</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token hvariable">Map<span class="token punctuation">.</span>singleton</span> <span class="token number">3</span> <span class="token number">9</span>
<span class="token hvariable">fromList</span> <span class="token punctuation">[</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">9</span><span class="token punctuation">)</span><span class="token punctuation">]</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token hvariable">Map<span class="token punctuation">.</span>insert</span> <span class="token number">5</span> <span class="token number">9</span> <span class="token operator">$</span> <span class="token hvariable">Map<span class="token punctuation">.</span>singleton</span> <span class="token number">3</span> <span class="token number">9</span>
<span class="token hvariable">fromList</span> <span class="token punctuation">[</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">9</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">9</span><span class="token punctuation">)</span><span class="token punctuation">]</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p><code>lookup</code> works like the <code>Data.List</code> <code>lookup</code>, only it operates on maps. It returns <code>Just something</code> if it finds something for the key and <code>Nothing</code> if it doesn't.</p></div><div><p><code>member</code> is a predicate takes a key and a map and reports whether the key is in the map or not.</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token hvariable">Map<span class="token punctuation">.</span>member</span> <span class="token number">3</span> <span class="token operator">$</span> <span class="token hvariable">Map<span class="token punctuation">.</span>fromList</span> <span class="token punctuation">[</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token number">6</span><span class="token punctuation">,</span><span class="token number">9</span><span class="token punctuation">)</span><span class="token punctuation">]</span>
<span class="token constant">True</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token hvariable">Map<span class="token punctuation">.</span>member</span> <span class="token number">3</span> <span class="token operator">$</span> <span class="token hvariable">Map<span class="token punctuation">.</span>fromList</span> <span class="token punctuation">[</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">]</span>
<span class="token constant">False</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p><code>map</code> and <code>filter</code> work much like their list equivalents.</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token constant">Map</span><span class="token punctuation">.</span><span class="token builtin">map</span> <span class="token punctuation">(</span><span class="token operator">*</span><span class="token number">100</span><span class="token punctuation">)</span> <span class="token operator">$</span> <span class="token hvariable">Map<span class="token punctuation">.</span>fromList</span> <span class="token punctuation">[</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">9</span><span class="token punctuation">)</span><span class="token punctuation">]</span>
<span class="token hvariable">fromList</span> <span class="token punctuation">[</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">400</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">900</span><span class="token punctuation">)</span><span class="token punctuation">]</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token constant">Map</span><span class="token punctuation">.</span><span class="token builtin">filter</span> <span class="token builtin">isUpper</span> <span class="token operator">$</span> <span class="token hvariable">Map<span class="token punctuation">.</span>fromList</span> <span class="token punctuation">[</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token char string">'a'</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token char string">'A'</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token char string">'b'</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token char string">'B'</span><span class="token punctuation">)</span><span class="token punctuation">]</span>
<span class="token hvariable">fromList</span> <span class="token punctuation">[</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token char string">'A'</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token char string">'B'</span><span class="token punctuation">)</span><span class="token punctuation">]</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p><code>toList</code> is the inverse of <code>fromList</code>.</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token hvariable">Map<span class="token punctuation">.</span>toList</span> <span class="token operator">.</span> <span class="token hvariable">Map<span class="token punctuation">.</span>insert</span> <span class="token number">9</span> <span class="token number">2</span> <span class="token operator">$</span> <span class="token hvariable">Map<span class="token punctuation">.</span>singleton</span> <span class="token number">4</span> <span class="token number">3</span>
<span class="token punctuation">[</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token number">9</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">]</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p><code>keys</code> and <code>elems</code> return lists of keys and values respectively. <code>keys</code> is the equivalent of <code>map fst . Map.toList</code> and <code>elems</code> is the equivalent of <code>map snd . Map.toList</code>.</p></div><div><p><code>fromListWith</code> is a cool little function. It acts like <code>fromList</code>, only it doesn't discard duplicate keys but it uses a function supplied to it to decide what to do with them. Let's say that a girl can have several numbers and we have an association list set up like this.</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">phoneBook</span> <span class="token operator">=</span> 
    <span class="token punctuation">[</span><span class="token punctuation">(</span><span class="token string">"betty"</span><span class="token punctuation">,</span><span class="token string">"555-2938"</span><span class="token punctuation">)</span>
    <span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token string">"betty"</span><span class="token punctuation">,</span><span class="token string">"342-2492"</span><span class="token punctuation">)</span>
    <span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token string">"bonnie"</span><span class="token punctuation">,</span><span class="token string">"452-2928"</span><span class="token punctuation">)</span>
    <span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token string">"patsy"</span><span class="token punctuation">,</span><span class="token string">"493-2928"</span><span class="token punctuation">)</span>
    <span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token string">"patsy"</span><span class="token punctuation">,</span><span class="token string">"943-2929"</span><span class="token punctuation">)</span>
    <span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token string">"patsy"</span><span class="token punctuation">,</span><span class="token string">"827-9162"</span><span class="token punctuation">)</span>
    <span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token string">"lucille"</span><span class="token punctuation">,</span><span class="token string">"205-2928"</span><span class="token punctuation">)</span>
    <span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token string">"wendy"</span><span class="token punctuation">,</span><span class="token string">"939-8282"</span><span class="token punctuation">)</span>
    <span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token string">"penny"</span><span class="token punctuation">,</span><span class="token string">"853-2492"</span><span class="token punctuation">)</span>
    <span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token string">"penny"</span><span class="token punctuation">,</span><span class="token string">"555-2111"</span><span class="token punctuation">)</span>
    <span class="token punctuation">]</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Now if we just use <code>fromList</code> to put that into a map, we'll lose a few numbers! So here's what we'll do:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">phoneBookToMap</span> <span class="token operator">::</span> <span class="token punctuation">(</span><span class="token constant">Ord</span> <span class="token hvariable">k</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">[</span><span class="token punctuation">(</span><span class="token hvariable">k</span><span class="token punctuation">,</span> <span class="token constant">String</span><span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token operator">-&gt;</span> <span class="token constant">Map<span class="token punctuation">.</span>Map</span> <span class="token hvariable">k</span> <span class="token constant">String</span>
<span class="token hvariable">phoneBookToMap</span> <span class="token hvariable">xs</span> <span class="token operator">=</span> <span class="token hvariable">Map<span class="token punctuation">.</span>fromListWith</span> <span class="token punctuation">(</span><span class="token operator">\</span><span class="token hvariable">number1</span> <span class="token hvariable">number2</span> <span class="token operator">-&gt;</span> <span class="token hvariable">number1</span> <span class="token operator">++</span> <span class="token string">", "</span> <span class="token operator">++</span> <span class="token hvariable">number2</span><span class="token punctuation">)</span> <span class="token hvariable">xs</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token constant">Map</span><span class="token punctuation">.</span><span class="token builtin">lookup</span> <span class="token string">"patsy"</span> <span class="token operator">$</span> <span class="token hvariable">phoneBookToMap</span> <span class="token hvariable">phoneBook</span>
<span class="token string">"827-9162, 943-2929, 493-2928"</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token constant">Map</span><span class="token punctuation">.</span><span class="token builtin">lookup</span> <span class="token string">"wendy"</span> <span class="token operator">$</span> <span class="token hvariable">phoneBookToMap</span> <span class="token hvariable">phoneBook</span>
<span class="token string">"939-8282"</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token constant">Map</span><span class="token punctuation">.</span><span class="token builtin">lookup</span> <span class="token string">"betty"</span> <span class="token operator">$</span> <span class="token hvariable">phoneBookToMap</span> <span class="token hvariable">phoneBook</span>
<span class="token string">"342-2492, 555-2938"</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>If a duplicate key is found, the function we pass is used to combine the values of those keys into some other value. We could also first make all the values in the association list singleton lists and then we can use <code>++</code> to combine the numbers.</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">phoneBookToMap</span> <span class="token operator">::</span> <span class="token punctuation">(</span><span class="token constant">Ord</span> <span class="token hvariable">k</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">[</span><span class="token punctuation">(</span><span class="token hvariable">k</span><span class="token punctuation">,</span> <span class="token hvariable">a</span><span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token operator">-&gt;</span> <span class="token constant">Map<span class="token punctuation">.</span>Map</span> <span class="token hvariable">k</span> <span class="token punctuation">[</span><span class="token hvariable">a</span><span class="token punctuation">]</span>
<span class="token hvariable">phoneBookToMap</span> <span class="token hvariable">xs</span> <span class="token operator">=</span> <span class="token hvariable">Map<span class="token punctuation">.</span>fromListWith</span> <span class="token punctuation">(</span><span class="token operator">++</span><span class="token punctuation">)</span> <span class="token operator">$</span> <span class="token builtin">map</span> <span class="token punctuation">(</span><span class="token operator">\</span><span class="token punctuation">(</span><span class="token hvariable">k</span><span class="token punctuation">,</span><span class="token hvariable">v</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token punctuation">(</span><span class="token hvariable">k</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token hvariable">v</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token hvariable">xs</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token constant">Map</span><span class="token punctuation">.</span><span class="token builtin">lookup</span> <span class="token string">"patsy"</span> <span class="token operator">$</span> <span class="token hvariable">phoneBookToMap</span> <span class="token hvariable">phoneBook</span>
<span class="token punctuation">[</span><span class="token string">"827-9162"</span><span class="token punctuation">,</span><span class="token string">"943-2929"</span><span class="token punctuation">,</span><span class="token string">"493-2928"</span><span class="token punctuation">]</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Pretty neat! Another use case is if we're making a map from an association list of numbers and when a duplicate key is found, we want the biggest value for the key to be kept.</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token hvariable">Map<span class="token punctuation">.</span>fromListWith</span> <span class="token builtin">max</span> <span class="token punctuation">[</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">29</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">22</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">11</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">22</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">15</span><span class="token punctuation">)</span><span class="token punctuation">]</span>
<span class="token hvariable">fromList</span> <span class="token punctuation">[</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">29</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">22</span><span class="token punctuation">)</span><span class="token punctuation">]</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Or we could choose to add together values on the same keys.</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token hvariable">Map<span class="token punctuation">.</span>fromListWith</span> <span class="token punctuation">(</span><span class="token operator">+</span><span class="token punctuation">)</span> <span class="token punctuation">[</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">29</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">22</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">11</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">22</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">15</span><span class="token punctuation">)</span><span class="token punctuation">]</span>
<span class="token hvariable">fromList</span> <span class="token punctuation">[</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">108</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">62</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">37</span><span class="token punctuation">)</span><span class="token punctuation">]</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p><code>insertWith</code> is to <code>insert</code> what <code>fromListWith</code> is to <code>fromList</code>. It inserts a key-value pair into a map, but if that map already contains the key, it uses the function passed to it to determine what to do.</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token hvariable">Map<span class="token punctuation">.</span>insertWith</span> <span class="token punctuation">(</span><span class="token operator">+</span><span class="token punctuation">)</span> <span class="token number">3</span> <span class="token number">100</span> <span class="token operator">$</span> <span class="token hvariable">Map<span class="token punctuation">.</span>fromList</span> <span class="token punctuation">[</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">103</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token number">6</span><span class="token punctuation">,</span><span class="token number">339</span><span class="token punctuation">)</span><span class="token punctuation">]</span>
<span class="token hvariable">fromList</span> <span class="token punctuation">[</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">104</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">103</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token number">6</span><span class="token punctuation">,</span><span class="token number">339</span><span class="token punctuation">)</span><span class="token punctuation">]</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>These were just a few functions from <code>Data.Map</code>. You can see a complete list of functions in the <a data-tooltip-position="top" aria-label="http://www.haskell.org/ghc/docs/latest/html/libraries/containers/Data-Map.html#v%3Aassocs" rel="noopener" class="external-link" href="http://www.haskell.org/ghc/docs/latest/html/libraries/containers/Data-Map.html#v%3Aassocs" target="_blank">documentation</a>.</p></div><div><h2 data-heading="Data.Set" id="Data.Set" style="display: flex;"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>Data.Set</h2></div><div><p><span alt="LYHfGG_45_legosets.png" src="LYHfGG_45_legosets.png" class="internal-embed media-embed image-embed is-loaded"><img alt="LYHfGG_45_legosets.png" src="курсы\learn-you-a-haskell-for-great-good!\картинки\lyhfgg_45_legosets.png"></span></p></div><div><p>The <code>Data.Set</code> module offers us, well, sets. Like sets from mathematics. Sets are kind of like a cross between lists and maps. All the elements in a set are unique. And because they're internally implemented with trees (much like maps in <code>Data.Map</code>), they're ordered. Checking for membership, inserting, deleting, etc. is much faster than doing the same thing with lists. The most common operation when dealing with sets are inserting into a set, checking for membership and converting a set to a list.</p></div><div><p>Because the names in <code>Data.Set</code> clash with a lot of <code>Prelude</code> and <code>Data.List</code> names, we do a qualified import.</p></div><div><p>Put this import statement in a script:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token import-statement"><span class="token keyword">import</span> <span class="token keyword">qualified</span> Data<span class="token punctuation">.</span>Set <span class="token keyword">as</span> Set</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>And then load the script via GHCI.</p></div><div><p>Let's say we have two pieces of text. We want to find out which characters were used in both of them.</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">text1</span> <span class="token operator">=</span> <span class="token string">"I just had an anime dream. Anime... Reality... Are they so different?"</span>
<span class="token hvariable">text2</span> <span class="token operator">=</span> <span class="token string">"The old man left his garbage can out and now his trash is all over my lawn!"</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>The <code>fromList</code> function works much like you would expect. It takes a list and converts it into a set.</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token keyword">let</span> <span class="token hvariable">set1</span> <span class="token operator">=</span> <span class="token hvariable">Set<span class="token punctuation">.</span>fromList</span> <span class="token hvariable">text1</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token keyword">let</span> <span class="token hvariable">set2</span> <span class="token operator">=</span> <span class="token hvariable">Set<span class="token punctuation">.</span>fromList</span> <span class="token hvariable">text2</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token hvariable">set1</span>
<span class="token hvariable">fromList</span> <span class="token string">" .?AIRadefhijlmnorstuy"</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token hvariable">set2</span>
<span class="token hvariable">fromList</span> <span class="token string">" !Tabcdefghilmnorstuvwy"</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>As you can see, the items are ordered and each element is unique. Now let's use the <code>intersection</code> function to see which elements they both share.</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token hvariable">Set<span class="token punctuation">.</span>intersection</span> <span class="token hvariable">set1</span> <span class="token hvariable">set2</span>
<span class="token hvariable">fromList</span> <span class="token string">" adefhilmnorstuy"</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>We can use the <code>difference</code> function to see which letters are in the first set but aren't in the second one and vice versa.</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token hvariable">Set<span class="token punctuation">.</span>difference</span> <span class="token hvariable">set1</span> <span class="token hvariable">set2</span>
<span class="token hvariable">fromList</span> <span class="token string">".?AIRj"</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token hvariable">Set<span class="token punctuation">.</span>difference</span> <span class="token hvariable">set2</span> <span class="token hvariable">set1</span>
<span class="token hvariable">fromList</span> <span class="token string">"!Tbcgvw"</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Or we can see all the unique letters used in both sentences by using <code>union</code>.</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token hvariable">Set<span class="token punctuation">.</span>union</span> <span class="token hvariable">set1</span> <span class="token hvariable">set2</span>
<span class="token hvariable">fromList</span> <span class="token string">" !.?AIRTabcdefghijlmnorstuvwy"</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>The <code>null</code>, <code>size</code>, <code>member</code>, <code>empty</code>, <code>singleton</code>, <code>insert</code> and <code>delete</code> functions all work like you'd expect them to.</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token constant">Set</span><span class="token punctuation">.</span><span class="token builtin">null</span> <span class="token hvariable">Set<span class="token punctuation">.</span>empty</span>
<span class="token constant">True</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token constant">Set</span><span class="token punctuation">.</span><span class="token builtin">null</span> <span class="token operator">$</span> <span class="token hvariable">Set<span class="token punctuation">.</span>fromList</span> <span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">]</span>
<span class="token constant">False</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token hvariable">Set<span class="token punctuation">.</span>size</span> <span class="token operator">$</span> <span class="token hvariable">Set<span class="token punctuation">.</span>fromList</span> <span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">]</span>
<span class="token number">3</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token hvariable">Set<span class="token punctuation">.</span>singleton</span> <span class="token number">9</span>
<span class="token hvariable">fromList</span> <span class="token punctuation">[</span><span class="token number">9</span><span class="token punctuation">]</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token hvariable">Set<span class="token punctuation">.</span>insert</span> <span class="token number">4</span> <span class="token operator">$</span> <span class="token hvariable">Set<span class="token punctuation">.</span>fromList</span> <span class="token punctuation">[</span><span class="token number">9</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">8</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">]</span>
<span class="token hvariable">fromList</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">8</span><span class="token punctuation">,</span><span class="token number">9</span><span class="token punctuation">]</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token hvariable">Set<span class="token punctuation">.</span>insert</span> <span class="token number">8</span> <span class="token operator">$</span> <span class="token hvariable">Set<span class="token punctuation">.</span>fromList</span> <span class="token punctuation">[</span><span class="token number">5</span><span class="token operator">..</span><span class="token number">10</span><span class="token punctuation">]</span>
<span class="token hvariable">fromList</span> <span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">,</span><span class="token number">7</span><span class="token punctuation">,</span><span class="token number">8</span><span class="token punctuation">,</span><span class="token number">9</span><span class="token punctuation">,</span><span class="token number">10</span><span class="token punctuation">]</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token hvariable">Set<span class="token punctuation">.</span>delete</span> <span class="token number">4</span> <span class="token operator">$</span> <span class="token hvariable">Set<span class="token punctuation">.</span>fromList</span> <span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">]</span>
<span class="token hvariable">fromList</span> <span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">]</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>We can also check for subsets or proper subset. Set A is a subset of set B if B contains all the elements that A does. Set A is a proper subset of set B if B contains all the elements that A does but has more elements.</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token hvariable">Set<span class="token punctuation">.</span>fromList</span> <span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">]</span> <span class="token operator">`Set.isSubsetOf`</span> <span class="token hvariable">Set<span class="token punctuation">.</span>fromList</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">]</span>
<span class="token constant">True</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token hvariable">Set<span class="token punctuation">.</span>fromList</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">]</span> <span class="token operator">`Set.isSubsetOf`</span> <span class="token hvariable">Set<span class="token punctuation">.</span>fromList</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">]</span>
<span class="token constant">True</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token hvariable">Set<span class="token punctuation">.</span>fromList</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">]</span> <span class="token operator">`Set.isProperSubsetOf`</span> <span class="token hvariable">Set<span class="token punctuation">.</span>fromList</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">]</span>
<span class="token constant">False</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token hvariable">Set<span class="token punctuation">.</span>fromList</span> <span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">8</span><span class="token punctuation">]</span> <span class="token operator">`Set.isSubsetOf`</span> <span class="token hvariable">Set<span class="token punctuation">.</span>fromList</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">]</span>
<span class="token constant">False</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>We can also <code>map</code> over sets and <code>filter</code> them.</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token constant">Set</span><span class="token punctuation">.</span><span class="token builtin">filter</span> <span class="token builtin">odd</span> <span class="token operator">$</span> <span class="token hvariable">Set<span class="token punctuation">.</span>fromList</span> <span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">,</span><span class="token number">7</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">]</span>
<span class="token hvariable">fromList</span> <span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">7</span><span class="token punctuation">]</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token constant">Set</span><span class="token punctuation">.</span><span class="token builtin">map</span> <span class="token punctuation">(</span><span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">$</span> <span class="token hvariable">Set<span class="token punctuation">.</span>fromList</span> <span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">,</span><span class="token number">7</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">]</span>
<span class="token hvariable">fromList</span> <span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">,</span><span class="token number">7</span><span class="token punctuation">,</span><span class="token number">8</span><span class="token punctuation">]</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Sets are often used to weed a list of duplicates from a list by first making it into a set with <code>fromList</code> and then converting it back to a list with <code>toList</code>. The <code>Data.List</code> function <code>nub</code> already does that, but weeding out duplicates for large lists is much faster if you cram them into a set and then convert them back to a list than using <code>nub</code>. But using <code>nub</code> only requires the type of the list's elements to be part of the <code>Eq</code> typeclass, whereas if you want to cram elements into a set, the type of the list has to be in <code>Ord</code>.</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token keyword">let</span> <span class="token hvariable">setNub</span> <span class="token hvariable">xs</span> <span class="token operator">=</span> <span class="token hvariable">Set<span class="token punctuation">.</span>toList</span> <span class="token operator">$</span> <span class="token hvariable">Set<span class="token punctuation">.</span>fromList</span> <span class="token hvariable">xs</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token hvariable">setNub</span> <span class="token string">"HEY WHATS CRACKALACKIN"</span>
<span class="token string">" ACEHIKLNRSTWY"</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token hvariable">nub</span> <span class="token string">"HEY WHATS CRACKALACKIN"</span>
<span class="token string">"HEY WATSCRKLIN"</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p><code>setNub</code> is generally faster than <code>nub</code> on big lists but as you can see, <code>nub</code> preserves the ordering of the list's elements, while <code>setNub</code> does not.</p></div><div><h2 data-heading="Making our own modules" id="Making_our_own_modules" style="display: flex;"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>Making our own modules</h2></div><div><p><span alt="LYHfGG_46_making_modules.png" src="LYHfGG_46_making_modules.png" class="internal-embed media-embed image-embed is-loaded"><img alt="LYHfGG_46_making_modules.png" src="курсы\learn-you-a-haskell-for-great-good!\картинки\lyhfgg_46_making_modules.png"></span></p></div><div><p>We've looked at some cool modules so far, but how do we make our own module? Almost every programming language enables you to split your code up into several files and Haskell is no different. When making programs, it's good practice to take functions and types that work towards a similar purpose and put them in a module. That way, you can easily reuse those functions in other programs by just importing your module.</p></div><div><p>Let's see how we can make our own modules by making a little module that provides some functions for calculating the volume and area of a few geometrical objects. We'll start by creating a file called <code>Geometry.hs</code>.</p></div><div><p>We say that a module <em>exports</em> functions. What that means is that when I import a module, I can use the functions that it exports. It can define functions that its functions call internally, but we can only see and use the ones that it exports.</p></div><div><p>At the beginning of a module, we specify the module name. If we have a file called <code>Geometry.hs</code>, then we should name our module <code>Geometry</code>. Then, we specify the functions that it exports and after that, we can start writing the functions. So we'll start with this.</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token keyword">module</span> <span class="token constant">Geometry</span>
<span class="token punctuation">(</span> <span class="token hvariable">sphereVolume</span>
<span class="token punctuation">,</span> <span class="token hvariable">sphereArea</span>
<span class="token punctuation">,</span> <span class="token hvariable">cubeVolume</span>
<span class="token punctuation">,</span> <span class="token hvariable">cubeArea</span>
<span class="token punctuation">,</span> <span class="token hvariable">cuboidArea</span>
<span class="token punctuation">,</span> <span class="token hvariable">cuboidVolume</span>
<span class="token punctuation">)</span> <span class="token keyword">where</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>As you can see, we'll be doing areas and volumes for spheres, cubes and cuboids. Let's go ahead and define our functions then:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token keyword">module</span> <span class="token constant">Geometry</span>
<span class="token punctuation">(</span> <span class="token hvariable">sphereVolume</span>
<span class="token punctuation">,</span> <span class="token hvariable">sphereArea</span>
<span class="token punctuation">,</span> <span class="token hvariable">cubeVolume</span>
<span class="token punctuation">,</span> <span class="token hvariable">cubeArea</span>
<span class="token punctuation">,</span> <span class="token hvariable">cuboidArea</span>
<span class="token punctuation">,</span> <span class="token hvariable">cuboidVolume</span>
<span class="token punctuation">)</span> <span class="token keyword">where</span>

<span class="token hvariable">sphereVolume</span> <span class="token operator">::</span> <span class="token constant">Float</span> <span class="token operator">-&gt;</span> <span class="token constant">Float</span>
<span class="token hvariable">sphereVolume</span> <span class="token hvariable">radius</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token number">4.0</span> <span class="token operator">/</span> <span class="token number">3.0</span><span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token builtin">pi</span> <span class="token operator">*</span> <span class="token punctuation">(</span><span class="token hvariable">radius</span> <span class="token operator">^</span> <span class="token number">3</span><span class="token punctuation">)</span>

<span class="token hvariable">sphereArea</span> <span class="token operator">::</span> <span class="token constant">Float</span> <span class="token operator">-&gt;</span> <span class="token constant">Float</span>
<span class="token hvariable">sphereArea</span> <span class="token hvariable">radius</span> <span class="token operator">=</span> <span class="token number">4</span> <span class="token operator">*</span> <span class="token builtin">pi</span> <span class="token operator">*</span> <span class="token punctuation">(</span><span class="token hvariable">radius</span> <span class="token operator">^</span> <span class="token number">2</span><span class="token punctuation">)</span>

<span class="token hvariable">cubeVolume</span> <span class="token operator">::</span> <span class="token constant">Float</span> <span class="token operator">-&gt;</span> <span class="token constant">Float</span>
<span class="token hvariable">cubeVolume</span> <span class="token hvariable">side</span> <span class="token operator">=</span> <span class="token hvariable">cuboidVolume</span> <span class="token hvariable">side</span> <span class="token hvariable">side</span> <span class="token hvariable">side</span>

<span class="token hvariable">cubeArea</span> <span class="token operator">::</span> <span class="token constant">Float</span> <span class="token operator">-&gt;</span> <span class="token constant">Float</span>
<span class="token hvariable">cubeArea</span> <span class="token hvariable">side</span> <span class="token operator">=</span> <span class="token hvariable">cuboidArea</span> <span class="token hvariable">side</span> <span class="token hvariable">side</span> <span class="token hvariable">side</span>

<span class="token hvariable">cuboidVolume</span> <span class="token operator">::</span> <span class="token constant">Float</span> <span class="token operator">-&gt;</span> <span class="token constant">Float</span> <span class="token operator">-&gt;</span> <span class="token constant">Float</span> <span class="token operator">-&gt;</span> <span class="token constant">Float</span>
<span class="token hvariable">cuboidVolume</span> <span class="token hvariable">a</span> <span class="token hvariable">b</span> <span class="token hvariable">c</span> <span class="token operator">=</span> <span class="token hvariable">rectangleArea</span> <span class="token hvariable">a</span> <span class="token hvariable">b</span> <span class="token operator">*</span> <span class="token hvariable">c</span>

<span class="token hvariable">cuboidArea</span> <span class="token operator">::</span> <span class="token constant">Float</span> <span class="token operator">-&gt;</span> <span class="token constant">Float</span> <span class="token operator">-&gt;</span> <span class="token constant">Float</span> <span class="token operator">-&gt;</span> <span class="token constant">Float</span>
<span class="token hvariable">cuboidArea</span> <span class="token hvariable">a</span> <span class="token hvariable">b</span> <span class="token hvariable">c</span> <span class="token operator">=</span> <span class="token hvariable">rectangleArea</span> <span class="token hvariable">a</span> <span class="token hvariable">b</span> <span class="token operator">*</span> <span class="token number">2</span> <span class="token operator">+</span> <span class="token hvariable">rectangleArea</span> <span class="token hvariable">a</span> <span class="token hvariable">c</span> <span class="token operator">*</span> <span class="token number">2</span> <span class="token operator">+</span> <span class="token hvariable">rectangleArea</span> <span class="token hvariable">c</span> <span class="token hvariable">b</span> <span class="token operator">*</span> <span class="token number">2</span>

<span class="token hvariable">rectangleArea</span> <span class="token operator">::</span> <span class="token constant">Float</span> <span class="token operator">-&gt;</span> <span class="token constant">Float</span> <span class="token operator">-&gt;</span> <span class="token constant">Float</span>
<span class="token hvariable">rectangleArea</span> <span class="token hvariable">a</span> <span class="token hvariable">b</span> <span class="token operator">=</span> <span class="token hvariable">a</span> <span class="token operator">*</span> <span class="token hvariable">b</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Pretty standard geometry right here. There are a few things to take note of though. Because a cube is only a special case of a cuboid, we defined its area and volume by treating it as a cuboid whose sides are all of the same length. We also defined a helper function called <code>rectangleArea</code>, which calculates a rectangle's area based on the lenghts of its sides. It's rather trivial because it's just multiplication. Notice that we used it in our functions in the module (namely <code>cuboidArea</code> and <code>cuboidVolume</code>) but we didn't export it! Because we want our module to just present functions for dealing with three dimensional objects, we used <code>rectangleArea</code> but we didn't export it.</p></div><div><p>When making a module, we usually export only those functions that act as a sort of interface to our module so that the implementation is hidden. If someone is using our <code>Geometry</code> module, they don't have to concern themselves with functions that we don't export. We can decide to change those functions completely or delete them in a newer version (we could delete <code>rectangleArea</code> and just use <code>*</code> instead) and no one will mind because we weren't exporting them in the first place.</p></div><div><p>To use our module, we just do:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token import-statement"><span class="token keyword">import</span> Geometry</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p><code>Geometry.hs</code> has to be in the same folder that the program that's importing it is in, though.</p></div><div><p>Modules can also be given a hierarchical structures. Each module can have a number of sub-modules and they can have sub-modules of their own. Let's section these functions off so that <code>Geometry</code> is a module that has three sub-modules, one for each type of object.</p></div><div><p>First, we'll make a folder called <code>Geometry</code>. Mind the capital G. In it, we'll place three files: <code>Sphere.hs</code>, <code>Cuboid.hs</code>, and <code>Cube.hs</code>. Here's what the files will contain:</p></div><div><p><code>Sphere.hs</code></p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token keyword">module</span> <span class="token constant">Geometry<span class="token punctuation">.</span>Sphere</span>
<span class="token punctuation">(</span> <span class="token hvariable">volume</span>
<span class="token punctuation">,</span> <span class="token hvariable">area</span>
<span class="token punctuation">)</span> <span class="token keyword">where</span>

<span class="token hvariable">volume</span> <span class="token operator">::</span> <span class="token constant">Float</span> <span class="token operator">-&gt;</span> <span class="token constant">Float</span>
<span class="token hvariable">volume</span> <span class="token hvariable">radius</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token number">4.0</span> <span class="token operator">/</span> <span class="token number">3.0</span><span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token builtin">pi</span> <span class="token operator">*</span> <span class="token punctuation">(</span><span class="token hvariable">radius</span> <span class="token operator">^</span> <span class="token number">3</span><span class="token punctuation">)</span>

<span class="token hvariable">area</span> <span class="token operator">::</span> <span class="token constant">Float</span> <span class="token operator">-&gt;</span> <span class="token constant">Float</span>
<span class="token hvariable">area</span> <span class="token hvariable">radius</span> <span class="token operator">=</span> <span class="token number">4</span> <span class="token operator">*</span> <span class="token builtin">pi</span> <span class="token operator">*</span> <span class="token punctuation">(</span><span class="token hvariable">radius</span> <span class="token operator">^</span> <span class="token number">2</span><span class="token punctuation">)</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p><code>Cuboid.hs</code></p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token keyword">module</span> <span class="token constant">Geometry<span class="token punctuation">.</span>Cuboid</span>
<span class="token punctuation">(</span> <span class="token hvariable">volume</span>
<span class="token punctuation">,</span> <span class="token hvariable">area</span>
<span class="token punctuation">)</span> <span class="token keyword">where</span>

<span class="token hvariable">volume</span> <span class="token operator">::</span> <span class="token constant">Float</span> <span class="token operator">-&gt;</span> <span class="token constant">Float</span> <span class="token operator">-&gt;</span> <span class="token constant">Float</span> <span class="token operator">-&gt;</span> <span class="token constant">Float</span>
<span class="token hvariable">volume</span> <span class="token hvariable">a</span> <span class="token hvariable">b</span> <span class="token hvariable">c</span> <span class="token operator">=</span> <span class="token hvariable">rectangleArea</span> <span class="token hvariable">a</span> <span class="token hvariable">b</span> <span class="token operator">*</span> <span class="token hvariable">c</span>

<span class="token hvariable">area</span> <span class="token operator">::</span> <span class="token constant">Float</span> <span class="token operator">-&gt;</span> <span class="token constant">Float</span> <span class="token operator">-&gt;</span> <span class="token constant">Float</span> <span class="token operator">-&gt;</span> <span class="token constant">Float</span>
<span class="token hvariable">area</span> <span class="token hvariable">a</span> <span class="token hvariable">b</span> <span class="token hvariable">c</span> <span class="token operator">=</span> <span class="token hvariable">rectangleArea</span> <span class="token hvariable">a</span> <span class="token hvariable">b</span> <span class="token operator">*</span> <span class="token number">2</span> <span class="token operator">+</span> <span class="token hvariable">rectangleArea</span> <span class="token hvariable">a</span> <span class="token hvariable">c</span> <span class="token operator">*</span> <span class="token number">2</span> <span class="token operator">+</span> <span class="token hvariable">rectangleArea</span> <span class="token hvariable">c</span> <span class="token hvariable">b</span> <span class="token operator">*</span> <span class="token number">2</span>

<span class="token hvariable">rectangleArea</span> <span class="token operator">::</span> <span class="token constant">Float</span> <span class="token operator">-&gt;</span> <span class="token constant">Float</span> <span class="token operator">-&gt;</span> <span class="token constant">Float</span>
<span class="token hvariable">rectangleArea</span> <span class="token hvariable">a</span> <span class="token hvariable">b</span> <span class="token operator">=</span> <span class="token hvariable">a</span> <span class="token operator">*</span> <span class="token hvariable">b</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p><code>Cube.hs</code></p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token keyword">module</span> <span class="token constant">Geometry<span class="token punctuation">.</span>Cube</span>
<span class="token punctuation">(</span> <span class="token hvariable">volume</span>
<span class="token punctuation">,</span> <span class="token hvariable">area</span>
<span class="token punctuation">)</span> <span class="token keyword">where</span>

<span class="token import-statement"><span class="token keyword">import</span> <span class="token keyword">qualified</span> Geometry<span class="token punctuation">.</span>Cuboid <span class="token keyword">as</span> Cuboid</span>

<span class="token hvariable">volume</span> <span class="token operator">::</span> <span class="token constant">Float</span> <span class="token operator">-&gt;</span> <span class="token constant">Float</span>
<span class="token hvariable">volume</span> <span class="token hvariable">side</span> <span class="token operator">=</span> <span class="token hvariable">Cuboid<span class="token punctuation">.</span>volume</span> <span class="token hvariable">side</span> <span class="token hvariable">side</span> <span class="token hvariable">side</span>

<span class="token hvariable">area</span> <span class="token operator">::</span> <span class="token constant">Float</span> <span class="token operator">-&gt;</span> <span class="token constant">Float</span>
<span class="token hvariable">area</span> <span class="token hvariable">side</span> <span class="token operator">=</span> <span class="token hvariable">Cuboid<span class="token punctuation">.</span>area</span> <span class="token hvariable">side</span> <span class="token hvariable">side</span> <span class="token hvariable">side</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Alright! So first is <code>Geometry.Sphere</code>. Notice how we placed it in a folder called <code>Geometry</code> and then defined the module name as <code>Geometry.Sphere</code>. We did the same for the cuboid. Also notice how in all three sub-modules, we defined functions with the same names. We can do this because they're separate modules. We want to use functions from <code>Geometry.Cuboid</code> in <code>Geometry.Cube</code> but we can't just straight up do <code>import Geometry.Cuboid</code> because it exports functions with the same names as <code>Geometry.Cube</code>. That's why we do a qualified import and all is well.</p></div><div><p>So now if we're in a file that's on the same level as the <code>Geometry</code> folder, we can do, say:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token import-statement"><span class="token keyword">import</span> Geometry<span class="token punctuation">.</span>Sphere</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>And then we can call <code>area</code> and <code>volume</code> and they'll give us the area and volume for a sphere. And if we want to juggle two or more of these modules, we have to do qualified imports because they export functions with the same names. So we just do something like:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token import-statement"><span class="token keyword">import</span> <span class="token keyword">qualified</span> Geometry<span class="token punctuation">.</span>Sphere <span class="token keyword">as</span> Sphere</span>
<span class="token import-statement"><span class="token keyword">import</span> <span class="token keyword">qualified</span> Geometry<span class="token punctuation">.</span>Cuboid <span class="token keyword">as</span> Cuboid</span>
<span class="token import-statement"><span class="token keyword">import</span> <span class="token keyword">qualified</span> Geometry<span class="token punctuation">.</span>Cube <span class="token keyword">as</span> Cube</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>And then we can call <code>Sphere.area</code>, <code>Sphere.volume</code>, <code>Cuboid.area</code>, etc. and each will calculate the area or volume for their corresponding object.</p></div><div><p>The next time you find yourself writing a file that's really big and has a lot of functions, try to see which functions serve some common purpose and then see if you can put them in their own module. You'll be able to just import your module the next time you're writing a program that requires some of the same functionality.</p></div><div><h1 data-heading="Making Our Own Types and Typeclasses" id="Making_Our_Own_Types_and_Typeclasses">Making Our Own Types and Typeclasses</h1></div><div><p>In the previous chapters, we covered some existing Haskell types and typeclasses. In this chapter, we'll learn how to make our own and how to put them to work!</p></div><div><h2 data-heading="Algebraic data types intro" id="Algebraic_data_types_intro" style="display: flex;"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>Algebraic data types intro</h2></div><div><p>So far, we've run into a lot of data types. <code>Bool</code>, <code>Int</code>, <code>Char</code>, <code>Maybe</code>, etc. But how do we make our own? Well, one way is to use the <strong>data</strong> keyword to define a type. Let's see how the <code>Bool</code> type is defined in the standard library.</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token keyword">data</span> <span class="token constant">Bool</span> <span class="token operator">=</span> <span class="token constant">False</span> <span class="token operator">|</span> <span class="token constant">True</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p><code>data</code> means that we're defining a new data type. The part before the <code>=</code> denotes the type, which is <code>Bool</code>. The parts after the <code>=</code> are <strong>value constructors</strong>. They specify the different values that this type can have. The <code>|</code> is read as <em>or</em>. So we can read this as: the <code>Bool</code> type can have a value of <code>True</code> or <code>False</code>. Both the type name and the value constructors have to be capital cased.</p></div><div><p>In a similar fashion, we can think of the <code>Int</code> type as being defined like this:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token keyword">data</span> <span class="token constant">Int</span> <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">2147483648</span> <span class="token operator">|</span> <span class="token operator">-</span><span class="token number">2147483647</span> <span class="token operator">|</span> <span class="token operator">...</span> <span class="token operator">|</span> <span class="token operator">-</span><span class="token number">1</span> <span class="token operator">|</span> <span class="token number">0</span> <span class="token operator">|</span> <span class="token number">1</span> <span class="token operator">|</span> <span class="token number">2</span> <span class="token operator">|</span> <span class="token operator">...</span> <span class="token operator">|</span> <span class="token number">2147483647</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p><span alt="LYHfGG_47_caveman.png" src="LYHfGG_47_caveman.png" class="internal-embed media-embed image-embed is-loaded"><img alt="LYHfGG_47_caveman.png" src="курсы\learn-you-a-haskell-for-great-good!\картинки\lyhfgg_47_caveman.png"></span></p></div><div><p>The first and last value constructors are the minimum and maximum possible values of <code>Int</code>. It's not actually defined like this, the ellipses are here because we omitted a heapload of numbers, so this is just for illustrative purposes.</p></div><div><p>Now, let's think about how we would represent a shape in Haskell. One way would be to use tuples. A circle could be denoted as <code>(43.1, 55.0, 10.4)</code> where the first and second fields are the coordinates of the circle's center and the third field is the radius. Sounds OK, but those could also represent a 3D vector or anything else. A better solution would be to make our own type to represent a shape. Let's say that a shape can be a circle or a rectangle. Here it is:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token keyword">data</span> <span class="token constant">Shape</span> <span class="token operator">=</span> <span class="token constant">Circle</span> <span class="token constant">Float</span> <span class="token constant">Float</span> <span class="token constant">Float</span> <span class="token operator">|</span> <span class="token constant">Rectangle</span> <span class="token constant">Float</span> <span class="token constant">Float</span> <span class="token constant">Float</span> <span class="token constant">Float</span> 
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Now what's this? Think of it like this. The <code>Circle</code> value constructor has three fields, which take floats. So when we write a value constructor, we can optionally add some types after it and those types define the values it will contain. Here, the first two fields are the coordinates of its center, the third one its radius. The <code>Rectangle</code> value constructor has four fields which accept floats. The first two are the coordinates to its upper left corner and the second two are coordinates to its lower right one.</p></div><div><p>Now when I say fields, I actually mean parameters. Value constructors are actually functions that ultimately return a value of a data type. Let's take a look at the type signatures for these two value constructors.</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token operator">:</span><span class="token hvariable">t</span> <span class="token constant">Circle</span>
<span class="token constant">Circle</span> <span class="token operator">::</span> <span class="token constant">Float</span> <span class="token operator">-&gt;</span> <span class="token constant">Float</span> <span class="token operator">-&gt;</span> <span class="token constant">Float</span> <span class="token operator">-&gt;</span> <span class="token constant">Shape</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token operator">:</span><span class="token hvariable">t</span> <span class="token constant">Rectangle</span>
<span class="token constant">Rectangle</span> <span class="token operator">::</span> <span class="token constant">Float</span> <span class="token operator">-&gt;</span> <span class="token constant">Float</span> <span class="token operator">-&gt;</span> <span class="token constant">Float</span> <span class="token operator">-&gt;</span> <span class="token constant">Float</span> <span class="token operator">-&gt;</span> <span class="token constant">Shape</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Cool, so value constructors are functions like everything else. Who would have thought? Let's make a function that takes a shape and returns its surface.</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">surface</span> <span class="token operator">::</span> <span class="token constant">Shape</span> <span class="token operator">-&gt;</span> <span class="token constant">Float</span>
<span class="token hvariable">surface</span> <span class="token punctuation">(</span><span class="token constant">Circle</span> <span class="token hvariable">_</span> <span class="token hvariable">_</span> <span class="token hvariable">r</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token builtin">pi</span> <span class="token operator">*</span> <span class="token hvariable">r</span> <span class="token operator">^</span> <span class="token number">2</span>
<span class="token hvariable">surface</span> <span class="token punctuation">(</span><span class="token constant">Rectangle</span> <span class="token hvariable">x1</span> <span class="token hvariable">y1</span> <span class="token hvariable">x2</span> <span class="token hvariable">y2</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token builtin">abs</span> <span class="token operator">$</span> <span class="token hvariable">x2</span> <span class="token operator">-</span> <span class="token hvariable">x1</span><span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token punctuation">(</span><span class="token builtin">abs</span> <span class="token operator">$</span> <span class="token hvariable">y2</span> <span class="token operator">-</span> <span class="token hvariable">y1</span><span class="token punctuation">)</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>The first notable thing here is the type declaration. It says that the function takes a shape and returns a float. We couldn't write a type declaration of <code>Circle -&gt; Float</code> because <code>Circle</code> is not a type, <code>Shape</code> is. Just like we can't write a function with a type declaration of <code>True -&gt; Int</code>. The next thing we notice here is that we can pattern match against constructors. We pattern matched against constructors before (all the time actually) when we pattern matched against values like <code>[]</code> or <code>False</code> or <code>5</code>, only those values didn't have any fields. We just write a constructor and then bind its fields to names. Because we're interested in the radius, we don't actually care about the first two fields, which tell us where the circle is.</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token hvariable">surface</span> <span class="token operator">$</span> <span class="token constant">Circle</span> <span class="token number">10</span> <span class="token number">20</span> <span class="token number">10</span>
<span class="token number">314.15927</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token hvariable">surface</span> <span class="token operator">$</span> <span class="token constant">Rectangle</span> <span class="token number">0</span> <span class="token number">0</span> <span class="token number">100</span> <span class="token number">100</span>
<span class="token number">10000.0</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Yay, it works! But if we try to just print out <code>Circle 10 20 5</code> in the prompt, we'll get an error. That's because Haskell doesn't know how to display our data type as a string (yet). Remember, when we try to print a value out in the prompt, Haskell first runs the <code>show</code> function to get the string representation of our value and then it prints that out to the terminal. To make our <code>Shape</code> type part of the <code>Show</code> typeclass, we modify it like this:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token keyword">data</span> <span class="token constant">Shape</span> <span class="token operator">=</span> <span class="token constant">Circle</span> <span class="token constant">Float</span> <span class="token constant">Float</span> <span class="token constant">Float</span> <span class="token operator">|</span> <span class="token constant">Rectangle</span> <span class="token constant">Float</span> <span class="token constant">Float</span> <span class="token constant">Float</span> <span class="token constant">Float</span> <span class="token keyword">deriving</span> <span class="token punctuation">(</span><span class="token constant">Show</span><span class="token punctuation">)</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>We won't concern ourselves with deriving too much for now. Let's just say that if we add <code>deriving (Show)</code> at the end of a <em>data</em> declaration, Haskell automagically makes that type part of the <code>Show</code> typeclass. So now, we can do this:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token constant">Circle</span> <span class="token number">10</span> <span class="token number">20</span> <span class="token number">5</span>
<span class="token constant">Circle</span> <span class="token number">10.0</span> <span class="token number">20.0</span> <span class="token number">5.0</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token constant">Rectangle</span> <span class="token number">50</span> <span class="token number">230</span> <span class="token number">60</span> <span class="token number">90</span>
<span class="token constant">Rectangle</span> <span class="token number">50.0</span> <span class="token number">230.0</span> <span class="token number">60.0</span> <span class="token number">90.0</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Value constructors are functions, so we can map them and partially apply them and everything. If we want a list of concentric circles with different radii, we can do this.</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token builtin">map</span> <span class="token punctuation">(</span><span class="token constant">Circle</span> <span class="token number">10</span> <span class="token number">20</span><span class="token punctuation">)</span> <span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">]</span>
<span class="token punctuation">[</span><span class="token constant">Circle</span> <span class="token number">10.0</span> <span class="token number">20.0</span> <span class="token number">4.0</span><span class="token punctuation">,</span><span class="token constant">Circle</span> <span class="token number">10.0</span> <span class="token number">20.0</span> <span class="token number">5.0</span><span class="token punctuation">,</span><span class="token constant">Circle</span> <span class="token number">10.0</span> <span class="token number">20.0</span> <span class="token number">6.0</span><span class="token punctuation">,</span><span class="token constant">Circle</span> <span class="token number">10.0</span> <span class="token number">20.0</span> <span class="token number">6.0</span><span class="token punctuation">]</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Our data type is good, although it could be better. Let's make an intermediate data type that defines a point in two-dimensional space. Then we can use that to make our shapes more understandable.</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token keyword">data</span> <span class="token constant">Point</span> <span class="token operator">=</span> <span class="token constant">Point</span> <span class="token constant">Float</span> <span class="token constant">Float</span> <span class="token keyword">deriving</span> <span class="token punctuation">(</span><span class="token constant">Show</span><span class="token punctuation">)</span>
<span class="token keyword">data</span> <span class="token constant">Shape</span> <span class="token operator">=</span> <span class="token constant">Circle</span> <span class="token constant">Point</span> <span class="token constant">Float</span> <span class="token operator">|</span> <span class="token constant">Rectangle</span> <span class="token constant">Point</span> <span class="token constant">Point</span> <span class="token keyword">deriving</span> <span class="token punctuation">(</span><span class="token constant">Show</span><span class="token punctuation">)</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Notice that when defining a point, we used the same name for the data type and the value constructor. This has no special meaning, although it's common to use the same name as the type if there's only one value constructor. So now the <code>Circle</code> has two fields, one is of type <code>Point</code> and the other of type <code>Float</code>. This makes it easier to understand what's what. Same goes for the rectangle. We have to adjust our <code>surface</code> function to reflect these changes.</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">surface</span> <span class="token operator">::</span> <span class="token constant">Shape</span> <span class="token operator">-&gt;</span> <span class="token constant">Float</span>
<span class="token hvariable">surface</span> <span class="token punctuation">(</span><span class="token constant">Circle</span> <span class="token hvariable">_</span> <span class="token hvariable">r</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token builtin">pi</span> <span class="token operator">*</span> <span class="token hvariable">r</span> <span class="token operator">^</span> <span class="token number">2</span>
<span class="token hvariable">surface</span> <span class="token punctuation">(</span><span class="token constant">Rectangle</span> <span class="token punctuation">(</span><span class="token constant">Point</span> <span class="token hvariable">x1</span> <span class="token hvariable">y1</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token constant">Point</span> <span class="token hvariable">x2</span> <span class="token hvariable">y2</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token builtin">abs</span> <span class="token operator">$</span> <span class="token hvariable">x2</span> <span class="token operator">-</span> <span class="token hvariable">x1</span><span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token punctuation">(</span><span class="token builtin">abs</span> <span class="token operator">$</span> <span class="token hvariable">y2</span> <span class="token operator">-</span> <span class="token hvariable">y1</span><span class="token punctuation">)</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>The only thing we had to change were the patterns. We disregarded the whole point in the circle pattern. In the rectangle pattern, we just used a nested pattern matching to get the fields of the points. If we wanted to reference the points themselves for some reason, we could have used as-patterns.</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token hvariable">surface</span> <span class="token punctuation">(</span><span class="token constant">Rectangle</span> <span class="token punctuation">(</span><span class="token constant">Point</span> <span class="token number">0</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token constant">Point</span> <span class="token number">100</span> <span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token number">10000.0</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token hvariable">surface</span> <span class="token punctuation">(</span><span class="token constant">Circle</span> <span class="token punctuation">(</span><span class="token constant">Point</span> <span class="token number">0</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token number">24</span><span class="token punctuation">)</span>
<span class="token number">1809.5574</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>How about a function that nudges a shape? It takes a shape, the amount to move it on the x axis and the amount to move it on the y axis and then returns a new shape that has the same dimensions, only it's located somewhere else.</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">nudge</span> <span class="token operator">::</span> <span class="token constant">Shape</span> <span class="token operator">-&gt;</span> <span class="token constant">Float</span> <span class="token operator">-&gt;</span> <span class="token constant">Float</span> <span class="token operator">-&gt;</span> <span class="token constant">Shape</span>
<span class="token hvariable">nudge</span> <span class="token punctuation">(</span><span class="token constant">Circle</span> <span class="token punctuation">(</span><span class="token constant">Point</span> <span class="token hvariable">x</span> <span class="token hvariable">y</span><span class="token punctuation">)</span> <span class="token hvariable">r</span><span class="token punctuation">)</span> <span class="token hvariable">a</span> <span class="token hvariable">b</span> <span class="token operator">=</span> <span class="token constant">Circle</span> <span class="token punctuation">(</span><span class="token constant">Point</span> <span class="token punctuation">(</span><span class="token hvariable">x</span><span class="token operator">+</span><span class="token hvariable">a</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token hvariable">y</span><span class="token operator">+</span><span class="token hvariable">b</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token hvariable">r</span>
<span class="token hvariable">nudge</span> <span class="token punctuation">(</span><span class="token constant">Rectangle</span> <span class="token punctuation">(</span><span class="token constant">Point</span> <span class="token hvariable">x1</span> <span class="token hvariable">y1</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token constant">Point</span> <span class="token hvariable">x2</span> <span class="token hvariable">y2</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token hvariable">a</span> <span class="token hvariable">b</span> <span class="token operator">=</span> <span class="token constant">Rectangle</span> <span class="token punctuation">(</span><span class="token constant">Point</span> <span class="token punctuation">(</span><span class="token hvariable">x1</span><span class="token operator">+</span><span class="token hvariable">a</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token hvariable">y1</span><span class="token operator">+</span><span class="token hvariable">b</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token constant">Point</span> <span class="token punctuation">(</span><span class="token hvariable">x2</span><span class="token operator">+</span><span class="token hvariable">a</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token hvariable">y2</span><span class="token operator">+</span><span class="token hvariable">b</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Pretty straightforward. We add the nudge amounts to the points that denote the position of the shape.</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token hvariable">nudge</span> <span class="token punctuation">(</span><span class="token constant">Circle</span> <span class="token punctuation">(</span><span class="token constant">Point</span> <span class="token number">34</span> <span class="token number">34</span><span class="token punctuation">)</span> <span class="token number">10</span><span class="token punctuation">)</span> <span class="token number">5</span> <span class="token number">10</span>
<span class="token constant">Circle</span> <span class="token punctuation">(</span><span class="token constant">Point</span> <span class="token number">39.0</span> <span class="token number">44.0</span><span class="token punctuation">)</span> <span class="token number">10.0</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>If we don't want to deal directly with points, we can make some auxilliary functions that create shapes of some size at the zero coordinates and then nudge those.</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">baseCircle</span> <span class="token operator">::</span> <span class="token constant">Float</span> <span class="token operator">-&gt;</span> <span class="token constant">Shape</span>
<span class="token hvariable">baseCircle</span> <span class="token hvariable">r</span> <span class="token operator">=</span> <span class="token constant">Circle</span> <span class="token punctuation">(</span><span class="token constant">Point</span> <span class="token number">0</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token hvariable">r</span>

<span class="token hvariable">baseRect</span> <span class="token operator">::</span> <span class="token constant">Float</span> <span class="token operator">-&gt;</span> <span class="token constant">Float</span> <span class="token operator">-&gt;</span> <span class="token constant">Shape</span>
<span class="token hvariable">baseRect</span> <span class="token hvariable">width</span> <span class="token hvariable">height</span> <span class="token operator">=</span> <span class="token constant">Rectangle</span> <span class="token punctuation">(</span><span class="token constant">Point</span> <span class="token number">0</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token constant">Point</span> <span class="token hvariable">width</span> <span class="token hvariable">height</span><span class="token punctuation">)</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token hvariable">nudge</span> <span class="token punctuation">(</span><span class="token hvariable">baseRect</span> <span class="token number">40</span> <span class="token number">100</span><span class="token punctuation">)</span> <span class="token number">60</span> <span class="token number">23</span>
<span class="token constant">Rectangle</span> <span class="token punctuation">(</span><span class="token constant">Point</span> <span class="token number">60.0</span> <span class="token number">23.0</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token constant">Point</span> <span class="token number">100.0</span> <span class="token number">123.0</span><span class="token punctuation">)</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>You can, of course, export your data types in your modules. To do that, just write your type along with the functions you are exporting and then add some parentheses and in them specify the value constructors that you want to export for it, separated by commas. If you want to export all the value constructors for a given type, just write <code>..</code>.</p></div><div><p>If we wanted to export the functions and types that we defined here in a module, we could start it off like this:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token keyword">module</span> <span class="token constant">Shapes</span> 
<span class="token punctuation">(</span> <span class="token constant">Point</span><span class="token punctuation">(</span><span class="token operator">..</span><span class="token punctuation">)</span>
<span class="token punctuation">,</span> <span class="token constant">Shape</span><span class="token punctuation">(</span><span class="token operator">..</span><span class="token punctuation">)</span>
<span class="token punctuation">,</span> <span class="token hvariable">surface</span>
<span class="token punctuation">,</span> <span class="token hvariable">nudge</span>
<span class="token punctuation">,</span> <span class="token hvariable">baseCircle</span>
<span class="token punctuation">,</span> <span class="token hvariable">baseRect</span>
<span class="token punctuation">)</span> <span class="token keyword">where</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>By doing <code>Shape(..)</code>, we exported all the value constructors for <code>Shape</code>, so that means that whoever imports our module can make shapes by using the <code>Rectangle</code> and <code>Circle</code> value constructors. It's the same as writing <code>Shape (Rectangle, Circle)</code>.</p></div><div><p>We could also opt not to export any value constructors for <code>Shape</code> by just writing <code>Shape</code> in the export statement. That way, someone importing our module could only make shapes by using the auxilliary functions <code>baseCircle</code> and <code>baseRect</code>. <code>Data.Map</code> uses that approach. You can't create a map by doing <code>Map.Map [(1,2),(3,4)]</code> because it doesn't export that value constructor. However, you can make a mapping by using one of the auxilliary functions like <code>Map.fromList</code>. Remember, value constructors are just functions that take the fields as parameters and return a value of some type (like <code>Shape</code>) as a result. So when we choose not to export them, we just prevent the person importing our module from using those functions, but if some other functions that are exported return a type, we can use them to make values of our custom data types.</p></div><div><p>Not exporting the value constructors of a data types makes them more abstract in such a way that we hide their implementation. Also, whoever uses our module can't pattern match against the value constructors.</p></div><div><h2 data-heading="Record syntax" id="Record_syntax" style="display: flex;"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>Record syntax</h2></div><div><p><span alt="LYHfGG_48_record.png" src="LYHfGG_48_record.png" class="internal-embed media-embed image-embed is-loaded"><img alt="LYHfGG_48_record.png" src="курсы\learn-you-a-haskell-for-great-good!\картинки\lyhfgg_48_record.png"></span></p></div><div><p>OK, we've been tasked with creating a data type that describes a person. The info that we want to store about that person is: first name, last name, age, height, phone number, and favorite ice-cream flavor. I don't know about you, but that's all I ever want to know about a person. Let's give it a go!</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token keyword">data</span> <span class="token constant">Person</span> <span class="token operator">=</span> <span class="token constant">Person</span> <span class="token constant">String</span> <span class="token constant">String</span> <span class="token constant">Int</span> <span class="token constant">Float</span> <span class="token constant">String</span> <span class="token constant">String</span> <span class="token keyword">deriving</span> <span class="token punctuation">(</span><span class="token constant">Show</span><span class="token punctuation">)</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>O-kay. The first field is the first name, the second is the last name, the third is the age and so on. Let's make a person.</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token keyword">let</span> <span class="token hvariable">guy</span> <span class="token operator">=</span> <span class="token constant">Person</span> <span class="token string">"Buddy"</span> <span class="token string">"Finklestein"</span> <span class="token number">43</span> <span class="token number">184.2</span> <span class="token string">"526-2928"</span> <span class="token string">"Chocolate"</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token hvariable">guy</span>
<span class="token constant">Person</span> <span class="token string">"Buddy"</span> <span class="token string">"Finklestein"</span> <span class="token number">43</span> <span class="token number">184.2</span> <span class="token string">"526-2928"</span> <span class="token string">"Chocolate"</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>That's kind of cool, although slightly unreadable. What if we want to create a function to get seperate info from a person? A function that gets some person's first name, a function that gets some person's last name, etc. Well, we'd have to define them kind of like this.</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">firstName</span> <span class="token operator">::</span> <span class="token constant">Person</span> <span class="token operator">-&gt;</span> <span class="token constant">String</span>
<span class="token hvariable">firstName</span> <span class="token punctuation">(</span><span class="token constant">Person</span> <span class="token hvariable">firstname</span> <span class="token hvariable">_</span> <span class="token hvariable">_</span> <span class="token hvariable">_</span> <span class="token hvariable">_</span> <span class="token hvariable">_</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token hvariable">firstname</span>

<span class="token hvariable">lastName</span> <span class="token operator">::</span> <span class="token constant">Person</span> <span class="token operator">-&gt;</span> <span class="token constant">String</span>
<span class="token hvariable">lastName</span> <span class="token punctuation">(</span><span class="token constant">Person</span> <span class="token hvariable">_</span> <span class="token hvariable">lastname</span> <span class="token hvariable">_</span> <span class="token hvariable">_</span> <span class="token hvariable">_</span> <span class="token hvariable">_</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token hvariable">lastname</span>

<span class="token hvariable">age</span> <span class="token operator">::</span> <span class="token constant">Person</span> <span class="token operator">-&gt;</span> <span class="token constant">Int</span>
<span class="token hvariable">age</span> <span class="token punctuation">(</span><span class="token constant">Person</span> <span class="token hvariable">_</span> <span class="token hvariable">_</span> <span class="token hvariable">age</span> <span class="token hvariable">_</span> <span class="token hvariable">_</span> <span class="token hvariable">_</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token hvariable">age</span>

<span class="token hvariable">height</span> <span class="token operator">::</span> <span class="token constant">Person</span> <span class="token operator">-&gt;</span> <span class="token constant">Float</span>
<span class="token hvariable">height</span> <span class="token punctuation">(</span><span class="token constant">Person</span> <span class="token hvariable">_</span> <span class="token hvariable">_</span> <span class="token hvariable">_</span> <span class="token hvariable">height</span> <span class="token hvariable">_</span> <span class="token hvariable">_</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token hvariable">height</span>

<span class="token hvariable">phoneNumber</span> <span class="token operator">::</span> <span class="token constant">Person</span> <span class="token operator">-&gt;</span> <span class="token constant">String</span>
<span class="token hvariable">phoneNumber</span> <span class="token punctuation">(</span><span class="token constant">Person</span> <span class="token hvariable">_</span> <span class="token hvariable">_</span> <span class="token hvariable">_</span> <span class="token hvariable">_</span> <span class="token hvariable">number</span> <span class="token hvariable">_</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token hvariable">number</span>

<span class="token hvariable">flavor</span> <span class="token operator">::</span> <span class="token constant">Person</span> <span class="token operator">-&gt;</span> <span class="token constant">String</span>
<span class="token hvariable">flavor</span> <span class="token punctuation">(</span><span class="token constant">Person</span> <span class="token hvariable">_</span> <span class="token hvariable">_</span> <span class="token hvariable">_</span> <span class="token hvariable">_</span> <span class="token hvariable">_</span> <span class="token hvariable">flavor</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token hvariable">flavor</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Whew! I certainly did not enjoy writing that! Despite being very cumbersome and BORING to write, this method works.</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token keyword">let</span> <span class="token hvariable">guy</span> <span class="token operator">=</span> <span class="token constant">Person</span> <span class="token string">"Buddy"</span> <span class="token string">"Finklestein"</span> <span class="token number">43</span> <span class="token number">184.2</span> <span class="token string">"526-2928"</span> <span class="token string">"Chocolate"</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token hvariable">firstName</span> <span class="token hvariable">guy</span>
<span class="token string">"Buddy"</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token hvariable">height</span> <span class="token hvariable">guy</span>
<span class="token number">184.2</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token hvariable">flavor</span> <span class="token hvariable">guy</span>
<span class="token string">"Chocolate"</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>There must be a better way, you say! Well no, there isn't, sorry.</p></div><div><p>Just kidding, there is. Hahaha! The makers of Haskell were very smart and anticipated this scenario. They included an alternative way to write data types. Here's how we could achieve the above functionality with record syntax.</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token keyword">data</span> <span class="token constant">Person</span> <span class="token operator">=</span> <span class="token constant">Person</span> <span class="token punctuation">{</span> <span class="token hvariable">firstName</span> <span class="token operator">::</span> <span class="token constant">String</span>
                     <span class="token punctuation">,</span> <span class="token hvariable">lastName</span> <span class="token operator">::</span> <span class="token constant">String</span>
                     <span class="token punctuation">,</span> <span class="token hvariable">age</span> <span class="token operator">::</span> <span class="token constant">Int</span>
                     <span class="token punctuation">,</span> <span class="token hvariable">height</span> <span class="token operator">::</span> <span class="token constant">Float</span>
                     <span class="token punctuation">,</span> <span class="token hvariable">phoneNumber</span> <span class="token operator">::</span> <span class="token constant">String</span>
                     <span class="token punctuation">,</span> <span class="token hvariable">flavor</span> <span class="token operator">::</span> <span class="token constant">String</span>
                     <span class="token punctuation">}</span> <span class="token keyword">deriving</span> <span class="token punctuation">(</span><span class="token constant">Show</span><span class="token punctuation">)</span> 
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>So instead of just naming the field types one after another and separating them with spaces, we use curly brackets. First we write the name of the field, for instance, <code>firstName</code> and then we write a double colon <code>::</code> (also called Paamayim Nekudotayim, haha) and then we specify the type. The resulting data type is exactly the same. The main benefit of this is that it creates functions that lookup fields in the data type. By using record syntax to create this data type, Haskell automatically made these functions: <code>firstName</code>, <code>lastName</code>, <code>age</code>, <code>height</code>, <code>phoneNumber</code> and <code>flavor</code>.</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token operator">:</span><span class="token hvariable">t</span> <span class="token hvariable">flavor</span>
<span class="token hvariable">flavor</span> <span class="token operator">::</span> <span class="token constant">Person</span> <span class="token operator">-&gt;</span> <span class="token constant">String</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token operator">:</span><span class="token hvariable">t</span> <span class="token hvariable">firstName</span>
<span class="token hvariable">firstName</span> <span class="token operator">::</span> <span class="token constant">Person</span> <span class="token operator">-&gt;</span> <span class="token constant">String</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>There's another benefit to using record syntax. When we derive <code>Show</code> for the type, it displays it differently if we use record syntax to define and instantiate the type. Say we have a type that represents a car. We want to keep track of the company that made it, the model name and its year of production. Watch.</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token keyword">data</span> <span class="token constant">Car</span> <span class="token operator">=</span> <span class="token constant">Car</span> <span class="token constant">String</span> <span class="token constant">String</span> <span class="token constant">Int</span> <span class="token keyword">deriving</span> <span class="token punctuation">(</span><span class="token constant">Show</span><span class="token punctuation">)</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token constant">Car</span> <span class="token string">"Ford"</span> <span class="token string">"Mustang"</span> <span class="token number">1967</span>
<span class="token constant">Car</span> <span class="token string">"Ford"</span> <span class="token string">"Mustang"</span> <span class="token number">1967</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>If we define it using record syntax, we can make a new car like this.</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token keyword">data</span> <span class="token constant">Car</span> <span class="token operator">=</span> <span class="token constant">Car</span> <span class="token punctuation">{</span><span class="token hvariable">company</span> <span class="token operator">::</span> <span class="token constant">String</span><span class="token punctuation">,</span> <span class="token hvariable">model</span> <span class="token operator">::</span> <span class="token constant">String</span><span class="token punctuation">,</span> <span class="token hvariable">year</span> <span class="token operator">::</span> <span class="token constant">Int</span><span class="token punctuation">}</span> <span class="token keyword">deriving</span> <span class="token punctuation">(</span><span class="token constant">Show</span><span class="token punctuation">)</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token constant">Car</span> <span class="token punctuation">{</span><span class="token hvariable">company</span><span class="token operator">=</span><span class="token string">"Ford"</span><span class="token punctuation">,</span> <span class="token hvariable">model</span><span class="token operator">=</span><span class="token string">"Mustang"</span><span class="token punctuation">,</span> <span class="token hvariable">year</span><span class="token operator">=</span><span class="token number">1967</span><span class="token punctuation">}</span>
<span class="token constant">Car</span> <span class="token punctuation">{</span><span class="token hvariable">company</span> <span class="token operator">=</span> <span class="token string">"Ford"</span><span class="token punctuation">,</span> <span class="token hvariable">model</span> <span class="token operator">=</span> <span class="token string">"Mustang"</span><span class="token punctuation">,</span> <span class="token hvariable">year</span> <span class="token operator">=</span> <span class="token number">1967</span><span class="token punctuation">}</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>When making a new car, we don't have to necessarily put the fields in the proper order, as long as we list all of them. But if we don't use record syntax, we have to specify them in order.</p></div><div><p>Use record syntax when a constructor has several fields and it's not obvious which field is which. If we make a 3D vector data type by doing <code>data Vector = Vector Int Int Int</code>, it's pretty obvious that the fields are the components of a vector. However, in our <code>Person</code> and <code>Car</code> types, it wasn't so obvious and we greatly benefited from using record syntax.</p></div><div><h2 data-heading="Type parameters" id="Type_parameters" style="display: flex;"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>Type parameters</h2></div><div><p>A value constructor can take some values parameters and then produce a new value. For instance, the <code>Car</code> constructor takes three values and produces a car value. In a similar manner, <strong>type constructors</strong> can take types as parameters to produce new types. This might sound a bit too meta at first, but it's not that complicated. If you're familiar with templates in C++, you'll see some parallels. To get a clear picture of what type parameters work like in action, let's take a look at how a type we've already met is implemented.</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token keyword">data</span> <span class="token constant">Maybe</span> <span class="token hvariable">a</span> <span class="token operator">=</span> <span class="token constant">Nothing</span> <span class="token operator">|</span> <span class="token constant">Just</span> <span class="token hvariable">a</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p><span alt="LYHfGG_49_yeti.png" src="LYHfGG_49_yeti.png" class="internal-embed media-embed image-embed is-loaded"><img alt="LYHfGG_49_yeti.png" src="курсы\learn-you-a-haskell-for-great-good!\картинки\lyhfgg_49_yeti.png"></span></p></div><div><p>The <code>a</code> here is the type parameter. And because there's a type parameter involved, we call <code>Maybe</code> a type constructor. Depending on what we want this data type to hold when it's not <code>Nothing</code>, this type constructor can end up producing a type of <code>Maybe Int</code>, <code>Maybe Car</code>, <code>Maybe String</code>, etc. No value can have a type of just <code>Maybe</code>, because that's not a type per se, it's a type constructor. In order for this to be a real type that a value can be part of, it has to have all its type parameters filled up.</p></div><div><p>So if we pass <code>Char</code> as the type parameter to <code>Maybe</code>, we get a type of <code>Maybe Char</code>. The value <code>Just 'a'</code> has a type of <code>Maybe Char</code>, for example.</p></div><div><p>You might not know it, but we used a type that has a type parameter before we used <code>Maybe</code>. That type is the list type. Although there's some syntactic sugar in play, the list type takes a parameter to produce a concrete type. Values can have an <code>[Int]</code> type, a <code>[Char]</code> type, a <code>[[String]]</code> type, but you can't have a value that just has a type of <code>[]</code>.</p></div><div><p>Let's play around with the <code>Maybe</code> type.</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token constant">Just</span> <span class="token string">"Haha"</span>
<span class="token constant">Just</span> <span class="token string">"Haha"</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token constant">Just</span> <span class="token number">84</span>
<span class="token constant">Just</span> <span class="token number">84</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token operator">:</span><span class="token hvariable">t</span> <span class="token constant">Just</span> <span class="token string">"Haha"</span>
<span class="token constant">Just</span> <span class="token string">"Haha"</span> <span class="token operator">::</span> <span class="token constant">Maybe</span> <span class="token punctuation">[</span><span class="token constant">Char</span><span class="token punctuation">]</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token operator">:</span><span class="token hvariable">t</span> <span class="token constant">Just</span> <span class="token number">84</span>
<span class="token constant">Just</span> <span class="token number">84</span> <span class="token operator">::</span> <span class="token punctuation">(</span><span class="token constant">Num</span> <span class="token hvariable">t</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token constant">Maybe</span> <span class="token hvariable">t</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token operator">:</span><span class="token hvariable">t</span> <span class="token constant">Nothing</span>
<span class="token constant">Nothing</span> <span class="token operator">::</span> <span class="token constant">Maybe</span> <span class="token hvariable">a</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token constant">Just</span> <span class="token number">10</span> <span class="token operator">::</span> <span class="token constant">Maybe</span> <span class="token constant">Double</span>
<span class="token constant">Just</span> <span class="token number">10.0</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Type parameters are useful because we can make different types with them depending on what kind of types we want contained in our data type. When we do <code>:t Just "Haha"</code>, the type inference engine figures it out to be of the type <code>Maybe [Char]</code>, because if the <code>a</code> in the <code>Just a</code> is a string, then the <code>a</code> in <code>Maybe a</code> must also be a string.</p></div><div><p>Notice that the type of <code>Nothing</code> is <code>Maybe a</code>. Its type is polymorphic. If some function requires a <code>Maybe Int</code> as a parameter, we can give it a <code>Nothing</code>, because a <code>Nothing</code> doesn't contain a value anyway and so it doesn't matter. The <code>Maybe a</code> type can act like a <code>Maybe Int</code> if it has to, just like <code>5</code> can act like an <code>Int</code> or a <code>Double</code>. Similarly, the type of the empty list is <code>[a]</code>. An empty list can act like a list of anything. That's why we can do <code>[1,2,3] ++ []</code> and <code>["ha","ha","ha"] ++ []</code>.</p></div><div><p>Using type parameters is very beneficial, but only when using them makes sense. Usually we use them when our data type would work regardless of the type of the value it then holds inside it, like with our <code>Maybe a</code> type. If our type acts as some kind of box, it's good to use them. We could change our <code>Car</code> data type from this:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token keyword">data</span> <span class="token constant">Car</span> <span class="token operator">=</span> <span class="token constant">Car</span> <span class="token punctuation">{</span> <span class="token hvariable">company</span> <span class="token operator">::</span> <span class="token constant">String</span>
               <span class="token punctuation">,</span> <span class="token hvariable">model</span> <span class="token operator">::</span> <span class="token constant">String</span>
               <span class="token punctuation">,</span> <span class="token hvariable">year</span> <span class="token operator">::</span> <span class="token constant">Int</span>
               <span class="token punctuation">}</span> <span class="token keyword">deriving</span> <span class="token punctuation">(</span><span class="token constant">Show</span><span class="token punctuation">)</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>To this:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token keyword">data</span> <span class="token constant">Car</span> <span class="token hvariable">a</span> <span class="token hvariable">b</span> <span class="token hvariable">c</span> <span class="token operator">=</span> <span class="token constant">Car</span> <span class="token punctuation">{</span> <span class="token hvariable">company</span> <span class="token operator">::</span> <span class="token hvariable">a</span>
                     <span class="token punctuation">,</span> <span class="token hvariable">model</span> <span class="token operator">::</span> <span class="token hvariable">b</span>
                     <span class="token punctuation">,</span> <span class="token hvariable">year</span> <span class="token operator">::</span> <span class="token hvariable">c</span> 
                     <span class="token punctuation">}</span> <span class="token keyword">deriving</span> <span class="token punctuation">(</span><span class="token constant">Show</span><span class="token punctuation">)</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>But would we really benefit? The answer is: probably no, because we'd just end up defining functions that only work on the <code>Car String String Int</code> type. For instance, given our first definition of <code>Car</code>, we could make a function that displays the car's properties in a nice little text.</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">tellCar</span> <span class="token operator">::</span> <span class="token constant">Car</span> <span class="token operator">-&gt;</span> <span class="token constant">String</span>
<span class="token hvariable">tellCar</span> <span class="token punctuation">(</span><span class="token constant">Car</span> <span class="token punctuation">{</span><span class="token hvariable">company</span> <span class="token operator">=</span> <span class="token hvariable">c</span><span class="token punctuation">,</span> <span class="token hvariable">model</span> <span class="token operator">=</span> <span class="token hvariable">m</span><span class="token punctuation">,</span> <span class="token hvariable">year</span> <span class="token operator">=</span> <span class="token hvariable">y</span><span class="token punctuation">}</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token string">"This "</span> <span class="token operator">++</span> <span class="token hvariable">c</span> <span class="token operator">++</span> <span class="token string">" "</span> <span class="token operator">++</span> <span class="token hvariable">m</span> <span class="token operator">++</span> <span class="token string">" was made in "</span> <span class="token operator">++</span> <span class="token builtin">show</span> <span class="token hvariable">y</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token keyword">let</span> <span class="token hvariable">stang</span> <span class="token operator">=</span> <span class="token constant">Car</span> <span class="token punctuation">{</span><span class="token hvariable">company</span><span class="token operator">=</span><span class="token string">"Ford"</span><span class="token punctuation">,</span> <span class="token hvariable">model</span><span class="token operator">=</span><span class="token string">"Mustang"</span><span class="token punctuation">,</span> <span class="token hvariable">year</span><span class="token operator">=</span><span class="token number">1967</span><span class="token punctuation">}</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token hvariable">tellCar</span> <span class="token hvariable">stang</span>
<span class="token string">"This Ford Mustang was made in 1967"</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>A cute little function! The type declaration is cute and it works nicely. Now what if <code>Car</code> was <code>Car a b c</code>?</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">tellCar</span> <span class="token operator">::</span> <span class="token punctuation">(</span><span class="token constant">Show</span> <span class="token hvariable">a</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token constant">Car</span> <span class="token constant">String</span> <span class="token constant">String</span> <span class="token hvariable">a</span> <span class="token operator">-&gt;</span> <span class="token constant">String</span>
<span class="token hvariable">tellCar</span> <span class="token punctuation">(</span><span class="token constant">Car</span> <span class="token punctuation">{</span><span class="token hvariable">company</span> <span class="token operator">=</span> <span class="token hvariable">c</span><span class="token punctuation">,</span> <span class="token hvariable">model</span> <span class="token operator">=</span> <span class="token hvariable">m</span><span class="token punctuation">,</span> <span class="token hvariable">year</span> <span class="token operator">=</span> <span class="token hvariable">y</span><span class="token punctuation">}</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token string">"This "</span> <span class="token operator">++</span> <span class="token hvariable">c</span> <span class="token operator">++</span> <span class="token string">" "</span> <span class="token operator">++</span> <span class="token hvariable">m</span> <span class="token operator">++</span> <span class="token string">" was made in "</span> <span class="token operator">++</span> <span class="token builtin">show</span> <span class="token hvariable">y</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>We'd have to force this function to take a <code>Car</code> type of <code>(Show a) =&gt; Car String String a</code>. You can see that the type signature is more complicated and the only benefit we'd actually get would be that we can use any type that's an instance of the <code>Show</code> typeclass as the type for <code>c</code>.</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token hvariable">tellCar</span> <span class="token punctuation">(</span><span class="token constant">Car</span> <span class="token string">"Ford"</span> <span class="token string">"Mustang"</span> <span class="token number">1967</span><span class="token punctuation">)</span>
<span class="token string">"This Ford Mustang was made in 1967"</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token hvariable">tellCar</span> <span class="token punctuation">(</span><span class="token constant">Car</span> <span class="token string">"Ford"</span> <span class="token string">"Mustang"</span> <span class="token string">"nineteen sixty seven"</span><span class="token punctuation">)</span>
<span class="token string">"This Ford Mustang was made in \"nineteen sixty seven\""</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token operator">:</span><span class="token hvariable">t</span> <span class="token constant">Car</span> <span class="token string">"Ford"</span> <span class="token string">"Mustang"</span> <span class="token number">1967</span>
<span class="token constant">Car</span> <span class="token string">"Ford"</span> <span class="token string">"Mustang"</span> <span class="token number">1967</span> <span class="token operator">::</span> <span class="token punctuation">(</span><span class="token constant">Num</span> <span class="token hvariable">t</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token constant">Car</span> <span class="token punctuation">[</span><span class="token constant">Char</span><span class="token punctuation">]</span> <span class="token punctuation">[</span><span class="token constant">Char</span><span class="token punctuation">]</span> <span class="token hvariable">t</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token operator">:</span><span class="token hvariable">t</span> <span class="token constant">Car</span> <span class="token string">"Ford"</span> <span class="token string">"Mustang"</span> <span class="token string">"nineteen sixty seven"</span>
<span class="token constant">Car</span> <span class="token string">"Ford"</span> <span class="token string">"Mustang"</span> <span class="token string">"nineteen sixty seven"</span> <span class="token operator">::</span> <span class="token constant">Car</span> <span class="token punctuation">[</span><span class="token constant">Char</span><span class="token punctuation">]</span> <span class="token punctuation">[</span><span class="token constant">Char</span><span class="token punctuation">]</span> <span class="token punctuation">[</span><span class="token constant">Char</span><span class="token punctuation">]</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p><span alt="LYHfGG_50_meekrat.png" src="LYHfGG_50_meekrat.png" class="internal-embed media-embed image-embed is-loaded"><img alt="LYHfGG_50_meekrat.png" src="курсы\learn-you-a-haskell-for-great-good!\картинки\lyhfgg_50_meekrat.png"></span></p></div><div><p>In real life though, we'd end up using <code>Car String String Int</code> most of the time and so it would seem that parameterizing the <code>Car</code> type isn't really worth it. We usually use type parameters when the type that's contained inside the data type's various value constructors isn't really that important for the type to work. A list of stuff is a list of stuff and it doesn't matter what the type of that stuff is, it can still work. If we want to sum a list of numbers, we can specify later in the summing function that we specifically want a list of numbers. Same goes for <code>Maybe</code>. <code>Maybe</code> represents an option of either having nothing or having one of something. It doesn't matter what the type of that something is.</p></div><div><p>Another example of a parameterized type that we've already met is <code>Map k v</code> from <code>Data.Map</code>. The <code>k</code> is the type of the keys in a map and the <code>v</code> is the type of the values. This is a good example of where type parameters are very useful. Having maps parameterized enables us to have mappings from any type to any other type, as long as the type of the key is part of the <code>Ord</code> typeclass. If we were defining a mapping type, we could add a typeclass constraint in the <em>data</em> declaration:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token keyword">data</span> <span class="token punctuation">(</span><span class="token constant">Ord</span> <span class="token hvariable">k</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token constant">Map</span> <span class="token hvariable">k</span> <span class="token hvariable">v</span> <span class="token operator">=</span> <span class="token operator">...</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>However, it's a very strong convention in Haskell to <strong>never add typeclass constraints in data declarations.</strong> Why? Well, because we don't benefit a lot, but we end up writing more class constraints, even when we don't need them. If we put or don't put the <code>Ord k</code> constraint in the <em>data</em> declaration for <code>Map k v</code>, we're going to have to put the constraint into functions that assume the keys in a map can be ordered. But if we don't put the constraint in the data declaration, we don't have to put <code>(Ord k) =&gt;</code> in the type declarations of functions that don't care whether the keys can be ordered or not. An example of such a function is <code>toList</code>, that just takes a mapping and converts it to an associative list. Its type signature is <code>toList :: Map k a -&gt; [(k, a)]</code>. If <code>Map k v</code> had a type constraint in its <em>data</em> declaration, the type for <code>toList</code> would have to be <code>toList :: (Ord k) =&gt; Map k a -&gt; [(k, a)]</code>, even though the function doesn't do any comparing of keys by order.</p></div><div><p>So don't put type constraints into <em>data</em> declarations even if it seems to make sense, because you'll have to put them into the function type declarations either way.</p></div><div><p>Let's implement a 3D vector type and add some operations for it. We'll be using a parameterized type because even though it will usually contain numeric types, it will still support several of them.</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token keyword">data</span> <span class="token constant">Vector</span> <span class="token hvariable">a</span> <span class="token operator">=</span> <span class="token constant">Vector</span> <span class="token hvariable">a</span> <span class="token hvariable">a</span> <span class="token hvariable">a</span> <span class="token keyword">deriving</span> <span class="token punctuation">(</span><span class="token constant">Show</span><span class="token punctuation">)</span>

<span class="token hvariable">vplus</span> <span class="token operator">::</span> <span class="token punctuation">(</span><span class="token constant">Num</span> <span class="token hvariable">t</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token constant">Vector</span> <span class="token hvariable">t</span> <span class="token operator">-&gt;</span> <span class="token constant">Vector</span> <span class="token hvariable">t</span> <span class="token operator">-&gt;</span> <span class="token constant">Vector</span> <span class="token hvariable">t</span>
<span class="token punctuation">(</span><span class="token constant">Vector</span> <span class="token hvariable">i</span> <span class="token hvariable">j</span> <span class="token hvariable">k</span><span class="token punctuation">)</span> <span class="token operator">`vplus`</span> <span class="token punctuation">(</span><span class="token constant">Vector</span> <span class="token hvariable">l</span> <span class="token hvariable">m</span> <span class="token hvariable">n</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token constant">Vector</span> <span class="token punctuation">(</span><span class="token hvariable">i</span><span class="token operator">+</span><span class="token hvariable">l</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token hvariable">j</span><span class="token operator">+</span><span class="token hvariable">m</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token hvariable">k</span><span class="token operator">+</span><span class="token hvariable">n</span><span class="token punctuation">)</span>

<span class="token hvariable">vectMult</span> <span class="token operator">::</span> <span class="token punctuation">(</span><span class="token constant">Num</span> <span class="token hvariable">t</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token constant">Vector</span> <span class="token hvariable">t</span> <span class="token operator">-&gt;</span> <span class="token hvariable">t</span> <span class="token operator">-&gt;</span> <span class="token constant">Vector</span> <span class="token hvariable">t</span>
<span class="token punctuation">(</span><span class="token constant">Vector</span> <span class="token hvariable">i</span> <span class="token hvariable">j</span> <span class="token hvariable">k</span><span class="token punctuation">)</span> <span class="token operator">`vectMult`</span> <span class="token hvariable">m</span> <span class="token operator">=</span> <span class="token constant">Vector</span> <span class="token punctuation">(</span><span class="token hvariable">i</span><span class="token operator">*</span><span class="token hvariable">m</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token hvariable">j</span><span class="token operator">*</span><span class="token hvariable">m</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token hvariable">k</span><span class="token operator">*</span><span class="token hvariable">m</span><span class="token punctuation">)</span>

<span class="token hvariable">scalarMult</span> <span class="token operator">::</span> <span class="token punctuation">(</span><span class="token constant">Num</span> <span class="token hvariable">t</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token constant">Vector</span> <span class="token hvariable">t</span> <span class="token operator">-&gt;</span> <span class="token constant">Vector</span> <span class="token hvariable">t</span> <span class="token operator">-&gt;</span> <span class="token hvariable">t</span>
<span class="token punctuation">(</span><span class="token constant">Vector</span> <span class="token hvariable">i</span> <span class="token hvariable">j</span> <span class="token hvariable">k</span><span class="token punctuation">)</span> <span class="token operator">`scalarMult`</span> <span class="token punctuation">(</span><span class="token constant">Vector</span> <span class="token hvariable">l</span> <span class="token hvariable">m</span> <span class="token hvariable">n</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token hvariable">i</span><span class="token operator">*</span><span class="token hvariable">l</span> <span class="token operator">+</span> <span class="token hvariable">j</span><span class="token operator">*</span><span class="token hvariable">m</span> <span class="token operator">+</span> <span class="token hvariable">k</span><span class="token operator">*</span><span class="token hvariable">n</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p><code>vplus</code> is for adding two vectors together. Two vectors are added just by adding their corresponding components. <code>scalarMult</code> is for the scalar product of two vectors and <code>vectMult</code> is for multiplying a vector with a scalar. These functions can operate on types of <code>Vector Int</code>, <code>Vector Integer</code>, <code>Vector Float</code>, whatever, as long as the <code>a</code> from <code>Vector a</code> is from the <code>Num</code> typeclass. Also, if you examine the type declaration for these functions, you'll see that they can operate only on vectors of the same type and the numbers involved must also be of the type that is contained in the vectors. Notice that we didn't put a <code>Num</code> class constraint in the <em>data</em> declaration, because we'd have to repeat it in the functions anyway.</p></div><div><p>Once again, it's very important to distinguish between the type constructor and the value constructor. When declaring a data type, the part before the <code>=</code> is the type constructor and the constructors after it (possibly separated by <code>|</code>'s) are value constructors. Giving a function a type of <code>Vector t t t -&gt; Vector t t t -&gt; t</code> would be wrong, because we have to put types in type declaration and the vector <strong>type</strong> constructor takes only one parameter, whereas the value constructor takes three. Let's play around with our vectors.</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token constant">Vector</span> <span class="token number">3</span> <span class="token number">5</span> <span class="token number">8</span> <span class="token operator">`vplus`</span> <span class="token constant">Vector</span> <span class="token number">9</span> <span class="token number">2</span> <span class="token number">8</span>
<span class="token constant">Vector</span> <span class="token number">12</span> <span class="token number">7</span> <span class="token number">16</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token constant">Vector</span> <span class="token number">3</span> <span class="token number">5</span> <span class="token number">8</span> <span class="token operator">`vplus`</span> <span class="token constant">Vector</span> <span class="token number">9</span> <span class="token number">2</span> <span class="token number">8</span> <span class="token operator">`vplus`</span> <span class="token constant">Vector</span> <span class="token number">0</span> <span class="token number">2</span> <span class="token number">3</span>
<span class="token constant">Vector</span> <span class="token number">12</span> <span class="token number">9</span> <span class="token number">19</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token constant">Vector</span> <span class="token number">3</span> <span class="token number">9</span> <span class="token number">7</span> <span class="token operator">`vectMult`</span> <span class="token number">10</span>
<span class="token constant">Vector</span> <span class="token number">30</span> <span class="token number">90</span> <span class="token number">70</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token constant">Vector</span> <span class="token number">4</span> <span class="token number">9</span> <span class="token number">5</span> <span class="token operator">`scalarMult`</span> <span class="token constant">Vector</span> <span class="token number">9.0</span> <span class="token number">2.0</span> <span class="token number">4.0</span>
<span class="token number">74.0</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token constant">Vector</span> <span class="token number">2</span> <span class="token number">9</span> <span class="token number">3</span> <span class="token operator">`vectMult`</span> <span class="token punctuation">(</span><span class="token constant">Vector</span> <span class="token number">4</span> <span class="token number">9</span> <span class="token number">5</span> <span class="token operator">`scalarMult`</span> <span class="token constant">Vector</span> <span class="token number">9</span> <span class="token number">2</span> <span class="token number">4</span><span class="token punctuation">)</span>
<span class="token constant">Vector</span> <span class="token number">148</span> <span class="token number">666</span> <span class="token number">222</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><h2 data-heading="Derived instances" id="Derived_instances" style="display: flex;"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>Derived instances</h2></div><div><p><span alt="LYHfGG_51_gob.png" src="LYHfGG_51_gob.png" class="internal-embed media-embed image-embed is-loaded"><img alt="LYHfGG_51_gob.png" src="курсы\learn-you-a-haskell-for-great-good!\картинки\lyhfgg_51_gob.png"></span></p></div><div><p>In the <a data-tooltip-position="top" aria-label="http://learnyouahaskell.com/types-and-typeclasses#typeclasses-101" rel="noopener" class="external-link" href="http://learnyouahaskell.com/types-and-typeclasses#typeclasses-101" target="_blank">Typeclasses 101</a> section, we explained the basics of typeclasses. We explained that a typeclass is a sort of an interface that defines some behavior. A type can be made an <strong>instance</strong> of a typeclass if it supports that behavior. Example: the <code>Int</code> type is an instance of the <code>Eq</code> typeclass because the <code>Eq</code> typeclass defines behavior for stuff that can be equated. And because integers can be equated, <code>Int</code> is a part of the <code>Eq</code> typeclass. The real usefulness comes with the functions that act as the interface for <code>Eq</code>, namely <code>==</code> and <code>/=</code>. If a type is a part of the <code>Eq</code> typeclass, we can use the <code>==</code> functions with values of that type. That's why expressions like <code>4 == 4</code> and <code>"foo" /= "bar"</code> typecheck.</p></div><div><p>We also mentioned that they're often confused with classes in languages like Java, Python, C++ and the like, which then baffles a lot of people. In those languages, classes are a blueprint from which we then create objects that contain state and can do some actions. Typeclasses are more like interfaces. We don't make data from typeclasses. Instead, we first make our data type and then we think about what it can act like. If it can act like something that can be equated, we make it an instance of the <code>Eq</code> typeclass. If it can act like something that can be ordered, we make it an instance of the <code>Ord</code> typeclass.</p></div><div><p>In the next section, we'll take a look at how we can manually make our types instances of typeclasses by implementing the functions defined by the typeclasses. But right now, let's see how Haskell can automatically make our type an instance of any of the following typeclasses: <code>Eq</code>, <code>Ord</code>, <code>Enum</code>, <code>Bounded</code>, <code>Show</code>, <code>Read</code>. Haskell can derive the behavior of our types in these contexts if we use the <em>deriving</em> keyword when making our data type.</p></div><div><p>Consider this data type:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token keyword">data</span> <span class="token constant">Person</span> <span class="token operator">=</span> <span class="token constant">Person</span> <span class="token punctuation">{</span> <span class="token hvariable">firstName</span> <span class="token operator">::</span> <span class="token constant">String</span>
                     <span class="token punctuation">,</span> <span class="token hvariable">lastName</span> <span class="token operator">::</span> <span class="token constant">String</span>
                     <span class="token punctuation">,</span> <span class="token hvariable">age</span> <span class="token operator">::</span> <span class="token constant">Int</span>
                     <span class="token punctuation">}</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>It describes a person. Let's assume that no two people have the same combination of first name, last name and age. Now, if we have records for two people, does it make sense to see if they represent the same person? Sure it does. We can try to equate them and see if they're equal or not. That's why it would make sense for this type to be part of the <code>Eq</code> typeclass. We'll derive the instance.</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token keyword">data</span> <span class="token constant">Person</span> <span class="token operator">=</span> <span class="token constant">Person</span> <span class="token punctuation">{</span> <span class="token hvariable">firstName</span> <span class="token operator">::</span> <span class="token constant">String</span>
                     <span class="token punctuation">,</span> <span class="token hvariable">lastName</span> <span class="token operator">::</span> <span class="token constant">String</span>
                     <span class="token punctuation">,</span> <span class="token hvariable">age</span> <span class="token operator">::</span> <span class="token constant">Int</span>
                     <span class="token punctuation">}</span> <span class="token keyword">deriving</span> <span class="token punctuation">(</span><span class="token constant">Eq</span><span class="token punctuation">)</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>When we derive the <code>Eq</code> instance for a type and then try to compare two values of that type with <code>==</code> or <code>/=</code>, Haskell will see if the value constructors match (there's only one value constructor here though) and then it will check if all the data contained inside matches by testing each pair of fields with <code>==</code>. There's only one catch though, the types of all the fields also have to be part of the <code>Eq</code> typeclass. But since both <code>String</code> and <code>Int</code> are, we're OK. Let's test our <code>Eq</code> instance.</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token keyword">let</span> <span class="token hvariable">mikeD</span> <span class="token operator">=</span> <span class="token constant">Person</span> <span class="token punctuation">{</span><span class="token hvariable">firstName</span> <span class="token operator">=</span> <span class="token string">"Michael"</span><span class="token punctuation">,</span> <span class="token hvariable">lastName</span> <span class="token operator">=</span> <span class="token string">"Diamond"</span><span class="token punctuation">,</span> <span class="token hvariable">age</span> <span class="token operator">=</span> <span class="token number">43</span><span class="token punctuation">}</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token keyword">let</span> <span class="token hvariable">adRock</span> <span class="token operator">=</span> <span class="token constant">Person</span> <span class="token punctuation">{</span><span class="token hvariable">firstName</span> <span class="token operator">=</span> <span class="token string">"Adam"</span><span class="token punctuation">,</span> <span class="token hvariable">lastName</span> <span class="token operator">=</span> <span class="token string">"Horovitz"</span><span class="token punctuation">,</span> <span class="token hvariable">age</span> <span class="token operator">=</span> <span class="token number">41</span><span class="token punctuation">}</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token keyword">let</span> <span class="token hvariable">mca</span> <span class="token operator">=</span> <span class="token constant">Person</span> <span class="token punctuation">{</span><span class="token hvariable">firstName</span> <span class="token operator">=</span> <span class="token string">"Adam"</span><span class="token punctuation">,</span> <span class="token hvariable">lastName</span> <span class="token operator">=</span> <span class="token string">"Yauch"</span><span class="token punctuation">,</span> <span class="token hvariable">age</span> <span class="token operator">=</span> <span class="token number">44</span><span class="token punctuation">}</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token hvariable">mca</span> <span class="token operator">==</span> <span class="token hvariable">adRock</span>
<span class="token constant">False</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token hvariable">mikeD</span> <span class="token operator">==</span> <span class="token hvariable">adRock</span>
<span class="token constant">False</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token hvariable">mikeD</span> <span class="token operator">==</span> <span class="token hvariable">mikeD</span>
<span class="token constant">True</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token hvariable">mikeD</span> <span class="token operator">==</span> <span class="token constant">Person</span> <span class="token punctuation">{</span><span class="token hvariable">firstName</span> <span class="token operator">=</span> <span class="token string">"Michael"</span><span class="token punctuation">,</span> <span class="token hvariable">lastName</span> <span class="token operator">=</span> <span class="token string">"Diamond"</span><span class="token punctuation">,</span> <span class="token hvariable">age</span> <span class="token operator">=</span> <span class="token number">43</span><span class="token punctuation">}</span>
<span class="token constant">True</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Of course, since <code>Person</code> is now in <code>Eq</code>, we can use it as the <code>a</code> for all functions that have a class constraint of <code>Eq a</code> in their type signature, such as <code>elem</code>.</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token keyword">let</span> <span class="token hvariable">beastieBoys</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token hvariable">mca</span><span class="token punctuation">,</span> <span class="token hvariable">adRock</span><span class="token punctuation">,</span> <span class="token hvariable">mikeD</span><span class="token punctuation">]</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token hvariable">mikeD</span> <span class="token operator">`elem`</span> <span class="token hvariable">beastieBoys</span>
<span class="token constant">True</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>The <code>Show</code> and <code>Read</code> typeclasses are for things that can be converted to or from strings, respectively. Like with <code>Eq</code>, if a type's constructors have fields, their type has to be a part of <code>Show</code> or <code>Read</code> if we want to make our type an instance of them. Let's make our <code>Person</code> data type a part of <code>Show</code> and <code>Read</code> as well.</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token keyword">data</span> <span class="token constant">Person</span> <span class="token operator">=</span> <span class="token constant">Person</span> <span class="token punctuation">{</span> <span class="token hvariable">firstName</span> <span class="token operator">::</span> <span class="token constant">String</span>
                     <span class="token punctuation">,</span> <span class="token hvariable">lastName</span> <span class="token operator">::</span> <span class="token constant">String</span>
                     <span class="token punctuation">,</span> <span class="token hvariable">age</span> <span class="token operator">::</span> <span class="token constant">Int</span>
                     <span class="token punctuation">}</span> <span class="token keyword">deriving</span> <span class="token punctuation">(</span><span class="token constant">Eq</span><span class="token punctuation">,</span> <span class="token constant">Show</span><span class="token punctuation">,</span> <span class="token constant">Read</span><span class="token punctuation">)</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Now we can print a person out to the terminal.</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token keyword">let</span> <span class="token hvariable">mikeD</span> <span class="token operator">=</span> <span class="token constant">Person</span> <span class="token punctuation">{</span><span class="token hvariable">firstName</span> <span class="token operator">=</span> <span class="token string">"Michael"</span><span class="token punctuation">,</span> <span class="token hvariable">lastName</span> <span class="token operator">=</span> <span class="token string">"Diamond"</span><span class="token punctuation">,</span> <span class="token hvariable">age</span> <span class="token operator">=</span> <span class="token number">43</span><span class="token punctuation">}</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token hvariable">mikeD</span>
<span class="token constant">Person</span> <span class="token punctuation">{</span><span class="token hvariable">firstName</span> <span class="token operator">=</span> <span class="token string">"Michael"</span><span class="token punctuation">,</span> <span class="token hvariable">lastName</span> <span class="token operator">=</span> <span class="token string">"Diamond"</span><span class="token punctuation">,</span> <span class="token hvariable">age</span> <span class="token operator">=</span> <span class="token number">43</span><span class="token punctuation">}</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token string">"mikeD is: "</span> <span class="token operator">++</span> <span class="token builtin">show</span> <span class="token hvariable">mikeD</span>
<span class="token string">"mikeD is: Person {firstName = \"Michael\", lastName = \"Diamond\", age = 43}"</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Had we tried to print a person on the terminal before making the <code>Person</code> data type part of <code>Show</code>, Haskell would have complained at us, claiming it doesn't know how to represent a person as a string. But now that we've derived a <code>Show</code> instance for it, it does know.</p></div><div><p><code>Read</code> is pretty much the inverse typeclass of <code>Show</code>. <code>Show</code> is for converting values of our a type to a string, <code>Read</code> is for converting strings to values of our type. Remember though, when we use the <code>read</code> function, we have to use an explicit type annotation to tell Haskell which type we want to get as a result. If we don't make the type we want as a result explicit, Haskell doesn't know which type we want.</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token builtin">read</span> <span class="token string">"Person {firstName =\"Michael\", lastName =\"Diamond\", age = 43}"</span> <span class="token operator">::</span> <span class="token constant">Person</span>
<span class="token constant">Person</span> <span class="token punctuation">{</span><span class="token hvariable">firstName</span> <span class="token operator">=</span> <span class="token string">"Michael"</span><span class="token punctuation">,</span> <span class="token hvariable">lastName</span> <span class="token operator">=</span> <span class="token string">"Diamond"</span><span class="token punctuation">,</span> <span class="token hvariable">age</span> <span class="token operator">=</span> <span class="token number">43</span><span class="token punctuation">}</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>If we use the result of our <code>read</code> later on in a way that Haskell can infer that it should read it as a person, we don't have to use type annotation.</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token builtin">read</span> <span class="token string">"Person {firstName =\"Michael\", lastName =\"Diamond\", age = 43}"</span> <span class="token operator">==</span> <span class="token hvariable">mikeD</span>
<span class="token constant">True</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>We can also read parameterized types, but we have to fill in the type parameters. So we can't do <code>read "Just 't'" :: Maybe a</code>, but we can do <code>read "Just 't'" :: Maybe Char</code>.</p></div><div><p>We can derive instances for the <code>Ord</code> type class, which is for types that have values that can be ordered. If we compare two values of the same type that were made using different constructors, the value which was made with a constructor that's defined first is considered smaller. For instance, consider the <code>Bool</code> type, which can have a value of either <code>False</code> or <code>True</code>. For the purpose of seeing how it behaves when compared, we can think of it as being implemented like this:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token keyword">data</span> <span class="token constant">Bool</span> <span class="token operator">=</span> <span class="token constant">False</span> <span class="token operator">|</span> <span class="token constant">True</span> <span class="token keyword">deriving</span> <span class="token punctuation">(</span><span class="token constant">Ord</span><span class="token punctuation">)</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Because the <code>False</code> value constructor is specified first and the <code>True</code> value constructor is specified after it, we can consider <code>True</code> as greater than <code>False</code>.</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token constant">True</span> <span class="token operator">`compare`</span> <span class="token constant">False</span>
<span class="token constant">GT</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token constant">True</span> <span class="token operator">&gt;</span> <span class="token constant">False</span>
<span class="token constant">True</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token constant">True</span> <span class="token operator">&lt;</span> <span class="token constant">False</span>
<span class="token constant">False</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>In the <code>Maybe a</code> data type, the <code>Nothing</code> value constructor is specified before the <code>Just</code> value constructor, so a value of <code>Nothing</code> is always smaller than a value of <code>Just something</code>, even if that something is minus one billion trillion. But if we compare two <code>Just</code> values, then it goes to compare what's inside them.</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token constant">Nothing</span> <span class="token operator">&lt;</span> <span class="token constant">Just</span> <span class="token number">100</span>
<span class="token constant">True</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token constant">Nothing</span> <span class="token operator">&gt;</span> <span class="token constant">Just</span> <span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">49999</span><span class="token punctuation">)</span>
<span class="token constant">False</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token constant">Just</span> <span class="token number">3</span> <span class="token operator">`compare`</span> <span class="token constant">Just</span> <span class="token number">2</span>
<span class="token constant">GT</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token constant">Just</span> <span class="token number">100</span> <span class="token operator">&gt;</span> <span class="token constant">Just</span> <span class="token number">50</span>
<span class="token constant">True</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>But we can't do something like <code>Just (*3) &gt; Just (*2)</code>, because <code>(*3)</code> and <code>(*2)</code> are functions, which aren't instances of <code>Ord</code>.</p></div><div><p>We can easily use algebraic data types to make enumerations and the <code>Enum</code> and <code>Bounded</code> typeclasses help us with that. Consider the following data type:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token keyword">data</span> <span class="token constant">Day</span> <span class="token operator">=</span> <span class="token constant">Monday</span> <span class="token operator">|</span> <span class="token constant">Tuesday</span> <span class="token operator">|</span> <span class="token constant">Wednesday</span> <span class="token operator">|</span> <span class="token constant">Thursday</span> <span class="token operator">|</span> <span class="token constant">Friday</span> <span class="token operator">|</span> <span class="token constant">Saturday</span> <span class="token operator">|</span> <span class="token constant">Sunday</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Because all the value constructors are nullary (take no parameters, i.e. fields), we can make it part of the <code>Enum</code> typeclass. The <code>Enum</code> typeclass is for things that have predecessors and successors. We can also make it part of the <code>Bounded</code> typeclass, which is for things that have a lowest possible value and highest possible value. And while we're at it, let's also make it an instance of all the other derivable typeclasses and see what we can do with it.</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token keyword">data</span> <span class="token constant">Day</span> <span class="token operator">=</span> <span class="token constant">Monday</span> <span class="token operator">|</span> <span class="token constant">Tuesday</span> <span class="token operator">|</span> <span class="token constant">Wednesday</span> <span class="token operator">|</span> <span class="token constant">Thursday</span> <span class="token operator">|</span> <span class="token constant">Friday</span> <span class="token operator">|</span> <span class="token constant">Saturday</span> <span class="token operator">|</span> <span class="token constant">Sunday</span> 
           <span class="token keyword">deriving</span> <span class="token punctuation">(</span><span class="token constant">Eq</span><span class="token punctuation">,</span> <span class="token constant">Ord</span><span class="token punctuation">,</span> <span class="token constant">Show</span><span class="token punctuation">,</span> <span class="token constant">Read</span><span class="token punctuation">,</span> <span class="token constant">Bounded</span><span class="token punctuation">,</span> <span class="token constant">Enum</span><span class="token punctuation">)</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Because it's part of the <code>Show</code> and <code>Read</code> typeclasses, we can convert values of this type to and from strings.</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token constant">Wednesday</span>
<span class="token constant">Wednesday</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token builtin">show</span> <span class="token constant">Wednesday</span>
<span class="token string">"Wednesday"</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token builtin">read</span> <span class="token string">"Saturday"</span> <span class="token operator">::</span> <span class="token constant">Day</span>
<span class="token constant">Saturday</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Because it's part of the <code>Eq</code> and <code>Ord</code> typeclasses, we can compare or equate days.</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token constant">Saturday</span> <span class="token operator">==</span> <span class="token constant">Sunday</span>
<span class="token constant">False</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token constant">Saturday</span> <span class="token operator">==</span> <span class="token constant">Saturday</span>
<span class="token constant">True</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token constant">Saturday</span> <span class="token operator">&gt;</span> <span class="token constant">Friday</span>
<span class="token constant">True</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token constant">Monday</span> <span class="token operator">`compare`</span> <span class="token constant">Wednesday</span>
<span class="token constant">LT</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>It's also part of <code>Bounded</code>, so we can get the lowest and highest day.</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token builtin">minBound</span> <span class="token operator">::</span> <span class="token constant">Day</span>
<span class="token constant">Monday</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token builtin">maxBound</span> <span class="token operator">::</span> <span class="token constant">Day</span>
<span class="token constant">Sunday</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>It's also an instance of <code>Enum</code>. We can get predecessors and successors of days and we can make list ranges from them!</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token builtin">succ</span> <span class="token constant">Monday</span>
<span class="token constant">Tuesday</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token builtin">pred</span> <span class="token constant">Saturday</span>
<span class="token constant">Friday</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token punctuation">[</span><span class="token constant">Thursday</span> <span class="token operator">..</span> <span class="token constant">Sunday</span><span class="token punctuation">]</span>
<span class="token punctuation">[</span><span class="token constant">Thursday</span><span class="token punctuation">,</span><span class="token constant">Friday</span><span class="token punctuation">,</span><span class="token constant">Saturday</span><span class="token punctuation">,</span><span class="token constant">Sunday</span><span class="token punctuation">]</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token punctuation">[</span><span class="token builtin">minBound</span> <span class="token operator">..</span> <span class="token builtin">maxBound</span><span class="token punctuation">]</span> <span class="token operator">::</span> <span class="token punctuation">[</span><span class="token constant">Day</span><span class="token punctuation">]</span>
<span class="token punctuation">[</span><span class="token constant">Monday</span><span class="token punctuation">,</span><span class="token constant">Tuesday</span><span class="token punctuation">,</span><span class="token constant">Wednesday</span><span class="token punctuation">,</span><span class="token constant">Thursday</span><span class="token punctuation">,</span><span class="token constant">Friday</span><span class="token punctuation">,</span><span class="token constant">Saturday</span><span class="token punctuation">,</span><span class="token constant">Sunday</span><span class="token punctuation">]</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>That's pretty awesome.</p></div><div><h2 data-heading="Type synonyms" id="Type_synonyms" style="display: flex;"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>Type synonyms</h2></div><div><p>Previously, we mentioned that when writing types, the <code>[Char]</code> and <code>String</code> types are equivalent and interchangeable. That's implemented with <strong>type synonyms</strong>. Type synonyms don't really do anything per se, they're just about giving some types different names so that they make more sense to someone reading our code and documentation. Here's how the standard library defines <code>String</code> as a synonym for <code>[Char]</code>.</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"> <span class="token keyword">type</span> <span class="token constant">String</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token constant">Char</span><span class="token punctuation">]</span>
 
</code><button class="copy-code-button">Копировать</button></pre></div><div><p><span alt="LYHfGG_52_chicken.png" src="LYHfGG_52_chicken.png" class="internal-embed media-embed image-embed is-loaded"><img alt="LYHfGG_52_chicken.png" src="курсы\learn-you-a-haskell-for-great-good!\картинки\lyhfgg_52_chicken.png"></span></p></div><div><p>We've introduced the <em>type</em> keyword. The keyword might be misleading to some, because we're not actually making anything new (we did that with the <em>data</em> keyword), but we're just making a synonym for an already existing type.</p></div><div><p>If we make a function that converts a string to uppercase and call it <code>toUpperString</code> or something, we can give it a type declaration of <code>toUpperString :: [Char] -&gt; [Char]</code> or <code>toUpperString :: String -&gt; String</code>. Both of these are essentially the same, only the latter is nicer to read.</p></div><div><p>When we were dealing with the <code>Data.Map</code> module, we first represented a phonebook with an association list before converting it into a map. As we've already found out, an association list is a list of key-value pairs. Let's look at a phonebook that we had.</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">phoneBook</span> <span class="token operator">::</span> <span class="token punctuation">[</span><span class="token punctuation">(</span><span class="token constant">String</span><span class="token punctuation">,</span><span class="token constant">String</span><span class="token punctuation">)</span><span class="token punctuation">]</span>
<span class="token hvariable">phoneBook</span> <span class="token operator">=</span>    
    <span class="token punctuation">[</span><span class="token punctuation">(</span><span class="token string">"betty"</span><span class="token punctuation">,</span><span class="token string">"555-2938"</span><span class="token punctuation">)</span>   
    <span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token string">"bonnie"</span><span class="token punctuation">,</span><span class="token string">"452-2928"</span><span class="token punctuation">)</span>   
    <span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token string">"patsy"</span><span class="token punctuation">,</span><span class="token string">"493-2928"</span><span class="token punctuation">)</span>   
    <span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token string">"lucille"</span><span class="token punctuation">,</span><span class="token string">"205-2928"</span><span class="token punctuation">)</span>   
    <span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token string">"wendy"</span><span class="token punctuation">,</span><span class="token string">"939-8282"</span><span class="token punctuation">)</span>   
    <span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token string">"penny"</span><span class="token punctuation">,</span><span class="token string">"853-2492"</span><span class="token punctuation">)</span>   
    <span class="token punctuation">]</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>We see that the type of <code>phoneBook</code> is <code>[(String,String)]</code>. That tells us that it's an association list that maps from strings to strings, but not much else. Let's make a type synonym to convey some more information in the type declaration.</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token keyword">type</span> <span class="token constant">PhoneBook</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">(</span><span class="token constant">String</span><span class="token punctuation">,</span><span class="token constant">String</span><span class="token punctuation">)</span><span class="token punctuation">]</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Now the type declaration for our phonebook can be <code>phoneBook :: PhoneBook</code>. Let's make a type synonym for <code>String</code> as well.</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token keyword">type</span> <span class="token constant">PhoneNumber</span> <span class="token operator">=</span> <span class="token constant">String</span>
<span class="token keyword">type</span> <span class="token constant">Name</span> <span class="token operator">=</span> <span class="token constant">String</span>
<span class="token keyword">type</span> <span class="token constant">PhoneBook</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">(</span><span class="token constant">Name</span><span class="token punctuation">,</span><span class="token constant">PhoneNumber</span><span class="token punctuation">)</span><span class="token punctuation">]</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Giving the <code>String</code> type synonyms is something that Haskell programmers do when they want to convey more information about what strings in their functions should be used as and what they represent.</p></div><div><p>So now, when we implement a function that takes a name and a number and sees if that name and number combination is in our phonebook, we can give it a very pretty and descriptive type declaration.</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">inPhoneBook</span> <span class="token operator">::</span> <span class="token constant">Name</span> <span class="token operator">-&gt;</span> <span class="token constant">PhoneNumber</span> <span class="token operator">-&gt;</span> <span class="token constant">PhoneBook</span> <span class="token operator">-&gt;</span> <span class="token constant">Bool</span>
<span class="token hvariable">inPhoneBook</span> <span class="token hvariable">name</span> <span class="token hvariable">pnumber</span> <span class="token hvariable">pbook</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token hvariable">name</span><span class="token punctuation">,</span><span class="token hvariable">pnumber</span><span class="token punctuation">)</span> <span class="token operator">`elem`</span> <span class="token hvariable">pbook</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>If we decided not to use type synonyms, our function would have a type of <code>String -&gt; String -&gt; [(String,String)] -&gt; Bool</code>. In this case, the type declaration that took advantage of type synonyms is easier to understand. However, you shouldn't go overboard with them. We introduce type synonyms either to describe what some existing type represents in our functions (and thus our type declarations become better documentation) or when something has a long-ish type that's repeated a lot (like <code>[(String,String)]</code>) but represents something more specific in the context of our functions.</p></div><div><p>Type synonyms can also be parameterized. If we want a type that represents an association list type but still want it to be general so it can use any type as the keys and values, we can do this:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token keyword">type</span> <span class="token constant">AssocList</span> <span class="token hvariable">k</span> <span class="token hvariable">v</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">(</span><span class="token hvariable">k</span><span class="token punctuation">,</span><span class="token hvariable">v</span><span class="token punctuation">)</span><span class="token punctuation">]</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Now, a function that gets the value by a key in an association list can have a type of <code>(Eq k) =&gt; k -&gt; AssocList k v -&gt; Maybe v</code>. <code>AssocList</code> is a type constructor that takes two types and produces a concrete type, like <code>AssocList Int String</code>, for instance.</p></div><div><blockquote>
<p><strong>Fonzie says:</strong> Aaay! When I talk about <em>concrete types</em> I mean like fully applied types like <code>Map Int String</code> or if we're dealin' with one of them polymorphic functions, <code>[a]</code> or <code>(Ord a) =&gt; Maybe a</code> and stuff. And like, sometimes me and the boys say that <code>Maybe</code> is a type, but we don't mean that, cause every idiot knows <code>Maybe</code> is a type constructor. When I apply an extra type to <code>Maybe</code>, like <code>Maybe String</code>, then I have a concrete type. You know, values can only have types that are concrete types! So in conclusion, live fast, love hard and don't let anybody else use your comb!</p>
</blockquote></div><div><p>Just like we can partially apply functions to get new functions, we can partially apply type parameters and get new type constructors from them. Just like we call a function with too few parameters to get back a new function, we can specify a type constructor with too few type parameters and get back a partially applied type constructor. If we wanted a type that represents a map (from <code>Data.Map</code>) from integers to something, we could either do this:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token keyword">type</span> <span class="token constant">IntMap</span> <span class="token hvariable">v</span> <span class="token operator">=</span> <span class="token constant">Map</span> <span class="token constant">Int</span> <span class="token hvariable">v</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Or we could do it like this:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token keyword">type</span> <span class="token constant">IntMap</span> <span class="token operator">=</span> <span class="token constant">Map</span> <span class="token constant">Int</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Either way, the <code>IntMap</code> type constructor takes one parameter and that is the type of what the integers will point to.</p></div><div><blockquote>
<p><strong>Oh yeah</strong>. If you're going to try and implement this, you'll probably going to do a qualified import of <code>Data.Map</code>. When you do a qualified import, type constructors also have to be preceeded with a module name. So you'd write <code>type IntMap = Map.Map Int</code>.</p>
</blockquote></div><div><p>Make sure that you really understand the distinction between type constructors and value constructors. Just because we made a type synonym called <code>IntMap</code> or <code>AssocList</code> doesn't mean that we can do stuff like <code>AssocList [(1,2),(4,5),(7,9)]</code>. All it means is that we can refer to its type by using different names. We can do <code>[(1,2),(3,5),(8,9)] :: AssocList Int Int</code>, which will make the numbers inside assume a type of <code>Int</code>, but we can still use that list as we would any normal list that has pairs of integers inside. Type synonyms (and types generally) can only be used in the type portion of Haskell. We're in Haskell's type portion whenever we're defining new types (so in <em>data</em> and <em>type</em> declarations) or when we're located after a <code>::</code>. The <code>::</code> is in type declarations or in type annotations.</p></div><div><p>Another cool data type that takes two types as its parameters is the <code>Either a b</code> type. This is roughly how it's defined:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token keyword">data</span> <span class="token constant">Either</span> <span class="token hvariable">a</span> <span class="token hvariable">b</span> <span class="token operator">=</span> <span class="token constant">Left</span> <span class="token hvariable">a</span> <span class="token operator">|</span> <span class="token constant">Right</span> <span class="token hvariable">b</span> <span class="token keyword">deriving</span> <span class="token punctuation">(</span><span class="token constant">Eq</span><span class="token punctuation">,</span> <span class="token constant">Ord</span><span class="token punctuation">,</span> <span class="token constant">Read</span><span class="token punctuation">,</span> <span class="token constant">Show</span><span class="token punctuation">)</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>It has two value constructors. If the <code>Left</code> is used, then its contents are of type <code>a</code> and if <code>Right</code> is used, then its contents are of type <code>b</code>. So we can use this type to encapsulate a value of one type or another and then when we get a value of type <code>Either a b</code>, we usually pattern match on both <code>Left</code> and <code>Right</code> and we different stuff based on which one of them it was.</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token constant">Right</span> <span class="token number">20</span>
<span class="token constant">Right</span> <span class="token number">20</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token constant">Left</span> <span class="token string">"w00t"</span>
<span class="token constant">Left</span> <span class="token string">"w00t"</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token operator">:</span><span class="token hvariable">t</span> <span class="token constant">Right</span> <span class="token char string">'a'</span>
<span class="token constant">Right</span> <span class="token char string">'a'</span> <span class="token operator">::</span> <span class="token constant">Either</span> <span class="token hvariable">a</span> <span class="token constant">Char</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token operator">:</span><span class="token hvariable">t</span> <span class="token constant">Left</span> <span class="token constant">True</span>
<span class="token constant">Left</span> <span class="token constant">True</span> <span class="token operator">::</span> <span class="token constant">Either</span> <span class="token constant">Bool</span> <span class="token hvariable">b</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>So far, we've seen that <code>Maybe a</code> was mostly used to represent the results of computations that could have either failed or not. But somtimes, <code>Maybe a</code> isn't good enough because <code>Nothing</code> doesn't really convey much information other than that something has failed. That's cool for functions that can fail in only one way or if we're just not interested in how and why they failed. A <code>Data.Map</code> lookup fails only if the key we were looking for wasn't in the map, so we know exactly what happened. However, when we're interested in how some function failed or why, we usually use the result type of <code>Either a b</code>, where <code>a</code> is some sort of type that can tell us something about the possible failure and <code>b</code> is the type of a successful computation. Hence, errors use the <code>Left</code> value constructor while results use <code>Right</code>.</p></div><div><p>An example: a high-school has lockers so that students have some place to put their Guns'n'Roses posters. Each locker has a code combination. When a student wants a new locker, they tell the locker supervisor which locker number they want and he gives them the code. However, if someone is already using that locker, he can't tell them the code for the locker and they have to pick a different one. We'll use a map from <code>Data.Map</code> to represent the lockers. It'll map from locker numbers to a pair of whether the locker is in use or not and the locker code.</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token import-statement"><span class="token keyword">import</span> <span class="token keyword">qualified</span> Data<span class="token punctuation">.</span>Map <span class="token keyword">as</span> Map</span>

<span class="token keyword">data</span> <span class="token constant">LockerState</span> <span class="token operator">=</span> <span class="token constant">Taken</span> <span class="token operator">|</span> <span class="token constant">Free</span> <span class="token keyword">deriving</span> <span class="token punctuation">(</span><span class="token constant">Show</span><span class="token punctuation">,</span> <span class="token constant">Eq</span><span class="token punctuation">)</span>

<span class="token keyword">type</span> <span class="token constant">Code</span> <span class="token operator">=</span> <span class="token constant">String</span>

<span class="token keyword">type</span> <span class="token constant">LockerMap</span> <span class="token operator">=</span> <span class="token constant">Map<span class="token punctuation">.</span>Map</span> <span class="token constant">Int</span> <span class="token punctuation">(</span><span class="token constant">LockerState</span><span class="token punctuation">,</span> <span class="token constant">Code</span><span class="token punctuation">)</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Simple stuff. We introduce a new data type to represent whether a locker is taken or free and we make a type synonym for the locker code. We also make a type synonym for the type that maps from integers to pairs of locker state and code. And now, we're going to make a function that searches for the code in a locker map. We're going to use an <code>Either String Code</code> type to represent our result, because our lookup can fail in two ways — the locker can be taken, in which case we can't tell the code or the locker number might not exist at all. If the lookup fails, we're just going to use a <code>String</code> to tell what's happened.</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">lockerLookup</span> <span class="token operator">::</span> <span class="token constant">Int</span> <span class="token operator">-&gt;</span> <span class="token constant">LockerMap</span> <span class="token operator">-&gt;</span> <span class="token constant">Either</span> <span class="token constant">String</span> <span class="token constant">Code</span>
<span class="token hvariable">lockerLookup</span> <span class="token hvariable">lockerNumber</span> <span class="token builtin">map</span> <span class="token operator">=</span> 
    <span class="token keyword">case</span> <span class="token constant">Map</span><span class="token punctuation">.</span><span class="token builtin">lookup</span> <span class="token hvariable">lockerNumber</span> <span class="token builtin">map</span> <span class="token keyword">of</span> 
        <span class="token constant">Nothing</span> <span class="token operator">-&gt;</span> <span class="token constant">Left</span> <span class="token operator">$</span> <span class="token string">"Locker number "</span> <span class="token operator">++</span> <span class="token builtin">show</span> <span class="token hvariable">lockerNumber</span> <span class="token operator">++</span> <span class="token string">" doesn't exist!"</span>
        <span class="token constant">Just</span> <span class="token punctuation">(</span><span class="token hvariable">state</span><span class="token punctuation">,</span> <span class="token hvariable">code</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token keyword">if</span> <span class="token hvariable">state</span> <span class="token operator">/=</span> <span class="token constant">Taken</span> 
                                <span class="token keyword">then</span> <span class="token constant">Right</span> <span class="token hvariable">code</span>
                                <span class="token keyword">else</span> <span class="token constant">Left</span> <span class="token operator">$</span> <span class="token string">"Locker "</span> <span class="token operator">++</span> <span class="token builtin">show</span> <span class="token hvariable">lockerNumber</span> <span class="token operator">++</span> <span class="token string">" is already taken!"</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>We do a normal lookup in the map. If we get a <code>Nothing</code>, we return a value of type <code>Left String</code>, saying that the locker doesn't exist at all. If we do find it, then we do an additional check to see if the locker is taken. If it is, return a <code>Left</code> saying that it's already taken. If it isn't, then return a value of type <code>Right Code</code>, in which we give the student the correct code for the locker. It's actually a <code>Right String</code>, but we introduced that type synonym to introduce some additional documentation into the type declaration. Here's an example map:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">lockers</span> <span class="token operator">::</span> <span class="token constant">LockerMap</span>
<span class="token hvariable">lockers</span> <span class="token operator">=</span> <span class="token hvariable">Map<span class="token punctuation">.</span>fromList</span> 
    <span class="token punctuation">[</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token constant">Taken</span><span class="token punctuation">,</span><span class="token string">"ZD39I"</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token number">101</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token constant">Free</span><span class="token punctuation">,</span><span class="token string">"JAH3I"</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token number">103</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token constant">Free</span><span class="token punctuation">,</span><span class="token string">"IQSA9"</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token number">105</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token constant">Free</span><span class="token punctuation">,</span><span class="token string">"QOTSA"</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token number">109</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token constant">Taken</span><span class="token punctuation">,</span><span class="token string">"893JJ"</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token number">110</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token constant">Taken</span><span class="token punctuation">,</span><span class="token string">"99292"</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token punctuation">]</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Now let's try looking up some locker codes.</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token hvariable">lockerLookup</span> <span class="token number">101</span> <span class="token hvariable">lockers</span>
<span class="token constant">Right</span> <span class="token string">"JAH3I"</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token hvariable">lockerLookup</span> <span class="token number">100</span> <span class="token hvariable">lockers</span>
<span class="token constant">Left</span> <span class="token string">"Locker 100 is already taken!"</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token hvariable">lockerLookup</span> <span class="token number">102</span> <span class="token hvariable">lockers</span>
<span class="token constant">Left</span> <span class="token string">"Locker number 102 doesn't exist!"</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token hvariable">lockerLookup</span> <span class="token number">110</span> <span class="token hvariable">lockers</span>
<span class="token constant">Left</span> <span class="token string">"Locker 110 is already taken!"</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token hvariable">lockerLookup</span> <span class="token number">105</span> <span class="token hvariable">lockers</span>
<span class="token constant">Right</span> <span class="token string">"QOTSA"</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>We could have used a <code>Maybe a</code> to represent the result but then we wouldn't know why we couldn't get the code. But now, we have information about the failure in our result type.</p></div><div><h2 data-heading="Recursive data structures" id="Recursive_data_structures" style="display: flex;"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>Recursive data structures</h2></div><div><p><span alt="LYHfGG_53_thefonz.png" src="LYHfGG_53_thefonz.png" class="internal-embed media-embed image-embed is-loaded"><img alt="LYHfGG_53_thefonz.png" src="курсы\learn-you-a-haskell-for-great-good!\картинки\lyhfgg_53_thefonz.png"></span></p></div><div><p>As we've seen, a constructor in an algebraic data type can have several (or none at all) fields and each field must be of some concrete type. With that in mind, we can make types whose constructors have fields that are of the same type! Using that, we can create recursive data types, where one value of some type contains values of that type, which in turn contain more values of the same type and so on.</p></div><div><p>Think about this list: <code>[5]</code>. That's just syntactic sugar for <code>5:[]</code>. On the left side of the <code>:</code>, there's a value and on the right side, there's a list. And in this case, it's an empty list. Now how about the list <code>[4,5]</code>? Well, that desugars to <code>4:(5:[])</code>. Looking at the first <code>:</code>, we see that it also has an element on its left side and a list (<code>5:[]</code>) on its right side. Same goes for a list like <code>3:(4:(5:6:[]))</code>, which could be written either like that or like <code>3:4:5:6:[]</code> (because <code>:</code> is right-associative) or <code>[3,4,5,6]</code>.</p></div><div><p>We could say that a list can be an empty list or it can be an element joined together with a <code>:</code> with another list (that can be either the empty list or not).</p></div><div><p>Let's use algebraic data types to implement our own list then!</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token keyword">data</span> <span class="token constant">List</span> <span class="token hvariable">a</span> <span class="token operator">=</span> <span class="token constant">Empty</span> <span class="token operator">|</span> <span class="token constant">Cons</span> <span class="token hvariable">a</span> <span class="token punctuation">(</span><span class="token constant">List</span> <span class="token hvariable">a</span><span class="token punctuation">)</span> <span class="token keyword">deriving</span> <span class="token punctuation">(</span><span class="token constant">Show</span><span class="token punctuation">,</span> <span class="token constant">Read</span><span class="token punctuation">,</span> <span class="token constant">Eq</span><span class="token punctuation">,</span> <span class="token constant">Ord</span><span class="token punctuation">)</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>This reads just like our definition of lists from one of the previous paragraphs. It's either an empty list or a combination of a head with some value and a list. If you're confused about this, you might find it easier to understand in record syntax.</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token keyword">data</span> <span class="token constant">List</span> <span class="token hvariable">a</span> <span class="token operator">=</span> <span class="token constant">Empty</span> <span class="token operator">|</span> <span class="token constant">Cons</span> <span class="token punctuation">{</span> <span class="token hvariable">listHead</span> <span class="token operator">::</span> <span class="token hvariable">a</span><span class="token punctuation">,</span> <span class="token hvariable">listTail</span> <span class="token operator">::</span> <span class="token constant">List</span> <span class="token hvariable">a</span><span class="token punctuation">}</span> <span class="token keyword">deriving</span> <span class="token punctuation">(</span><span class="token constant">Show</span><span class="token punctuation">,</span> <span class="token constant">Read</span><span class="token punctuation">,</span> <span class="token constant">Eq</span><span class="token punctuation">,</span> <span class="token constant">Ord</span><span class="token punctuation">)</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>You might also be confused about the <code>Cons</code> constructor here. <em>cons</em> is another word for <code>:</code>. You see, in lists, <code>:</code> is actually a constructor that takes a value and another list and returns a list. We can already use our new list type! In other words, it has two fields. One field is of the type of <code>a</code> and the other is of the type <code>[a]</code>.</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token constant">Empty</span>
<span class="token constant">Empty</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token number">5</span> `<span class="token constant">Cons</span>` <span class="token constant">Empty</span>
<span class="token constant">Cons</span> <span class="token number">5</span> <span class="token constant">Empty</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token number">4</span> `<span class="token constant">Cons</span>` <span class="token punctuation">(</span><span class="token number">5</span> `<span class="token constant">Cons</span>` <span class="token constant">Empty</span><span class="token punctuation">)</span>
<span class="token constant">Cons</span> <span class="token number">4</span> <span class="token punctuation">(</span><span class="token constant">Cons</span> <span class="token number">5</span> <span class="token constant">Empty</span><span class="token punctuation">)</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token number">3</span> `<span class="token constant">Cons</span>` <span class="token punctuation">(</span><span class="token number">4</span> `<span class="token constant">Cons</span>` <span class="token punctuation">(</span><span class="token number">5</span> `<span class="token constant">Cons</span>` <span class="token constant">Empty</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token constant">Cons</span> <span class="token number">3</span> <span class="token punctuation">(</span><span class="token constant">Cons</span> <span class="token number">4</span> <span class="token punctuation">(</span><span class="token constant">Cons</span> <span class="token number">5</span> <span class="token constant">Empty</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>We called our <code>Cons</code> constructor in an infix manner so you can see how it's just like <code>:</code>. <code>Empty</code> is like <code>[]</code> and <code>4 `Cons` (5 `Cons` Empty)</code> is like <code>4:(5:[])</code>.</p></div><div><p>We can define functions to be automatically infix by making them comprised of only special characters. We can also do the same with constructors, since they're just functions that return a data type. So check this out.</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token keyword">infixr</span> <span class="token number">5</span> <span class="token operator">:-:</span>
<span class="token keyword">data</span> <span class="token constant">List</span> <span class="token hvariable">a</span> <span class="token operator">=</span> <span class="token constant">Empty</span> <span class="token operator">|</span> <span class="token hvariable">a</span> <span class="token operator">:-:</span> <span class="token punctuation">(</span><span class="token constant">List</span> <span class="token hvariable">a</span><span class="token punctuation">)</span> <span class="token keyword">deriving</span> <span class="token punctuation">(</span><span class="token constant">Show</span><span class="token punctuation">,</span> <span class="token constant">Read</span><span class="token punctuation">,</span> <span class="token constant">Eq</span><span class="token punctuation">,</span> <span class="token constant">Ord</span><span class="token punctuation">)</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>First off, we notice a new syntactic construct, the fixity declarations. When we define functions as operators, we can use that to give them a fixity (but we don't have to). A fixity states how tightly the operator binds and whether it's left-associative or right-associative. For instance, <code>*</code>'s fixity is <code>infixl 7 *</code> and <code>+</code>'s fixity is <code>infixl 6</code>. That means that they're both left-associative (<code>4 * 3 * 2</code> is <code>(4 * 3) * 2</code>) but <code>*</code> binds tighter than <code>+</code>, because it has a greater fixity, so <code>5 * 4 + 3</code> is <code>(5 * 4) + 3</code>.</p></div><div><p>Otherwise, we just wrote <code>a :-: (List a)</code> instead of <code>Cons a (List a)</code>. Now, we can write out lists in our list type like so:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token number">3</span> <span class="token operator">:-:</span> <span class="token number">4</span> <span class="token operator">:-:</span> <span class="token number">5</span> <span class="token operator">:-:</span> <span class="token constant">Empty</span>
<span class="token punctuation">(</span><span class="token operator">:-:</span><span class="token punctuation">)</span> <span class="token number">3</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token operator">:-:</span><span class="token punctuation">)</span> <span class="token number">4</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token operator">:-:</span><span class="token punctuation">)</span> <span class="token number">5</span> <span class="token constant">Empty</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token keyword">let</span> <span class="token hvariable">a</span> <span class="token operator">=</span> <span class="token number">3</span> <span class="token operator">:-:</span> <span class="token number">4</span> <span class="token operator">:-:</span> <span class="token number">5</span> <span class="token operator">:-:</span> <span class="token constant">Empty</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token number">100</span> <span class="token operator">:-:</span> <span class="token hvariable">a</span>
<span class="token punctuation">(</span><span class="token operator">:-:</span><span class="token punctuation">)</span> <span class="token number">100</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token operator">:-:</span><span class="token punctuation">)</span> <span class="token number">3</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token operator">:-:</span><span class="token punctuation">)</span> <span class="token number">4</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token operator">:-:</span><span class="token punctuation">)</span> <span class="token number">5</span> <span class="token constant">Empty</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>When deriving <code>Show</code> for our type, Haskell will still display it as if the constructor was a prefix function, hence the parentheses around the operator (remember, <code>4 + 3</code> is <code>(+) 4 3</code>).</p></div><div><p>Let's make a function that adds two of our lists together. This is how <code>++</code> is defined for normal lists:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token keyword">infixr</span> <span class="token number">5</span>  <span class="token operator">++</span>
<span class="token punctuation">(</span><span class="token operator">++</span><span class="token punctuation">)</span> <span class="token operator">::</span> <span class="token punctuation">[</span><span class="token hvariable">a</span><span class="token punctuation">]</span> <span class="token operator">-&gt;</span> <span class="token punctuation">[</span><span class="token hvariable">a</span><span class="token punctuation">]</span> <span class="token operator">-&gt;</span> <span class="token punctuation">[</span><span class="token hvariable">a</span><span class="token punctuation">]</span>
<span class="token punctuation">[</span><span class="token punctuation">]</span>     <span class="token operator">++</span> <span class="token hvariable">ys</span> <span class="token operator">=</span> <span class="token hvariable">ys</span>
<span class="token punctuation">(</span><span class="token hvariable">x</span><span class="token operator">:</span><span class="token hvariable">xs</span><span class="token punctuation">)</span> <span class="token operator">++</span> <span class="token hvariable">ys</span> <span class="token operator">=</span> <span class="token hvariable">x</span> <span class="token operator">:</span> <span class="token punctuation">(</span><span class="token hvariable">xs</span> <span class="token operator">++</span> <span class="token hvariable">ys</span><span class="token punctuation">)</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>So we'll just steal that for our own list. We'll name the function <code>.++</code>.</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token keyword">infixr</span> <span class="token number">5</span>  <span class="token operator">.++</span>
<span class="token punctuation">(</span><span class="token operator">.++</span><span class="token punctuation">)</span> <span class="token operator">::</span> <span class="token constant">List</span> <span class="token hvariable">a</span> <span class="token operator">-&gt;</span> <span class="token constant">List</span> <span class="token hvariable">a</span> <span class="token operator">-&gt;</span> <span class="token constant">List</span> <span class="token hvariable">a</span> 
<span class="token constant">Empty</span> <span class="token operator">.++</span> <span class="token hvariable">ys</span> <span class="token operator">=</span> <span class="token hvariable">ys</span>
<span class="token punctuation">(</span><span class="token hvariable">x</span> <span class="token operator">:-:</span> <span class="token hvariable">xs</span><span class="token punctuation">)</span> <span class="token operator">.++</span> <span class="token hvariable">ys</span> <span class="token operator">=</span> <span class="token hvariable">x</span> <span class="token operator">:-:</span> <span class="token punctuation">(</span><span class="token hvariable">xs</span> <span class="token operator">.++</span> <span class="token hvariable">ys</span><span class="token punctuation">)</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>And let's see if it works ...</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token keyword">let</span> <span class="token hvariable">a</span> <span class="token operator">=</span> <span class="token number">3</span> <span class="token operator">:-:</span> <span class="token number">4</span> <span class="token operator">:-:</span> <span class="token number">5</span> <span class="token operator">:-:</span> <span class="token constant">Empty</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token keyword">let</span> <span class="token hvariable">b</span> <span class="token operator">=</span> <span class="token number">6</span> <span class="token operator">:-:</span> <span class="token number">7</span> <span class="token operator">:-:</span> <span class="token constant">Empty</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token hvariable">a</span> <span class="token operator">.++</span> <span class="token hvariable">b</span>
<span class="token punctuation">(</span><span class="token operator">:-:</span><span class="token punctuation">)</span> <span class="token number">3</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token operator">:-:</span><span class="token punctuation">)</span> <span class="token number">4</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token operator">:-:</span><span class="token punctuation">)</span> <span class="token number">5</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token operator">:-:</span><span class="token punctuation">)</span> <span class="token number">6</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token operator">:-:</span><span class="token punctuation">)</span> <span class="token number">7</span> <span class="token constant">Empty</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Nice. Is nice. If we wanted, we could implement all of the functions that operate on lists on our own list type.</p></div><div><p>Notice how we pattern matched on <code>(x :-: xs)</code>. That works because pattern matching is actually about matching constructors. We can match on <code>:-:</code> because it is a constructor for our own list type and we can also match on <code>:</code> because it is a constructor for the built-in list type. Same goes for <code>[]</code>. Because pattern matching works (only) on constructors, we can match for stuff like that, normal prefix constructors or stuff like <code>8</code> or <code>'a'</code>, which are basically constructors for the numeric and character types, respectively.</p></div><div><p><span alt="LYHfGG_54_binarytree.png" src="LYHfGG_54_binarytree.png" class="internal-embed media-embed image-embed is-loaded"><img alt="LYHfGG_54_binarytree.png" src="курсы\learn-you-a-haskell-for-great-good!\картинки\lyhfgg_54_binarytree.png"></span></p></div><div><p>Now, we're going to implement a <strong>binary search tree</strong>. If you're not familiar with binary search trees from languages like C, here's what they are: an element points to two elements, one on its left and one on its right. The element to the left is smaller, the element to the right is bigger. Each of those elements can also point to two elements (or one, or none). In effect, each element has up to two sub-trees. And a cool thing about binary search trees is that we know that all the elements at the left sub-tree of, say, 5 are going to be smaller than 5. Elements in its right sub-tree are going to be bigger. So if we need to find if 8 is in our tree, we'd start at 5 and then because 8 is greater than 5, we'd go right. We're now at 7 and because 8 is greater than 7, we go right again. And we've found our element in three hops! Now if this were a normal list (or a tree, but really unbalanced), it would take us seven hops instead of three to see if 8 is in there.</p></div><div><p>Sets and maps from <code>Data.Set</code> and <code>Data.Map</code> are implemented using trees, only instead of normal binary search trees, they use balanced binary search trees, which are always balanced. But right now, we'll just be implementing normal binary search trees.</p></div><div><p>Here's what we're going to say: a tree is either an empty tree or it's an element that contains some value and two trees. Sounds like a perfect fit for an algebraic data type!</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token keyword">data</span> <span class="token constant">Tree</span> <span class="token hvariable">a</span> <span class="token operator">=</span> <span class="token constant">EmptyTree</span> <span class="token operator">|</span> <span class="token constant">Node</span> <span class="token hvariable">a</span> <span class="token punctuation">(</span><span class="token constant">Tree</span> <span class="token hvariable">a</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token constant">Tree</span> <span class="token hvariable">a</span><span class="token punctuation">)</span> <span class="token keyword">deriving</span> <span class="token punctuation">(</span><span class="token constant">Show</span><span class="token punctuation">,</span> <span class="token constant">Read</span><span class="token punctuation">,</span> <span class="token constant">Eq</span><span class="token punctuation">)</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Okay, good, this is good. Instead of manually building a tree, we're going to make a function that takes a tree and an element and inserts an element. We do this by comparing the value we want to insert to the root node and then if it's smaller, we go left, if it's larger, we go right. We do the same for every subsequent node until we reach an empty tree. Once we've reached an empty tree, we just insert a node with that value instead of the empty tree.</p></div><div><p>In languages like C, we'd do this by modifying the pointers and values inside the tree. In Haskell, we can't really modify our tree, so we have to make a new sub-tree each time we decide to go left or right and in the end the insertion function returns a completely new tree, because Haskell doesn't really have a concept of pointer, just values. Hence, the type for our insertion function is going to be something like <code>a -&gt; Tree a - &gt; Tree a</code>. It takes an element and a tree and returns a new tree that has that element inside. This might seem like it's inefficient but laziness takes care of that problem.</p></div><div><p>So, here are two functions. One is a utility function for making a singleton tree (a tree with just one node) and a function to insert an element into a tree.</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">singleton</span> <span class="token operator">::</span> <span class="token hvariable">a</span> <span class="token operator">-&gt;</span> <span class="token constant">Tree</span> <span class="token hvariable">a</span>
<span class="token hvariable">singleton</span> <span class="token hvariable">x</span> <span class="token operator">=</span> <span class="token constant">Node</span> <span class="token hvariable">x</span> <span class="token constant">EmptyTree</span> <span class="token constant">EmptyTree</span>

<span class="token hvariable">treeInsert</span> <span class="token operator">::</span> <span class="token punctuation">(</span><span class="token constant">Ord</span> <span class="token hvariable">a</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token hvariable">a</span> <span class="token operator">-&gt;</span> <span class="token constant">Tree</span> <span class="token hvariable">a</span> <span class="token operator">-&gt;</span> <span class="token constant">Tree</span> <span class="token hvariable">a</span>
<span class="token hvariable">treeInsert</span> <span class="token hvariable">x</span> <span class="token constant">EmptyTree</span> <span class="token operator">=</span> <span class="token hvariable">singleton</span> <span class="token hvariable">x</span>
<span class="token hvariable">treeInsert</span> <span class="token hvariable">x</span> <span class="token punctuation">(</span><span class="token constant">Node</span> <span class="token hvariable">a</span> <span class="token hvariable">left</span> <span class="token hvariable">right</span><span class="token punctuation">)</span> 
    <span class="token operator">|</span> <span class="token hvariable">x</span> <span class="token operator">==</span> <span class="token hvariable">a</span> <span class="token operator">=</span> <span class="token constant">Node</span> <span class="token hvariable">x</span> <span class="token hvariable">left</span> <span class="token hvariable">right</span>
    <span class="token operator">|</span> <span class="token hvariable">x</span> <span class="token operator">&lt;</span> <span class="token hvariable">a</span>  <span class="token operator">=</span> <span class="token constant">Node</span> <span class="token hvariable">a</span> <span class="token punctuation">(</span><span class="token hvariable">treeInsert</span> <span class="token hvariable">x</span> <span class="token hvariable">left</span><span class="token punctuation">)</span> <span class="token hvariable">right</span>
    <span class="token operator">|</span> <span class="token hvariable">x</span> <span class="token operator">&gt;</span> <span class="token hvariable">a</span>  <span class="token operator">=</span> <span class="token constant">Node</span> <span class="token hvariable">a</span> <span class="token hvariable">left</span> <span class="token punctuation">(</span><span class="token hvariable">treeInsert</span> <span class="token hvariable">x</span> <span class="token hvariable">right</span><span class="token punctuation">)</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>The <code>singleton</code> function is just a shortcut for making a node that has something and then two empty sub-trees. In the insertion function, we first have the edge condition as a pattern. If we've reached an empty sub-tree, that means we're where we want and instead of the empty tree, we put a singleton tree with our element. If we're not inserting into an empty tree, then we have to check some things. First off, if the element we're inserting is equal to the root element, just return a tree that's the same. If it's smaller, return a tree that has the same root value, the same right sub-tree but instead of its left sub-tree, put a tree that has our value inserted into it. Same (but the other way around) goes if our value is bigger than the root element.</p></div><div><p>Next up, we're going to make a function that checks if some element is in the tree. First, let's define the edge condition. If we're looking for an element in an empty tree, then it's certainly not there. Okay. Notice how this is the same as the edge condition when searching for elements in lists. If we're looking for an element in an empty list, it's not there. Anyway, if we're not looking for an element in an empty tree, then we check some things. If the element in the root node is what we're looking for, great! If it's not, what then? Well, we can take advantage of knowing that all the left elements are smaller than the root node. So if the element we're looking for is smaller than the root node, check to see if it's in the left sub-tree. If it's bigger, check to see if it's in the right sub-tree.</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">treeElem</span> <span class="token operator">::</span> <span class="token punctuation">(</span><span class="token constant">Ord</span> <span class="token hvariable">a</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token hvariable">a</span> <span class="token operator">-&gt;</span> <span class="token constant">Tree</span> <span class="token hvariable">a</span> <span class="token operator">-&gt;</span> <span class="token constant">Bool</span>
<span class="token hvariable">treeElem</span> <span class="token hvariable">x</span> <span class="token constant">EmptyTree</span> <span class="token operator">=</span> <span class="token constant">False</span>
<span class="token hvariable">treeElem</span> <span class="token hvariable">x</span> <span class="token punctuation">(</span><span class="token constant">Node</span> <span class="token hvariable">a</span> <span class="token hvariable">left</span> <span class="token hvariable">right</span><span class="token punctuation">)</span>
    <span class="token operator">|</span> <span class="token hvariable">x</span> <span class="token operator">==</span> <span class="token hvariable">a</span> <span class="token operator">=</span> <span class="token constant">True</span>
    <span class="token operator">|</span> <span class="token hvariable">x</span> <span class="token operator">&lt;</span> <span class="token hvariable">a</span>  <span class="token operator">=</span> <span class="token hvariable">treeElem</span> <span class="token hvariable">x</span> <span class="token hvariable">left</span>
    <span class="token operator">|</span> <span class="token hvariable">x</span> <span class="token operator">&gt;</span> <span class="token hvariable">a</span>  <span class="token operator">=</span> <span class="token hvariable">treeElem</span> <span class="token hvariable">x</span> <span class="token hvariable">right</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>All we had to do was write up the previous paragraph in code. Let's have some fun with our trees! Instead of manually building one (although we could), we'll use a fold to build up a tree from a list. Remember, pretty much everything that traverses a list one by one and then returns some sort of value can be implemented with a fold! We're going to start with the empty tree and then approach a list from the right and just insert element after element into our accumulator tree.</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token keyword">let</span> <span class="token hvariable">nums</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">8</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">7</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">]</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token keyword">let</span> <span class="token hvariable">numsTree</span> <span class="token operator">=</span> <span class="token builtin">foldr</span> <span class="token hvariable">treeInsert</span> <span class="token constant">EmptyTree</span> <span class="token hvariable">nums</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token hvariable">numsTree</span>
<span class="token constant">Node</span> <span class="token number">5</span> <span class="token punctuation">(</span><span class="token constant">Node</span> <span class="token number">3</span> <span class="token punctuation">(</span><span class="token constant">Node</span> <span class="token number">1</span> <span class="token constant">EmptyTree</span> <span class="token constant">EmptyTree</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token constant">Node</span> <span class="token number">4</span> <span class="token constant">EmptyTree</span> <span class="token constant">EmptyTree</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token constant">Node</span> <span class="token number">7</span> <span class="token punctuation">(</span><span class="token constant">Node</span> <span class="token number">6</span> <span class="token constant">EmptyTree</span> <span class="token constant">EmptyTree</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token constant">Node</span> <span class="token number">8</span> <span class="token constant">EmptyTree</span> <span class="token constant">EmptyTree</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>In that <code>foldr</code>, <code>treeInsert</code> was the folding function (it takes a tree and a list element and produces a new tree) and <code>EmptyTree</code> was the starting accumulator. <code>nums</code>, of course, was the list we were folding over.</p></div><div><p>When we print our tree to the console, it's not very readable, but if we try, we can make out its structure. We see that the root node is 5 and then it has two sub-trees, one of which has the root node of 3 and the other a 7, etc.</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token number">8</span> <span class="token operator">`treeElem`</span> <span class="token hvariable">numsTree</span>
<span class="token constant">True</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token number">100</span> <span class="token operator">`treeElem`</span> <span class="token hvariable">numsTree</span>
<span class="token constant">False</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token number">1</span> <span class="token operator">`treeElem`</span> <span class="token hvariable">numsTree</span>
<span class="token constant">True</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token number">10</span> <span class="token operator">`treeElem`</span> <span class="token hvariable">numsTree</span>
<span class="token constant">False</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Checking for membership also works nicely. Cool.</p></div><div><p>So as you can see, algebraic data structures are a really cool and powerful concept in Haskell. We can use them to make anything from boolean values and weekday enumerations to binary search trees and more!</p></div><div><h2 data-heading="Typeclasses 102" id="Typeclasses_102" style="display: flex;"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>Typeclasses 102</h2></div><div><p><span alt="LYHfGG_55_trafficlight.png" src="LYHfGG_55_trafficlight.png" class="internal-embed media-embed image-embed is-loaded"><img alt="LYHfGG_55_trafficlight.png" src="курсы\learn-you-a-haskell-for-great-good!\картинки\lyhfgg_55_trafficlight.png"></span></p></div><div><p>So far, we've learned about some of the standard Haskell typeclasses and we've seen which types are in them. We've also learned how to automatically make our own types instances of the standard typeclasses by asking Haskell to derive the instances for us. In this section, we're going to learn how to make our own typeclasses and how to make types instances of them by hand.</p></div><div><p>A quick recap on typeclasses: typeclasses are like interfaces. A typeclass defines some behavior (like comparing for equality, comparing for ordering, enumeration) and then types that can behave in that way are made instances of that typeclass. The behavior of typeclasses is achieved by defining functions or just type declarations that we then implement. So when we say that a type is an instance of a typeclass, we mean that we can use the functions that the typeclass defines with that type.</p></div><div><p>Typeclasses have pretty much nothing to do with classes in languages like Java or Python. This confuses many people, so I want you to forget everything you know about classes in imperative languages right now.</p></div><div><p>For example, the <code>Eq</code> typeclass is for stuff that can be equated. It defines the functions <code>==</code> and <code>/=</code>. If we have a type (say, <code>Car</code>) and comparing two cars with the equality function <code>==</code> makes sense, then it makes sense for <code>Car</code> to be an instance of <code>Eq</code>.</p></div><div><p>This is how the <code>Eq</code> class is defined in the standard prelude:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token keyword">class</span> <span class="token constant">Eq</span> <span class="token hvariable">a</span> <span class="token keyword">where</span>
    <span class="token punctuation">(</span><span class="token operator">==</span><span class="token punctuation">)</span> <span class="token operator">::</span> <span class="token hvariable">a</span> <span class="token operator">-&gt;</span> <span class="token hvariable">a</span> <span class="token operator">-&gt;</span> <span class="token constant">Bool</span>
    <span class="token punctuation">(</span><span class="token operator">/=</span><span class="token punctuation">)</span> <span class="token operator">::</span> <span class="token hvariable">a</span> <span class="token operator">-&gt;</span> <span class="token hvariable">a</span> <span class="token operator">-&gt;</span> <span class="token constant">Bool</span>
    <span class="token hvariable">x</span> <span class="token operator">==</span> <span class="token hvariable">y</span> <span class="token operator">=</span> <span class="token builtin">not</span> <span class="token punctuation">(</span><span class="token hvariable">x</span> <span class="token operator">/=</span> <span class="token hvariable">y</span><span class="token punctuation">)</span>
    <span class="token hvariable">x</span> <span class="token operator">/=</span> <span class="token hvariable">y</span> <span class="token operator">=</span> <span class="token builtin">not</span> <span class="token punctuation">(</span><span class="token hvariable">x</span> <span class="token operator">==</span> <span class="token hvariable">y</span><span class="token punctuation">)</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Woah, woah, woah! Some new strange syntax and keywords there! Don't worry, this will all be clear in a second. First off, when we write <code>class Eq a where</code>, this means that we're defining a new typeclass and that's called <code>Eq</code>. The <code>a</code> is the type variable and it means that <code>a</code> will play the role of the type that we will soon be making an instance of <code>Eq</code>. It doesn't have to be called <code>a</code>, it doesn't even have to be one letter, it just has to be a lowercase word. Then, we define several functions. It's not mandatory to implement the function bodies themselves, we just have to specify the type declarations for the functions.</p></div><div><blockquote>
<p>Some people might understand this better if we wrote <code>class Eq equatable where</code> and then specified the type declarations like <code>(==) :: equatable -&gt; equatable -&gt; Bool</code>.</p>
</blockquote></div><div><p>Anyway, we <em>did</em> implement the function bodies for the functions that <code>Eq</code> defines, only we defined them in terms of mutual recursion. We said that two instances of <code>Eq</code> are equal if they are not different and they are different if they are not equal. We didn't have to do this, really, but we did and we'll see how this helps us soon.</p></div><div><blockquote>
<p>If we have say <code>class Eq a where</code> and then define a type declaration within that class like <code>(==) :: a -&gt; -a -&gt; Bool</code>, then when we examine the type of that function later on, it will have the type of <code>(Eq a) =&gt; a -&gt; a -&gt; Bool</code>.</p>
</blockquote></div><div><p>So once we have a class, what can we do with it? Well, not much, really. But once we start making types instances of that class, we start getting some nice functionality. So check out this type:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token keyword">data</span> <span class="token constant">TrafficLight</span> <span class="token operator">=</span> <span class="token constant">Red</span> <span class="token operator">|</span> <span class="token constant">Yellow</span> <span class="token operator">|</span> <span class="token constant">Green</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>It defines the states of a traffic light. Notice how we didn't derive any class instances for it. That's because we're going to write up some instances by hand, even though we could derive them for types like <code>Eq</code> and <code>Show</code>. Here's how we make it an instance of <code>Eq</code>.</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token keyword">instance</span> <span class="token constant">Eq</span> <span class="token constant">TrafficLight</span> <span class="token keyword">where</span>
    <span class="token constant">Red</span> <span class="token operator">==</span> <span class="token constant">Red</span> <span class="token operator">=</span> <span class="token constant">True</span>
    <span class="token constant">Green</span> <span class="token operator">==</span> <span class="token constant">Green</span> <span class="token operator">=</span> <span class="token constant">True</span>
    <span class="token constant">Yellow</span> <span class="token operator">==</span> <span class="token constant">Yellow</span> <span class="token operator">=</span> <span class="token constant">True</span>
    <span class="token hvariable">_</span> <span class="token operator">==</span> <span class="token hvariable">_</span> <span class="token operator">=</span> <span class="token constant">False</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>We did it by using the <em>instance</em> keyword. So <em>class</em> is for defining new typeclasses and <em>instance</em> is for making our types instances of typeclasses. When we were defining <code>Eq</code>, we wrote <code>class Eq a where</code> and we said that <code>a</code> plays the role of whichever type will be made an instance later on. We can see that clearly here, because when we're making an instance, we write <code>instance Eq TrafficLight where</code>. We replace the <code>a</code> with the actual type.</p></div><div><p>Because <code>==</code> was defined in terms of <code>/=</code> and vice versa in the <em>class</em> declaration, we only had to overwrite one of them in the instance declaration. That's called the minimal complete definition for the typeclass — the minimum of functions that we have to implement so that our type can behave like the class advertises. To fulfill the minimal complete definition for <code>Eq</code>, we have to overwrite either one of <code>==</code> or <code>/=</code>. If <code>Eq</code> was defined simply like this:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token keyword">class</span> <span class="token constant">Eq</span> <span class="token hvariable">a</span> <span class="token keyword">where</span>
    <span class="token punctuation">(</span><span class="token operator">==</span><span class="token punctuation">)</span> <span class="token operator">::</span> <span class="token hvariable">a</span> <span class="token operator">-&gt;</span> <span class="token hvariable">a</span> <span class="token operator">-&gt;</span> <span class="token constant">Bool</span>
    <span class="token punctuation">(</span><span class="token operator">/=</span><span class="token punctuation">)</span> <span class="token operator">::</span> <span class="token hvariable">a</span> <span class="token operator">-&gt;</span> <span class="token hvariable">a</span> <span class="token operator">-&gt;</span> <span class="token constant">Bool</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>we'd have to implement both of these functions when making a type an instance of it, because Haskell wouldn't know how these two functions are related. The minimal complete definition would then be: both <code>==</code> and <code>/=</code>.</p></div><div><p>You can see that we implemented <code>==</code> simply by doing pattern matching. Since there are many more cases where two lights aren't equal, we specified the ones that are equal and then just did a catch-all pattern saying that if it's none of the previous combinations, then two lights aren't equal.</p></div><div><p>Let's make this an instance of <code>Show</code> by hand, too. To satisfy the minimal complete definition for <code>Show</code>, we just have to implement its <code>show</code> function, which takes a value and turns it into a string.</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token keyword">instance</span> <span class="token constant">Show</span> <span class="token constant">TrafficLight</span> <span class="token keyword">where</span>
    <span class="token builtin">show</span> <span class="token constant">Red</span> <span class="token operator">=</span> <span class="token string">"Red light"</span>
    <span class="token builtin">show</span> <span class="token constant">Yellow</span> <span class="token operator">=</span> <span class="token string">"Yellow light"</span>
    <span class="token builtin">show</span> <span class="token constant">Green</span> <span class="token operator">=</span> <span class="token string">"Green light"</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Once again, we used pattern matching to achieve our goals. Let's see how it works in action:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token constant">Red</span> <span class="token operator">==</span> <span class="token constant">Red</span>
<span class="token constant">True</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token constant">Red</span> <span class="token operator">==</span> <span class="token constant">Yellow</span>
<span class="token constant">False</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token constant">Red</span> <span class="token operator">`elem`</span> <span class="token punctuation">[</span><span class="token constant">Red</span><span class="token punctuation">,</span> <span class="token constant">Yellow</span><span class="token punctuation">,</span> <span class="token constant">Green</span><span class="token punctuation">]</span>
<span class="token constant">True</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token punctuation">[</span><span class="token constant">Red</span><span class="token punctuation">,</span> <span class="token constant">Yellow</span><span class="token punctuation">,</span> <span class="token constant">Green</span><span class="token punctuation">]</span>
<span class="token punctuation">[</span><span class="token constant">Red</span> <span class="token hvariable">light</span><span class="token punctuation">,</span><span class="token constant">Yellow</span> <span class="token hvariable">light</span><span class="token punctuation">,</span><span class="token constant">Green</span> <span class="token hvariable">light</span><span class="token punctuation">]</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Nice. We could have just derived <code>Eq</code> and it would have had the same effect (but we didn't for educational purposes). However, deriving <code>Show</code> would have just directly translated the value constructors to strings. But if we want lights to appear like <code>"Red light"</code>, then we have to make the instance declaration by hand.</p></div><div><p>You can also make typeclasses that are subclasses of other typeclasses. The <em>class</em> declaration for <code>Num</code> is a bit long, but here's the first part:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token keyword">class</span> <span class="token punctuation">(</span><span class="token constant">Eq</span> <span class="token hvariable">a</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token constant">Num</span> <span class="token hvariable">a</span> <span class="token keyword">where</span>
   <span class="token operator">...</span>  
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>As we mentioned previously, there are a lot of places where we can cram in class constraints. So this is just like writing <code>class Num a where</code>, only we state that our type <code>a</code> must be an instance of <code>Eq</code>. We're essentially saying that we have to make a type an instance of <code>Eq</code> before we can make it an instance of <code>Num</code>. Before some type can be considered a number, it makes sense that we can determine whether values of that type can be equated or not. That's all there is to subclassing really, it's just a class constraint on a <em>class</em> declaration! When defining function bodies in the <em>class</em> declaration or when defining them in <em>instance</em> declarations, we can assume that <code>a</code> is a part of <code>Eq</code> and so we can use <code>==</code> on values of that type.</p></div><div><p>But how are the <code>Maybe</code> or list types made as instances of typeclasses? What makes <code>Maybe</code> different from, say, <code>TrafficLight</code> is that <code>Maybe</code> in itself isn't a concrete type, it's a type constructor that takes one type parameter (like <code>Char</code> or something) to produce a concrete type (like <code>Maybe Char</code>). Let's take a look at the <code>Eq</code> typeclass again:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token keyword">class</span> <span class="token constant">Eq</span> <span class="token hvariable">a</span> <span class="token keyword">where</span>
    <span class="token punctuation">(</span><span class="token operator">==</span><span class="token punctuation">)</span> <span class="token operator">::</span> <span class="token hvariable">a</span> <span class="token operator">-&gt;</span> <span class="token hvariable">a</span> <span class="token operator">-&gt;</span> <span class="token constant">Bool</span>
    <span class="token punctuation">(</span><span class="token operator">/=</span><span class="token punctuation">)</span> <span class="token operator">::</span> <span class="token hvariable">a</span> <span class="token operator">-&gt;</span> <span class="token hvariable">a</span> <span class="token operator">-&gt;</span> <span class="token constant">Bool</span>
    <span class="token hvariable">x</span> <span class="token operator">==</span> <span class="token hvariable">y</span> <span class="token operator">=</span> <span class="token builtin">not</span> <span class="token punctuation">(</span><span class="token hvariable">x</span> <span class="token operator">/=</span> <span class="token hvariable">y</span><span class="token punctuation">)</span>
    <span class="token hvariable">x</span> <span class="token operator">/=</span> <span class="token hvariable">y</span> <span class="token operator">=</span> <span class="token builtin">not</span> <span class="token punctuation">(</span><span class="token hvariable">x</span> <span class="token operator">==</span> <span class="token hvariable">y</span><span class="token punctuation">)</span> 
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>From the type declarations, we see that the <code>a</code> is used as a concrete type because all the types in functions have to be concrete (remember, you can't have a function of the type <code>a -&gt; Maybe</code> but you can have a function of <code>a -&gt; Maybe a</code> or <code>Maybe Int -&gt; Maybe String</code>). That's why we can't do something like</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token keyword">instance</span> <span class="token constant">Eq</span> <span class="token constant">Maybe</span> <span class="token keyword">where</span>
    <span class="token operator">...</span>  
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Because like we've seen, the <code>a</code> has to be a concrete type but <code>Maybe</code> isn't a concrete type. It's a type constructor that takes one parameter and then produces a concrete type. It would also be tedious to write <code>instance Eq (Maybe Int) where</code>, <code>instance Eq (Maybe Char) where</code>, etc. for every type ever. So we could write it out like so:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token keyword">instance</span> <span class="token constant">Eq</span> <span class="token punctuation">(</span><span class="token constant">Maybe</span> <span class="token hvariable">m</span><span class="token punctuation">)</span> <span class="token keyword">where</span>
    <span class="token constant">Just</span> <span class="token hvariable">x</span> <span class="token operator">==</span> <span class="token constant">Just</span> <span class="token hvariable">y</span> <span class="token operator">=</span> <span class="token hvariable">x</span> <span class="token operator">==</span> <span class="token hvariable">y</span>
    <span class="token constant">Nothing</span> <span class="token operator">==</span> <span class="token constant">Nothing</span> <span class="token operator">=</span> <span class="token constant">True</span>
    <span class="token hvariable">_</span> <span class="token operator">==</span> <span class="token hvariable">_</span> <span class="token operator">=</span> <span class="token constant">False</span>
      
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>This is like saying that we want to make all types of the form <code>Maybe something</code> an instance of <code>Eq</code>. We actually could have written <code>(Maybe something)</code>, but we usually opt for single letters to be true to the Haskell style. The <code>(Maybe m)</code> here plays the role of the <code>a</code> from <code>class Eq a where</code>. While <code>Maybe</code> isn't a concrete type, <code>Maybe m</code> is. By specifying a type parameter (<code>m</code>, which is in lowercase), we said that we want all types that are in the form of <code>Maybe m</code>, where <code>m</code> is any type, to be an instance of <code>Eq</code>.</p></div><div><p>There's one problem with this though. Can you spot it? We use <code>==</code> on the contents of the <code>Maybe</code> but we have no assurance that what the <code>Maybe</code> contains can be used with <code>Eq</code>! That's why we have to modify our <em>instance</em> declaration like this:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token keyword">instance</span> <span class="token punctuation">(</span><span class="token constant">Eq</span> <span class="token hvariable">m</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token constant">Eq</span> <span class="token punctuation">(</span><span class="token constant">Maybe</span> <span class="token hvariable">m</span><span class="token punctuation">)</span> <span class="token keyword">where</span>
    <span class="token constant">Just</span> <span class="token hvariable">x</span> <span class="token operator">==</span> <span class="token constant">Just</span> <span class="token hvariable">y</span> <span class="token operator">=</span> <span class="token hvariable">x</span> <span class="token operator">==</span> <span class="token hvariable">y</span>
    <span class="token constant">Nothing</span> <span class="token operator">==</span> <span class="token constant">Nothing</span> <span class="token operator">=</span> <span class="token constant">True</span>
    <span class="token hvariable">_</span> <span class="token operator">==</span> <span class="token hvariable">_</span> <span class="token operator">=</span> <span class="token constant">False</span>
      
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>We had to add a class constraint! With this <em>instance</em> declaration, we say this: we want all types of the form <code>Maybe m</code> to be part of the <code>Eq</code> typeclass, but only those types where the <code>m</code> (so what's contained inside the <code>Maybe</code>) is also a part of <code>Eq</code>. This is actually how Haskell would derive the instance too.</p></div><div><p>Most of the times, class constraints in <em>class</em> declarations are used for making a typeclass a subclass of another typeclass and class constraints in <em>instance</em> declarations are used to express requirements about the contents of some type. For instance, here we required the contents of the <code>Maybe</code> to also be part of the <code>Eq</code> typeclass.</p></div><div><p>When making instances, if you see that a type is used as a concrete type in the type declarations (like the <code>a</code> in <code>a -&gt; a -&gt; Bool</code>), you have to supply type parameters and add parentheses so that you end up with a concrete type.</p></div><div><blockquote>
<p>Take into account that the type you're trying to make an instance of will replace the parameter in the <em>class</em> declaration. The <code>a</code> from <code>class Eq a where</code> will be replaced with a real type when you make an instance, so try mentally putting your type into the function type declarations as well. <code>(==) :: Maybe -&gt; Maybe -&gt; Bool</code> doesn't make much sense but <code>(==) :: (Eq m) =&gt; Maybe m -&gt; Maybe m -&gt; Bool</code> does. But this is just something to think about, because <code>==</code> will always have a type of <code>(==) :: (Eq a) =&gt; a -&gt; a -&gt; Bool</code>, no matter what instances we make.</p>
</blockquote></div><div><p>Ooh, one more thing, check this out! If you want to see what the instances of a typeclass are, just do <code>:info YourTypeClass</code> in GHCI. So typing <code>:info Num</code> will show which functions the typeclass defines and it will give you a list of the types in the typeclass. <code>:info</code> works for types and type constructors too. If you do <code>:info Maybe</code>, it will show you all the typeclasses that <code>Maybe</code> is an instance of. Also <code>:info</code> can show you the type declaration of a function. I think that's pretty cool.</p></div><div><h2 data-heading="A yes-no typeclass" id="A_yes-no_typeclass" style="display: flex;"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>A yes-no typeclass</h2></div><div><p><span alt="LYHfGG_56_yesno.png" src="LYHfGG_56_yesno.png" class="internal-embed media-embed image-embed is-loaded"><img alt="LYHfGG_56_yesno.png" src="курсы\learn-you-a-haskell-for-great-good!\картинки\lyhfgg_56_yesno.png"></span></p></div><div><p>In JavaScript and some other weakly typed languages, you can put almost anything inside an if expression. For example, you can do all of the following: <code>if (0) alert("YEAH!") else alert("NO!")</code>, <code>if ("") alert ("YEAH!") else alert("NO!")</code>, <code>if (false) alert("YEAH") else alert("NO!)</code>, etc. and all of these will throw an alert of <code>NO!</code>. If you do <code>if ("WHAT") alert ("YEAH") else alert("NO!")</code>, it will alert a <code>"YEAH!"</code> because JavaScript considers non-empty strings to be a sort of true-ish value.</p></div><div><p>Even though strictly using <code>Bool</code> for boolean semantics works better in Haskell, let's try and implement that JavaScript-ish behavior anyway. For fun! Let's start out with a <em>class</em> declaration.</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token keyword">class</span> <span class="token constant">YesNo</span> <span class="token hvariable">a</span> <span class="token keyword">where</span>
    <span class="token hvariable">yesno</span> <span class="token operator">::</span> <span class="token hvariable">a</span> <span class="token operator">-&gt;</span> <span class="token constant">Bool</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Pretty simple. The <code>YesNo</code> typeclass defines one function. That function takes one value of a type that can be considered to hold some concept of true-ness and tells us for sure if it's true or not. Notice that from the way we use the <code>a</code> in the function, <code>a</code> has to be a concrete type.</p></div><div><p>Next up, let's define some instances. For numbers, we'll assume that (like in JavaScript) any number that isn't 0 is true-ish and 0 is false-ish.</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token keyword">instance</span> <span class="token constant">YesNo</span> <span class="token constant">Int</span> <span class="token keyword">where</span>
    <span class="token hvariable">yesno</span> <span class="token number">0</span> <span class="token operator">=</span> <span class="token constant">False</span>
    <span class="token hvariable">yesno</span> <span class="token hvariable">_</span> <span class="token operator">=</span> <span class="token constant">True</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Empty lists (and by extensions, strings) are a no-ish value, while non-empty lists are a yes-ish value.</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token keyword">instance</span> <span class="token constant">YesNo</span> <span class="token punctuation">[</span><span class="token hvariable">a</span><span class="token punctuation">]</span> <span class="token keyword">where</span>
    <span class="token hvariable">yesno</span> <span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token constant">False</span>
    <span class="token hvariable">yesno</span> <span class="token hvariable">_</span> <span class="token operator">=</span> <span class="token constant">True</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Notice how we just put in a type parameter <code>a</code> in there to make the list a concrete type, even though we don't make any assumptions about the type that's contained in the list. What else, hmm ... I know, <code>Bool</code> itself also holds true-ness and false-ness and it's pretty obvious which is which.</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token keyword">instance</span> <span class="token constant">YesNo</span> <span class="token constant">Bool</span> <span class="token keyword">where</span>
    <span class="token hvariable">yesno</span> <span class="token operator">=</span> <span class="token builtin">id</span>   
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Huh? What's <code>id</code>? It's just a standard library function that takes a parameter and returns the same thing, which is what we would be writing here anyway.</p></div><div><p>Let's make <code>Maybe a</code> an instance too.</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token keyword">instance</span> <span class="token constant">YesNo</span> <span class="token punctuation">(</span><span class="token constant">Maybe</span> <span class="token hvariable">a</span><span class="token punctuation">)</span> <span class="token keyword">where</span>
    <span class="token hvariable">yesno</span> <span class="token punctuation">(</span><span class="token constant">Just</span> <span class="token hvariable">_</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token constant">True</span>
    <span class="token hvariable">yesno</span> <span class="token constant">Nothing</span> <span class="token operator">=</span> <span class="token constant">False</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>We didn't need a class constraint because we made no assumptions about the contents of the <code>Maybe</code>. We just said that it's true-ish if it's a <code>Just</code> value and false-ish if it's a <code>Nothing</code>. We still had to write out <code>(Maybe a)</code> instead of just <code>Maybe</code> because if you think about it, a <code>Maybe -&gt; Bool</code> function can't exist (because <code>Maybe</code> isn't a concrete type), whereas a <code>Maybe a -&gt; Bool</code> is fine and dandy. Still, this is really cool because now, any type of the form <code>Maybe something</code> is part of <code>YesNo</code> and it doesn't matter what that <code>something</code> is.</p></div><div><p>Previously, we defined a <code>Tree a</code> type, that represented a binary search tree. We can say an empty tree is false-ish and anything that's not an empty tree is true-ish.</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token keyword">instance</span> <span class="token constant">YesNo</span> <span class="token punctuation">(</span><span class="token constant">Tree</span> <span class="token hvariable">a</span><span class="token punctuation">)</span> <span class="token keyword">where</span>
    <span class="token hvariable">yesno</span> <span class="token constant">EmptyTree</span> <span class="token operator">=</span> <span class="token constant">False</span>
    <span class="token hvariable">yesno</span> <span class="token hvariable">_</span> <span class="token operator">=</span> <span class="token constant">True</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Can a traffic light be a yes or no value? Sure. If it's red, you stop. If it's green, you go. If it's yellow? Eh, I usually run the yellows because I live for adrenaline.</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token keyword">instance</span> <span class="token constant">YesNo</span> <span class="token constant">TrafficLight</span> <span class="token keyword">where</span>
    <span class="token hvariable">yesno</span> <span class="token constant">Red</span> <span class="token operator">=</span> <span class="token constant">False</span>
    <span class="token hvariable">yesno</span> <span class="token hvariable">_</span> <span class="token operator">=</span> <span class="token constant">True</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Cool, now that we have some instances, let's go play!</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token hvariable">yesno</span> <span class="token operator">$</span> <span class="token builtin">length</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
<span class="token constant">False</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token hvariable">yesno</span> <span class="token string">"haha"</span>
<span class="token constant">True</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token hvariable">yesno</span> <span class="token string">""</span>
<span class="token constant">False</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token hvariable">yesno</span> <span class="token operator">$</span> <span class="token constant">Just</span> <span class="token number">0</span>
<span class="token constant">True</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token hvariable">yesno</span> <span class="token constant">True</span>
<span class="token constant">True</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token hvariable">yesno</span> <span class="token constant">EmptyTree</span>
<span class="token constant">False</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token hvariable">yesno</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
<span class="token constant">False</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token hvariable">yesno</span> <span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">]</span>
<span class="token constant">True</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token operator">:</span><span class="token hvariable">t</span> <span class="token hvariable">yesno</span>
<span class="token hvariable">yesno</span> <span class="token operator">::</span> <span class="token punctuation">(</span><span class="token constant">YesNo</span> <span class="token hvariable">a</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token hvariable">a</span> <span class="token operator">-&gt;</span> <span class="token constant">Bool</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Right, it works! Let's make a function that mimics the if statement, but it works with <code>YesNo</code> values.</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">yesnoIf</span> <span class="token operator">::</span> <span class="token punctuation">(</span><span class="token constant">YesNo</span> <span class="token hvariable">y</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token hvariable">y</span> <span class="token operator">-&gt;</span> <span class="token hvariable">a</span> <span class="token operator">-&gt;</span> <span class="token hvariable">a</span> <span class="token operator">-&gt;</span> <span class="token hvariable">a</span>
<span class="token hvariable">yesnoIf</span> <span class="token hvariable">yesnoVal</span> <span class="token hvariable">yesResult</span> <span class="token hvariable">noResult</span> <span class="token operator">=</span> <span class="token keyword">if</span> <span class="token hvariable">yesno</span> <span class="token hvariable">yesnoVal</span> <span class="token keyword">then</span> <span class="token hvariable">yesResult</span> <span class="token keyword">else</span> <span class="token hvariable">noResult</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Pretty straightforward. It takes a yes-no-ish value and two things. If the yes-no-ish value is more of a yes, it returns the first of the two things, otherwise it returns the second of them.</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token hvariable">yesnoIf</span> <span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token string">"YEAH!"</span> <span class="token string">"NO!"</span>
<span class="token string">"NO!"</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token hvariable">yesnoIf</span> <span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">]</span> <span class="token string">"YEAH!"</span> <span class="token string">"NO!"</span>
<span class="token string">"YEAH!"</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token hvariable">yesnoIf</span> <span class="token constant">True</span> <span class="token string">"YEAH!"</span> <span class="token string">"NO!"</span>
<span class="token string">"YEAH!"</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token hvariable">yesnoIf</span> <span class="token punctuation">(</span><span class="token constant">Just</span> <span class="token number">500</span><span class="token punctuation">)</span> <span class="token string">"YEAH!"</span> <span class="token string">"NO!"</span>
<span class="token string">"YEAH!"</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token hvariable">yesnoIf</span> <span class="token constant">Nothing</span> <span class="token string">"YEAH!"</span> <span class="token string">"NO!"</span>
<span class="token string">"NO!"</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><h2 data-heading="The Functor typeclass" id="The_Functor_typeclass" style="display: flex;"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>The Functor typeclass</h2></div><div><p>So far, we've encountered a lot of the typeclasses in the standard library. We've played with <code>Ord</code>, which is for stuff that can be ordered. We've palled around with <code>Eq</code>, which is for things that can be equated. We've seen <code>Show</code>, which presents an interface for types whose values can be displayed as strings. Our good friend <code>Read</code> is there whenever we need to convert a string to a value of some type. And now, we're going to take a look at the <code>Functor</code> typeclass, which is basically for things that can be mapped over. You're probably thinking about lists now, since mapping over lists is such a dominant idiom in Haskell. And you're right, the list type is part of the <code>Functor</code> typeclass.</p></div><div><p>What better way to get to know the <code>Functor</code> typeclass than to see how it's implemented? Let's take a peek.</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token keyword">class</span> <span class="token constant">Functor</span> <span class="token hvariable">f</span> <span class="token keyword">where</span>
    <span class="token builtin">fmap</span> <span class="token operator">::</span> <span class="token punctuation">(</span><span class="token hvariable">a</span> <span class="token operator">-&gt;</span> <span class="token hvariable">b</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token hvariable">f</span> <span class="token hvariable">a</span> <span class="token operator">-&gt;</span> <span class="token hvariable">f</span> <span class="token hvariable">b</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p><span alt="LYHfGG_57_functor.png" src="LYHfGG_57_functor.png" class="internal-embed media-embed image-embed is-loaded"><img alt="LYHfGG_57_functor.png" src="курсы\learn-you-a-haskell-for-great-good!\картинки\lyhfgg_57_functor.png"></span></p></div><div><p>Alright. We see that it defines one function, <code>fmap</code>, and doesn't provide any default implementation for it. The type of <code>fmap</code> is interesting. In the definitions of typeclasses so far, the type variable that played the role of the type in the typeclass was a concrete type, like the <code>a</code> in <code>(==) :: (Eq a) =&gt; a -&gt; a -&gt; Bool</code>. But now, the <code>f</code> is not a concrete type (a type that a value can hold, like <code>Int</code>, <code>Bool</code> or <code>Maybe String</code>), but a type constructor that takes one type parameter. A quick refresher example: <code>Maybe Int</code> is a concrete type, but <code>Maybe</code> is a type constructor that takes one type as the parameter. Anyway, we see that <code>fmap</code> takes a function from one type to another and a functor applied with one type and returns a functor applied with another type.</p></div><div><p>If this sounds a bit confusing, don't worry. All will be revealed soon when we check out a few examples. Hmm, this type declaration for <code>fmap</code> reminds me of something. If you don't know what the type signature of <code>map</code> is, it's: <code>map :: (a -&gt; b) -&gt; [a] -&gt; [b]</code>.</p></div><div><p>Ah, interesting! It takes a function from one type to another and a list of one type and returns a list of another type. My friends, I think we have ourselves a functor! In fact, <code>map</code> is just a <code>fmap</code> that works only on lists. Here's how the list is an instance of the <code>Functor</code> typeclass.</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token keyword">instance</span> <span class="token constant">Functor</span> <span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token keyword">where</span>
    <span class="token builtin">fmap</span> <span class="token operator">=</span> <span class="token builtin">map</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>That's it! Notice how we didn't write <code>instance Functor [a] where</code>, because from <code>fmap :: (a -&gt; b) -&gt; f a -&gt; f b</code>, we see that the <code>f</code> has to be a type constructor that takes one type. <code>[a]</code> is already a concrete type (of a list with any type inside it), while <code>[]</code> is a type constructor that takes one type and can produce types such as <code>[Int]</code>, <code>[String]</code> or even <code>[[String]]</code>.</p></div><div><p>Since for lists, <code>fmap</code> is just <code>map</code>, we get the same results when using them on lists.</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token builtin">map</span> <span class="token operator">::</span> <span class="token punctuation">(</span><span class="token hvariable">a</span> <span class="token operator">-&gt;</span> <span class="token hvariable">b</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token punctuation">[</span><span class="token hvariable">a</span><span class="token punctuation">]</span> <span class="token operator">-&gt;</span> <span class="token punctuation">[</span><span class="token hvariable">b</span><span class="token punctuation">]</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token builtin">fmap</span> <span class="token punctuation">(</span><span class="token operator">*</span><span class="token number">2</span><span class="token punctuation">)</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token operator">..</span><span class="token number">3</span><span class="token punctuation">]</span>
<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">]</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token builtin">map</span> <span class="token punctuation">(</span><span class="token operator">*</span><span class="token number">2</span><span class="token punctuation">)</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token operator">..</span><span class="token number">3</span><span class="token punctuation">]</span>
<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">]</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>What happens when we <code>map</code> or <code>fmap</code> over an empty list? Well, of course, we get an empty list. It just turns an empty list of type <code>[a]</code> into an empty list of type <code>[b]</code>.</p></div><div><p>Types that can act like a box can be functors. You can think of a list as a box that has an infinite amount of little compartments and they can all be empty, one can be full and the others empty or a number of them can be full. So, what else has the properties of being like a box? For one, the <code>Maybe a</code> type. In a way, it's like a box that can either hold nothing, in which case it has the value of <code>Nothing</code>, or it can hold one item, like <code>"HAHA"</code>, in which case it has a value of <code>Just "HAHA"</code>. Here's how <code>Maybe</code> is a functor.</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token keyword">instance</span> <span class="token constant">Functor</span> <span class="token constant">Maybe</span> <span class="token keyword">where</span>
    <span class="token builtin">fmap</span> <span class="token hvariable">f</span> <span class="token punctuation">(</span><span class="token constant">Just</span> <span class="token hvariable">x</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token constant">Just</span> <span class="token punctuation">(</span><span class="token hvariable">f</span> <span class="token hvariable">x</span><span class="token punctuation">)</span>
    <span class="token builtin">fmap</span> <span class="token hvariable">f</span> <span class="token constant">Nothing</span> <span class="token operator">=</span> <span class="token constant">Nothing</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Again, notice how we wrote <code>instance Functor Maybe where</code> instead of <code>instance Functor (Maybe m) where</code>, like we did when we were dealing with <code>Maybe</code> and <code>YesNo</code>. <code>Functor</code> wants a type constructor that takes one type and not a concrete type. If you mentally replace the <code>f</code>s with <code>Maybe</code>s, <code>fmap</code> acts like a <code>(a -&gt; b) -&gt; Maybe a -&gt; Maybe b</code> for this particular type, which looks OK. But if you replace <code>f</code> with <code>(Maybe m)</code>, then it would seem to act like a <code>(a -&gt; b) -&gt; Maybe m a -&gt; Maybe m b</code>, which doesn't make any damn sense because <code>Maybe</code> takes just one type parameter.</p></div><div><p>Anyway, the <code>fmap</code> implementation is pretty simple. If it's an empty value of <code>Nothing</code>, then just return a <code>Nothing</code>. If we map over an empty box, we get an empty box. It makes sense. Just like if we map over an empty list, we get back an empty list. If it's not an empty value, but rather a single value packed up in a <code>Just</code>, then we apply the function on the contents of the <code>Just</code>.</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token builtin">fmap</span> <span class="token punctuation">(</span><span class="token operator">++</span> <span class="token string">" HEY GUYS IM INSIDE THE JUST"</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token constant">Just</span> <span class="token string">"Something serious."</span><span class="token punctuation">)</span>
<span class="token constant">Just</span> <span class="token string">"Something serious. HEY GUYS IM INSIDE THE JUST"</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token builtin">fmap</span> <span class="token punctuation">(</span><span class="token operator">++</span> <span class="token string">" HEY GUYS IM INSIDE THE JUST"</span><span class="token punctuation">)</span> <span class="token constant">Nothing</span>
<span class="token constant">Nothing</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token builtin">fmap</span> <span class="token punctuation">(</span><span class="token operator">*</span><span class="token number">2</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token constant">Just</span> <span class="token number">200</span><span class="token punctuation">)</span>
<span class="token constant">Just</span> <span class="token number">400</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token builtin">fmap</span> <span class="token punctuation">(</span><span class="token operator">*</span><span class="token number">2</span><span class="token punctuation">)</span> <span class="token constant">Nothing</span>
<span class="token constant">Nothing</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Another thing that can be mapped over and made an instance of <code>Functor</code> is our <code>Tree a</code> type. It can be thought of as a box in a way (holds several or no values) and the <code>Tree</code> type constructor takes exactly one type parameter. If you look at <code>fmap</code> as if it were a function made only for <code>Tree</code>, its type signature would look like <code>(a -&gt; b) -&gt; Tree a -&gt; Tree b</code>. We're going to use recursion on this one. Mapping over an empty tree will produce an empty tree. Mapping over a non-empty tree will be a tree consisting of our function applied to the root value and its left and right sub-trees will be the previous sub-trees, only our function will be mapped over them.</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token keyword">instance</span> <span class="token constant">Functor</span> <span class="token constant">Tree</span> <span class="token keyword">where</span>
    <span class="token builtin">fmap</span> <span class="token hvariable">f</span> <span class="token constant">EmptyTree</span> <span class="token operator">=</span> <span class="token constant">EmptyTree</span>
    <span class="token builtin">fmap</span> <span class="token hvariable">f</span> <span class="token punctuation">(</span><span class="token constant">Node</span> <span class="token hvariable">x</span> <span class="token hvariable">leftsub</span> <span class="token hvariable">rightsub</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token constant">Node</span> <span class="token punctuation">(</span><span class="token hvariable">f</span> <span class="token hvariable">x</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token builtin">fmap</span> <span class="token hvariable">f</span> <span class="token hvariable">leftsub</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token builtin">fmap</span> <span class="token hvariable">f</span> <span class="token hvariable">rightsub</span><span class="token punctuation">)</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token builtin">fmap</span> <span class="token punctuation">(</span><span class="token operator">*</span><span class="token number">2</span><span class="token punctuation">)</span> <span class="token constant">EmptyTree</span>
<span class="token constant">EmptyTree</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token builtin">fmap</span> <span class="token punctuation">(</span><span class="token operator">*</span><span class="token number">4</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token builtin">foldr</span> <span class="token hvariable">treeInsert</span> <span class="token constant">EmptyTree</span> <span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">7</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">7</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
<span class="token constant">Node</span> <span class="token number">28</span> <span class="token punctuation">(</span><span class="token constant">Node</span> <span class="token number">4</span> <span class="token constant">EmptyTree</span> <span class="token punctuation">(</span><span class="token constant">Node</span> <span class="token number">8</span> <span class="token constant">EmptyTree</span> <span class="token punctuation">(</span><span class="token constant">Node</span> <span class="token number">12</span> <span class="token constant">EmptyTree</span> <span class="token punctuation">(</span><span class="token constant">Node</span> <span class="token number">20</span> <span class="token constant">EmptyTree</span> <span class="token constant">EmptyTree</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token constant">EmptyTree</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Nice! Now how about <code>Either a b</code>? Can this be made a functor? The <code>Functor</code> typeclass wants a type constructor that takes only one type parameter but <code>Either</code> takes two. Hmmm! I know, we'll partially apply <code>Either</code> by feeding it only one parameter so that it has one free parameter. Here's how <code>Either a</code> is a functor in the standard libraries:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token keyword">instance</span> <span class="token constant">Functor</span> <span class="token punctuation">(</span><span class="token constant">Either</span> <span class="token hvariable">a</span><span class="token punctuation">)</span> <span class="token keyword">where</span>
    <span class="token builtin">fmap</span> <span class="token hvariable">f</span> <span class="token punctuation">(</span><span class="token constant">Right</span> <span class="token hvariable">x</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token constant">Right</span> <span class="token punctuation">(</span><span class="token hvariable">f</span> <span class="token hvariable">x</span><span class="token punctuation">)</span>
    <span class="token builtin">fmap</span> <span class="token hvariable">f</span> <span class="token punctuation">(</span><span class="token constant">Left</span> <span class="token hvariable">x</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token constant">Left</span> <span class="token hvariable">x</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Well well, what did we do here? You can see how we made <code>Either a</code> an instance instead of just <code>Either</code>. That's because <code>Either a</code> is a type constructor that takes one parameter, whereas <code>Either</code> takes two. If <code>fmap</code> was specifically for <code>Either a</code>, the type signature would then be <code>(b -&gt; c) -&gt; Either a b -&gt; Either a c</code> because that's the same as <code>(b -&gt; c) -&gt; (Either a) b -&gt; (Either a) c</code>. In the implementation, we mapped in the case of a <code>Right</code> value constructor, but we didn't in the case of a <code>Left</code>. Why is that? Well, if we look back at how the <code>Either a b</code> type is defined, it's kind of like:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token keyword">data</span> <span class="token constant">Either</span> <span class="token hvariable">a</span> <span class="token hvariable">b</span> <span class="token operator">=</span> <span class="token constant">Left</span> <span class="token hvariable">a</span> <span class="token operator">|</span> <span class="token constant">Right</span> <span class="token hvariable">b</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Well, if we wanted to map one function over both of them, <code>a</code> and <code>b</code> would have to be the same type. I mean, if we tried to map a function that takes a string and returns a string and the <code>b</code> was a string but the <code>a</code> was a number, that wouldn't really work out. Also, from seeing what <code>fmap</code>'s type would be if it operated only on <code>Either</code> values, we see that the first parameter has to remain the same while the second one can change and the first parameter is actualized by the <code>Left</code> value constructor.</p></div><div><p>This also goes nicely with our box analogy if we think of the <code>Left</code> part as sort of an empty box with an error message written on the side telling us why it's empty.</p></div><div><p>Maps from <code>Data.Map</code> can also be made a functor because they hold values (or not!). In the case of <code>Map k v</code>, <code>fmap</code> will map a function <code>v -&gt; v'</code> over a map of type <code>Map k v</code> and return a map of type <code>Map k v'</code>.</p></div><div><blockquote>
<p>Note, the <code>'</code> has no special meaning in types just like it doesn't have special meaning when naming values. It's used to denote things that are similar, only slightly changed.</p>
</blockquote></div><div><p>Try figuring out how <code>Map k</code> is made an instance of <code>Functor</code> by yourself!</p></div><div><p>With the <code>Functor</code> typeclass, we've seen how typeclasses can represent pretty cool higher-order concepts. We've also had some more practice with partially applying types and making instances. In one of the next chapters, we'll also take a look at some laws that apply for functors.</p></div><div><blockquote>
<p><strong>Just one more thing!</strong> Functors should obey some laws so that they may have some properties that we can depend on and not think about too much. If we use <code>fmap (+1)</code> over the list <code>[1,2,3,4]</code>, we expect the result to be <code>[2,3,4,5]</code> and not its reverse, <code>[5,4,3,2]</code>. If we use <code>fmap (\a -&gt; a)</code> (the identity function, which just returns its parameter) over some list, we expect to get back the same list as a result. For example, if we gave the wrong functor instance to our <code>Tree</code> type, using <code>fmap</code> over a tree where the left sub-tree of a node only has elements that are smaller than the node and the right sub-tree only has nodes that are larger than the node might produce a tree where that's not the case. We'll go over the functor laws in more detail in one of the next chapters.</p>
</blockquote></div><div><h2 data-heading="Kinds and some type-foo" id="Kinds_and_some_type-foo" style="display: flex;"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>Kinds and some type-foo</h2></div><div><p><span alt="LYHfGG_58_typefoo.png" src="LYHfGG_58_typefoo.png" class="internal-embed media-embed image-embed is-loaded"><img alt="LYHfGG_58_typefoo.png" src="курсы\learn-you-a-haskell-for-great-good!\картинки\lyhfgg_58_typefoo.png"></span></p></div><div><p>Type constructors take other types as parameters to eventually produce concrete types. That kind of reminds me of functions, which take values as parameters to produce values. We've seen that type constructors can be partially applied (<code>Either String</code> is a type that takes one type and produces a concrete type, like <code>Either String Int</code>), just like functions can. This is all very interesting indeed. In this section, we'll take a look at formally defining how types are applied to type constructors, just like we took a look at formally defining how values are applied to functions by using type declarations. <strong>You don't really have to read this section to continue on your magical Haskell quest</strong> and if you don't understand it, don't worry about it. However, getting this will give you a very thorough understanding of the type system.</p></div><div><p>So, values like <code>3</code>, <code>"YEAH"</code> or <code>takeWhile</code> (functions are also values, because we can pass them around and such) each have their own type. Types are little labels that values carry so that we can reason about the values. But types have their own little labels, called <strong>kinds</strong>. A kind is more or less the type of a type. This may sound a bit weird and confusing, but it's actually a really cool concept.</p></div><div><p>What are kinds and what are they good for? Well, let's examine the kind of a type by using the <code>:k</code> command in GHCI.</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token operator">:</span><span class="token hvariable">k</span> <span class="token constant">Int</span>
<span class="token constant">Int</span> <span class="token operator">::</span> <span class="token operator">*</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>A star? How quaint. What does that mean? A <code>*</code> means that the type is a concrete type. A concrete type is a type that doesn't take any type parameters and values can only have types that are concrete types. If I had to read <code>*</code> out loud (I haven't had to do that so far), I'd say <em>star</em> or just <em>type</em>.</p></div><div><p>Okay, now let's see what the kind of <code>Maybe</code> is.</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token operator">:</span><span class="token hvariable">k</span> <span class="token constant">Maybe</span>
<span class="token constant">Maybe</span> <span class="token operator">::</span> <span class="token operator">*</span> <span class="token operator">-&gt;</span> <span class="token operator">*</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>The <code>Maybe</code> type constructor takes one concrete type (like <code>Int</code>) and then returns a concrete type like <code>Maybe Int</code>. And that's what this kind tells us. Just like <code>Int -&gt; Int</code> means that a function takes an <code>Int</code> and returns an <code>Int</code>, <code>* -&gt; *</code> means that the type constructor takes one concrete type and returns a concrete type. Let's apply the type parameter to <code>Maybe</code> and see what the kind of that type is.</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token operator">:</span><span class="token hvariable">k</span> <span class="token constant">Maybe</span> <span class="token constant">Int</span>
<span class="token constant">Maybe</span> <span class="token constant">Int</span> <span class="token operator">::</span> <span class="token operator">*</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Just like I expected! We applied the type parameter to <code>Maybe</code> and got back a concrete type (that's what <code>* -&gt; *</code> means. A parallel (although not equivalent, types and kinds are two different things) to this is if we do <code>:t isUpper</code> and <code>:t isUpper 'A'</code>. <code>isUpper</code> has a type of <code>Char -&gt; Bool</code> and <code>isUpper 'A'</code> has a type of <code>Bool</code>, because its value is basically <code>True</code>. Both those types, however, have a kind of <code>*</code>.</p></div><div><p>We used <code>:k</code> on a type to get its kind, just like we can use <code>:t</code> on a value to get its type. Like we said, types are the labels of values and kinds are the labels of types and there are parallels between the two.</p></div><div><p>Let's look at another kind.</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token operator">:</span><span class="token hvariable">k</span> <span class="token constant">Either</span>
<span class="token constant">Either</span> <span class="token operator">::</span> <span class="token operator">*</span> <span class="token operator">-&gt;</span> <span class="token operator">*</span> <span class="token operator">-&gt;</span> <span class="token operator">*</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Aha, this tells us that <code>Either</code> takes two concrete types as type parameters to produce a concrete type. It also looks kind of like a type declaration of a function that takes two values and returns something. Type constructors are curried (just like functions), so we can partially apply them.</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token operator">:</span><span class="token hvariable">k</span> <span class="token constant">Either</span> <span class="token constant">String</span>
<span class="token constant">Either</span> <span class="token constant">String</span> <span class="token operator">::</span> <span class="token operator">*</span> <span class="token operator">-&gt;</span> <span class="token operator">*</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token operator">:</span><span class="token hvariable">k</span> <span class="token constant">Either</span> <span class="token constant">String</span> <span class="token constant">Int</span>
<span class="token constant">Either</span> <span class="token constant">String</span> <span class="token constant">Int</span> <span class="token operator">::</span> <span class="token operator">*</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>When we wanted to make <code>Either</code> a part of the <code>Functor</code> typeclass, we had to partially apply it because <code>Functor</code> wants types that take only one parameter while <code>Either</code> takes two. In other words, <code>Functor</code> wants types of kind <code>* -&gt; *</code> and so we had to partially apply <code>Either</code> to get a type of kind <code>* -&gt; *</code> instead of its original kind <code>* -&gt; * -&gt; *</code>. If we look at the definition of <code>Functor</code> again</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token keyword">class</span> <span class="token constant">Functor</span> <span class="token hvariable">f</span> <span class="token keyword">where</span> 
    <span class="token builtin">fmap</span> <span class="token operator">::</span> <span class="token punctuation">(</span><span class="token hvariable">a</span> <span class="token operator">-&gt;</span> <span class="token hvariable">b</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token hvariable">f</span> <span class="token hvariable">a</span> <span class="token operator">-&gt;</span> <span class="token hvariable">f</span> <span class="token hvariable">b</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>we see that the <code>f</code> type variable is used as a type that takes one concrete type to produce a concrete type. We know it has to produce a concrete type because it's used as the type of a value in a function. And from that, we can deduce that types that want to be friends with <code>Functor</code> have to be of kind <code>* -&gt; *</code>.</p></div><div><p>Now, let's do some type-foo. Take a look at this typeclass that I'm just going to make up right now:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token keyword">class</span> <span class="token constant">Tofu</span> <span class="token hvariable">t</span> <span class="token keyword">where</span>
    <span class="token hvariable">tofu</span> <span class="token operator">::</span> <span class="token hvariable">j</span> <span class="token hvariable">a</span> <span class="token operator">-&gt;</span> <span class="token hvariable">t</span> <span class="token hvariable">a</span> <span class="token hvariable">j</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Man, that looks weird. How would we make a type that could be an instance of that strange typeclass? Well, let's look at what its kind would have to be. Because <code>j a</code> is used as the type of a value that the <code>tofu</code> function takes as its parameter, <code>j a</code> has to have a kind of <code>*</code>. We assume <code>*</code> for <code>a</code> and so we can infer that <code>j</code> has to have a kind of <code>* -&gt; *</code>. We see that <code>t</code> has to produce a concrete value too and that it takes two types. And knowing that <code>a</code> has a kind of <code>*</code> and <code>j</code> has a kind of <code>* -&gt; *</code>, we infer that <code>t</code> has to have a kind of <code>* -&gt; (* -&gt; *) -&gt; *</code>. So it takes a concrete type (<code>a</code>), a type constructor that takes one concrete type (<code>j</code>) and produces a concrete type. Wow.</p></div><div><p>OK, so let's make a type with a kind of <code>* -&gt; (* -&gt; *) -&gt; *</code>. Here's one way of going about it.</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token keyword">data</span> <span class="token constant">Frank</span> <span class="token hvariable">a</span> <span class="token hvariable">b</span>  <span class="token operator">=</span> <span class="token constant">Frank</span> <span class="token punctuation">{</span><span class="token hvariable">frankField</span> <span class="token operator">::</span> <span class="token hvariable">b</span> <span class="token hvariable">a</span><span class="token punctuation">}</span> <span class="token keyword">deriving</span> <span class="token punctuation">(</span><span class="token constant">Show</span><span class="token punctuation">)</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>How do we know this type has a kind of <code>* -&gt; (* -&gt; *) - &gt; *</code>? Well, fields in ADTs are made to hold values, so they must be of kind <code>*</code>, obviously. We assume <code>*</code> for <code>a</code>, which means that <code>b</code> takes one type parameter and so its kind is <code>* -&gt; *</code>. Now we know the kinds of both <code>a</code> and <code>b</code> and because they're parameters for <code>Frank</code>, we see that <code>Frank</code> has a kind of <code>* -&gt; (* -&gt; *) -&gt; *</code> The first <code>*</code> represents <code>a</code> and the <code>(* -&gt; *)</code> represents <code>b</code>. Let's make some <code>Frank</code> values and check out their types.</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token operator">:</span><span class="token hvariable">t</span> <span class="token constant">Frank</span> <span class="token punctuation">{</span><span class="token hvariable">frankField</span> <span class="token operator">=</span> <span class="token constant">Just</span> <span class="token string">"HAHA"</span><span class="token punctuation">}</span>
<span class="token constant">Frank</span> <span class="token punctuation">{</span><span class="token hvariable">frankField</span> <span class="token operator">=</span> <span class="token constant">Just</span> <span class="token string">"HAHA"</span><span class="token punctuation">}</span> <span class="token operator">::</span> <span class="token constant">Frank</span> <span class="token punctuation">[</span><span class="token constant">Char</span><span class="token punctuation">]</span> <span class="token constant">Maybe</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token operator">:</span><span class="token hvariable">t</span> <span class="token constant">Frank</span> <span class="token punctuation">{</span><span class="token hvariable">frankField</span> <span class="token operator">=</span> <span class="token constant">Node</span> <span class="token char string">'a'</span> <span class="token constant">EmptyTree</span> <span class="token constant">EmptyTree</span><span class="token punctuation">}</span>
<span class="token constant">Frank</span> <span class="token punctuation">{</span><span class="token hvariable">frankField</span> <span class="token operator">=</span> <span class="token constant">Node</span> <span class="token char string">'a'</span> <span class="token constant">EmptyTree</span> <span class="token constant">EmptyTree</span><span class="token punctuation">}</span> <span class="token operator">::</span> <span class="token constant">Frank</span> <span class="token constant">Char</span> <span class="token constant">Tree</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token operator">:</span><span class="token hvariable">t</span> <span class="token constant">Frank</span> <span class="token punctuation">{</span><span class="token hvariable">frankField</span> <span class="token operator">=</span> <span class="token string">"YES"</span><span class="token punctuation">}</span>
<span class="token constant">Frank</span> <span class="token punctuation">{</span><span class="token hvariable">frankField</span> <span class="token operator">=</span> <span class="token string">"YES"</span><span class="token punctuation">}</span> <span class="token operator">::</span> <span class="token constant">Frank</span> <span class="token constant">Char</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Hmm. Because <code>frankField</code> has a type of form <code>a b</code>, its values must have types that are of a similar form as well. So they can be <code>Just "HAHA"</code>, which has a type of <code>Maybe [Char]</code> or it can have a value of <code>['Y','E','S']</code>, which has a type of <code>[Char]</code> (if we used our own list type for this, it would have a type of <code>List Char</code>). And we see that the types of the <code>Frank</code> values correspond with the kind for <code>Frank</code>. <code>[Char]</code> has a kind of <code>*</code> and <code>Maybe</code> has a kind of <code>* -&gt; *</code>. Because in order to have a value, it has to be a concrete type and thus has to be fully applied, every value of <code>Frank blah blaah</code> has a kind of <code>*</code>.</p></div><div><p>Making <code>Frank</code> an instance of <code>Tofu</code> is pretty simple. We see that <code>tofu</code> takes a <code>j a</code> (so an example type of that form would be <code>Maybe Int</code>) and returns a <code>t a j</code>. So if we replace <code>Frank</code> with <code>j</code>, the result type would be <code>Frank Int Maybe</code>.</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token keyword">instance</span> <span class="token constant">Tofu</span> <span class="token constant">Frank</span> <span class="token keyword">where</span>
    <span class="token hvariable">tofu</span> <span class="token hvariable">x</span> <span class="token operator">=</span> <span class="token constant">Frank</span> <span class="token hvariable">x</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token hvariable">tofu</span> <span class="token punctuation">(</span><span class="token constant">Just</span> <span class="token char string">'a'</span><span class="token punctuation">)</span> <span class="token operator">::</span> <span class="token constant">Frank</span> <span class="token constant">Char</span> <span class="token constant">Maybe</span>
<span class="token constant">Frank</span> <span class="token punctuation">{</span><span class="token hvariable">frankField</span> <span class="token operator">=</span> <span class="token constant">Just</span> <span class="token char string">'a'</span><span class="token punctuation">}</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token hvariable">tofu</span> <span class="token punctuation">[</span><span class="token string">"HELLO"</span><span class="token punctuation">]</span> <span class="token operator">::</span> <span class="token constant">Frank</span> <span class="token punctuation">[</span><span class="token constant">Char</span><span class="token punctuation">]</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
<span class="token constant">Frank</span> <span class="token punctuation">{</span><span class="token hvariable">frankField</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">"HELLO"</span><span class="token punctuation">]</span><span class="token punctuation">}</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Not very useful, but we did flex our type muscles. Let's do some more type-foo. We have this data type:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token keyword">data</span> <span class="token constant">Barry</span> <span class="token hvariable">t</span> <span class="token hvariable">k</span> <span class="token hvariable">p</span> <span class="token operator">=</span> <span class="token constant">Barry</span> <span class="token punctuation">{</span> <span class="token hvariable">yabba</span> <span class="token operator">::</span> <span class="token hvariable">p</span><span class="token punctuation">,</span> <span class="token hvariable">dabba</span> <span class="token operator">::</span> <span class="token hvariable">t</span> <span class="token hvariable">k</span> <span class="token punctuation">}</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>And now we want to make it an instance of <code>Functor</code>. <code>Functor</code> wants types of kind <code>* -&gt; *</code> but <code>Barry</code> doesn't look like it has that kind. What is the kind of <code>Barry</code>? Well, we see it takes three type parameters, so it's going to be <code>something -&gt; something -&gt; something -&gt; *</code>. It's safe to say that <code>p</code> is a concrete type and thus has a kind of <code>*</code>. For <code>k</code>, we assume <code>*</code> and so by extension, <code>t</code> has a kind of <code>* -&gt; *</code>. Now let's just replace those kinds with the <em>somethings</em> that we used as placeholders and we see it has a kind of <code>(* -&gt; *) -&gt; * -&gt; * -&gt; *</code>. Let's check that with GHCI.</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token operator">:</span><span class="token hvariable">k</span> <span class="token constant">Barry</span>
<span class="token constant">Barry</span> <span class="token operator">::</span> <span class="token punctuation">(</span><span class="token operator">*</span> <span class="token operator">-&gt;</span> <span class="token operator">*</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token operator">*</span> <span class="token operator">-&gt;</span> <span class="token operator">*</span> <span class="token operator">-&gt;</span> <span class="token operator">*</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Ah, we were right. How satisfying. Now, to make this type a part of <code>Functor</code> we have to partially apply the first two type parameters so that we're left with <code>* -&gt; *</code>. That means that the start of the instance declaration will be: <code>instance Functor (Barry a b) where</code>. If we look at <code>fmap</code> as if it was made specifically for <code>Barry</code>, it would have a type of <code>fmap :: (a -&gt; b) -&gt; Barry c d a -&gt; Barry c d b</code>, because we just replace the <code>Functor</code>'s <code>f</code> with <code>Barry c d</code>. The third type parameter from <code>Barry</code> will have to change and we see that it's conviniently in its own field.</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token keyword">instance</span> <span class="token constant">Functor</span> <span class="token punctuation">(</span><span class="token constant">Barry</span> <span class="token hvariable">a</span> <span class="token hvariable">b</span><span class="token punctuation">)</span> <span class="token keyword">where</span>
    <span class="token builtin">fmap</span> <span class="token hvariable">f</span> <span class="token punctuation">(</span><span class="token constant">Barry</span> <span class="token punctuation">{</span><span class="token hvariable">yabba</span> <span class="token operator">=</span> <span class="token hvariable">x</span><span class="token punctuation">,</span> <span class="token hvariable">dabba</span> <span class="token operator">=</span> <span class="token hvariable">y</span><span class="token punctuation">}</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token constant">Barry</span> <span class="token punctuation">{</span><span class="token hvariable">yabba</span> <span class="token operator">=</span> <span class="token hvariable">f</span> <span class="token hvariable">x</span><span class="token punctuation">,</span> <span class="token hvariable">dabba</span> <span class="token operator">=</span> <span class="token hvariable">y</span><span class="token punctuation">}</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>There we go! We just mapped the <code>f</code> over the first field.</p></div><div><p>In this section, we took a good look at how type parameters work and kind of formalized them with kinds, just like we formalized function parameters with type declarations. We saw that there are interesting parallels between functions and type constructors. They are, however, two completely different things. When working on real Haskell, you usually won't have to mess with kinds and do kind inference by hand like we did now. Usually, you just have to partially apply your own type to <code>* -&gt; *</code> or <code>*</code> when making it an instance of one of the standard typeclasses, but it's good to know how and why that actually works. It's also interesting to see that types have little types of their own. Again, you don't really have to understand everything we did here to read on, but if you understand how kinds work, chances are that you have a very solid grasp of Haskell's type system.</p></div><div><h1 data-heading="Input and Output" id="Input_and_Output">Input and Output</h1></div><div><p><span alt="LYHfGG_59_dognap.png" src="LYHfGG_59_dognap.png" class="internal-embed media-embed image-embed is-loaded"><img alt="LYHfGG_59_dognap.png" src="курсы\learn-you-a-haskell-for-great-good!\картинки\lyhfgg_59_dognap.png"></span></p></div><div><p>We've mentioned that Haskell is a purely functional language. Whereas in imperative languages you usually get things done by giving the computer a series of steps to execute, functional programming is more of defining what stuff is. In Haskell, a function can't change some state, like changing the contents of a variable (when a function changes state, we say that the function has <em>side-effects</em>). The only thing a function can do in Haskell is give us back some result based on the parameters we gave it. If a function is called two times with the same parameters, it has to return the same result. While this may seem a bit limiting when you're coming from an imperative world, we've seen that it's actually really cool. In an imperative language, you have no guarantee that a simple function that should just crunch some numbers won't burn down your house, kidnap your dog and scratch your car with a potato while crunching those numbers. For instance, when we were making a binary search tree, we didn't insert an element into a tree by modifying some tree in place. Our function for inserting into a binary search tree actually returned a new tree, because it can't change the old one.</p></div><div><p>While functions being unable to change state is good because it helps us reason about our programs, there's one problem with that. If a function can't change anything in the world, how is it supposed to tell us what it calculated? In order to tell us what it calculated, it has to change the state of an output device (usually the state of the screen), which then emits photons that travel to our brain and change the state of our mind, man.</p></div><div><p>Do not despair, all is not lost. It turns out that Haskell actually has a really clever system for dealing with functions that have side-effects that neatly separates the part of our program that is pure and the part of our program that is impure, which does all the dirty work like talking to the keyboard and the screen. With those two parts separated, we can still reason about our pure program and take advantage of all the things that purity offers, like laziness, robustness and modularity while efficiently communicating with the outside world.</p></div><div><h2 data-heading="Hello, world!" id="Hello,_world!" style="display: flex;"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>Hello, world!</h2></div><div><p><span alt="LYHfGG_60_helloworld.png" src="LYHfGG_60_helloworld.png" class="internal-embed media-embed image-embed is-loaded"><img alt="LYHfGG_60_helloworld.png" src="курсы\learn-you-a-haskell-for-great-good!\картинки\lyhfgg_60_helloworld.png"></span></p></div><div><p>Up until now, we've always loaded our functions into GHCI to test them out and play with them. We've also explored the standard library functions that way. But now, after eight or so chapters, we're finally going to write our first <em>real</em> Haskell program! Yay! And sure enough, we're going to do the good old <code>"hello, world"</code> schtick.</p></div><div><blockquote>
<p><strong>Hey!</strong> For the purposes of this chapter, I'm going to assume you're using a unix-y environment for learning Haskell. If you're in Windows, I'd suggest you download <a data-tooltip-position="top" aria-label="http://www.cygwin.com/" rel="noopener" class="external-link" href="http://www.cygwin.com/" target="_blank">Cygwin</a>, which is a Linux-like environment for Windows, A.K.A. just what you need.</p>
</blockquote></div><div><p>So, for starters, punch in the following in your favorite text editor:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">main</span> <span class="token operator">=</span> <span class="token builtin">putStrLn</span> <span class="token string">"hello, world"</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>We just defined a name called <code>main</code> and in it we call a function called <code>putStrLn</code> with the parameter <code>"hello, world"</code>. Looks pretty much run of the mill, but it isn't, as we'll see in just a few moments. Save that file as <code>helloworld.hs</code>.</p></div><div><p>And now, we're going to do something we've never done before. We're actually going to compile our program! I'm so excited! Open up your terminal and navigate to the directory where <code>helloworld.hs</code> is located and do the following:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token operator">$</span> <span class="token hvariable">ghc</span> <span class="token comment">--make helloworld</span>
<span class="token punctuation">[</span><span class="token number">1</span> <span class="token keyword">of</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token constant">Compiling</span> <span class="token constant">Main</span>             <span class="token punctuation">(</span> <span class="token hvariable">helloworld</span><span class="token punctuation">.</span><span class="token hvariable">hs</span><span class="token punctuation">,</span> <span class="token hvariable">helloworld</span><span class="token punctuation">.</span><span class="token hvariable">o</span> <span class="token punctuation">)</span>
<span class="token constant">Linking</span> <span class="token hvariable">helloworld</span> <span class="token operator">...</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Okay! With any luck, you got something like this and now you can run your program by doing <code>./helloworld</code>.</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token operator">$</span> <span class="token operator">./</span><span class="token hvariable">helloworld</span>
<span class="token hvariable">hello</span><span class="token punctuation">,</span> <span class="token hvariable">world</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>And there we go, our first compiled program that printed out something to the terminal. How extraordinarily boring!</p></div><div><p>Let's examine what we wrote. First, let's look at the type of the function <code>putStrLn</code>.</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token operator">:</span><span class="token hvariable">t</span> <span class="token builtin">putStrLn</span>
<span class="token builtin">putStrLn</span> <span class="token operator">::</span> <span class="token constant">String</span> <span class="token operator">-&gt;</span> <span class="token constant">IO</span> <span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token operator">:</span><span class="token hvariable">t</span> <span class="token builtin">putStrLn</span> <span class="token string">"hello, world"</span>
<span class="token builtin">putStrLn</span> <span class="token string">"hello, world"</span> <span class="token operator">::</span> <span class="token constant">IO</span> <span class="token punctuation">(</span><span class="token punctuation">)</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>We can read the type of <code>putStrLn</code> like this: <code>putStrLn</code> takes a string and returns an <strong>I/O action</strong> that has a result type of <code>()</code> (i.e. the empty tuple, also know as unit). An I/O action is something that, when performed, will carry out an action with a side-effect (that's usually either reading from the input or printing stuff to the screen) and will also contain some kind of return value inside it. Printing a string to the terminal doesn't really have any kind of meaningful return value, so a dummy value of <code>()</code> is used.</p></div><div><blockquote>
<p>The empty tuple is a value of <code>()</code> and it also has a type of <code>()</code>.</p>
</blockquote></div><div><p>So, when will an I/O action be performed? Well, this is where <code>main</code> comes in. An I/O action will be performed when we give it a name of <code>main</code> and then run our program.</p></div><div><p>Having your whole program be just one I/O action seems kind of limiting. That's why we can use <em>do</em> syntax to glue together several I/O actions into one. Take a look at the following example:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">main</span> <span class="token operator">=</span> <span class="token keyword">do</span>
    <span class="token builtin">putStrLn</span> <span class="token string">"Hello, what's your name?"</span>
    <span class="token hvariable">name</span> <span class="token operator">&lt;-</span> <span class="token builtin">getLine</span>
    <span class="token builtin">putStrLn</span> <span class="token punctuation">(</span><span class="token string">"Hey "</span> <span class="token operator">++</span> <span class="token hvariable">name</span> <span class="token operator">++</span> <span class="token string">", you rock!"</span><span class="token punctuation">)</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Ah, interesting, new syntax! And this reads pretty much like an imperative program. If you compile it and try it out, it will probably behave just like you expect it to. Notice that we said <em>do</em> and then we laid out a series of steps, like we would in an imperative program. Each of these steps is an I/O action. By putting them together with <em>do</em> syntax, we glued them into one I/O action. The action that we got has a type of <code>IO ()</code>, because that's the type of the last I/O action inside.</p></div><div><p>Because of that, <code>main</code> always has a type signature of <code>main :: IO _something_</code>, where <code>_something_</code> is some concrete type. By convention, we don't usually specify a type declaration for <code>main</code>.</p></div><div><p>An interesting thing that we haven't met before is the third line, which states <code>name &lt;- getLine</code>. It looks like it reads a line from the input and stores it into a variable called <code>name</code>. Does it really? Well, let's examine the type of <code>getLine</code>.</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token operator">:</span><span class="token hvariable">t</span> <span class="token builtin">getLine</span>
<span class="token builtin">getLine</span> <span class="token operator">::</span> <span class="token constant">IO</span> <span class="token constant">String</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p><span alt="LYHfGG_61_luggage.png" src="LYHfGG_61_luggage.png" class="internal-embed media-embed image-embed is-loaded"><img alt="LYHfGG_61_luggage.png" src="курсы\learn-you-a-haskell-for-great-good!\картинки\lyhfgg_61_luggage.png"></span></p></div><div><p>Aha, o-kay. <code>getLine</code> is an I/O action that contains a result type of <code>String</code>. That makes sense, because it will wait for the user to input something at the terminal and then that something will be represented as a string. So what's up with <code>name &lt;- getLine</code> then? You can read that piece of code like this: <strong>perform the I/O action getLine and then bind its result value to name</strong>. <code>getLine</code> has a type of <code>IO String</code>, so <code>name</code> will have a type of <code>String</code>. You can think of an I/O action as a box with little feet that will go out into the real world and do something there (like write some graffiti on a wall) and maybe bring back some data. Once it's fetched that data for you, the only way to open the box and get the data inside it is to use the <code>&lt;-</code> construct. And if we're taking data out of an I/O action, we can only take it out when we're inside another I/O action. This is how Haskell manages to neatly separate the pure and impure parts of our code. <code>getLine</code> is in a sense impure because its result value is not guaranteed to be the same when performed twice. That's why it's sort of <em>tainted</em> with the <code>IO</code> type constructor and we can only get that data out in I/O code. And because I/O code is tainted too, any computation that depends on tainted I/O data will have a tainted result.</p></div><div><p>When I say <em>tainted</em>, I don't mean tainted in such a way that we can never use the result contained in an I/O action ever again in pure code. No, we temporarily <em>un-taint</em> the data inside an I/O action when we bind it to a name. When we do <code>name &lt;- getLine</code>, <code>name</code> is just a normal string, because it represents what's inside the box. We can have a really complicated function that, say, takes your name (a normal string) as a parameter and tells you your fortune and your whole life's future based on your name. We can do this:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">main</span> <span class="token operator">=</span> <span class="token keyword">do</span>
    <span class="token builtin">putStrLn</span> <span class="token string">"Hello, what's your name?"</span>
    <span class="token hvariable">name</span> <span class="token operator">&lt;-</span> <span class="token builtin">getLine</span>
    <span class="token builtin">putStrLn</span> <span class="token operator">$</span> <span class="token string">"Read this carefully, because this is your future: "</span> <span class="token operator">++</span> <span class="token hvariable">tellFortune</span> <span class="token hvariable">name</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>and <code>tellFortune</code> (or any of the functions it passes <code>name</code> to) doesn't have to know anything about I/O, it's just a normal <code>String -&gt; String</code> function!</p></div><div><p>Take a look at this piece of code. Is it valid?</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">nameTag</span> <span class="token operator">=</span> <span class="token string">"Hello, my name is "</span> <span class="token operator">++</span> <span class="token builtin">getLine</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>If you said no, go eat a cookie. If you said yes, drink a bowl of molten lava. Just kidding, don't! The reason that this doesn't work is that <code>++</code> requires both its parameters to be lists over the same type. The left parameter has a type of <code>String</code> (or <code>[Char]</code> if you will), whilst <code>getLine</code> has a type of <code>IO String</code>. You can't concatenate a string and an I/O action. We first have to get the result out of the I/O action to get a value of type <code>String</code> and the only way to do that is to say something like <code>name &lt;- getLine</code> inside some other I/O action. If we want to deal with impure data, we have to do it in an impure environment. So the taint of impurity spreads around much like the undead scourge and it's in our best interest to keep the I/O parts of our code as small as possible.</p></div><div><p>Every I/O action that gets performed has a result encapsulated within it. That's why our previous example program could also have been written like this:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">main</span> <span class="token operator">=</span> <span class="token keyword">do</span>
    <span class="token hvariable">foo</span> <span class="token operator">&lt;-</span> <span class="token builtin">putStrLn</span> <span class="token string">"Hello, what's your name?"</span>
    <span class="token hvariable">name</span> <span class="token operator">&lt;-</span> <span class="token builtin">getLine</span>
    <span class="token builtin">putStrLn</span> <span class="token punctuation">(</span><span class="token string">"Hey "</span> <span class="token operator">++</span> <span class="token hvariable">name</span> <span class="token operator">++</span> <span class="token string">", you rock!"</span><span class="token punctuation">)</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>However, <code>foo</code> would just have a value of <code>()</code>, so doing that would be kind of moot. Notice that we didn't bind the last <code>putStrLn</code> to anything. That's because in a <em>do</em> block, <strong>the last action cannot be bound to a name</strong> like the first two were. We'll see exactly why that is so a bit later when we venture off into the world of monads. For now, you can think of it in the way that the <em>do</em> block automatically extracts the value from the last action and binds it to its own result.</p></div><div><p>Except for the last line, every line in a <em>do</em> block that doesn't bind can also be written with a bind. So <code>putStrLn "BLAH"</code> can be written as <code>_ &lt;- putStrLn "BLAH"</code>. But that's useless, so we leave out the <code>&lt;-</code> for I/O actions that don't contain an important result, like <code>putStrLn _something_</code>.</p></div><div><p>Beginners sometimes think that doing</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">name</span> <span class="token operator">=</span> <span class="token builtin">getLine</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>will read from the input and then bind the value of that to <code>name</code>. Well, it won't, all this does is give the <code>getLine</code> I/O action a different name called, well, <code>name</code>. Remember, to get the value out of an I/O action, you have to perform it inside another I/O action by binding it to a name with <code>&lt;-</code>.</p></div><div><p>I/O actions will only be performed when they are given a name of <code>main</code> or when they're inside a bigger I/O action that we composed with a <em>do</em> block. We can also use a <em>do</em> block to glue together a few I/O actions and then we can use that I/O action in another <em>do</em> block and so on. Either way, they'll be performed only if they eventually fall into <code>main</code>.</p></div><div><p>Oh, right, there's also one more case when I/O actions will be performed. When we type out an I/O action in GHCI and press return, it will be performed.</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token builtin">putStrLn</span> <span class="token string">"HEEY"</span>
<span class="token constant">HEEY</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Even when we just punch out a number or call a function in GHCI and press return, it will evaluate it (as much as it needs) and then call <code>show</code> on it and then it will print that string to the terminal using <code>putStrLn</code> implicitly.</p></div><div><p>Remember <em>let</em> bindings? If you don't, refresh your memory on them by reading <a data-tooltip-position="top" aria-label="http://learnyouahaskell.com/syntax-in-functions#let-it-be" rel="noopener" class="external-link" href="http://learnyouahaskell.com/syntax-in-functions#let-it-be" target="_blank">this section</a>. They have to be in the form of <code>let _bindings_ in _expression_</code>, where <code>_bindings_</code> are names to be given to expressions and <code>_expression_</code> is the expression that is to be evaluated that sees them. We also said that in list comprehensions, the <em>in</em> part isn't needed. Well, you can use them in <em>do</em> blocks pretty much like you use them in list comprehensions. Check this out:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token import-statement"><span class="token keyword">import</span> Data<span class="token punctuation">.</span>Char</span>

<span class="token hvariable">main</span> <span class="token operator">=</span> <span class="token keyword">do</span>
    <span class="token builtin">putStrLn</span> <span class="token string">"What's your first name?"</span>
    <span class="token hvariable">firstName</span> <span class="token operator">&lt;-</span> <span class="token builtin">getLine</span>
    <span class="token builtin">putStrLn</span> <span class="token string">"What's your last name?"</span>
    <span class="token hvariable">lastName</span> <span class="token operator">&lt;-</span> <span class="token builtin">getLine</span>
    <span class="token keyword">let</span> <span class="token hvariable">bigFirstName</span> <span class="token operator">=</span> <span class="token builtin">map</span> <span class="token builtin">toUpper</span> <span class="token hvariable">firstName</span>
        <span class="token hvariable">bigLastName</span> <span class="token operator">=</span> <span class="token builtin">map</span> <span class="token builtin">toUpper</span> <span class="token hvariable">lastName</span>
    <span class="token builtin">putStrLn</span> <span class="token operator">$</span> <span class="token string">"hey "</span> <span class="token operator">++</span> <span class="token hvariable">bigFirstName</span> <span class="token operator">++</span> <span class="token string">" "</span> <span class="token operator">++</span> <span class="token hvariable">bigLastName</span> <span class="token operator">++</span> <span class="token string">", how are you?"</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>See how the I/O actions in the <em>do</em> block are lined up? Also notice how the <em>let</em> is lined up with the I/O actions and the names of the <em>let</em> are lined up with each other? That's good practice, because indentation is important in Haskell. Now, we did <code>map toUpper firstName</code>, which turns something like <code>"John"</code> into a much cooler string like <code>"JOHN"</code>. We bound that uppercased string to a name and then used it in a string later on that we printed to the terminal.</p></div><div><p>You may be wondering when to use <code>&lt;-</code> and when to use <em>let</em> bindings? Well, remember, <code>&lt;-</code> is (for now) for performing I/O actions and binding their results to names. <code>map toUpper firstName</code>, however, isn't an I/O action. It's a pure expression in Haskell. So use <code>&lt;-</code> when you want to bind results of I/O actions to names and you can use <em>let</em> bindings to bind pure expressions to names. Had we done something like <code>let firstName = getLine</code>, we would have just called the <code>getLine</code> I/O action a different name and we'd still have to run it through a <code>&lt;-</code> to perform it.</p></div><div><p>Now we're going to make a program that continuously reads a line and prints out the same line with the words reversed. The program's execution will stop when we input a blank line. This is the program:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">main</span> <span class="token operator">=</span> <span class="token keyword">do</span> 
    <span class="token hvariable">line</span> <span class="token operator">&lt;-</span> <span class="token builtin">getLine</span>
    <span class="token keyword">if</span> <span class="token builtin">null</span> <span class="token hvariable">line</span>
        <span class="token keyword">then</span> <span class="token builtin">return</span> <span class="token punctuation">(</span><span class="token punctuation">)</span>
        <span class="token keyword">else</span> <span class="token keyword">do</span>
            <span class="token builtin">putStrLn</span> <span class="token operator">$</span> <span class="token hvariable">reverseWords</span> <span class="token hvariable">line</span>
            <span class="token hvariable">main</span>

<span class="token hvariable">reverseWords</span> <span class="token operator">::</span> <span class="token constant">String</span> <span class="token operator">-&gt;</span> <span class="token constant">String</span>
<span class="token hvariable">reverseWords</span> <span class="token operator">=</span> <span class="token builtin">unwords</span> <span class="token operator">.</span> <span class="token builtin">map</span> <span class="token builtin">reverse</span> <span class="token operator">.</span> <span class="token builtin">words</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>To get a feel of what it does, you can run it before we go over the code.</p></div><div><blockquote>
<p><strong>Protip</strong>: To run a program you can either compile it and then run the produced executable file by doing <code>ghc --make helloworld</code> and then <code>./helloworld</code> or you can use the <code>runhaskell</code> command like so: <code>runhaskell helloworld.hs</code> and your program will be executed on the fly.</p>
</blockquote></div><div><p>First, let's take a look at the <code>reverseWords</code> function. It's just a normal function that takes a string like <code>"hey there man"</code> and then calls <code>words</code> with it to produce a list of words like <code>["hey","there","man"]</code>. Then we map <code>reverse</code> on the list, getting <code>["yeh","ereht","nam"]</code> and then we put that back into one string by using <code>unwords</code> and the final result is <code>"yeh ereht nam"</code>. See how we used function composition here. Without function composition, we'd have to write something like <code>reverseWords st = unwords (map reverse (words st))</code>.</p></div><div><p>What about <code>main</code>? First, we get a line from the terminal by performing <code>getLine</code> call that line <code>line</code>. And now, we have a conditional expression. Remember that in Haskell, every <em>if</em> must have a corresponding <em>else</em> because every expression has to have some sort of value. We make the <em>if</em> so that when a condition is true (in our case, the line that we entered is blank), we perform one I/O action and when it isn't, the I/O action under the <em>else</em> is performed. That's why in an I/O <em>do</em> block, <em>if_s have to have a form of `if _condition</em> then <em>I/O action</em> else <em>I/O action</em>.`</p></div><div><p>Let's first take a look at what happens under the <em>else</em> clause. Because, we have to have exactly one I/O action after the <em>else</em>, we use a <em>do</em> block to glue together two I/O actions into one. You could also write that part out as:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded">        <span class="token keyword">else</span> <span class="token punctuation">(</span><span class="token keyword">do</span>
            <span class="token builtin">putStrLn</span> <span class="token operator">$</span> <span class="token hvariable">reverseWords</span> <span class="token hvariable">line</span>
            <span class="token hvariable">main</span><span class="token punctuation">)</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>This makes it more explicit that the <em>do</em> block can be viewed as one I/O action, but it's uglier. Anyway, inside the <em>do</em> block, we call <code>reverseWords</code> on the line that we got from <code>getLine</code> and then print that out to the terminal. After that, we just perform <code>main</code>. It's called recursively and that's okay, because <code>main</code> is itself an I/O action. So in a sense, we go back to the start of the program.</p></div><div><p>Now what happens when <code>null line</code> holds true? What's after the <em>then</em> is performed in that case. If we look up, we'll see that it says <code>then return ()</code>. If you've done imperative languages like C, Java or Python, you're probably thinking that you know what this <code>return</code> does and chances are you've already skipped this really long paragraph. Well, here's the thing: <strong>the return in Haskell is really nothing like the return in most other languages!</strong> It has the same name, which confuses a lot of people, but in reality it's quite different. In imperative languages, <code>return</code> usually ends the execution of a method or subroutine and makes it report some sort of value to whoever called it. In Haskell (in I/O actions specifically), it makes an I/O action out of a pure value. If you think about the box analogy from before, it takes a value and wraps it up in a box. The resulting I/O action doesn't actually do anything, it just has that value encapsulated as its result. So in an I/O context, <code>return "haha"</code> will have a type of <code>IO String</code>. What's the point of just transforming a pure value into an I/O action that doesn't do anything? Why taint our program with <code>IO</code> more than it has to be? Well, we needed some I/O action to carry out in the case of an empty input line. That's why we just made a bogus I/O action that doesn't do anything by writing <code>return ()</code>.</p></div><div><p>Using <code>return</code> doesn't cause the I/O <em>do</em> block to end in execution or anything like that. For instance, this program will quite happily carry out all the way to the last line:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">main</span> <span class="token operator">=</span> <span class="token keyword">do</span>
    <span class="token builtin">return</span> <span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token builtin">return</span> <span class="token string">"HAHAHA"</span>
    <span class="token hvariable">line</span> <span class="token operator">&lt;-</span> <span class="token builtin">getLine</span>
    <span class="token builtin">return</span> <span class="token string">"BLAH BLAH BLAH"</span>
    <span class="token builtin">return</span> <span class="token number">4</span>
    <span class="token builtin">putStrLn</span> <span class="token hvariable">line</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>All these <code>return</code>s do is that they make I/O actions that don't really do anything except have an encapsulated result and that result is thrown away because it isn't bound to a name. We can use <code>return</code> in combination with <code>&lt;-</code> to bind stuff to names.</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">main</span> <span class="token operator">=</span> <span class="token keyword">do</span>
    <span class="token hvariable">a</span> <span class="token operator">&lt;-</span> <span class="token builtin">return</span> <span class="token string">"hell"</span>
    <span class="token hvariable">b</span> <span class="token operator">&lt;-</span> <span class="token builtin">return</span> <span class="token string">"yeah!"</span>
    <span class="token builtin">putStrLn</span> <span class="token operator">$</span> <span class="token hvariable">a</span> <span class="token operator">++</span> <span class="token string">" "</span> <span class="token operator">++</span> <span class="token hvariable">b</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>So you see, <code>return</code> is sort of the opposite to <code>&lt;-</code>. While <code>return</code> takes a value and wraps it up in a box, <code>&lt;-</code> takes a box (and performs it) and takes the value out of it, binding it to a name. But doing this is kind of redundant, especially since you can use <em>let</em> bindings in <em>do</em> blocks to bind to names, like so:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">main</span> <span class="token operator">=</span> <span class="token keyword">do</span>
    <span class="token keyword">let</span> <span class="token hvariable">a</span> <span class="token operator">=</span> <span class="token string">"hell"</span>
        <span class="token hvariable">b</span> <span class="token operator">=</span> <span class="token string">"yeah"</span>
    <span class="token builtin">putStrLn</span> <span class="token operator">$</span> <span class="token hvariable">a</span> <span class="token operator">++</span> <span class="token string">" "</span> <span class="token operator">++</span> <span class="token hvariable">b</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>When dealing with I/O <em>do</em> blocks, we mostly use <code>return</code> either because we need to create an I/O action that doesn't do anything or because we don't want the I/O action that's made up from a <em>do</em> block to have the result value of its last action, but we want it to have a different result value, so we use <code>return</code> to make an I/O action that always has our desired result contained and we put it at the end.</p></div><div><blockquote>
<p>A <em>do</em> block can also have just one I/O action. In that case, it's the same as just writing the I/O action. Some people would prefer writing <code>then do return ()</code> in this case because the <em>else</em> also has a <em>do</em>.</p>
</blockquote></div><div><p>Before we move on to files, let's take a look at some functions that are useful when dealing with I/O.</p></div><div><p><code>putStr</code> is much like <code>putStrLn</code> in that it takes a string as a parameter and returns an I/O action that will print that string to the terminal, only <code>putStr</code> doesn't jump into a new line after printing out the string while <code>putStrLn</code> does.</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">main</span> <span class="token operator">=</span> <span class="token keyword">do</span>   <span class="token builtin">putStr</span> <span class="token string">"Hey, "</span>
            <span class="token builtin">putStr</span> <span class="token string">"I'm "</span>
            <span class="token builtin">putStrLn</span> <span class="token string">"Andy!"</span> 
</code><button class="copy-code-button">Копировать</button></pre></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token operator">$</span> <span class="token hvariable">runhaskell</span> <span class="token hvariable">putstr_test</span><span class="token punctuation">.</span><span class="token hvariable">hs</span>
<span class="token constant">Hey</span><span class="token punctuation">,</span> <span class="token constant">I'</span><span class="token hvariable">m</span> <span class="token constant">Andy</span><span class="token operator">!</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Its type signature is <code>putStr :: String -&gt; IO ()</code>, so the result encapsulated within the resulting I/O action is the unit. A dud value, so it doesn't make sense to bind it.</p></div><div><p><code>putChar</code> takes a character and returns an I/O action that will print it out to the terminal.</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">main</span> <span class="token operator">=</span> <span class="token keyword">do</span>   <span class="token builtin">putChar</span> <span class="token char string">'t'</span>
            <span class="token builtin">putChar</span> <span class="token char string">'e'</span>
            <span class="token builtin">putChar</span> <span class="token char string">'h'</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token operator">$</span> <span class="token hvariable">runhaskell</span> <span class="token hvariable">putchar_test</span><span class="token punctuation">.</span><span class="token hvariable">hs</span>
<span class="token hvariable">teh</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p><code>putStr</code> is actually defined recursively with the help of <code>putChar</code>. The edge condition of <code>putStr</code> is the empty string, so if we're printing an empty string, just return an I/O action that does nothing by using <code>return ()</code>. If it's not empty, then print the first character of the string by doing <code>putChar</code> and then print of them using <code>putStr</code>.</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token builtin">putStr</span> <span class="token operator">::</span> <span class="token constant">String</span> <span class="token operator">-&gt;</span> <span class="token constant">IO</span> <span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token builtin">putStr</span> <span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token builtin">return</span> <span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token builtin">putStr</span> <span class="token punctuation">(</span><span class="token hvariable">x</span><span class="token operator">:</span><span class="token hvariable">xs</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token keyword">do</span>
    <span class="token builtin">putChar</span> <span class="token hvariable">x</span>
    <span class="token builtin">putStr</span> <span class="token hvariable">xs</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>See how we can use recursion in I/O, just like we can use it in pure code. Just like in pure code, we define the edge case and then think what the result actually is. It's an action that first outputs the first character and then outputs the rest of the string.</p></div><div><p><code>print</code> takes a value of any type that's an instance of <code>Show</code> (meaning that we know how to represent it as a string), calls <code>show</code> with that value to stringify it and then outputs that string to the terminal. Basically, it's just <code>putStrLn . show</code>. It first runs <code>show</code> on a value and then feeds that to <code>putStrLn</code>, which returns an I/O action that will print out our value.</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">main</span> <span class="token operator">=</span> <span class="token keyword">do</span>   <span class="token builtin">print</span> <span class="token constant">True</span>
            <span class="token builtin">print</span> <span class="token number">2</span>
            <span class="token builtin">print</span> <span class="token string">"haha"</span>
            <span class="token builtin">print</span> <span class="token number">3.2</span>
            <span class="token builtin">print</span> <span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">]</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token operator">$</span> <span class="token hvariable">runhaskell</span> <span class="token hvariable">print_test</span><span class="token punctuation">.</span><span class="token hvariable">hs</span>
<span class="token constant">True</span>
<span class="token number">2</span>
<span class="token string">"haha"</span>
<span class="token number">3.2</span>
<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">]</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>As you can see, it's a very handy function. Remember how we talked about how I/O actions are performed only when they fall into <code>main</code> or when we try to evaluate them in the GHCI prompt? When we type out a value (like <code>3</code> or <code>[1,2,3]</code>) and press the return key, GHCI actually uses <code>print</code> on that value to display it on our terminal!</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token number">3</span>
<span class="token number">3</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token builtin">print</span> <span class="token number">3</span>
<span class="token number">3</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token builtin">map</span> <span class="token punctuation">(</span><span class="token operator">++</span><span class="token string">"!"</span><span class="token punctuation">)</span> <span class="token punctuation">[</span><span class="token string">"hey"</span><span class="token punctuation">,</span><span class="token string">"ho"</span><span class="token punctuation">,</span><span class="token string">"woo"</span><span class="token punctuation">]</span>
<span class="token punctuation">[</span><span class="token string">"hey!"</span><span class="token punctuation">,</span><span class="token string">"ho!"</span><span class="token punctuation">,</span><span class="token string">"woo!"</span><span class="token punctuation">]</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token builtin">print</span> <span class="token punctuation">(</span><span class="token builtin">map</span> <span class="token punctuation">(</span><span class="token operator">++</span><span class="token string">"!"</span><span class="token punctuation">)</span> <span class="token punctuation">[</span><span class="token string">"hey"</span><span class="token punctuation">,</span><span class="token string">"ho"</span><span class="token punctuation">,</span><span class="token string">"woo"</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
<span class="token punctuation">[</span><span class="token string">"hey!"</span><span class="token punctuation">,</span><span class="token string">"ho!"</span><span class="token punctuation">,</span><span class="token string">"woo!"</span><span class="token punctuation">]</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>When we want to print out strings, we usually use <code>putStrLn</code> because we don't want the quotes around them, but for printing out values of other types to the terminal, <code>print</code> is used the most.</p></div><div><p><code>getChar</code> is an I/O action that reads a character from the input. Thus, its type signature is <code>getChar :: IO Char</code>, because the result contained within the I/O action is a <code>Char</code>. Note that due to buffering, reading of the characters won't actually happen until the user mashes the return key.</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">main</span> <span class="token operator">=</span> <span class="token keyword">do</span>   
    <span class="token hvariable">c</span> <span class="token operator">&lt;-</span> <span class="token builtin">getChar</span>
    <span class="token keyword">if</span> <span class="token hvariable">c</span> <span class="token operator">/=</span> <span class="token char string">' '</span>
        <span class="token keyword">then</span> <span class="token keyword">do</span>
            <span class="token builtin">putChar</span> <span class="token hvariable">c</span>
            <span class="token hvariable">main</span>
        <span class="token keyword">else</span> <span class="token builtin">return</span> <span class="token punctuation">(</span><span class="token punctuation">)</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>This program looks like it should read a character and then check if it's a space. If it is, halt execution and if it isn't, print it to the terminal and then do the same thing all over again. Well, it kind of does, only not in the way you might expect. Check this out:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token operator">$</span> <span class="token hvariable">runhaskell</span> <span class="token hvariable">getchar_test</span><span class="token punctuation">.</span><span class="token hvariable">hs</span>
<span class="token hvariable">hello</span> <span class="token hvariable">sir</span>
<span class="token hvariable">hello</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>The second line is the input. We input <code>hello sir</code> and then press return. Due to buffering, the execution of the program will begin only when after we've hit return and not after every inputted character. But once we press return, it acts on what we've been putting in so far. Try playing with this program to get a feel for it!</p></div><div><p>The <code>when</code> function is found in <code>Control.Monad</code> (to get access to it, do <code>import Control.Monad</code>). It's interesting because in a <em>do</em> block it looks like a control flow statement, but it's actually a normal function. It takes a boolean value and an I/O action if that boolean value is <code>True</code>, it returns the same I/O action that we supplied to it. However, if it's <code>False</code>, it returns the <code>return ()</code>, action, so an I/O action that doesn't do anything. Here's how we could rewrite the previous piece of code with which we demonstrated <code>getChar</code> by using <code>when</code>:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token import-statement"><span class="token keyword">import</span> Control<span class="token punctuation">.</span>Monad</span> 

<span class="token hvariable">main</span> <span class="token operator">=</span> <span class="token keyword">do</span>
    <span class="token hvariable">c</span> <span class="token operator">&lt;-</span> <span class="token builtin">getChar</span>
    <span class="token hvariable">when</span> <span class="token punctuation">(</span><span class="token hvariable">c</span> <span class="token operator">/=</span> <span class="token char string">' '</span><span class="token punctuation">)</span> <span class="token operator">$</span> <span class="token keyword">do</span>
        <span class="token builtin">putChar</span> <span class="token hvariable">c</span>
        <span class="token hvariable">main</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>So as you can see, it's useful for encapsulating the <code>if _something_ then do _some I/O action_ else return ()</code> pattern.</p></div><div><p><code>sequence</code> takes a list of I/O actions and returns an I/O actions that will perform those actions one after the other. The result contained in that I/O action will be a list of the results of all the I/O actions that were performed. Its type signature is <code>sequence :: [IO a] -&gt; IO [a]</code>. Doing this:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">main</span> <span class="token operator">=</span> <span class="token keyword">do</span>
    <span class="token hvariable">a</span> <span class="token operator">&lt;-</span> <span class="token builtin">getLine</span>
    <span class="token hvariable">b</span> <span class="token operator">&lt;-</span> <span class="token builtin">getLine</span>
    <span class="token hvariable">c</span> <span class="token operator">&lt;-</span> <span class="token builtin">getLine</span>
    <span class="token builtin">print</span> <span class="token punctuation">[</span><span class="token hvariable">a</span><span class="token punctuation">,</span><span class="token hvariable">b</span><span class="token punctuation">,</span><span class="token hvariable">c</span><span class="token punctuation">]</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Is exactly the same as doing this:.</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">main</span> <span class="token operator">=</span> <span class="token keyword">do</span>
    <span class="token hvariable">rs</span> <span class="token operator">&lt;-</span> <span class="token builtin">sequence</span> <span class="token punctuation">[</span><span class="token builtin">getLine</span><span class="token punctuation">,</span> <span class="token builtin">getLine</span><span class="token punctuation">,</span> <span class="token builtin">getLine</span><span class="token punctuation">]</span>
    <span class="token builtin">print</span> <span class="token hvariable">rs</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>So <code>sequence [getLine, getLine, getLine]</code> makes an I/O action that will perform <code>getLine</code> three times. If we bind that action to a name, the result is a list of all the results, so in our case, a list of three things that the user entered at the prompt.</p></div><div><p>A common pattern with <code>sequence</code> is when we map functions like <code>print</code> or <code>putStrLn</code> over lists. Doing <code>map print [1,2,3,4]</code> won't create an I/O action. It will create a list of I/O actions, because that's like writing <code>[print 1, print 2, print 3, print 4]</code>. If we want to transform that list of I/O actions into an I/O action, we have to sequence it.</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token builtin">sequence</span> <span class="token punctuation">(</span><span class="token builtin">map</span> <span class="token builtin">print</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
<span class="token number">1</span>
<span class="token number">2</span>
<span class="token number">3</span>
<span class="token number">4</span>
<span class="token number">5</span>
<span class="token punctuation">[</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">]</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>What's with the <code>[(),(),(),(),()]</code> at the end? Well, when we evaluate an I/O action in GHCI, it's performed and then its result is printed out, unless that result is <code>()</code>, in which case it's not printed out. That's why evaluating <code>putStrLn "hehe"</code> in GHCI just prints out <code>hehe</code> (because the contained result in <code>putStrLn "hehe"</code> is <code>()</code>). But when we do <code>getLine</code> in GHCI, the result of that I/O action is printed out, because <code>getLine</code> has a type of <code>IO String</code>.</p></div><div><p>Because mapping a function that returns an I/O action over a list and then sequencing it is so common, the utility functions <code>mapM</code> and <code>mapM_</code> were introduced. <code>mapM</code> takes a function and a list, maps the function over the list and then sequences it. <code>mapM_</code> does the same, only it throws away the result later. We usually use <code>mapM_</code> when we don't care what result our sequenced I/O actions have.</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token builtin">mapM</span> <span class="token builtin">print</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">]</span>
<span class="token number">1</span>
<span class="token number">2</span>
<span class="token number">3</span>
<span class="token punctuation">[</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">]</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token builtin">mapM_</span> <span class="token builtin">print</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">]</span>
<span class="token number">1</span>
<span class="token number">2</span>
<span class="token number">3</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p><code>forever</code> takes an I/O action and returns an I/O action that just repeats the I/O action it got forever. It's located in <code>Control.Monad</code>. This little program will indefinitely ask the user for some input and spit it back to him, CAPSLOCKED:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token import-statement"><span class="token keyword">import</span> Control<span class="token punctuation">.</span>Monad</span>
<span class="token import-statement"><span class="token keyword">import</span> Data<span class="token punctuation">.</span>Char</span>

<span class="token hvariable">main</span> <span class="token operator">=</span> <span class="token hvariable">forever</span> <span class="token operator">$</span> <span class="token keyword">do</span>
    <span class="token builtin">putStr</span> <span class="token string">"Give me some input: "</span>
    <span class="token hvariable">l</span> <span class="token operator">&lt;-</span> <span class="token builtin">getLine</span>
    <span class="token builtin">putStrLn</span> <span class="token operator">$</span> <span class="token builtin">map</span> <span class="token builtin">toUpper</span> <span class="token hvariable">l</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p><code>forM</code> (located in <code>Control.Monad</code>) is like <code>mapM</code>, only that it has its parameters switched around. The first parameter is the list and the second one is the function to map over that list, which is then sequenced. Why is that useful? Well, with some creative use of lambdas and <em>do</em> notation, we can do stuff like this:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token import-statement"><span class="token keyword">import</span> Control<span class="token punctuation">.</span>Monad</span>

<span class="token hvariable">main</span> <span class="token operator">=</span> <span class="token keyword">do</span> 
    <span class="token hvariable">colors</span> <span class="token operator">&lt;-</span> <span class="token hvariable">forM</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">]</span> <span class="token punctuation">(</span><span class="token operator">\</span><span class="token hvariable">a</span> <span class="token operator">-&gt;</span> <span class="token keyword">do</span>
        <span class="token builtin">putStrLn</span> <span class="token operator">$</span> <span class="token string">"Which color do you associate with the number "</span> <span class="token operator">++</span> <span class="token builtin">show</span> <span class="token hvariable">a</span> <span class="token operator">++</span> <span class="token string">"?"</span>
        <span class="token hvariable">color</span> <span class="token operator">&lt;-</span> <span class="token builtin">getLine</span>
        <span class="token builtin">return</span> <span class="token hvariable">color</span><span class="token punctuation">)</span>
    <span class="token builtin">putStrLn</span> <span class="token string">"The colors that you associate with 1, 2, 3 and 4 are: "</span>
    <span class="token builtin">mapM</span> <span class="token builtin">putStrLn</span> <span class="token hvariable">colors</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>The <code>(\a -&gt; do ... )</code> is a function that takes a number and returns an I/O action. We have to surround it with parentheses, otherwise the lambda thinks the last two I/O actions belong to it. Notice that we do <code>return color</code> in the inside <em>do</em> block. We do that so that the I/O action which the <em>do</em> block defines has the result of our color contained within it. We actually didn't have to do that, because <code>getLine</code> already has that contained within it. Doing <code>color &lt;- getLine</code> and then <code>return color</code> is just unpacking the result from <code>getLine</code> and then repackaging it again, so it's the same as just doing <code>getLine</code>. The <code>forM</code> (called with its two parameters) produces an I/O action, whose result we bind to <code>colors</code>. <code>colors</code> is just a normal list that holds strings. At the end, we print out all those colors by doing <code>mapM putStrLn colors</code>.</p></div><div><p>You can think of <code>forM</code> as meaning: make an I/O action for every element in this list. What each I/O action will do can depend on the element that was used to make the action. Finally, perform those actions and bind their results to something. We don't have to bind it, we can also just throw it away.</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token operator">$</span> <span class="token hvariable">runhaskell</span> <span class="token hvariable">form_test</span><span class="token punctuation">.</span><span class="token hvariable">hs</span>
<span class="token constant">Which</span> <span class="token hvariable">color</span> <span class="token keyword">do</span> <span class="token hvariable">you</span> <span class="token hvariable">associate</span> <span class="token hvariable">with</span> <span class="token hvariable">the</span> <span class="token hvariable">number</span> <span class="token number">1</span><span class="token operator">?</span>
<span class="token hvariable">white</span>
<span class="token constant">Which</span> <span class="token hvariable">color</span> <span class="token keyword">do</span> <span class="token hvariable">you</span> <span class="token hvariable">associate</span> <span class="token hvariable">with</span> <span class="token hvariable">the</span> <span class="token hvariable">number</span> <span class="token number">2</span><span class="token operator">?</span>
<span class="token hvariable">blue</span>
<span class="token constant">Which</span> <span class="token hvariable">color</span> <span class="token keyword">do</span> <span class="token hvariable">you</span> <span class="token hvariable">associate</span> <span class="token hvariable">with</span> <span class="token hvariable">the</span> <span class="token hvariable">number</span> <span class="token number">3</span><span class="token operator">?</span>
<span class="token hvariable">red</span>
<span class="token constant">Which</span> <span class="token hvariable">color</span> <span class="token keyword">do</span> <span class="token hvariable">you</span> <span class="token hvariable">associate</span> <span class="token hvariable">with</span> <span class="token hvariable">the</span> <span class="token hvariable">number</span> <span class="token number">4</span><span class="token operator">?</span>
<span class="token hvariable">orange</span>
<span class="token constant">The</span> <span class="token hvariable">colors</span> <span class="token hvariable">that</span> <span class="token hvariable">you</span> <span class="token hvariable">associate</span> <span class="token hvariable">with</span> <span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span> <span class="token builtin">and</span> <span class="token number">4</span> <span class="token hvariable">are</span><span class="token operator">:</span>
<span class="token hvariable">white</span>
<span class="token hvariable">blue</span>
<span class="token hvariable">red</span>
<span class="token hvariable">orange</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>We could have actually done that without <code>forM</code>, only with <code>forM</code> it's more readable. Normally we write <code>forM</code> when we want to map and sequence some actions that we define there on the spot using <em>do</em> notation. In the same vein, we could have replaced the last line with <code>forM colors putStrLn</code>.</p></div><div><p>In this section, we learned the basics of input and output. We also found out what I/O actions are, how they enable us to do input and output and when they are actually performed. To reiterate, I/O actions are values much like any other value in Haskell. We can pass them as parameters to functions and functions can return I/O actions as results. What's special about them is that if they fall into the <code>main</code> function (or are the result in a GHCI line), they are performed. And that's when they get to write stuff on your screen or play Yakety Sax through your speakers. Each I/O action can also encapsulate a result with which it tells you what it got from the real world.</p></div><div><p>Don't think of a function like <code>putStrLn</code> as a function that takes a string and prints it to the screen. Think of it as a function that takes a string and returns an I/O action. That I/O action will, when performed, print beautiful poetry to your terminal.</p></div><div><h2 data-heading="Files and streams" id="Files_and_streams" style="display: flex;"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>Files and streams</h2></div><div><p><span alt="LYHfGG_62_streams.png" src="LYHfGG_62_streams.png" class="internal-embed media-embed image-embed is-loaded"><img alt="LYHfGG_62_streams.png" src="курсы\learn-you-a-haskell-for-great-good!\картинки\lyhfgg_62_streams.png"></span></p></div><div><p><code>getChar</code> is an I/O action that reads a single character from the terminal. <code>getLine</code> is an I/O action that reads a line from the terminal. These two are pretty straightforward and most programming languages have some functions or statements that are parallel to them. But now, let's meet <code>getContents</code>. <code>getContents</code> is an I/O action that reads everything from the standard input until it encounters an end-of-file character. Its type is <code>getContents :: IO String</code>. What's cool about <code>getContents</code> is that it does lazy I/O. When we do <code>foo &lt;- getContents</code>, it doesn't read all of the input at once, store it in memory and then bind it to <code>foo</code>. No, it's lazy! It'll say: <em>"Yeah yeah, I'll read the input from the terminal later as we go along, when you really need it!"</em>.</p></div><div><p><code>getContents</code> is really useful when we're piping the output from one program into the input of our program. In case you don't know how piping works in unix-y systems, here's a quick primer. Let's make a text file that contains the following little haiku:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token constant">I'</span><span class="token hvariable">m</span> <span class="token hvariable">a</span> <span class="token hvariable">lil'</span> <span class="token hvariable">teapot</span>
<span class="token constant">What'</span><span class="token hvariable">s</span> <span class="token hvariable">with</span> <span class="token hvariable">that</span> <span class="token hvariable">airplane</span> <span class="token hvariable">food</span><span class="token punctuation">,</span> <span class="token hvariable">huh</span><span class="token operator">?</span>
<span class="token constant">It'</span><span class="token hvariable">s</span> <span class="token hvariable">so</span> <span class="token hvariable">small</span><span class="token punctuation">,</span> <span class="token hvariable">tasteless</span> 
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Yeah, the haiku sucks, what of it? If anyone knows of any good haiku tutorials, let me know.</p></div><div><p>Now, recall the little program we wrote when we were introducing the <code>forever</code> function. It prompted the user for a line, returned it to him in CAPSLOCK and then did that all over again, indefinitely. Just so you don't have to scroll all the way back, here it is again:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token import-statement"><span class="token keyword">import</span> Control<span class="token punctuation">.</span>Monad</span>
<span class="token import-statement"><span class="token keyword">import</span> Data<span class="token punctuation">.</span>Char</span>

<span class="token hvariable">main</span> <span class="token operator">=</span> <span class="token hvariable">forever</span> <span class="token operator">$</span> <span class="token keyword">do</span>
    <span class="token builtin">putStr</span> <span class="token string">"Give me some input: "</span>
    <span class="token hvariable">l</span> <span class="token operator">&lt;-</span> <span class="token builtin">getLine</span>
    <span class="token builtin">putStrLn</span> <span class="token operator">$</span> <span class="token builtin">map</span> <span class="token builtin">toUpper</span> <span class="token hvariable">l</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>We'll save that program as <code>capslocker.hs</code> or something and compile it. And then, we're going to use a unix pipe to feed our text file directly to our little program. We're going to use the help of the GNU <em>cat</em> program, which prints out a file that's given to it as an argument. Check it out, booyaka!</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token operator">$</span> <span class="token hvariable">ghc</span> <span class="token comment">--make capslocker </span>
<span class="token punctuation">[</span><span class="token number">1</span> <span class="token keyword">of</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token constant">Compiling</span> <span class="token constant">Main</span>             <span class="token punctuation">(</span> <span class="token hvariable">capslocker</span><span class="token punctuation">.</span><span class="token hvariable">hs</span><span class="token punctuation">,</span> <span class="token hvariable">capslocker</span><span class="token punctuation">.</span><span class="token hvariable">o</span> <span class="token punctuation">)</span>
<span class="token constant">Linking</span> <span class="token hvariable">capslocker</span> <span class="token operator">...</span>
<span class="token operator">$</span> <span class="token hvariable">cat</span> <span class="token hvariable">haiku</span><span class="token punctuation">.</span><span class="token hvariable">txt</span>
<span class="token constant">I'</span><span class="token hvariable">m</span> <span class="token hvariable">a</span> <span class="token hvariable">lil'</span> <span class="token hvariable">teapot</span>
<span class="token constant">What'</span><span class="token hvariable">s</span> <span class="token hvariable">with</span> <span class="token hvariable">that</span> <span class="token hvariable">airplane</span> <span class="token hvariable">food</span><span class="token punctuation">,</span> <span class="token hvariable">huh</span><span class="token operator">?</span>
<span class="token constant">It'</span><span class="token hvariable">s</span> <span class="token hvariable">so</span> <span class="token hvariable">small</span><span class="token punctuation">,</span> <span class="token hvariable">tasteless</span>
<span class="token operator">$</span> <span class="token hvariable">cat</span> <span class="token hvariable">haiku</span><span class="token punctuation">.</span><span class="token hvariable">txt</span> <span class="token operator">|</span> <span class="token operator">./</span><span class="token hvariable">capslocker</span>
<span class="token constant">I'M</span> <span class="token constant">A</span> <span class="token constant">LIL'</span> <span class="token constant">TEAPOT</span>
<span class="token constant">WHAT'S</span> <span class="token constant">WITH</span> <span class="token constant">THAT</span> <span class="token constant">AIRPLANE</span> <span class="token constant">FOOD</span><span class="token punctuation">,</span> <span class="token constant">HUH</span><span class="token operator">?</span>
<span class="token constant">IT'S</span> <span class="token constant">SO</span> <span class="token constant">SMALL</span><span class="token punctuation">,</span> <span class="token constant">TASTELESS</span>
<span class="token hvariable">capslocker</span> <span class="token operator">&lt;</span><span class="token hvariable">stdin</span><span class="token operator">&gt;:</span> <span class="token hvariable">hGetLine</span><span class="token operator">:</span> <span class="token hvariable">end</span> <span class="token keyword">of</span> <span class="token hvariable">file</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>As you can see, piping the output of one program (in our case that was <em>cat</em>) to the input of another (<em>capslocker</em>) is done with the <code>|</code> character. What we've done is pretty much equivalent to just running <em>capslocker</em>, typing our haiku at the terminal and then issuing an end-of-file character (that's usually done by pressing Ctrl-D). It's like running <em>cat haiku.txt</em> and saying: “Wait, don't print this out to the terminal, tell it to <em>capslocker</em> instead!”.</p></div><div><p>So what we're essentially doing with that use of <code>forever</code> is taking the input and transforming it into some output. That's why we can use <code>getContents</code> to make our program even shorter and better:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token import-statement"><span class="token keyword">import</span> Data<span class="token punctuation">.</span>Char</span>

<span class="token hvariable">main</span> <span class="token operator">=</span> <span class="token keyword">do</span>
    <span class="token hvariable">contents</span> <span class="token operator">&lt;-</span> <span class="token builtin">getContents</span>
    <span class="token builtin">putStr</span> <span class="token punctuation">(</span><span class="token builtin">map</span> <span class="token builtin">toUpper</span> <span class="token hvariable">contents</span><span class="token punctuation">)</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>We run the <code>getContents</code> I/O action and name the string it produces <code>contents</code>. Then, we map <code>toUpper</code> over that string and print that to the terminal. Keep in mind that because strings are basically lists, which are lazy, and <code>getContents</code> is I/O lazy, it won't try to read the whole content at once and store it into memory before printing out the capslocked version. Rather, it will print out the capslocked version as it reads it, because it will only read a line from the input when it really needs to.</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token operator">$</span> <span class="token hvariable">cat</span> <span class="token hvariable">haiku</span><span class="token punctuation">.</span><span class="token hvariable">txt</span> <span class="token operator">|</span> <span class="token operator">./</span><span class="token hvariable">capslocker</span>
<span class="token constant">I'M</span> <span class="token constant">A</span> <span class="token constant">LIL'</span> <span class="token constant">TEAPOT</span>
<span class="token constant">WHAT'S</span> <span class="token constant">WITH</span> <span class="token constant">THAT</span> <span class="token constant">AIRPLANE</span> <span class="token constant">FOOD</span><span class="token punctuation">,</span> <span class="token constant">HUH</span><span class="token operator">?</span>
<span class="token constant">IT'S</span> <span class="token constant">SO</span> <span class="token constant">SMALL</span><span class="token punctuation">,</span> <span class="token constant">TASTELESS</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Cool, it works. What if we just run <em>capslocker</em> and try to type in the lines ourselves?</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token operator">$</span> <span class="token operator">./</span><span class="token hvariable">capslocker</span>
<span class="token hvariable">hey</span> <span class="token hvariable">ho</span>
<span class="token constant">HEY</span> <span class="token constant">HO</span>
<span class="token hvariable">lets</span> <span class="token hvariable">go</span>
<span class="token constant">LETS</span> <span class="token constant">GO</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>We got out of that by pressing Ctrl-D. Pretty nice! As you can see, it prints out our capslocked input back to us line by line. When the result of <code>getContents</code> is bound to <code>contents</code>, it's not represented in memory as a real string, but more like a promise that it will produce the string eventually. When we map <code>toUpper</code> over <code>contents</code>, that's also a promise to map that function over the eventual contents. And finally when <code>putStr</code> happens, it says to the previous promise: <em>"Hey, I need a capslocked line!"</em>. It doesn't have any lines yet, so it says to <code>contents</code>: <em>"Hey, how about actually getting a line from the terminal?"</em>. So that's when <code>getContents</code> actually reads from the terminal and gives a line to the code that asked it to produce something tangible. That code then maps <code>toUpper</code> over that line and gives it to <code>putStr</code>, which prints it. And then, <code>putStr</code> says: <em>"Hey, I need the next line, come on!"</em> and this repeats until there's no more input, which is signified by an end-of-file character.</p></div><div><p>Let's make program that takes some input and prints out only those lines that are shorter than 10 characters. Observe:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">main</span> <span class="token operator">=</span> <span class="token keyword">do</span>
    <span class="token hvariable">contents</span> <span class="token operator">&lt;-</span> <span class="token builtin">getContents</span>
    <span class="token builtin">putStr</span> <span class="token punctuation">(</span><span class="token hvariable">shortLinesOnly</span> <span class="token hvariable">contents</span><span class="token punctuation">)</span>

<span class="token hvariable">shortLinesOnly</span> <span class="token operator">::</span> <span class="token constant">String</span> <span class="token operator">-&gt;</span> <span class="token constant">String</span>
<span class="token hvariable">shortLinesOnly</span> <span class="token hvariable">input</span> <span class="token operator">=</span> 
    <span class="token keyword">let</span> <span class="token hvariable">allLines</span> <span class="token operator">=</span> <span class="token builtin">lines</span> <span class="token hvariable">input</span>
        <span class="token hvariable">shortLines</span> <span class="token operator">=</span> <span class="token builtin">filter</span> <span class="token punctuation">(</span><span class="token operator">\</span><span class="token hvariable">line</span> <span class="token operator">-&gt;</span> <span class="token builtin">length</span> <span class="token hvariable">line</span> <span class="token operator">&lt;</span> <span class="token number">10</span><span class="token punctuation">)</span> <span class="token hvariable">allLines</span>
        <span class="token hvariable">result</span> <span class="token operator">=</span> <span class="token builtin">unlines</span> <span class="token hvariable">shortLines</span>
    <span class="token keyword">in</span>  <span class="token hvariable">result</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>We've made our I/O part of the program as short as possible. Because our program is supposed to take some input and print out some output based on the input, we can implement it by reading the input contents, running a function on them and then printing out what the function gave back.</p></div><div><p>The <code>shortLinesOnly</code> function works like this: it takes a string, like <code>"short\nlooooooooooooooong\nshort again"</code>. That string has three lines, two of them are short and the middle one is long. It runs the <code>lines</code> function on that string, which converts it to <code>["short", "looooooooooooooong", "short again"]</code>, which we then bind to the name <code>allLines</code>. That list of string is then filtered so that only those lines that are shorter than 10 characters remain in the list, producing <code>["short", "short again"]</code>. And finally, <code>unlines</code> joins that list into a single newline delimited string, giving <code>"short\nshort again"</code>. Let's give it a go.</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">i'm</span> <span class="token hvariable">short</span>
<span class="token hvariable">so</span> <span class="token hvariable">am</span> <span class="token hvariable">i</span>
<span class="token hvariable">i</span> <span class="token hvariable">am</span> <span class="token hvariable">a</span> <span class="token hvariable">loooooooooong</span> <span class="token hvariable">line</span><span class="token operator">!!!</span>
<span class="token hvariable">yeah</span> <span class="token hvariable">i'm</span> <span class="token hvariable">long</span> <span class="token hvariable">so</span> <span class="token hvariable">what</span> <span class="token hvariable">hahahaha</span><span class="token operator">!!!!!!</span>
<span class="token hvariable">short</span> <span class="token hvariable">line</span>
<span class="token hvariable">loooooooooooooooooooooooooooong</span>
<span class="token hvariable">short</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token operator">$</span> <span class="token hvariable">ghc</span> <span class="token comment">--make shortlinesonly</span>
<span class="token punctuation">[</span><span class="token number">1</span> <span class="token keyword">of</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token constant">Compiling</span> <span class="token constant">Main</span>             <span class="token punctuation">(</span> <span class="token hvariable">shortlinesonly</span><span class="token punctuation">.</span><span class="token hvariable">hs</span><span class="token punctuation">,</span> <span class="token hvariable">shortlinesonly</span><span class="token punctuation">.</span><span class="token hvariable">o</span> <span class="token punctuation">)</span>
<span class="token constant">Linking</span> <span class="token hvariable">shortlinesonly</span> <span class="token operator">...</span>
<span class="token operator">$</span> <span class="token hvariable">cat</span> <span class="token hvariable">shortlines</span><span class="token punctuation">.</span><span class="token hvariable">txt</span> <span class="token operator">|</span> <span class="token operator">./</span><span class="token hvariable">shortlinesonly</span>
<span class="token hvariable">i'm</span> <span class="token hvariable">short</span>
<span class="token hvariable">so</span> <span class="token hvariable">am</span> <span class="token hvariable">i</span>
<span class="token hvariable">short</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>We pipe the contents of <em>shortlines.txt</em> into the output of <em>shortlinesonly</em> and as the output, we only get the short lines.</p></div><div><p>This pattern of getting some string from the input, transforming it with a function and then outputting that is so common that there exists a function which makes that even easier, called <code>interact</code>. <code>interact</code> takes a function of type <code>String -&gt; String</code> as a parameter and returns an I/O action that will take some input, run that function on it and then print out the function's result. Let's modify our program to use that.</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">main</span> <span class="token operator">=</span> <span class="token builtin">interact</span> <span class="token hvariable">shortLinesOnly</span>

<span class="token hvariable">shortLinesOnly</span> <span class="token operator">::</span> <span class="token constant">String</span> <span class="token operator">-&gt;</span> <span class="token constant">String</span>
<span class="token hvariable">shortLinesOnly</span> <span class="token hvariable">input</span> <span class="token operator">=</span> 
    <span class="token keyword">let</span> <span class="token hvariable">allLines</span> <span class="token operator">=</span> <span class="token builtin">lines</span> <span class="token hvariable">input</span>
        <span class="token hvariable">shortLines</span> <span class="token operator">=</span> <span class="token builtin">filter</span> <span class="token punctuation">(</span><span class="token operator">\</span><span class="token hvariable">line</span> <span class="token operator">-&gt;</span> <span class="token builtin">length</span> <span class="token hvariable">line</span> <span class="token operator">&lt;</span> <span class="token number">10</span><span class="token punctuation">)</span> <span class="token hvariable">allLines</span>
        <span class="token hvariable">result</span> <span class="token operator">=</span> <span class="token builtin">unlines</span> <span class="token hvariable">shortLines</span>
    <span class="token keyword">in</span>  <span class="token hvariable">result</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Just to show that this can be achieved in much less code (even though it will be less readable) and to demonstrate our function composition skill, we're going to rework that a bit further.</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">main</span> <span class="token operator">=</span> <span class="token builtin">interact</span> <span class="token operator">$</span> <span class="token builtin">unlines</span> <span class="token operator">.</span> <span class="token builtin">filter</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token operator">&lt;</span><span class="token number">10</span><span class="token punctuation">)</span> <span class="token operator">.</span> <span class="token builtin">length</span><span class="token punctuation">)</span> <span class="token operator">.</span> <span class="token builtin">lines</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Wow, we actually reduced that to just one line, which is pretty cool!</p></div><div><p><code>interact</code> can be used to make programs that are piped some contents into them and then dump some result out or it can be used to make programs that appear to take a line of input from the user, give back some result based on that line and then take another line and so on. There isn't actually a real distinction between the two, it just depends on how the user is supposed to use them.</p></div><div><p>Let's make a program that continuously reads a line and then tells us if the line is a palindrome or not. We could just use <code>getLine</code> to read a line, tell the user if it's a palindrome and then run <code>main</code> all over again. But it's simpler if we use <code>interact</code>. When using <code>interact</code>, think about what you need to do to transform some input into the desired output. In our case, we have to replace each line of the input with either <code>"palindrome"</code> or <code>"not a palindrome"</code>. So we have to write a function that transforms something like <code>"elephant\nABCBA\nwhatever"</code> into <code>"not a palindrome\npalindrome\nnot a palindrome"</code>. Let's do this!</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">respondPalindromes</span> <span class="token hvariable">contents</span> <span class="token operator">=</span> <span class="token builtin">unlines</span> <span class="token punctuation">(</span><span class="token builtin">map</span> <span class="token punctuation">(</span><span class="token operator">\</span><span class="token hvariable">xs</span> <span class="token operator">-&gt;</span> <span class="token keyword">if</span> <span class="token hvariable">isPalindrome</span> <span class="token hvariable">xs</span> <span class="token keyword">then</span> <span class="token string">"palindrome"</span> <span class="token keyword">else</span> <span class="token string">"not a palindrome"</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token builtin">lines</span> <span class="token hvariable">contents</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token keyword">where</span>   <span class="token hvariable">isPalindrome</span> <span class="token hvariable">xs</span> <span class="token operator">=</span> <span class="token hvariable">xs</span> <span class="token operator">==</span> <span class="token builtin">reverse</span> <span class="token hvariable">xs</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Let's write this in point-free.</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">respondPalindromes</span> <span class="token operator">=</span> <span class="token builtin">unlines</span> <span class="token operator">.</span> <span class="token builtin">map</span> <span class="token punctuation">(</span><span class="token operator">\</span><span class="token hvariable">xs</span> <span class="token operator">-&gt;</span> <span class="token keyword">if</span> <span class="token hvariable">isPalindrome</span> <span class="token hvariable">xs</span> <span class="token keyword">then</span> <span class="token string">"palindrome"</span> <span class="token keyword">else</span> <span class="token string">"not a palindrome"</span><span class="token punctuation">)</span> <span class="token operator">.</span> <span class="token builtin">lines</span>
    <span class="token keyword">where</span>   <span class="token hvariable">isPalindrome</span> <span class="token hvariable">xs</span> <span class="token operator">=</span> <span class="token hvariable">xs</span> <span class="token operator">==</span> <span class="token builtin">reverse</span> <span class="token hvariable">xs</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Pretty straightforward. First it turns something like <code>"elephant\nABCBA\nwhatever"</code> into <code>["elephant", "ABCBA", "whatever"]</code> and then it maps that lambda over it, giving <code>["not a palindrome", "palindrome", "not a palindrome"]</code> and then <code>unlines</code> joins that list into a single, newline delimited string. Now we can do</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">main</span> <span class="token operator">=</span> <span class="token builtin">interact</span> <span class="token hvariable">respondPalindromes</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Let's test this out:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token operator">$</span> <span class="token hvariable">runhaskell</span> <span class="token hvariable">palindromes</span><span class="token punctuation">.</span><span class="token hvariable">hs</span>
<span class="token hvariable">hehe</span>
<span class="token builtin">not</span> <span class="token hvariable">a</span> <span class="token hvariable">palindrome</span>
<span class="token constant">ABCBA</span>
<span class="token hvariable">palindrome</span>
<span class="token hvariable">cookie</span>
<span class="token builtin">not</span> <span class="token hvariable">a</span> <span class="token hvariable">palindrome</span>

</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Even though we made a program that transforms one big string of input into another, it acts like we made a program that does it line by line. That's because Haskell is lazy and it wants to print the first line of the result string, but it can't because it doesn't have the first line of the input yet. So as soon as we give it the first line of input, it prints the first line of the output. We get out of the program by issuing an end-of-line character.</p></div><div><p>We can also use this program by just piping a file into it. Let's say we have this file:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">dogaroo</span>
<span class="token hvariable">radar</span>
<span class="token hvariable">rotor</span>
<span class="token hvariable">madam</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>and we save it as <code>words.txt</code>. This is what we get by piping it into our program:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token operator">$</span> <span class="token hvariable">cat</span> <span class="token builtin">words</span><span class="token punctuation">.</span><span class="token hvariable">txt</span> <span class="token operator">|</span> <span class="token hvariable">runhaskell</span> <span class="token hvariable">palindromes</span><span class="token punctuation">.</span><span class="token hvariable">hs</span>
<span class="token builtin">not</span> <span class="token hvariable">a</span> <span class="token hvariable">palindrome</span>
<span class="token hvariable">palindrome</span>
<span class="token hvariable">palindrome</span>
<span class="token hvariable">palindrome</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Again, we get the same output as if we had run our program and put in the words ourselves at the standard input. We just don't see the input that <code>palindromes.hs</code> because the input came from the file and not from us typing the words in.</p></div><div><p>So now you probably see how lazy I/O works and how we can use it to our advantage. You can just think in terms of what the output is supposed to be for some given input and write a function to do that transformation. In lazy I/O, nothing is eaten from the input until it absolutely has to be because what we want to print right now depends on that input.</p></div><div><p>So far, we've worked with I/O by printing out stuff to the terminal and reading from it. But what about reading and writing files? Well, in a way, we've already been doing that. One way to think about reading from the terminal is to imagine that it's like reading from a (somewhat special) file. Same goes for writing to the terminal, it's kind of like writing to a file. We can call these two files <code>stdout</code> and <code>stdin</code>, meaning <em>standard output</em> and <em>standard input</em>, respectively. Keeping that in mind, we'll see that writing to and reading from files is very much like writing to the standard output and reading from the standard input.</p></div><div><p>We'll start off with a really simple program that opens a file called <em>girlfriend.txt</em>, which contains a verse from Avril Lavigne's #1 hit <em>Girlfriend</em>, and just prints out out to the terminal. Here's <em>girlfriend.txt</em>:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token constant">Hey</span><span class="token operator">!</span> <span class="token constant">Hey</span><span class="token operator">!</span> <span class="token constant">You</span><span class="token operator">!</span> <span class="token constant">You</span><span class="token operator">!</span> 
<span class="token constant">I</span> <span class="token hvariable">don't</span> <span class="token hvariable">like</span> <span class="token hvariable">your</span> <span class="token hvariable">girlfriend</span><span class="token operator">!</span> 
<span class="token constant">No</span> <span class="token hvariable">way</span><span class="token operator">!</span> <span class="token constant">No</span> <span class="token hvariable">way</span><span class="token operator">!</span> 
<span class="token constant">I</span> <span class="token hvariable">think</span> <span class="token hvariable">you</span> <span class="token hvariable">need</span> <span class="token hvariable">a</span> <span class="token hvariable">new</span> <span class="token hvariable">one</span><span class="token operator">!</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>And here's our program:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token import-statement"><span class="token keyword">import</span> System<span class="token punctuation">.</span>IO</span>

<span class="token hvariable">main</span> <span class="token operator">=</span> <span class="token keyword">do</span>
    <span class="token hvariable">handle</span> <span class="token operator">&lt;-</span> <span class="token hvariable">openFile</span> <span class="token string">"girlfriend.txt"</span> <span class="token constant">ReadMode</span>
    <span class="token hvariable">contents</span> <span class="token operator">&lt;-</span> <span class="token hvariable">hGetContents</span> <span class="token hvariable">handle</span>
    <span class="token builtin">putStr</span> <span class="token hvariable">contents</span>
    <span class="token hvariable">hClose</span> <span class="token hvariable">handle</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Running it, we get the expected result:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token operator">$</span> <span class="token hvariable">runhaskell</span> <span class="token hvariable">girlfriend</span><span class="token punctuation">.</span><span class="token hvariable">hs</span>
<span class="token constant">Hey</span><span class="token operator">!</span> <span class="token constant">Hey</span><span class="token operator">!</span> <span class="token constant">You</span><span class="token operator">!</span> <span class="token constant">You</span><span class="token operator">!</span>
<span class="token constant">I</span> <span class="token hvariable">don't</span> <span class="token hvariable">like</span> <span class="token hvariable">your</span> <span class="token hvariable">girlfriend</span><span class="token operator">!</span>
<span class="token constant">No</span> <span class="token hvariable">way</span><span class="token operator">!</span> <span class="token constant">No</span> <span class="token hvariable">way</span><span class="token operator">!</span>
<span class="token constant">I</span> <span class="token hvariable">think</span> <span class="token hvariable">you</span> <span class="token hvariable">need</span> <span class="token hvariable">a</span> <span class="token hvariable">new</span> <span class="token hvariable">one</span><span class="token operator">!</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Let's go over this line by line. The first line is just four exclamations, to get our attention. In the second line, Avril tells us that she doesn't like our current romantic partner. The third line serves to emphasize that disapproval, whereas the fourth line suggests we should seek out a new girlfriend.</p></div><div><p>Let's also go over the program line by line! Our program is several I/O actions glued together with a <em>do</em> block. In the first line of the <em>do</em> block, we notice a new function called <code>openFile</code>. This is its type signature: <code>openFile :: FilePath -&gt; IOMode -&gt; IO Handle</code>. If you read that out loud, it states: <code>openFile</code> takes a file path and an <code>IOMode</code> and returns an I/O action that will open a file and have the file's associated handle encapsulated as its result.</p></div><div><p><code>FilePath</code> is just a <a data-tooltip-position="top" aria-label="http://learnyouahaskell.com/making-our-own-types-and-typeclasses#type-synonyms" rel="noopener" class="external-link" href="http://learnyouahaskell.com/making-our-own-types-and-typeclasses#type-synonyms" target="_blank">type synonym</a> for <code>String</code>, simply defined as:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token keyword">type</span> <span class="token constant">FilePath</span> <span class="token operator">=</span> <span class="token constant">String</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p><code>IOMode</code> is a type that's defined like this:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token keyword">data</span> <span class="token constant">IOMode</span> <span class="token operator">=</span> <span class="token constant">ReadMode</span> <span class="token operator">|</span> <span class="token constant">WriteMode</span> <span class="token operator">|</span> <span class="token constant">AppendMode</span> <span class="token operator">|</span> <span class="token constant">ReadWriteMode</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p><span alt="LYHfGG_63_file.png" src="LYHfGG_63_file.png" class="internal-embed media-embed image-embed is-loaded"><img alt="LYHfGG_63_file.png" src="курсы\learn-you-a-haskell-for-great-good!\картинки\lyhfgg_63_file.png"></span></p></div><div><p>Just like our type that represents the seven possible values for the days of the week, this type is an enumeration that represents what we want to do with our opened file. Very simple. Just note that this type is <code>IOMode</code> and not <code>IO Mode</code>. <code>IO Mode</code> would be the type of an I/O action that has a value of some type <code>Mode</code> as its result, but <code>IOMode</code> is just a simple enumeration.</p></div><div><p>Finally, it returns an I/O action that will open the specified file in the specified mode. If we bind that action to something we get a <code>Handle</code>. A value of type <code>Handle</code> represents where our file is. We'll use that handle so we know which file to read from. It would be stupid to read a file but not bind that read to a handle because we wouldn't be able to do anything with the file. So in our case, we bound the handle to <code>handle</code>.</p></div><div><p>In the next line, we see a function called <code>hGetContents</code>. It takes a <code>Handle</code>, so it knows which file to get the contents from and returns an <code>IO String</code> — an I/O action that holds as its result the contents of the file. This function is pretty much like <code>getContents</code>. The only difference is that <code>getContents</code> will automatically read from the standard input (that is from the terminal), whereas <code>hGetContents</code> takes a file handle which tells it which file to read from. In all other respects, they work the same. And just like <code>getContents</code>, <code>hGetContents</code> won't attempt to read the file at once and store it in memory, but it will read it as needed. That's really cool because we can treat <code>contents</code> as the whole contents of the file, but it's not really loaded in memory. So if this were a really huge file, doing <code>hGetContents</code> wouldn't choke up our memory, but it would read only what it needed to from the file, when it needed to.</p></div><div><p>Note the difference between the handle used to identify a file and the contents of the file, bound in our program to <code>handle</code> and <code>contents</code>. The handle is just something by which we know what our file is. If you imagine your whole file system to be a really big book and each file is a chapter in the book, the handle is a bookmark that shows where you're currently reading (or writing) a chapter, whereas the contents are the actual chapter.</p></div><div><p>With <code>putStr contents</code> we just print the contents out to the standard output and then we do <code>hClose</code>, which takes a handle and returns an I/O action that closes the file. You have to close the file yourself after opening it with <code>openFile</code>!</p></div><div><p>Another way of doing what we just did is to use the <code>withFile</code> function, which has a type signature of <code>withFile :: FilePath -&gt; IOMode -&gt; (Handle -&gt; IO a) -&gt; IO a</code>. It takes a path to a file, an <code>IOMode</code> and then it takes a function that takes a handle and returns some I/O action. What it returns is an I/O action that will open that file, do something we want with the file and then close it. The result encapsulated in the final I/O action that's returned is the same as the result of the I/O action that the function we give it returns. This might sound a bit complicated, but it's really simple, especially with lambdas, here's our previous example rewritten to use <code>withFile</code>:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token import-statement"><span class="token keyword">import</span> System<span class="token punctuation">.</span>IO</span>   
  
<span class="token hvariable">main</span> <span class="token operator">=</span> <span class="token keyword">do</span>   
    <span class="token hvariable">withFile</span> <span class="token string">"girlfriend.txt"</span> <span class="token constant">ReadMode</span> <span class="token punctuation">(</span><span class="token operator">\</span><span class="token hvariable">handle</span> <span class="token operator">-&gt;</span> <span class="token keyword">do</span>
        <span class="token hvariable">contents</span> <span class="token operator">&lt;-</span> <span class="token hvariable">hGetContents</span> <span class="token hvariable">handle</span>   
        <span class="token builtin">putStr</span> <span class="token hvariable">contents</span><span class="token punctuation">)</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>As you can see, it's very similar to the previous piece of code. <code>(\handle -&gt; ... )</code> is the function that takes a handle and returns an I/O action and it's usually done like this, with a lambda. The reason it has to take a function that returns an I/O action instead of just taking an I/O action to do and then close the file is because the I/O action that we'd pass to it wouldn't know on which file to operate. This way, <code>withFile</code> opens the file and then passes the handle to the function we gave it. It gets an I/O action back from that function and then makes an I/O action that's just like it, only it closes the file afterwards. Here's how we can make our own <code>withFile</code> function:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">withFile'</span> <span class="token operator">::</span> <span class="token constant">FilePath</span> <span class="token operator">-&gt;</span> <span class="token constant">IOMode</span> <span class="token operator">-&gt;</span> <span class="token punctuation">(</span><span class="token constant">Handle</span> <span class="token operator">-&gt;</span> <span class="token constant">IO</span> <span class="token hvariable">a</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token constant">IO</span> <span class="token hvariable">a</span>
<span class="token hvariable">withFile'</span> <span class="token hvariable">path</span> <span class="token hvariable">mode</span> <span class="token hvariable">f</span> <span class="token operator">=</span> <span class="token keyword">do</span>
    <span class="token hvariable">handle</span> <span class="token operator">&lt;-</span> <span class="token hvariable">openFile</span> <span class="token hvariable">path</span> <span class="token hvariable">mode</span> 
    <span class="token hvariable">result</span> <span class="token operator">&lt;-</span> <span class="token hvariable">f</span> <span class="token hvariable">handle</span>
    <span class="token hvariable">hClose</span> <span class="token hvariable">handle</span>
    <span class="token builtin">return</span> <span class="token hvariable">result</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p><span alt="LYHfGG_64_edd.png" src="LYHfGG_64_edd.png" class="internal-embed media-embed image-embed is-loaded"><img alt="LYHfGG_64_edd.png" src="курсы\learn-you-a-haskell-for-great-good!\картинки\lyhfgg_64_edd.png"></span></p></div><div><p>We know the result will be an I/O action so we can just start off with a <em>do</em>. First we open the file and get a handle from it. Then, we apply <code>handle</code> to our function to get back the I/O action that does all the work. We bind that action to <code>result</code>, close the handle and then do <code>return result</code>. By <code>return</code>ing the result encapsulated in the I/O action that we got from <code>f</code>, we make it so that our I/O action encapsulates the same result as the one we got from <code>f handle</code>. So if <code>f handle</code> returns an action that will read a number of lines from the standard input and write them to a file and have as its result encapsulated the number of lines it read, if we used that with <code>withFile'</code>, the resulting I/O action would also have as its result the number of lines read.</p></div><div><p>Just like we have <code>hGetContents</code> that works like <code>getContents</code> but for a specific file, there's also <code>hGetLine</code>, <code>hPutStr</code>, <code>hPutStrLn</code>, <code>hGetChar</code>, etc. They work just like their counterparts without the <em>h</em>, only they take a handle as a parameter and operate on that specific file instead of operating on standard input or standard output. Example: <code>putStrLn</code> is a function that takes a string and returns an I/O action that will print out that string to the terminal and a newline after it. <code>hPutStrLn</code> takes a handle and a string and returns an I/O action that will write that string to the file associated with the handle and then put a newline after it. In the same vein, <code>hGetLine</code> takes a handle and returns an I/O action that reads a line from its file.</p></div><div><p>Loading files and then treating their contents as strings is so common that we have these three nice little functions to make our work even easier:</p></div><div><p><code>readFile</code> has a type signature of <code>readFile :: FilePath -&gt; IO String</code>. Remember, <code>FilePath</code> is just a fancy name for <code>String</code>. <code>readFile</code> takes a path to a file and returns an I/O action that will read that file (lazily, of course) and bind its contents to something as a string. It's usually more handy than doing <code>openFile</code> and binding it to a handle and then doing <code>hGetContents</code>. Here's how we could have written our previous example with <code>readFile</code>:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token import-statement"><span class="token keyword">import</span> System<span class="token punctuation">.</span>IO</span>

<span class="token hvariable">main</span> <span class="token operator">=</span> <span class="token keyword">do</span>
    <span class="token hvariable">contents</span> <span class="token operator">&lt;-</span> <span class="token builtin">readFile</span> <span class="token string">"girlfriend.txt"</span>
    <span class="token builtin">putStr</span> <span class="token hvariable">contents</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Because we don't get a handle with which to identify our file, we can't close it manually, so Haskell does that for us when we use <code>readFile</code>.</p></div><div><p><code>writeFile</code> has a type of <code>writeFile :: FilePath -&gt; String -&gt; IO ()</code>. It takes a path to a file and a string to write to that file and returns an I/O action that will do the writing. If such a file already exists, it will be stomped down to zero length before being written on. Here's how to turn <em>girlfriend.txt</em> into a CAPSLOCKED version and write it to <em>girlfriendcaps.txt</em>:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token import-statement"><span class="token keyword">import</span> System<span class="token punctuation">.</span>IO</span>   
<span class="token import-statement"><span class="token keyword">import</span> Data<span class="token punctuation">.</span>Char</span>
  
<span class="token hvariable">main</span> <span class="token operator">=</span> <span class="token keyword">do</span>   
    <span class="token hvariable">contents</span> <span class="token operator">&lt;-</span> <span class="token builtin">readFile</span> <span class="token string">"girlfriend.txt"</span>   
    <span class="token builtin">writeFile</span> <span class="token string">"girlfriendcaps.txt"</span> <span class="token punctuation">(</span><span class="token builtin">map</span> <span class="token builtin">toUpper</span> <span class="token hvariable">contents</span><span class="token punctuation">)</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token operator">$</span> <span class="token hvariable">runhaskell</span> <span class="token hvariable">girlfriendtocaps</span><span class="token punctuation">.</span><span class="token hvariable">hs</span>
<span class="token operator">$</span> <span class="token hvariable">cat</span> <span class="token hvariable">girlfriendcaps</span><span class="token punctuation">.</span><span class="token hvariable">txt</span>
<span class="token constant">HEY</span><span class="token operator">!</span> <span class="token constant">HEY</span><span class="token operator">!</span> <span class="token constant">YOU</span><span class="token operator">!</span> <span class="token constant">YOU</span><span class="token operator">!</span>
<span class="token constant">I</span> <span class="token constant">DON'T</span> <span class="token constant">LIKE</span> <span class="token constant">YOUR</span> <span class="token constant">GIRLFRIEND</span><span class="token operator">!</span>
<span class="token constant">NO</span> <span class="token constant">WAY</span><span class="token operator">!</span> <span class="token constant">NO</span> <span class="token constant">WAY</span><span class="token operator">!</span>
<span class="token constant">I</span> <span class="token constant">THINK</span> <span class="token constant">YOU</span> <span class="token constant">NEED</span> <span class="token constant">A</span> <span class="token constant">NEW</span> <span class="token constant">ONE</span><span class="token operator">!</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p><code>appendFile</code> has a type signature that's just like <code>writeFile</code>, only <code>appendFile</code> doesn't truncate the file to zero length if it already exists but it appends stuff to it.</p></div><div><p>Let's say we have a file <em>todo.txt</em> that has one task per line that we have to do. Now let's make a program that takes a line from the standard input and adds that to our to-do list.</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token import-statement"><span class="token keyword">import</span> System<span class="token punctuation">.</span>IO</span>   
  
<span class="token hvariable">main</span> <span class="token operator">=</span> <span class="token keyword">do</span>   
    <span class="token hvariable">todoItem</span> <span class="token operator">&lt;-</span> <span class="token builtin">getLine</span>
    <span class="token builtin">appendFile</span> <span class="token string">"todo.txt"</span> <span class="token punctuation">(</span><span class="token hvariable">todoItem</span> <span class="token operator">++</span> <span class="token string">"\n"</span><span class="token punctuation">)</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token operator">$</span> <span class="token hvariable">runhaskell</span> <span class="token hvariable">appendtodo</span><span class="token punctuation">.</span><span class="token hvariable">hs</span>
<span class="token constant">Iron</span> <span class="token hvariable">the</span> <span class="token hvariable">dishes</span>
<span class="token operator">$</span> <span class="token hvariable">runhaskell</span> <span class="token hvariable">appendtodo</span><span class="token punctuation">.</span><span class="token hvariable">hs</span>
<span class="token constant">Dust</span> <span class="token hvariable">the</span> <span class="token hvariable">dog</span>
<span class="token operator">$</span> <span class="token hvariable">runhaskell</span> <span class="token hvariable">appendtodo</span><span class="token punctuation">.</span><span class="token hvariable">hs</span>
<span class="token constant">Take</span> <span class="token hvariable">salad</span> <span class="token hvariable">out</span> <span class="token keyword">of</span> <span class="token hvariable">the</span> <span class="token hvariable">oven</span>
<span class="token operator">$</span> <span class="token hvariable">cat</span> <span class="token hvariable">todo</span><span class="token punctuation">.</span><span class="token hvariable">txt</span>
<span class="token constant">Iron</span> <span class="token hvariable">the</span> <span class="token hvariable">dishes</span>
<span class="token constant">Dust</span> <span class="token hvariable">the</span> <span class="token hvariable">dog</span>
<span class="token constant">Take</span> <span class="token hvariable">salad</span> <span class="token hvariable">out</span> <span class="token keyword">of</span> <span class="token hvariable">the</span> <span class="token hvariable">oven</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>We needed to add the <code>"\n"</code> to the end of each line because <code>getLine</code> doesn't give us a newline character at the end.</p></div><div><p>Ooh, one more thing. We talked about how doing <code>contents &lt;- hGetContents handle</code> doesn't cause the whole file to be read at once and stored in-memory. It's I/O lazy, so doing this:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">main</span> <span class="token operator">=</span> <span class="token keyword">do</span> 
    <span class="token hvariable">withFile</span> <span class="token string">"something.txt"</span> <span class="token constant">ReadMode</span> <span class="token punctuation">(</span><span class="token operator">\</span><span class="token hvariable">handle</span> <span class="token operator">-&gt;</span> <span class="token keyword">do</span>
        <span class="token hvariable">contents</span> <span class="token operator">&lt;-</span> <span class="token hvariable">hGetContents</span> <span class="token hvariable">handle</span>
        <span class="token builtin">putStr</span> <span class="token hvariable">contents</span><span class="token punctuation">)</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>is actually like connecting a pipe from the file to the output. Just like you can think of lists as streams, you can also think of files as streams. This will read one line at a time and print it out to the terminal as it goes along. So you may be asking, how wide is this pipe then? How often will the disk be accessed? Well, for text files, the default buffering is line-buffering usually. That means that the smallest part of the file to be read at once is one line. That's why in this case it actually reads a line, prints it to the output, reads the next line, prints it, etc. For binary files, the default buffering is usually block-buffering. That means that it will read the file chunk by chunk. The chunk size is some size that your operating system thinks is cool.</p></div><div><p>You can control how exactly buffering is done by using the <code>hSetBuffering</code> function. It takes a handle and a <code>BufferMode</code> and returns an I/O action that sets the buffering. <code>BufferMode</code> is a simple enumeration data type and the possible values it can hold are: <code>NoBuffering</code>, <code>LineBuffering</code> or <code>BlockBuffering (Maybe Int)</code>. The <code>Maybe Int</code> is for how big the chunk should be, in bytes. If it's <code>Nothing</code>, then the operating system determines the chunk size. <code>NoBuffering</code> means that it will be read one character at a time. <code>NoBuffering</code> usually sucks as a buffering mode because it has to access the disk so much.</p></div><div><p>Here's our previous piece of code, only it doesn't read it line by line but reads the whole file in chunks of 2048 bytes.</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">main</span> <span class="token operator">=</span> <span class="token keyword">do</span> 
    <span class="token hvariable">withFile</span> <span class="token string">"something.txt"</span> <span class="token constant">ReadMode</span> <span class="token punctuation">(</span><span class="token operator">\</span><span class="token hvariable">handle</span> <span class="token operator">-&gt;</span> <span class="token keyword">do</span>
        <span class="token hvariable">hSetBuffering</span> <span class="token hvariable">handle</span> <span class="token operator">$</span> <span class="token constant">BlockBuffering</span> <span class="token punctuation">(</span><span class="token constant">Just</span> <span class="token number">2048</span><span class="token punctuation">)</span>
        <span class="token hvariable">contents</span> <span class="token operator">&lt;-</span> <span class="token hvariable">hGetContents</span> <span class="token hvariable">handle</span>
        <span class="token builtin">putStr</span> <span class="token hvariable">contents</span><span class="token punctuation">)</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Reading files in bigger chunks can help if we want to minimize disk access or when our file is actually a slow network resource.</p></div><div><p>We can also use <code>hFlush</code>, which is a function that takes a handle and returns an I/O action that will flush the buffer of the file associated with the handle. When we're doing line-buffering, the buffer is flushed after every line. When we're doing block-buffering, it's after we've read a chunk. It's also flushed after closing a handle. That means that when we've reached a newline character, the reading (or writing) mechanism reports all the data so far. But we can use <code>hFlush</code> to force that reporting of data that has been read so far. After flushing, the data is available to other programs that are running at the same time.</p></div><div><p>Think of reading a block-buffered file like this: your toilet bowl is set to flush itself after it has one gallon of water inside it. So you start pouring in water and once the gallon mark is reached, that water is automatically flushed and the data in the water that you've poured in so far is read. But you can flush the toilet manually too by pressing the button on the toilet. This makes the toilet flush and all the water (data) inside the toilet is read. In case you haven't noticed, flushing the toilet manually is a metaphor for <code>hFlush</code>. This is not a very great analogy by programming analogy standards, but I wanted a real world object that can be flushed for the punchline.</p></div><div><p>We already made a program to add a new item to our to-do list in <em>todo.txt</em>, now let's make a program to remove an item. I'll just paste the code and then we'll go over the program together so you see that it's really easy. We'll be using a few new functions from <code>System.Directory</code> and one new function from <code>System.IO</code>, but they'll all be explained.</p></div><div><p>Anyway, here's the program for removing an item from <em>todo.txt</em>:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token import-statement"><span class="token keyword">import</span> System<span class="token punctuation">.</span>IO</span>
<span class="token import-statement"><span class="token keyword">import</span> System<span class="token punctuation">.</span>Directory</span>
<span class="token import-statement"><span class="token keyword">import</span> Data<span class="token punctuation">.</span>List</span>

<span class="token hvariable">main</span> <span class="token operator">=</span> <span class="token keyword">do</span>      
    <span class="token hvariable">handle</span> <span class="token operator">&lt;-</span> <span class="token hvariable">openFile</span> <span class="token string">"todo.txt"</span> <span class="token constant">ReadMode</span>
    <span class="token punctuation">(</span><span class="token hvariable">tempName</span><span class="token punctuation">,</span> <span class="token hvariable">tempHandle</span><span class="token punctuation">)</span> <span class="token operator">&lt;-</span> <span class="token hvariable">openTempFile</span> <span class="token string">"."</span> <span class="token string">"temp"</span>
    <span class="token hvariable">contents</span> <span class="token operator">&lt;-</span> <span class="token hvariable">hGetContents</span> <span class="token hvariable">handle</span>
    <span class="token keyword">let</span> <span class="token hvariable">todoTasks</span> <span class="token operator">=</span> <span class="token builtin">lines</span> <span class="token hvariable">contents</span>   
        <span class="token hvariable">numberedTasks</span> <span class="token operator">=</span> <span class="token builtin">zipWith</span> <span class="token punctuation">(</span><span class="token operator">\</span><span class="token hvariable">n</span> <span class="token hvariable">line</span> <span class="token operator">-&gt;</span> <span class="token builtin">show</span> <span class="token hvariable">n</span> <span class="token operator">++</span> <span class="token string">" - "</span> <span class="token operator">++</span> <span class="token hvariable">line</span><span class="token punctuation">)</span> <span class="token punctuation">[</span><span class="token number">0</span><span class="token operator">..</span><span class="token punctuation">]</span> <span class="token hvariable">todoTasks</span>   
    <span class="token builtin">putStrLn</span> <span class="token string">"These are your TO-DO items:"</span>
    <span class="token builtin">putStr</span> <span class="token operator">$</span> <span class="token builtin">unlines</span> <span class="token hvariable">numberedTasks</span>
    <span class="token builtin">putStrLn</span> <span class="token string">"Which one do you want to delete?"</span>   
    <span class="token hvariable">numberString</span> <span class="token operator">&lt;-</span> <span class="token builtin">getLine</span>   
    <span class="token keyword">let</span> <span class="token hvariable">number</span> <span class="token operator">=</span> <span class="token builtin">read</span> <span class="token hvariable">numberString</span>   
        <span class="token hvariable">newTodoItems</span> <span class="token operator">=</span> <span class="token hvariable">delete</span> <span class="token punctuation">(</span><span class="token hvariable">todoTasks</span> <span class="token operator">!!</span> <span class="token hvariable">number</span><span class="token punctuation">)</span> <span class="token hvariable">todoTasks</span>   
    <span class="token hvariable">hPutStr</span> <span class="token hvariable">tempHandle</span> <span class="token operator">$</span> <span class="token builtin">unlines</span> <span class="token hvariable">newTodoItems</span>
    <span class="token hvariable">hClose</span> <span class="token hvariable">handle</span>
    <span class="token hvariable">hClose</span> <span class="token hvariable">tempHandle</span>
    <span class="token hvariable">removeFile</span> <span class="token string">"todo.txt"</span>
    <span class="token hvariable">renameFile</span> <span class="token hvariable">tempName</span> <span class="token string">"todo.txt"</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>At first, we just open <em>todo.txt</em> in read mode and bind its handle to <code>handle</code>.</p></div><div><p>Next up, we use a function that we haven't met before which is from <code>System.IO</code> — <code>openTempFile</code>. Its name is pretty self-explanatory. It takes a path to a temporary directory and a template name for a file and opens a temporary file. We used <code>"."</code> for the temporary directory, because <code>.</code> denotes the current directory on just about any OS. We used <code>"temp"</code> as the template name for the temporary file, which means that the temporary file will be named <em>temp</em> plus some random characters. It returns an I/O action that makes the temporary file and the result in that I/O action is a pair of values: the name of the temporary file and a handle. We could just open a normal file called <em>todo2.txt</em> or something like that but it's better practice to use <code>openTempFile</code> so you know you're probably not overwriting anything.</p></div><div><p>The reason we didn't use <code>getCurrentDirectory</code> to get the current directory and then pass it to <code>openTempFile</code> but instead just passed <code>"."</code> to <code>openTempFile</code> is because <code>.</code> refers to the current directory on unix-like system and Windows</p></div><div><p>Next up, we bind the contents of <em>todo.txt</em> to <code>contents</code>. Then, split that string into a list of strings, each string one line. So <code>todoTasks</code> is now something like <code>["Iron the dishes", "Dust the dog", "Take salad out of the oven"]</code>. We zip the numbers from 0 onwards and that list with a function that takes a number, like 3, and a string, like <code>"hey"</code> and returns <code>"3 - hey"</code>, so <code>numberedTasks</code> is <code>["0 - Iron the dishes", "1 - Dust the dog" ...</code>. We join that list of strings into a single newline delimited string with <code>unlines</code> and print that string out to the terminal. Note that instead of doing that, we could have also done <code>mapM putStrLn numberedTasks</code></p></div><div><p>We ask the user which one they want to delete and wait for them to enter a number. Let's say they want to delete number 1, which is <code>Dust the dog</code>, so they punch in <code>1</code>. <code>numberString</code> is now <code>"1"</code> and because we want a number, not a string, we run <code>read</code> on that to get <code>1</code> and bind that to <code>number</code>.</p></div><div><p>Remember the <code>delete</code> and <code>!!</code> functions from <code>Data.List</code>. <code>!!</code> returns an element from a list with some index and <code>delete</code> deletes the first occurence of an element in a list and returns a new list without that occurence. <code>(todoTasks !! number)</code> (number is now <code>1</code>) returns <code>"Dust the dog"</code>. We bind <code>todoTasks</code> without the first occurence of <code>"Dust the dog"</code> to <code>newTodoItems</code> and then join that into a single string with <code>unlines</code> before writing it to the temporary file that we opened. The old file is now unchanged and the temporary file contains all the lines that the old one does, except the one we deleted.</p></div><div><p>After that we close both the original and the temporary files and then we remove the original one with <code>removeFile</code>, which, as you can see, takes a path to a file and deletes it. After deleting the old <em>todo.txt</em>, we use <code>renameFile</code> to rename the temporary file to <em>todo.txt</em>. Be careful, <code>removeFile</code> and <code>renameFile</code> (which are both in <code>System.Directory</code> by the way) take file paths as their parameters, not handles.</p></div><div><p>And that's that! We could have done this in even fewer lines, but we were very careful not to overwrite any existing files and politely asked the operating system to tell us where we can put our temporary file. Let's give this a go!</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token operator">$</span> <span class="token hvariable">runhaskell</span> <span class="token hvariable">deletetodo</span><span class="token punctuation">.</span><span class="token hvariable">hs</span>
<span class="token constant">These</span> <span class="token hvariable">are</span> <span class="token hvariable">your</span> <span class="token constant">TO</span><span class="token operator">-</span><span class="token constant">DO</span> <span class="token hvariable">items</span><span class="token operator">:</span>
<span class="token number">0</span> <span class="token operator">-</span> <span class="token constant">Iron</span> <span class="token hvariable">the</span> <span class="token hvariable">dishes</span>
<span class="token number">1</span> <span class="token operator">-</span> <span class="token constant">Dust</span> <span class="token hvariable">the</span> <span class="token hvariable">dog</span>
<span class="token number">2</span> <span class="token operator">-</span> <span class="token constant">Take</span> <span class="token hvariable">salad</span> <span class="token hvariable">out</span> <span class="token keyword">of</span> <span class="token hvariable">the</span> <span class="token hvariable">oven</span>
<span class="token constant">Which</span> <span class="token hvariable">one</span> <span class="token keyword">do</span> <span class="token hvariable">you</span> <span class="token hvariable">want</span> <span class="token hvariable">to</span> <span class="token hvariable">delete</span><span class="token operator">?</span>
<span class="token number">1</span>

<span class="token operator">$</span> <span class="token hvariable">cat</span> <span class="token hvariable">todo</span><span class="token punctuation">.</span><span class="token hvariable">txt</span>
<span class="token constant">Iron</span> <span class="token hvariable">the</span> <span class="token hvariable">dishes</span>
<span class="token constant">Take</span> <span class="token hvariable">salad</span> <span class="token hvariable">out</span> <span class="token keyword">of</span> <span class="token hvariable">the</span> <span class="token hvariable">oven</span>

<span class="token operator">$</span> <span class="token hvariable">runhaskell</span> <span class="token hvariable">deletetodo</span><span class="token punctuation">.</span><span class="token hvariable">hs</span>
<span class="token constant">These</span> <span class="token hvariable">are</span> <span class="token hvariable">your</span> <span class="token constant">TO</span><span class="token operator">-</span><span class="token constant">DO</span> <span class="token hvariable">items</span><span class="token operator">:</span>
<span class="token number">0</span> <span class="token operator">-</span> <span class="token constant">Iron</span> <span class="token hvariable">the</span> <span class="token hvariable">dishes</span>
<span class="token number">1</span> <span class="token operator">-</span> <span class="token constant">Take</span> <span class="token hvariable">salad</span> <span class="token hvariable">out</span> <span class="token keyword">of</span> <span class="token hvariable">the</span> <span class="token hvariable">oven</span>
<span class="token constant">Which</span> <span class="token hvariable">one</span> <span class="token keyword">do</span> <span class="token hvariable">you</span> <span class="token hvariable">want</span> <span class="token hvariable">to</span> <span class="token hvariable">delete</span><span class="token operator">?</span>
<span class="token number">0</span>

<span class="token operator">$</span> <span class="token hvariable">cat</span> <span class="token hvariable">todo</span><span class="token punctuation">.</span><span class="token hvariable">txt</span>
<span class="token constant">Take</span> <span class="token hvariable">salad</span> <span class="token hvariable">out</span> <span class="token keyword">of</span> <span class="token hvariable">the</span> <span class="token hvariable">oven</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><h2 data-heading="Command line arguments" id="Command_line_arguments" style="display: flex;"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>Command line arguments</h2></div><div><p><span alt="LYHfGG_65_arguments.png" src="LYHfGG_65_arguments.png" class="internal-embed media-embed image-embed is-loaded"><img alt="LYHfGG_65_arguments.png" src="курсы\learn-you-a-haskell-for-great-good!\картинки\lyhfgg_65_arguments.png"></span></p></div><div><p>Dealing with command line arguments is pretty much a necessity if you want to make a script or application that runs on a terminal. Luckily, Haskell's standard library has a nice way of getting command line arguments of a program.</p></div><div><p>In the previous section, we made one program for adding a to-do item to our to-do list and one program for removing an item. There are two problems with the approach we took. The first one is that we just hardcoded the name of our to-do file in our code. We just decided that the file will be named <em>todo.txt</em> and that the user will never have a need for managing several to-do lists.</p></div><div><p>One way to solve that is to always ask the user which file they want to use as their to-do list. We used that approach when we wanted to know which item the user wants to delete. It works, but it's not so good, because it requires the user to run the program, wait for the program to ask something and then tell that to the program. That's called an interactive program and the difficult bit with interactive command line programs is this — what if you want to automate the execution of that program, like with a batch script? It's harder to make a batch script that interacts with a program than a batch script that just calls one program or several of them.</p></div><div><p>That's why it's sometimes better to have the user tell the program what they want when they run the program, instead of having the program ask the user once it's run. And what better way to have the user tell the program what they want it to do when they run it than via command line arguments!</p></div><div><p>The <code>System.Environment</code> module has two cool I/O actions. One is <code>getArgs</code>, which has a type of <code>getArgs :: IO [String]</code> and is an I/O action that will get the arguments that the program was run with and have as its contained result a list with the arguments. <code>getProgName</code> has a type of <code>getProgName :: IO String</code> and is an I/O action that contains the program name.</p></div><div><p>Here's a small program that demonstrates how these two work:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"> <span class="token import-statement"><span class="token keyword">import</span> System<span class="token punctuation">.</span>Environment</span> 
 <span class="token import-statement"><span class="token keyword">import</span> Data<span class="token punctuation">.</span>List</span>
 
 <span class="token hvariable">main</span> <span class="token operator">=</span> <span class="token keyword">do</span>
    <span class="token hvariable">args</span> <span class="token operator">&lt;-</span> <span class="token hvariable">getArgs</span>
    <span class="token hvariable">progName</span> <span class="token operator">&lt;-</span> <span class="token hvariable">getProgName</span>
    <span class="token builtin">putStrLn</span> <span class="token string">"The arguments are:"</span>
    <span class="token builtin">mapM</span> <span class="token builtin">putStrLn</span> <span class="token hvariable">args</span>
    <span class="token builtin">putStrLn</span> <span class="token string">"The program name is:"</span>
    <span class="token builtin">putStrLn</span> <span class="token hvariable">progName</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>We bind <code>getArgs</code> and <code>progName</code> to <code>args</code> and <code>progName</code>. We say <code>The arguments are:</code> and then for every argument in <code>args</code>, we do <code>putStrLn</code>. Finally, we also print out the program name. Let's compile this as <code>arg-test</code>.</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token operator">$</span> <span class="token operator">./</span><span class="token hvariable">arg</span><span class="token operator">-</span><span class="token hvariable">test</span> <span class="token hvariable">first</span> <span class="token hvariable">second</span> <span class="token hvariable">w00t</span> <span class="token string">"multi word arg"</span>
<span class="token constant">The</span> <span class="token hvariable">arguments</span> <span class="token hvariable">are</span><span class="token operator">:</span>
<span class="token hvariable">first</span>
<span class="token hvariable">second</span>
<span class="token hvariable">w00t</span>
<span class="token hvariable">multi</span> <span class="token hvariable">word</span> <span class="token hvariable">arg</span>
<span class="token constant">The</span> <span class="token hvariable">program</span> <span class="token hvariable">name</span> <span class="token hvariable">is</span><span class="token operator">:</span>
<span class="token hvariable">arg</span><span class="token operator">-</span><span class="token hvariable">test</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Nice. Armed with this knowledge you could create some cool command line apps. In fact, let's go ahead and make one. In the previous section, we made a separate program for adding tasks and a separate program for deleting them. Now, we're going to join that into one program, what it does will depend on the command line arguments. We're also going to make it so it can operate on different files, not just <em>todo.txt</em>.</p></div><div><p>We'll call it simply <em>todo</em> and it'll be able to do (haha!) three different things:</p></div><div><ul class="has-list-bullet">
<li data-line="0"><div class="list-bullet"></div>View tasks</li>
<li data-line="1"><div class="list-bullet"></div>Add tasks</li>
<li data-line="2"><div class="list-bullet"></div>Delete tasks</li>
</ul></div><div><p>We're not going to concern ourselves with possible bad input too much right now.</p></div><div><p>Our program will be made so that if we want to add the task <code>Find the magic sword of power</code> to the file <em>todo.txt</em>, we have to punch in <code>todo add todo.txt "Find the magic sword of power"</code> in our terminal. To view the tasks we'll just do <code>todo view todo.txt</code> and to remove the task with the index of 2, we'll do <code>todo remove todo.txt 2</code>.</p></div><div><p>We'll start by making a dispatch association list. It's going to be a simple association list that has command line arguments as keys and functions as their corresponding values. All these functions will be of type <code>[String] -&gt; IO ()</code>. They're going to take the argument list as a parameter and return an I/O action that does the viewing, adding, deleting, etc.</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token import-statement"><span class="token keyword">import</span> System<span class="token punctuation">.</span>Environment</span> 
<span class="token import-statement"><span class="token keyword">import</span> System<span class="token punctuation">.</span>Directory</span>
<span class="token import-statement"><span class="token keyword">import</span> System<span class="token punctuation">.</span>IO</span>
<span class="token import-statement"><span class="token keyword">import</span> Data<span class="token punctuation">.</span>List</span>

<span class="token hvariable">dispatch</span> <span class="token operator">::</span> <span class="token punctuation">[</span><span class="token punctuation">(</span><span class="token constant">String</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token constant">String</span><span class="token punctuation">]</span> <span class="token operator">-&gt;</span> <span class="token constant">IO</span> <span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">]</span>
<span class="token hvariable">dispatch</span> <span class="token operator">=</span>  <span class="token punctuation">[</span> <span class="token punctuation">(</span><span class="token string">"add"</span><span class="token punctuation">,</span> <span class="token hvariable">add</span><span class="token punctuation">)</span>
            <span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token string">"view"</span><span class="token punctuation">,</span> <span class="token hvariable">view</span><span class="token punctuation">)</span>
            <span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token string">"remove"</span><span class="token punctuation">,</span> <span class="token hvariable">remove</span><span class="token punctuation">)</span>
            <span class="token punctuation">]</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>We have yet to define <code>main</code>, <code>add</code>, <code>view</code> and <code>remove</code>, so let's start with <code>main</code>:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">main</span> <span class="token operator">=</span> <span class="token keyword">do</span>
    <span class="token punctuation">(</span><span class="token hvariable">command</span><span class="token operator">:</span><span class="token hvariable">args</span><span class="token punctuation">)</span> <span class="token operator">&lt;-</span> <span class="token hvariable">getArgs</span>
    <span class="token keyword">let</span> <span class="token punctuation">(</span><span class="token constant">Just</span> <span class="token hvariable">action</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token builtin">lookup</span> <span class="token hvariable">command</span> <span class="token hvariable">dispatch</span>
    <span class="token hvariable">action</span> <span class="token hvariable">args</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>First, we get the arguments and bind them to <code>(command:args)</code>. If you remember your pattern matching, this means that the first argument will get bound to <code>command</code> and the rest of them will get bound to <code>args</code>. If we call our program like <code>todo add todo.txt "Spank the monkey"</code>, <code>command</code> will be <code>"add"</code> and <code>args</code> will be <code>["todo.xt", "Spank the monkey"]</code>.</p></div><div><p>In the next line, we look up our command in the dispatch list. Because <code>"add"</code> points to <code>add</code>, we get <code>Just add</code> as a result. We use pattern matching again to extract our function out of the <code>Maybe</code>. What happens if our command isn't in the dispatch list? Well then the lookup will return <code>Nothing</code>, but we said we won't concern ourselves with failing gracefully too much, so the pattern matching will fail and our program will throw a fit.</p></div><div><p>Finally, we call our <code>action</code> function with the rest of the argument list. That will return an I/O action that either adds an item, displays a list of items or deletes an item and because that action is part of the <code>main</code> <em>do</em> block, it will get performed. If we follow our concrete example so far and our <code>action</code> function is <code>add</code>, it will get called with <code>args</code> (so <code>["todo.txt", "Spank the monkey"]</code>) and return an I/O action that adds <code>Spank the monkey</code> to <em>todo.txt</em>.</p></div><div><p>Great! All that's left now is to implement <code>add</code>, <code>view</code> and <code>remove</code>. Let's start with <code>add</code>:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">add</span> <span class="token operator">::</span> <span class="token punctuation">[</span><span class="token constant">String</span><span class="token punctuation">]</span> <span class="token operator">-&gt;</span> <span class="token constant">IO</span> <span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token hvariable">add</span> <span class="token punctuation">[</span><span class="token hvariable">fileName</span><span class="token punctuation">,</span> <span class="token hvariable">todoItem</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token builtin">appendFile</span> <span class="token hvariable">fileName</span> <span class="token punctuation">(</span><span class="token hvariable">todoItem</span> <span class="token operator">++</span> <span class="token string">"\n"</span><span class="token punctuation">)</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>If we call our program like <code>todo add todo.txt "Spank the monkey"</code>, the <code>"add"</code> will get bound to <code>command</code> in the first pattern match in the <code>main</code> block, whereas <code>["todo.txt", "Spank the monkey"]</code> will get passed to the function that we get from the dispatch list. So, because we're not dealing with bad input right now, we just pattern match against a list with those two elements right away and return an I/O action that appends that line to the end of the file, along with a newline character.</p></div><div><p>Next, let's implement the list viewing functionality. If we want to view the items in a file, we do <code>todo view todo.txt</code>. So in the first pattern match, <code>command</code> will be <code>"view"</code> and <code>args</code> will be <code>["todo.txt"]</code>.</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">view</span> <span class="token operator">::</span> <span class="token punctuation">[</span><span class="token constant">String</span><span class="token punctuation">]</span> <span class="token operator">-&gt;</span> <span class="token constant">IO</span> <span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token hvariable">view</span> <span class="token punctuation">[</span><span class="token hvariable">fileName</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">do</span>
    <span class="token hvariable">contents</span> <span class="token operator">&lt;-</span> <span class="token builtin">readFile</span> <span class="token hvariable">fileName</span>
    <span class="token keyword">let</span> <span class="token hvariable">todoTasks</span> <span class="token operator">=</span> <span class="token builtin">lines</span> <span class="token hvariable">contents</span>
        <span class="token hvariable">numberedTasks</span> <span class="token operator">=</span> <span class="token builtin">zipWith</span> <span class="token punctuation">(</span><span class="token operator">\</span><span class="token hvariable">n</span> <span class="token hvariable">line</span> <span class="token operator">-&gt;</span> <span class="token builtin">show</span> <span class="token hvariable">n</span> <span class="token operator">++</span> <span class="token string">" - "</span> <span class="token operator">++</span> <span class="token hvariable">line</span><span class="token punctuation">)</span> <span class="token punctuation">[</span><span class="token number">0</span><span class="token operator">..</span><span class="token punctuation">]</span> <span class="token hvariable">todoTasks</span>
    <span class="token builtin">putStr</span> <span class="token operator">$</span> <span class="token builtin">unlines</span> <span class="token hvariable">numberedTasks</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>We already did pretty much the same thing in the program that only deleted tasks when we were displaying the tasks so that the user can choose one for deletion, only here we just display the tasks.</p></div><div><p>And finally, we're going to implement <code>remove</code>. It's going to be very similar to the program that only deleted the tasks, so if you don't understand how deleting an item here works, check out the explanation under that program. The main difference is that we're not hardcoding <em>todo.txt</em> but getting it as an argument. We're also not prompting the user for the task number to delete, we're getting it as an argument.</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">remove</span> <span class="token operator">::</span> <span class="token punctuation">[</span><span class="token constant">String</span><span class="token punctuation">]</span> <span class="token operator">-&gt;</span> <span class="token constant">IO</span> <span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token hvariable">remove</span> <span class="token punctuation">[</span><span class="token hvariable">fileName</span><span class="token punctuation">,</span> <span class="token hvariable">numberString</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">do</span>
    <span class="token hvariable">handle</span> <span class="token operator">&lt;-</span> <span class="token hvariable">openFile</span> <span class="token hvariable">fileName</span> <span class="token constant">ReadMode</span>
    <span class="token punctuation">(</span><span class="token hvariable">tempName</span><span class="token punctuation">,</span> <span class="token hvariable">tempHandle</span><span class="token punctuation">)</span> <span class="token operator">&lt;-</span> <span class="token hvariable">openTempFile</span> <span class="token string">"."</span> <span class="token string">"temp"</span>
    <span class="token hvariable">contents</span> <span class="token operator">&lt;-</span> <span class="token hvariable">hGetContents</span> <span class="token hvariable">handle</span>
    <span class="token keyword">let</span> <span class="token hvariable">number</span> <span class="token operator">=</span> <span class="token builtin">read</span> <span class="token hvariable">numberString</span>
        <span class="token hvariable">todoTasks</span> <span class="token operator">=</span> <span class="token builtin">lines</span> <span class="token hvariable">contents</span>
        <span class="token hvariable">newTodoItems</span> <span class="token operator">=</span> <span class="token hvariable">delete</span> <span class="token punctuation">(</span><span class="token hvariable">todoTasks</span> <span class="token operator">!!</span> <span class="token hvariable">number</span><span class="token punctuation">)</span> <span class="token hvariable">todoTasks</span>
    <span class="token hvariable">hPutStr</span> <span class="token hvariable">tempHandle</span> <span class="token operator">$</span> <span class="token builtin">unlines</span> <span class="token hvariable">newTodoItems</span>
    <span class="token hvariable">hClose</span> <span class="token hvariable">handle</span>
    <span class="token hvariable">hClose</span> <span class="token hvariable">tempHandle</span>
    <span class="token hvariable">removeFile</span> <span class="token hvariable">fileName</span>
    <span class="token hvariable">renameFile</span> <span class="token hvariable">tempName</span> <span class="token hvariable">fileName</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>We opened up the file based on <code>fileName</code> and opened a temporary file, deleted the line with the index that the user wants to delete, wrote that to the temporary file, removed the original file and renamed the temporary file back to <code>fileName</code>.</p></div><div><p>Here's the whole program at once, in all its glory!</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token import-statement"><span class="token keyword">import</span> System<span class="token punctuation">.</span>Environment</span> 
<span class="token import-statement"><span class="token keyword">import</span> System<span class="token punctuation">.</span>Directory</span>
<span class="token import-statement"><span class="token keyword">import</span> System<span class="token punctuation">.</span>IO</span>
<span class="token import-statement"><span class="token keyword">import</span> Data<span class="token punctuation">.</span>List</span>

<span class="token hvariable">dispatch</span> <span class="token operator">::</span> <span class="token punctuation">[</span><span class="token punctuation">(</span><span class="token constant">String</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token constant">String</span><span class="token punctuation">]</span> <span class="token operator">-&gt;</span> <span class="token constant">IO</span> <span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">]</span>
<span class="token hvariable">dispatch</span> <span class="token operator">=</span>  <span class="token punctuation">[</span> <span class="token punctuation">(</span><span class="token string">"add"</span><span class="token punctuation">,</span> <span class="token hvariable">add</span><span class="token punctuation">)</span>
            <span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token string">"view"</span><span class="token punctuation">,</span> <span class="token hvariable">view</span><span class="token punctuation">)</span>
            <span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token string">"remove"</span><span class="token punctuation">,</span> <span class="token hvariable">remove</span><span class="token punctuation">)</span>
            <span class="token punctuation">]</span>
 
<span class="token hvariable">main</span> <span class="token operator">=</span> <span class="token keyword">do</span>
    <span class="token punctuation">(</span><span class="token hvariable">command</span><span class="token operator">:</span><span class="token hvariable">args</span><span class="token punctuation">)</span> <span class="token operator">&lt;-</span> <span class="token hvariable">getArgs</span>
    <span class="token keyword">let</span> <span class="token punctuation">(</span><span class="token constant">Just</span> <span class="token hvariable">action</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token builtin">lookup</span> <span class="token hvariable">command</span> <span class="token hvariable">dispatch</span>
    <span class="token hvariable">action</span> <span class="token hvariable">args</span>

<span class="token hvariable">add</span> <span class="token operator">::</span> <span class="token punctuation">[</span><span class="token constant">String</span><span class="token punctuation">]</span> <span class="token operator">-&gt;</span> <span class="token constant">IO</span> <span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token hvariable">add</span> <span class="token punctuation">[</span><span class="token hvariable">fileName</span><span class="token punctuation">,</span> <span class="token hvariable">todoItem</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token builtin">appendFile</span> <span class="token hvariable">fileName</span> <span class="token punctuation">(</span><span class="token hvariable">todoItem</span> <span class="token operator">++</span> <span class="token string">"\n"</span><span class="token punctuation">)</span>

<span class="token hvariable">view</span> <span class="token operator">::</span> <span class="token punctuation">[</span><span class="token constant">String</span><span class="token punctuation">]</span> <span class="token operator">-&gt;</span> <span class="token constant">IO</span> <span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token hvariable">view</span> <span class="token punctuation">[</span><span class="token hvariable">fileName</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">do</span>
    <span class="token hvariable">contents</span> <span class="token operator">&lt;-</span> <span class="token builtin">readFile</span> <span class="token hvariable">fileName</span>
    <span class="token keyword">let</span> <span class="token hvariable">todoTasks</span> <span class="token operator">=</span> <span class="token builtin">lines</span> <span class="token hvariable">contents</span>
        <span class="token hvariable">numberedTasks</span> <span class="token operator">=</span> <span class="token builtin">zipWith</span> <span class="token punctuation">(</span><span class="token operator">\</span><span class="token hvariable">n</span> <span class="token hvariable">line</span> <span class="token operator">-&gt;</span> <span class="token builtin">show</span> <span class="token hvariable">n</span> <span class="token operator">++</span> <span class="token string">" - "</span> <span class="token operator">++</span> <span class="token hvariable">line</span><span class="token punctuation">)</span> <span class="token punctuation">[</span><span class="token number">0</span><span class="token operator">..</span><span class="token punctuation">]</span> <span class="token hvariable">todoTasks</span>
    <span class="token builtin">putStr</span> <span class="token operator">$</span> <span class="token builtin">unlines</span> <span class="token hvariable">numberedTasks</span>

<span class="token hvariable">remove</span> <span class="token operator">::</span> <span class="token punctuation">[</span><span class="token constant">String</span><span class="token punctuation">]</span> <span class="token operator">-&gt;</span> <span class="token constant">IO</span> <span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token hvariable">remove</span> <span class="token punctuation">[</span><span class="token hvariable">fileName</span><span class="token punctuation">,</span> <span class="token hvariable">numberString</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">do</span>
    <span class="token hvariable">handle</span> <span class="token operator">&lt;-</span> <span class="token hvariable">openFile</span> <span class="token hvariable">fileName</span> <span class="token constant">ReadMode</span>
    <span class="token punctuation">(</span><span class="token hvariable">tempName</span><span class="token punctuation">,</span> <span class="token hvariable">tempHandle</span><span class="token punctuation">)</span> <span class="token operator">&lt;-</span> <span class="token hvariable">openTempFile</span> <span class="token string">"."</span> <span class="token string">"temp"</span>
    <span class="token hvariable">contents</span> <span class="token operator">&lt;-</span> <span class="token hvariable">hGetContents</span> <span class="token hvariable">handle</span>
    <span class="token keyword">let</span> <span class="token hvariable">number</span> <span class="token operator">=</span> <span class="token builtin">read</span> <span class="token hvariable">numberString</span>
        <span class="token hvariable">todoTasks</span> <span class="token operator">=</span> <span class="token builtin">lines</span> <span class="token hvariable">contents</span>
        <span class="token hvariable">newTodoItems</span> <span class="token operator">=</span> <span class="token hvariable">delete</span> <span class="token punctuation">(</span><span class="token hvariable">todoTasks</span> <span class="token operator">!!</span> <span class="token hvariable">number</span><span class="token punctuation">)</span> <span class="token hvariable">todoTasks</span>
    <span class="token hvariable">hPutStr</span> <span class="token hvariable">tempHandle</span> <span class="token operator">$</span> <span class="token builtin">unlines</span> <span class="token hvariable">newTodoItems</span>
    <span class="token hvariable">hClose</span> <span class="token hvariable">handle</span>
    <span class="token hvariable">hClose</span> <span class="token hvariable">tempHandle</span>
    <span class="token hvariable">removeFile</span> <span class="token hvariable">fileName</span>
    <span class="token hvariable">renameFile</span> <span class="token hvariable">tempName</span> <span class="token hvariable">fileName</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p><span alt="LYHfGG_66_salad.png" src="LYHfGG_66_salad.png" class="internal-embed media-embed image-embed is-loaded"><img alt="LYHfGG_66_salad.png" src="курсы\learn-you-a-haskell-for-great-good!\картинки\lyhfgg_66_salad.png"></span></p></div><div><p>To summarize our solution: we made a dispatch association that maps from commands to functions that take some command line arguments and return an I/O action. We see what the command is and based on that we get the appropriate function from the dispatch list. We call that function with the rest of the command line arguments to get back an I/O action that will do the appropriate thing and then just perform that action!</p></div><div><p>In other languages, we might have implemented this with a big switch case statement or whatever, but using higher order functions allows us to just tell the dispatch list to give us the appropriate function and then tell that function to give us an I/O action for some command line arguments.</p></div><div><p>Let's try our app out!</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token operator">$</span> <span class="token operator">./</span><span class="token hvariable">todo</span> <span class="token hvariable">view</span> <span class="token hvariable">todo</span><span class="token punctuation">.</span><span class="token hvariable">txt</span>
<span class="token number">0</span> <span class="token operator">-</span> <span class="token constant">Iron</span> <span class="token hvariable">the</span> <span class="token hvariable">dishes</span>
<span class="token number">1</span> <span class="token operator">-</span> <span class="token constant">Dust</span> <span class="token hvariable">the</span> <span class="token hvariable">dog</span>
<span class="token number">2</span> <span class="token operator">-</span> <span class="token constant">Take</span> <span class="token hvariable">salad</span> <span class="token hvariable">out</span> <span class="token keyword">of</span> <span class="token hvariable">the</span> <span class="token hvariable">oven</span>

<span class="token operator">$</span> <span class="token operator">./</span><span class="token hvariable">todo</span> <span class="token hvariable">add</span> <span class="token hvariable">todo</span><span class="token punctuation">.</span><span class="token hvariable">txt</span> <span class="token string">"Pick up children from drycleaners"</span>

<span class="token operator">$</span> <span class="token operator">./</span><span class="token hvariable">todo</span> <span class="token hvariable">view</span> <span class="token hvariable">todo</span><span class="token punctuation">.</span><span class="token hvariable">txt</span>
<span class="token number">0</span> <span class="token operator">-</span> <span class="token constant">Iron</span> <span class="token hvariable">the</span> <span class="token hvariable">dishes</span>
<span class="token number">1</span> <span class="token operator">-</span> <span class="token constant">Dust</span> <span class="token hvariable">the</span> <span class="token hvariable">dog</span>
<span class="token number">2</span> <span class="token operator">-</span> <span class="token constant">Take</span> <span class="token hvariable">salad</span> <span class="token hvariable">out</span> <span class="token keyword">of</span> <span class="token hvariable">the</span> <span class="token hvariable">oven</span>
<span class="token number">3</span> <span class="token operator">-</span> <span class="token constant">Pick</span> <span class="token hvariable">up</span> <span class="token hvariable">children</span> <span class="token hvariable">from</span> <span class="token hvariable">drycleaners</span>

<span class="token operator">$</span> <span class="token operator">./</span><span class="token hvariable">todo</span> <span class="token hvariable">remove</span> <span class="token hvariable">todo</span><span class="token punctuation">.</span><span class="token hvariable">txt</span> <span class="token number">2</span>

<span class="token operator">$</span> <span class="token operator">./</span><span class="token hvariable">todo</span> <span class="token hvariable">view</span> <span class="token hvariable">todo</span><span class="token punctuation">.</span><span class="token hvariable">txt</span>
<span class="token number">0</span> <span class="token operator">-</span> <span class="token constant">Iron</span> <span class="token hvariable">the</span> <span class="token hvariable">dishes</span>
<span class="token number">1</span> <span class="token operator">-</span> <span class="token constant">Dust</span> <span class="token hvariable">the</span> <span class="token hvariable">dog</span>
<span class="token number">2</span> <span class="token operator">-</span> <span class="token constant">Pick</span> <span class="token hvariable">up</span> <span class="token hvariable">children</span> <span class="token hvariable">from</span> <span class="token hvariable">drycleaners</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Another cool thing about this is that it's easy to add extra functionality. Just add an entry in the dispatch association list and implement the corresponding function and you're laughing! As an exercise, you can try implementing a <code>bump</code> function that will take a file and a task number and return an I/O action that bumps that task to the top of the to-do list.</p></div><div><p>You could make this program fail a bit more gracefully in case of bad input (for example, if someone runs <code>todo UP YOURS HAHAHAHA</code>) by making an I/O action that just reports there has been an error (say, <code>errorExit :: IO ()</code>) and then check for possible erronous input and if there is erronous input, perform the error reporting I/O action. Another way is to use exceptions, which we will meet soon.</p></div><div><h2 data-heading="Randomness" id="Randomness" style="display: flex;"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>Randomness</h2></div><div><p><span alt="LYHfGG_67_random.png" src="LYHfGG_67_random.png" class="internal-embed media-embed image-embed is-loaded"><img alt="LYHfGG_67_random.png" src="курсы\learn-you-a-haskell-for-great-good!\картинки\lyhfgg_67_random.png"></span></p></div><div><p>Many times while programming, you need to get some random data. Maybe you're making a game where a die needs to be thrown or you need to generate some test data to test out your program. There are a lot of uses for random data when programming. Well, actually, pseudo-random, because we all know that the only true source of randomness is a monkey on a unicycle with a cheese in one hand and its butt in the other. In this section, we'll take a look at how to make Haskell generate seemingly random data.</p></div><div><p>In most other programming languages, you have functions that give you back some random number. Each time you call that function, you get back a (hopefully) different random number. How about Haskell? Well, remember, Haskell is a pure functional language. What that means is that it has referential transparency. What THAT means is that a function, if given the same parameters twice, must produce the same result twice. That's really cool because it allows us to reason differently about programs and it enables us to defer evaluation until we really need it. If I call a function, I can be sure that it won't do any funny stuff before giving me the results. All that matters are its results. However, this makes it a bit tricky for getting random numbers. If I have a function like this:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">randomNumber</span> <span class="token operator">::</span> <span class="token punctuation">(</span><span class="token constant">Num</span> <span class="token hvariable">a</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token hvariable">a</span>
<span class="token hvariable">randomNumber</span> <span class="token operator">=</span> <span class="token number">4</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>It's not very useful as a random number function because it will always return <code>4</code>, even though I can assure you that the 4 is completely random, because I used a die to determine it.</p></div><div><p>How do other languages make seemingly random numbers? Well, they take various info from your computer, like the current time, how much and where you moved your mouse and what kind of noises you made behind your computer and based on that, give a number that looks really random. The combination of those factors (that randomness) is probably different in any given moment in time, so you get a different random number.</p></div><div><p>Ah. So in Haskell, we can make a random number then if we make a function that takes as its parameter that randomness and based on that returns some number (or other data type).</p></div><div><p>Enter the <code>System.Random</code> module. It has all the functions that satisfy our need for randomness. Let's just dive into one of the functions it exports then, namely <code>random</code>. Here's its type: <code>random :: (RandomGen g, Random a) =&gt; g -&gt; (a, g)</code>. Whoa! Some new typeclasses in this type declaration up in here! The <code>RandomGen</code> typeclass is for types that can act as sources of randomness. The <code>Random</code> typeclass is for things that can take on random values. A boolean value can take on a random value, namely <code>True</code> or <code>False</code>. A number can also take up a plethora of different random values. Can a function take on a random value? I don't think so, probably not! If we try to translate the type declaration of <code>random</code> to English, we get something like: it takes a random generator (that's our source of randomness) and returns a random value and a new random generator. Why does it also return a new generator as well as a random value? Well, we'll see in a moment.</p></div><div><p>To use our <code>random</code> function, we have to get our hands on one of those random generators. The <code>System.Random</code> module exports a cool type, namely <code>StdGen</code> that is an instance of the <code>RandomGen</code> typeclass. We can either make a <code>StdGen</code> manually or we can tell the system to give us one based on a multitude of sort of random stuff.</p></div><div><p>To manually make a random generator, use the <code>mkStdGen</code> function. It has a type of <code>mkStdGen :: Int -&gt; StdGen</code>. It takes an integer and based on that, gives us a random generator. Okay then, let's try using <code>random</code> and <code>mkStdGen</code> in tandem to get a (hardly random) number.</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token hvariable">random</span> <span class="token punctuation">(</span><span class="token hvariable">mkStdGen</span> <span class="token number">100</span><span class="token punctuation">)</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token operator">&lt;</span><span class="token hvariable">interactive</span><span class="token operator">&gt;:</span><span class="token number">1</span><span class="token operator">:</span><span class="token number">0</span><span class="token operator">:</span>
    <span class="token constant">Ambiguous</span> <span class="token keyword">type</span> <span class="token hvariable">variable</span> `<span class="token hvariable">a'</span> <span class="token keyword">in</span> <span class="token hvariable">the</span> <span class="token hvariable">constraint</span><span class="token operator">:</span>
      `<span class="token constant">Random</span> <span class="token hvariable">a'</span> <span class="token hvariable">arising</span> <span class="token hvariable">from</span> <span class="token hvariable">a</span> <span class="token hvariable">use</span> <span class="token keyword">of</span> `<span class="token hvariable">random'</span> <span class="token hvariable">at</span> <span class="token operator">&lt;</span><span class="token hvariable">interactive</span><span class="token operator">&gt;:</span><span class="token number">1</span><span class="token operator">:</span><span class="token number">0</span><span class="token operator">-</span><span class="token number">20</span>
    <span class="token constant">Probable</span> <span class="token hvariable">fix</span><span class="token operator">:</span> <span class="token hvariable">add</span> <span class="token hvariable">a</span> <span class="token keyword">type</span> <span class="token hvariable">signature</span> <span class="token hvariable">that</span> <span class="token hvariable">fixes</span> <span class="token hvariable">these</span> <span class="token keyword">type</span> <span class="token hvariable">variable</span><span class="token punctuation">(</span><span class="token hvariable">s</span><span class="token punctuation">)</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>What's this? Ah, right, the <code>random</code> function can return a value of any type that's part of the <code>Random</code> typeclass, so we have to inform Haskell what kind of type we want. Also let's not forget that it returns a random value and a random generator in a pair.</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token hvariable">random</span> <span class="token punctuation">(</span><span class="token hvariable">mkStdGen</span> <span class="token number">100</span><span class="token punctuation">)</span> <span class="token operator">::</span> <span class="token punctuation">(</span><span class="token constant">Int</span><span class="token punctuation">,</span> <span class="token constant">StdGen</span><span class="token punctuation">)</span>
<span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1352021624</span><span class="token punctuation">,</span><span class="token number">651872571</span> <span class="token number">1655838864</span><span class="token punctuation">)</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Finally! A number that looks kind of random! The first component of the tuple is our number whereas the second component is a textual representation of our new random generator. What happens if we call <code>random</code> with the same random generator again?</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token hvariable">random</span> <span class="token punctuation">(</span><span class="token hvariable">mkStdGen</span> <span class="token number">100</span><span class="token punctuation">)</span> <span class="token operator">::</span> <span class="token punctuation">(</span><span class="token constant">Int</span><span class="token punctuation">,</span> <span class="token constant">StdGen</span><span class="token punctuation">)</span>
<span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1352021624</span><span class="token punctuation">,</span><span class="token number">651872571</span> <span class="token number">1655838864</span><span class="token punctuation">)</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Of course. The same result for the same parameters. So let's try giving it a different random generator as a parameter.</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token hvariable">random</span> <span class="token punctuation">(</span><span class="token hvariable">mkStdGen</span> <span class="token number">949494</span><span class="token punctuation">)</span> <span class="token operator">::</span> <span class="token punctuation">(</span><span class="token constant">Int</span><span class="token punctuation">,</span> <span class="token constant">StdGen</span><span class="token punctuation">)</span>
<span class="token punctuation">(</span><span class="token number">539963926</span><span class="token punctuation">,</span><span class="token number">466647808</span> <span class="token number">1655838864</span><span class="token punctuation">)</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Alright, cool, great, a different number. We can use the type annotation to get different types back from that function.</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token hvariable">random</span> <span class="token punctuation">(</span><span class="token hvariable">mkStdGen</span> <span class="token number">949488</span><span class="token punctuation">)</span> <span class="token operator">::</span> <span class="token punctuation">(</span><span class="token constant">Float</span><span class="token punctuation">,</span> <span class="token constant">StdGen</span><span class="token punctuation">)</span>
<span class="token punctuation">(</span><span class="token number">0.8938442</span><span class="token punctuation">,</span><span class="token number">1597344447</span> <span class="token number">1655838864</span><span class="token punctuation">)</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token hvariable">random</span> <span class="token punctuation">(</span><span class="token hvariable">mkStdGen</span> <span class="token number">949488</span><span class="token punctuation">)</span> <span class="token operator">::</span> <span class="token punctuation">(</span><span class="token constant">Bool</span><span class="token punctuation">,</span> <span class="token constant">StdGen</span><span class="token punctuation">)</span>
<span class="token punctuation">(</span><span class="token constant">False</span><span class="token punctuation">,</span><span class="token number">1485632275</span> <span class="token number">40692</span><span class="token punctuation">)</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token hvariable">random</span> <span class="token punctuation">(</span><span class="token hvariable">mkStdGen</span> <span class="token number">949488</span><span class="token punctuation">)</span> <span class="token operator">::</span> <span class="token punctuation">(</span><span class="token constant">Integer</span><span class="token punctuation">,</span> <span class="token constant">StdGen</span><span class="token punctuation">)</span>
<span class="token punctuation">(</span><span class="token number">1691547873</span><span class="token punctuation">,</span><span class="token number">1597344447</span> <span class="token number">1655838864</span><span class="token punctuation">)</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Let's make a function that simulates tossing a coin three times. If <code>random</code> didn't return a new generator along with a random value, we'd have to make this function take three random generators as a parameter and then return coin tosses for each of them. But that sounds wrong because if one generator can make a random value of type <code>Int</code> (which can take on a load of different values), it should be able to make three coin tosses (which can take on precisely eight combinations). So this is where <code>random</code> returning a new generator along with a value really comes in handy.</p></div><div><p>We'll represent a coin with a simple <code>Bool</code>. <code>True</code> is tails, <code>False</code> is heads.</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">threeCoins</span> <span class="token operator">::</span> <span class="token constant">StdGen</span> <span class="token operator">-&gt;</span> <span class="token punctuation">(</span><span class="token constant">Bool</span><span class="token punctuation">,</span> <span class="token constant">Bool</span><span class="token punctuation">,</span> <span class="token constant">Bool</span><span class="token punctuation">)</span>
<span class="token hvariable">threeCoins</span> <span class="token hvariable">gen</span> <span class="token operator">=</span> 
    <span class="token keyword">let</span> <span class="token punctuation">(</span><span class="token hvariable">firstCoin</span><span class="token punctuation">,</span> <span class="token hvariable">newGen</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token hvariable">random</span> <span class="token hvariable">gen</span>
        <span class="token punctuation">(</span><span class="token hvariable">secondCoin</span><span class="token punctuation">,</span> <span class="token hvariable">newGen'</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token hvariable">random</span> <span class="token hvariable">newGen</span>
        <span class="token punctuation">(</span><span class="token hvariable">thirdCoin</span><span class="token punctuation">,</span> <span class="token hvariable">newGen''</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token hvariable">random</span> <span class="token hvariable">newGen'</span>
    <span class="token keyword">in</span>  <span class="token punctuation">(</span><span class="token hvariable">firstCoin</span><span class="token punctuation">,</span> <span class="token hvariable">secondCoin</span><span class="token punctuation">,</span> <span class="token hvariable">thirdCoin</span><span class="token punctuation">)</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>We call <code>random</code> with the generator we got as a parameter to get a coin and a new generator. Then we call it again, only this time with our new generator, to get the second coin. We do the same for the third coin. Had we called it with the same generator every time, all the coins would have had the same value and we'd only be able to get <code>(False, False, False)</code> or <code>(True, True, True)</code> as a result.</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token hvariable">threeCoins</span> <span class="token punctuation">(</span><span class="token hvariable">mkStdGen</span> <span class="token number">21</span><span class="token punctuation">)</span>
<span class="token punctuation">(</span><span class="token constant">True</span><span class="token punctuation">,</span><span class="token constant">True</span><span class="token punctuation">,</span><span class="token constant">True</span><span class="token punctuation">)</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token hvariable">threeCoins</span> <span class="token punctuation">(</span><span class="token hvariable">mkStdGen</span> <span class="token number">22</span><span class="token punctuation">)</span>
<span class="token punctuation">(</span><span class="token constant">True</span><span class="token punctuation">,</span><span class="token constant">False</span><span class="token punctuation">,</span><span class="token constant">True</span><span class="token punctuation">)</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token hvariable">threeCoins</span> <span class="token punctuation">(</span><span class="token hvariable">mkStdGen</span> <span class="token number">943</span><span class="token punctuation">)</span>
<span class="token punctuation">(</span><span class="token constant">True</span><span class="token punctuation">,</span><span class="token constant">False</span><span class="token punctuation">,</span><span class="token constant">True</span><span class="token punctuation">)</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token hvariable">threeCoins</span> <span class="token punctuation">(</span><span class="token hvariable">mkStdGen</span> <span class="token number">944</span><span class="token punctuation">)</span>
<span class="token punctuation">(</span><span class="token constant">True</span><span class="token punctuation">,</span><span class="token constant">True</span><span class="token punctuation">,</span><span class="token constant">True</span><span class="token punctuation">)</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Notice that we didn't have to do <code>random gen :: (Bool, StdGen)</code>. That's because we already specified that we want booleans in the type declaration of the function. That's why Haskell can infer that we want a boolean value in this case.</p></div><div><p>So what if we want to flip four coins? Or five? Well, there's a function called <code>randoms</code> that takes a generator and returns an infinite sequence of values based on that generator.</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token builtin">take</span> <span class="token number">5</span> <span class="token operator">$</span> <span class="token hvariable">randoms</span> <span class="token punctuation">(</span><span class="token hvariable">mkStdGen</span> <span class="token number">11</span><span class="token punctuation">)</span> <span class="token operator">::</span> <span class="token punctuation">[</span><span class="token constant">Int</span><span class="token punctuation">]</span>
<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1807975507</span><span class="token punctuation">,</span><span class="token number">545074951</span><span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">1015194702</span><span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">1622477312</span><span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">502893664</span><span class="token punctuation">]</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token builtin">take</span> <span class="token number">5</span> <span class="token operator">$</span> <span class="token hvariable">randoms</span> <span class="token punctuation">(</span><span class="token hvariable">mkStdGen</span> <span class="token number">11</span><span class="token punctuation">)</span> <span class="token operator">::</span> <span class="token punctuation">[</span><span class="token constant">Bool</span><span class="token punctuation">]</span>
<span class="token punctuation">[</span><span class="token constant">True</span><span class="token punctuation">,</span><span class="token constant">True</span><span class="token punctuation">,</span><span class="token constant">True</span><span class="token punctuation">,</span><span class="token constant">True</span><span class="token punctuation">,</span><span class="token constant">False</span><span class="token punctuation">]</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token builtin">take</span> <span class="token number">5</span> <span class="token operator">$</span> <span class="token hvariable">randoms</span> <span class="token punctuation">(</span><span class="token hvariable">mkStdGen</span> <span class="token number">11</span><span class="token punctuation">)</span> <span class="token operator">::</span> <span class="token punctuation">[</span><span class="token constant">Float</span><span class="token punctuation">]</span>
<span class="token punctuation">[</span><span class="token number">7.904789e-2</span><span class="token punctuation">,</span><span class="token number">0.62691015</span><span class="token punctuation">,</span><span class="token number">0.26363158</span><span class="token punctuation">,</span><span class="token number">0.12223756</span><span class="token punctuation">,</span><span class="token number">0.38291094</span><span class="token punctuation">]</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Why doesn't <code>randoms</code> return a new generator as well as a list? We could implement the <code>randoms</code> function very easily like this:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">randoms'</span> <span class="token operator">::</span> <span class="token punctuation">(</span><span class="token constant">RandomGen</span> <span class="token hvariable">g</span><span class="token punctuation">,</span> <span class="token constant">Random</span> <span class="token hvariable">a</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token hvariable">g</span> <span class="token operator">-&gt;</span> <span class="token punctuation">[</span><span class="token hvariable">a</span><span class="token punctuation">]</span>
<span class="token hvariable">randoms'</span> <span class="token hvariable">gen</span> <span class="token operator">=</span> <span class="token keyword">let</span> <span class="token punctuation">(</span><span class="token hvariable">value</span><span class="token punctuation">,</span> <span class="token hvariable">newGen</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token hvariable">random</span> <span class="token hvariable">gen</span> <span class="token keyword">in</span> <span class="token hvariable">value</span><span class="token operator">:</span><span class="token hvariable">randoms'</span> <span class="token hvariable">newGen</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>A recursive definition. We get a random value and a new generator from the current generator and then make a list that has the value as its head and random numbers based on the new generator as its tail. Because we have to be able to potentially generate an infinite amount of numbers, we can't give the new random generator back.</p></div><div><p>We could make a function that generates a finite stream of numbers and a new generator like this:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">finiteRandoms</span> <span class="token operator">::</span> <span class="token punctuation">(</span><span class="token constant">RandomGen</span> <span class="token hvariable">g</span><span class="token punctuation">,</span> <span class="token constant">Random</span> <span class="token hvariable">a</span><span class="token punctuation">,</span> <span class="token constant">Num</span> <span class="token hvariable">n</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token hvariable">n</span> <span class="token operator">-&gt;</span> <span class="token hvariable">g</span> <span class="token operator">-&gt;</span> <span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token hvariable">a</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token hvariable">g</span><span class="token punctuation">)</span>
<span class="token hvariable">finiteRandoms</span> <span class="token number">0</span> <span class="token hvariable">gen</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token hvariable">gen</span><span class="token punctuation">)</span>
<span class="token hvariable">finiteRandoms</span> <span class="token hvariable">n</span> <span class="token hvariable">gen</span> <span class="token operator">=</span> 
    <span class="token keyword">let</span> <span class="token punctuation">(</span><span class="token hvariable">value</span><span class="token punctuation">,</span> <span class="token hvariable">newGen</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token hvariable">random</span> <span class="token hvariable">gen</span>
        <span class="token punctuation">(</span><span class="token hvariable">restOfList</span><span class="token punctuation">,</span> <span class="token hvariable">finalGen</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token hvariable">finiteRandoms</span> <span class="token punctuation">(</span><span class="token hvariable">n</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token hvariable">newGen</span>
    <span class="token keyword">in</span>  <span class="token punctuation">(</span><span class="token hvariable">value</span><span class="token operator">:</span><span class="token hvariable">restOfList</span><span class="token punctuation">,</span> <span class="token hvariable">finalGen</span><span class="token punctuation">)</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Again, a recursive definition. We say that if we want 0 numbers, we just return an empty list and the generator that was given to us. For any other number of random values, we first get one random number and a new generator. That will be the head. Then we say that the tail will be <em>n - 1</em> numbers generated with the new generator. Then we return the head and the rest of the list joined and the final generator that we got from getting the <em>n - 1</em> random numbers.</p></div><div><p>What if we want a random value in some sort of range? All the random integers so far were outrageously big or small. What if we want to to throw a die? Well, we use <code>randomR</code> for that purpose. It has a type of <code>randomR :: (RandomGen g, Random a) :: (a, a) -&gt; g -&gt; (a, g)</code>, meaning that it's kind of like <code>random</code>, only it takes as its first parameter a pair of values that set the lower and upper bounds and the final value produced will be within those bounds.</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token hvariable">randomR</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token hvariable">mkStdGen</span> <span class="token number">359353</span><span class="token punctuation">)</span>
<span class="token punctuation">(</span><span class="token number">6</span><span class="token punctuation">,</span><span class="token number">1494289578</span> <span class="token number">40692</span><span class="token punctuation">)</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token hvariable">randomR</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token hvariable">mkStdGen</span> <span class="token number">35935335</span><span class="token punctuation">)</span>
<span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">1250031057</span> <span class="token number">40692</span><span class="token punctuation">)</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>There's also <code>randomRs</code>, which produces a stream of random values within our defined ranges. Check this out:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token builtin">take</span> <span class="token number">10</span> <span class="token operator">$</span> <span class="token hvariable">randomRs</span> <span class="token punctuation">(</span><span class="token char string">'a'</span><span class="token punctuation">,</span><span class="token char string">'z'</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token hvariable">mkStdGen</span> <span class="token number">3</span><span class="token punctuation">)</span> <span class="token operator">::</span> <span class="token punctuation">[</span><span class="token constant">Char</span><span class="token punctuation">]</span>
<span class="token string">"ndkxbvmomg"</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Nice, looks like a super secret password or something.</p></div><div><p>You may be asking yourself, what does this section have to do with I/O anyway? We haven't done anything concerning I/O so far. Well, so far we've always made our random number generator manually by making it with some arbitrary integer. The problem is, if we do that in our real programs, they will always return the same random numbers, which is no good for us. That's why <code>System.Random</code> offers the <code>getStdGen</code> I/O action, which has a type of <code>IO StdGen</code>. When your program starts, it asks the system for a good random number generator and stores that in a so called global generator. <code>getStdGen</code> fetches you that global random generator when you bind it to something.</p></div><div><p>Here's a simple program that generates a random string.</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token import-statement"><span class="token keyword">import</span> System<span class="token punctuation">.</span>Random</span>

<span class="token hvariable">main</span> <span class="token operator">=</span> <span class="token keyword">do</span>
    <span class="token hvariable">gen</span> <span class="token operator">&lt;-</span> <span class="token hvariable">getStdGen</span>
    <span class="token builtin">putStr</span> <span class="token operator">$</span> <span class="token builtin">take</span> <span class="token number">20</span> <span class="token punctuation">(</span><span class="token hvariable">randomRs</span> <span class="token punctuation">(</span><span class="token char string">'a'</span><span class="token punctuation">,</span><span class="token char string">'z'</span><span class="token punctuation">)</span> <span class="token hvariable">gen</span><span class="token punctuation">)</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token operator">$</span> <span class="token hvariable">runhaskell</span> <span class="token hvariable">random_string</span><span class="token punctuation">.</span><span class="token hvariable">hs</span>
<span class="token hvariable">pybphhzzhuepknbykxhe</span>
<span class="token operator">$</span> <span class="token hvariable">runhaskell</span> <span class="token hvariable">random_string</span><span class="token punctuation">.</span><span class="token hvariable">hs</span>
<span class="token hvariable">eiqgcxykivpudlsvvjpg</span>
<span class="token operator">$</span> <span class="token hvariable">runhaskell</span> <span class="token hvariable">random_string</span><span class="token punctuation">.</span><span class="token hvariable">hs</span>
<span class="token hvariable">nzdceoconysdgcyqjruo</span>
<span class="token operator">$</span> <span class="token hvariable">runhaskell</span> <span class="token hvariable">random_string</span><span class="token punctuation">.</span><span class="token hvariable">hs</span>
<span class="token hvariable">bakzhnnuzrkgvesqplrx</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Be careful though, just performing <code>getStdGen</code> twice will ask the system for the same global generator twice. If you do this:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token import-statement"><span class="token keyword">import</span> System<span class="token punctuation">.</span>Random</span>

<span class="token hvariable">main</span> <span class="token operator">=</span> <span class="token keyword">do</span>
    <span class="token hvariable">gen</span> <span class="token operator">&lt;-</span> <span class="token hvariable">getStdGen</span>
    <span class="token builtin">putStrLn</span> <span class="token operator">$</span> <span class="token builtin">take</span> <span class="token number">20</span> <span class="token punctuation">(</span><span class="token hvariable">randomRs</span> <span class="token punctuation">(</span><span class="token char string">'a'</span><span class="token punctuation">,</span><span class="token char string">'z'</span><span class="token punctuation">)</span> <span class="token hvariable">gen</span><span class="token punctuation">)</span>
    <span class="token hvariable">gen2</span> <span class="token operator">&lt;-</span> <span class="token hvariable">getStdGen</span>
    <span class="token builtin">putStr</span> <span class="token operator">$</span> <span class="token builtin">take</span> <span class="token number">20</span> <span class="token punctuation">(</span><span class="token hvariable">randomRs</span> <span class="token punctuation">(</span><span class="token char string">'a'</span><span class="token punctuation">,</span><span class="token char string">'z'</span><span class="token punctuation">)</span> <span class="token hvariable">gen2</span><span class="token punctuation">)</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>you will get the same string printed out twice! One way to get two different strings of length 20 is to set up an infinite stream and then take the first 20 characters and print them out in one line and then take the second set of 20 characters and print them out in the second line. For this, we can use the <code>splitAt</code> function from <code>Data.List</code>, which splits a list at some index and returns a tuple that has the first part as the first component and the second part as the second component.</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token import-statement"><span class="token keyword">import</span> System<span class="token punctuation">.</span>Random</span>
<span class="token import-statement"><span class="token keyword">import</span> Data<span class="token punctuation">.</span>List</span>

<span class="token hvariable">main</span> <span class="token operator">=</span> <span class="token keyword">do</span>
    <span class="token hvariable">gen</span> <span class="token operator">&lt;-</span> <span class="token hvariable">getStdGen</span>
    <span class="token keyword">let</span> <span class="token hvariable">randomChars</span> <span class="token operator">=</span> <span class="token hvariable">randomRs</span> <span class="token punctuation">(</span><span class="token char string">'a'</span><span class="token punctuation">,</span><span class="token char string">'z'</span><span class="token punctuation">)</span> <span class="token hvariable">gen</span>
        <span class="token punctuation">(</span><span class="token hvariable">first20</span><span class="token punctuation">,</span> <span class="token hvariable">rest</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token builtin">splitAt</span> <span class="token number">20</span> <span class="token hvariable">randomChars</span>
        <span class="token punctuation">(</span><span class="token hvariable">second20</span><span class="token punctuation">,</span> <span class="token hvariable">_</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token builtin">splitAt</span> <span class="token number">20</span> <span class="token hvariable">rest</span>
    <span class="token builtin">putStrLn</span> <span class="token hvariable">first20</span>
    <span class="token builtin">putStr</span> <span class="token hvariable">second20</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Another way is to use the <code>newStdGen</code> action, which splits our current random generator into two generators. It updates the global random generator with one of them and encapsulates the other as its result.</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token import-statement"><span class="token keyword">import</span> System<span class="token punctuation">.</span>Random</span>

<span class="token hvariable">main</span> <span class="token operator">=</span> <span class="token keyword">do</span>   
    <span class="token hvariable">gen</span> <span class="token operator">&lt;-</span> <span class="token hvariable">getStdGen</span>   
    <span class="token builtin">putStrLn</span> <span class="token operator">$</span> <span class="token builtin">take</span> <span class="token number">20</span> <span class="token punctuation">(</span><span class="token hvariable">randomRs</span> <span class="token punctuation">(</span><span class="token char string">'a'</span><span class="token punctuation">,</span><span class="token char string">'z'</span><span class="token punctuation">)</span> <span class="token hvariable">gen</span><span class="token punctuation">)</span>   
    <span class="token hvariable">gen'</span> <span class="token operator">&lt;-</span> <span class="token hvariable">newStdGen</span>
    <span class="token builtin">putStr</span> <span class="token operator">$</span> <span class="token builtin">take</span> <span class="token number">20</span> <span class="token punctuation">(</span><span class="token hvariable">randomRs</span> <span class="token punctuation">(</span><span class="token char string">'a'</span><span class="token punctuation">,</span><span class="token char string">'z'</span><span class="token punctuation">)</span> <span class="token hvariable">gen'</span><span class="token punctuation">)</span>   
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Not only do we get a new random generator when we bind <code>newStdGen</code> to something, the global one gets updated as well, so if we do <code>getStdGen</code> again and bind it to something, we'll get a generator that's not the same as <code>gen</code>.</p></div><div><p>Here's a little program that will make the user guess which number it's thinking of.</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token import-statement"><span class="token keyword">import</span> System<span class="token punctuation">.</span>Random</span>
<span class="token import-statement"><span class="token keyword">import</span> Control<span class="token punctuation">.</span>Monad</span><span class="token punctuation">(</span><span class="token hvariable">when</span><span class="token punctuation">)</span>

<span class="token hvariable">main</span> <span class="token operator">=</span> <span class="token keyword">do</span>
    <span class="token hvariable">gen</span> <span class="token operator">&lt;-</span> <span class="token hvariable">getStdGen</span>
    <span class="token hvariable">askForNumber</span> <span class="token hvariable">gen</span>

<span class="token hvariable">askForNumber</span> <span class="token operator">::</span> <span class="token constant">StdGen</span> <span class="token operator">-&gt;</span> <span class="token constant">IO</span> <span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token hvariable">askForNumber</span> <span class="token hvariable">gen</span> <span class="token operator">=</span> <span class="token keyword">do</span>
    <span class="token keyword">let</span> <span class="token punctuation">(</span><span class="token hvariable">randNumber</span><span class="token punctuation">,</span> <span class="token hvariable">newGen</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token hvariable">randomR</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">10</span><span class="token punctuation">)</span> <span class="token hvariable">gen</span> <span class="token operator">::</span> <span class="token punctuation">(</span><span class="token constant">Int</span><span class="token punctuation">,</span> <span class="token constant">StdGen</span><span class="token punctuation">)</span>
    <span class="token builtin">putStr</span> <span class="token string">"Which number in the range from 1 to 10 am I thinking of? "</span>
    <span class="token hvariable">numberString</span> <span class="token operator">&lt;-</span> <span class="token builtin">getLine</span>
    <span class="token hvariable">when</span> <span class="token punctuation">(</span><span class="token builtin">not</span> <span class="token operator">$</span> <span class="token builtin">null</span> <span class="token hvariable">numberString</span><span class="token punctuation">)</span> <span class="token operator">$</span> <span class="token keyword">do</span>
        <span class="token keyword">let</span> <span class="token hvariable">number</span> <span class="token operator">=</span> <span class="token builtin">read</span> <span class="token hvariable">numberString</span>
        <span class="token keyword">if</span> <span class="token hvariable">randNumber</span> <span class="token operator">==</span> <span class="token hvariable">number</span> 
            <span class="token keyword">then</span> <span class="token builtin">putStrLn</span> <span class="token string">"You are correct!"</span>
            <span class="token keyword">else</span> <span class="token builtin">putStrLn</span> <span class="token operator">$</span> <span class="token string">"Sorry, it was "</span> <span class="token operator">++</span> <span class="token builtin">show</span> <span class="token hvariable">randNumber</span>
        <span class="token hvariable">askForNumber</span> <span class="token hvariable">newGen</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p><span alt="LYHfGG_68_jackofdiamonds.png" src="LYHfGG_68_jackofdiamonds.png" class="internal-embed media-embed image-embed is-loaded"><img alt="LYHfGG_68_jackofdiamonds.png" src="курсы\learn-you-a-haskell-for-great-good!\картинки\lyhfgg_68_jackofdiamonds.png"></span></p></div><div><p>We make a function <code>askForNumber</code>, which takes a random number generator and returns an I/O action that will prompt the user for a number and tell him if he guessed it right. In that function, we first generate a random number and a new generator based on the generator that we got as a parameter and call them <code>randNumber</code> and <code>newGen</code>. Let's say that the number generated was <code>7</code>. Then we tell the user to guess which number we're thinking of. We perform <code>getLine</code> and bind its result to <code>numberString</code>. When the user enters <code>7</code>, <code>numberString</code> becomes <code>"7"</code>. Next, we use <code>when</code> to check if the string the user entered is an empty string. If it is, an empty I/O action of <code>return ()</code> is performed, which effectively ends the program. If it isn't, the action consisting of that <em>do</em> block right there gets performed. We use <code>read</code> on <code>numberString</code> to convert it to a number, so <code>number</code> is now <code>7</code>.</p></div><div><blockquote>
<p><strong>Excuse me!</strong> If the user gives us some input here that <code>read</code> can't read (like <code>"haha"</code>), our program will crash with an ugly error message. If you don't want your program to crash on erronous input, use <code>reads</code>, which returns an empty list when it fails to read a string. When it succeeds, it returns a singleton list with a tuple that has our desired value as one component and a string with what it didn't consume as the other.</p>
</blockquote></div><div><p>We check if the number that we entered is equal to the one generated randomly and give the user the appropriate message. And then we call <code>askForNumber</code> recursively, only this time with the new generator that we got, which gives us an I/O action that's just like the one we performed, only it depends on a different generator and we perform it.</p></div><div><p><code>main</code> consists of just getting a random generator from the system and calling <code>askForNumber</code> with it to get the initial action.</p></div><div><p>Here's our program in action!</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token operator">$</span> <span class="token hvariable">runhaskell</span> <span class="token hvariable">guess_the_number</span><span class="token punctuation">.</span><span class="token hvariable">hs</span>
<span class="token constant">Which</span> <span class="token hvariable">number</span> <span class="token keyword">in</span> <span class="token hvariable">the</span> <span class="token builtin">range</span> <span class="token hvariable">from</span> <span class="token number">1</span> <span class="token hvariable">to</span> <span class="token number">10</span> <span class="token hvariable">am</span> <span class="token constant">I</span> <span class="token hvariable">thinking</span> <span class="token keyword">of</span><span class="token operator">?</span> <span class="token number">4</span>
<span class="token constant">Sorry</span><span class="token punctuation">,</span> <span class="token hvariable">it</span> <span class="token hvariable">was</span> <span class="token number">3</span>
<span class="token constant">Which</span> <span class="token hvariable">number</span> <span class="token keyword">in</span> <span class="token hvariable">the</span> <span class="token builtin">range</span> <span class="token hvariable">from</span> <span class="token number">1</span> <span class="token hvariable">to</span> <span class="token number">10</span> <span class="token hvariable">am</span> <span class="token constant">I</span> <span class="token hvariable">thinking</span> <span class="token keyword">of</span><span class="token operator">?</span> <span class="token number">10</span>
<span class="token constant">You</span> <span class="token hvariable">are</span> <span class="token hvariable">correct</span><span class="token operator">!</span>
<span class="token constant">Which</span> <span class="token hvariable">number</span> <span class="token keyword">in</span> <span class="token hvariable">the</span> <span class="token builtin">range</span> <span class="token hvariable">from</span> <span class="token number">1</span> <span class="token hvariable">to</span> <span class="token number">10</span> <span class="token hvariable">am</span> <span class="token constant">I</span> <span class="token hvariable">thinking</span> <span class="token keyword">of</span><span class="token operator">?</span> <span class="token number">2</span>
<span class="token constant">Sorry</span><span class="token punctuation">,</span> <span class="token hvariable">it</span> <span class="token hvariable">was</span> <span class="token number">4</span>
<span class="token constant">Which</span> <span class="token hvariable">number</span> <span class="token keyword">in</span> <span class="token hvariable">the</span> <span class="token builtin">range</span> <span class="token hvariable">from</span> <span class="token number">1</span> <span class="token hvariable">to</span> <span class="token number">10</span> <span class="token hvariable">am</span> <span class="token constant">I</span> <span class="token hvariable">thinking</span> <span class="token keyword">of</span><span class="token operator">?</span> <span class="token number">5</span>
<span class="token constant">Sorry</span><span class="token punctuation">,</span> <span class="token hvariable">it</span> <span class="token hvariable">was</span> <span class="token number">10</span>
<span class="token constant">Which</span> <span class="token hvariable">number</span> <span class="token keyword">in</span> <span class="token hvariable">the</span> <span class="token builtin">range</span> <span class="token hvariable">from</span> <span class="token number">1</span> <span class="token hvariable">to</span> <span class="token number">10</span> <span class="token hvariable">am</span> <span class="token constant">I</span> <span class="token hvariable">thinking</span> <span class="token keyword">of</span><span class="token operator">?</span>

</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Another way to make this same program is like this:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token import-statement"><span class="token keyword">import</span> System<span class="token punctuation">.</span>Random</span>
<span class="token import-statement"><span class="token keyword">import</span> Control<span class="token punctuation">.</span>Monad</span><span class="token punctuation">(</span><span class="token hvariable">when</span><span class="token punctuation">)</span>

<span class="token hvariable">main</span> <span class="token operator">=</span> <span class="token keyword">do</span>
    <span class="token hvariable">gen</span> <span class="token operator">&lt;-</span> <span class="token hvariable">getStdGen</span>
    <span class="token keyword">let</span> <span class="token punctuation">(</span><span class="token hvariable">randNumber</span><span class="token punctuation">,</span> <span class="token hvariable">_</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token hvariable">randomR</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">10</span><span class="token punctuation">)</span> <span class="token hvariable">gen</span> <span class="token operator">::</span> <span class="token punctuation">(</span><span class="token constant">Int</span><span class="token punctuation">,</span> <span class="token constant">StdGen</span><span class="token punctuation">)</span>   
    <span class="token builtin">putStr</span> <span class="token string">"Which number in the range from 1 to 10 am I thinking of? "</span>
    <span class="token hvariable">numberString</span> <span class="token operator">&lt;-</span> <span class="token builtin">getLine</span>
    <span class="token hvariable">when</span> <span class="token punctuation">(</span><span class="token builtin">not</span> <span class="token operator">$</span> <span class="token builtin">null</span> <span class="token hvariable">numberString</span><span class="token punctuation">)</span> <span class="token operator">$</span> <span class="token keyword">do</span>
        <span class="token keyword">let</span> <span class="token hvariable">number</span> <span class="token operator">=</span> <span class="token builtin">read</span> <span class="token hvariable">numberString</span>
        <span class="token keyword">if</span> <span class="token hvariable">randNumber</span> <span class="token operator">==</span> <span class="token hvariable">number</span>
            <span class="token keyword">then</span> <span class="token builtin">putStrLn</span> <span class="token string">"You are correct!"</span>
            <span class="token keyword">else</span> <span class="token builtin">putStrLn</span> <span class="token operator">$</span> <span class="token string">"Sorry, it was "</span> <span class="token operator">++</span> <span class="token builtin">show</span> <span class="token hvariable">randNumber</span>
        <span class="token hvariable">newStdGen</span>
        <span class="token hvariable">main</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>It's very similar to the previous version, only instead of making a function that takes a generator and then calls itself recursively with the new updated generator, we do all the work in <code>main</code>. After telling the user whether they were correct in their guess or not, we update the global generator and then call <code>main</code> again. Both approaches are valid but I like the first one more since it does less stuff in <code>main</code> and also provides us with a function that we can reuse easily.</p></div><div><h2 data-heading="Bytestrings" id="Bytestrings" style="display: flex;"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>Bytestrings</h2></div><div><p><span alt="LYHfGG_69_chainchomp.png" src="LYHfGG_69_chainchomp.png" class="internal-embed media-embed image-embed is-loaded"><img alt="LYHfGG_69_chainchomp.png" src="курсы\learn-you-a-haskell-for-great-good!\картинки\lyhfgg_69_chainchomp.png"></span></p></div><div><p>Lists are a cool and useful data structure. So far, we've used them pretty much everywhere. There are a multitude of functions that operate on them and Haskell's laziness allows us to exchange the for and while loops of other languages for filtering and mapping over lists, because evaluation will only happen once it really needs to, so things like infinite lists (and even infinite lists of infinite lists!) are no problem for us. That's why lists can also be used to represent streams, either when reading from the standard input or when reading from files. We can just open a file and read it as a string, even though it will only be accessed when the need arises.</p></div><div><p>However, processing files as strings has one drawback: it tends to be slow. As you know, <code>String</code> is a type synonym for <code>[Char]</code>. <code>Char</code>s don't have a fixed size, because it takes several bytes to represent a character from, say, Unicode. Furthemore, lists are really lazy. If you have a list like <code>[1,2,3,4]</code>, it will be evaluated only when completely necessary. So the whole list is sort of a promise of a list. Remember that <code>[1,2,3,4]</code> is syntactic sugar for <code>1:2:3:4:[]</code>. When the first element of the list is forcibly evaluated (say by printing it), the rest of the list <code>2:3:4:[]</code> is still just a promise of a list, and so on. So you can think of lists as promises that the next element will be delivered once it really has to and along with it, the promise of the element after it. It doesn't take a big mental leap to conclude that processing a simple list of numbers as a series of promises might not be the most efficient thing in the world.</p></div><div><p>That overhead doesn't bother us so much most of the time, but it turns out to be a liability when reading big files and manipulating them. That's why Haskell has <strong>bytestrings</strong>. Bytestrings are sort of like lists, only each element is one byte (or 8 bits) in size. The way they handle laziness is also different.</p></div><div><p>Bytestrings come in two flavors: strict and lazy ones. Strict bytestrings reside in <code>Data.ByteString</code> and they do away with the laziness completely. There are no promises involved; a strict bytestring represents a series of bytes in an array. You can't have things like infinite strict bytestrings. If you evaluate the first byte of a strict bytestring, you have to evaluate it whole. The upside is that there's less overhead because there are no thunks (the technical term for <em>promise</em>) involved. The downside is that they're likely to fill your memory up faster because they're read into memory at once.</p></div><div><p>The other variety of bytestrings resides in <code>Data.ByteString.Lazy</code>. They're lazy, but not quite as lazy as lists. Like we said before, there are as many thunks in a list as there are elements. That's what makes them kind of slow for some purposes. Lazy bytestrings take a different approach — they are stored in chunks (not to be confused with thunks!), each chunk has a size of 64K. So if you evaluate a byte in a lazy bytestring (by printing it or something), the first 64K will be evaluated. After that, it's just a promise for the rest of the chunks. Lazy bytestrings are kind of like lists of strict bytestrings with a size of 64K. When you process a file with lazy bytestrings, it will be read chunk by chunk. This is cool because it won't cause the memory usage to skyrocket and the 64K probably fits neatly into your CPU's L2 cache.</p></div><div><p>If you look through the <a data-tooltip-position="top" aria-label="http://www.haskell.org/ghc/docs/latest/html/libraries/bytestring/Data-ByteString-Lazy.html" rel="noopener" class="external-link" href="http://www.haskell.org/ghc/docs/latest/html/libraries/bytestring/Data-ByteString-Lazy.html" target="_blank">documentation</a> for <code>Data.ByteString.Lazy</code>, you'll see that it has a lot of functions that have the same names as the ones from <code>Data.List</code>, only the type signatures have <code>ByteString</code> instead of <code>[a]</code> and <code>Word8</code> instead of <code>a</code> in them. The functions with the same names mostly act the same as the ones that work on lists. Because the names are the same, we're going to do a qualified import in a script and then load that script into GHCI to play with bytestrings.</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token import-statement"><span class="token keyword">import</span> <span class="token keyword">qualified</span> Data<span class="token punctuation">.</span>ByteString<span class="token punctuation">.</span>Lazy <span class="token keyword">as</span> B</span>
<span class="token import-statement"><span class="token keyword">import</span> <span class="token keyword">qualified</span> Data<span class="token punctuation">.</span>ByteString <span class="token keyword">as</span> S</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p><code>B</code> has lazy bytestring types and functions, whereas <code>S</code> has strict ones. We'll mostly be using the lazy version.</p></div><div><p>The function <code>pack</code> has the type signature <code>pack :: [Word8] -&gt; ByteString</code>. What that means is that it takes a list of bytes of type <code>Word8</code> and returns a <code>ByteString</code>. You can think of it as taking a list, which is lazy, and making it less lazy, so that it's lazy only at 64K intervals.</p></div><div><p>What's the deal with that <code>Word8</code> type? Well, it's like <code>Int</code>, only that it has a much smaller range, namely 0-255. It represents an 8-bit number. And just like <code>Int</code>, it's in the <code>Num</code> typeclass. For instance, we know that the value <code>5</code> is polymorphic in that it can act like any numeral type. Well, it can also take the type of <code>Word8</code>.</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token constant">B</span><span class="token punctuation">.</span><span class="token builtin">pack</span> <span class="token punctuation">[</span><span class="token number">99</span><span class="token punctuation">,</span><span class="token number">97</span><span class="token punctuation">,</span><span class="token number">110</span><span class="token punctuation">]</span>
<span class="token constant">Chunk</span> <span class="token string">"can"</span> <span class="token constant">Empty</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token constant">B</span><span class="token punctuation">.</span><span class="token builtin">pack</span> <span class="token punctuation">[</span><span class="token number">98</span><span class="token operator">..</span><span class="token number">120</span><span class="token punctuation">]</span>
<span class="token constant">Chunk</span> <span class="token string">"bcdefghijklmnopqrstuvwx"</span> <span class="token constant">Empty</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>As you can see, you usually don't have to worry about the <code>Word8</code> too much, because the type system can makes the numbers choose that type. If you try to use a big number, like <code>336</code> as a <code>Word8</code>, it will just wrap around to <code>80</code>.</p></div><div><p>We packed only a handful of values into a <code>ByteString</code>, so they fit inside one chunk. The <code>Empty</code> is like the <code>[]</code> for lists.</p></div><div><p><code>unpack</code> is the inverse function of <code>pack</code>. It takes a bytestring and turns it into a list of bytes.</p></div><div><p><code>fromChunks</code> takes a list of strict bytestrings and converts it to a lazy bytestring. <code>toChunks</code> takes a lazy bytestring and converts it to a list of strict ones.</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token hvariable">B<span class="token punctuation">.</span>fromChunks</span> <span class="token punctuation">[</span><span class="token constant">S</span><span class="token punctuation">.</span><span class="token builtin">pack</span> <span class="token punctuation">[</span><span class="token number">40</span><span class="token punctuation">,</span><span class="token number">41</span><span class="token punctuation">,</span><span class="token number">42</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token constant">S</span><span class="token punctuation">.</span><span class="token builtin">pack</span> <span class="token punctuation">[</span><span class="token number">43</span><span class="token punctuation">,</span><span class="token number">44</span><span class="token punctuation">,</span><span class="token number">45</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token constant">S</span><span class="token punctuation">.</span><span class="token builtin">pack</span> <span class="token punctuation">[</span><span class="token number">46</span><span class="token punctuation">,</span><span class="token number">47</span><span class="token punctuation">,</span><span class="token number">48</span><span class="token punctuation">]</span><span class="token punctuation">]</span>
<span class="token constant">Chunk</span> <span class="token string">"()*"</span> <span class="token punctuation">(</span><span class="token constant">Chunk</span> <span class="token string">"+,-"</span> <span class="token punctuation">(</span><span class="token constant">Chunk</span> <span class="token string">"./0"</span> <span class="token constant">Empty</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>This is good if you have a lot of small strict bytestrings and you want to process them efficiently without joining them into one big strict bytestring in memory first.</p></div><div><p>The bytestring version of <code>:</code> is called <code>cons</code> It takes a byte and a bytestring and puts the byte at the beginning. It's lazy though, so it will make a new chunk even if the first chunk in the bytestring isn't full. That's why it's better to use the strict version of <code>cons</code>, <code>cons'</code> if you're going to be inserting a lot of bytes at the beginning of a bytestring.</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token hvariable">B<span class="token punctuation">.</span>cons</span> <span class="token number">85</span> <span class="token operator">$</span> <span class="token constant">B</span><span class="token punctuation">.</span><span class="token builtin">pack</span> <span class="token punctuation">[</span><span class="token number">80</span><span class="token punctuation">,</span><span class="token number">81</span><span class="token punctuation">,</span><span class="token number">82</span><span class="token punctuation">,</span><span class="token number">84</span><span class="token punctuation">]</span>
<span class="token constant">Chunk</span> <span class="token string">"U"</span> <span class="token punctuation">(</span><span class="token constant">Chunk</span> <span class="token string">"PQRT"</span> <span class="token constant">Empty</span><span class="token punctuation">)</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token hvariable">B<span class="token punctuation">.</span>cons'</span> <span class="token number">85</span> <span class="token operator">$</span> <span class="token constant">B</span><span class="token punctuation">.</span><span class="token builtin">pack</span> <span class="token punctuation">[</span><span class="token number">80</span><span class="token punctuation">,</span><span class="token number">81</span><span class="token punctuation">,</span><span class="token number">82</span><span class="token punctuation">,</span><span class="token number">84</span><span class="token punctuation">]</span>
<span class="token constant">Chunk</span> <span class="token string">"UPQRT"</span> <span class="token constant">Empty</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token builtin">foldr</span> <span class="token hvariable">B<span class="token punctuation">.</span>cons</span> <span class="token hvariable">B<span class="token punctuation">.</span>empty</span> <span class="token punctuation">[</span><span class="token number">50</span><span class="token operator">..</span><span class="token number">60</span><span class="token punctuation">]</span>
<span class="token constant">Chunk</span> <span class="token string">"2"</span> <span class="token punctuation">(</span><span class="token constant">Chunk</span> <span class="token string">"3"</span> <span class="token punctuation">(</span><span class="token constant">Chunk</span> <span class="token string">"4"</span> <span class="token punctuation">(</span><span class="token constant">Chunk</span> <span class="token string">"5"</span> <span class="token punctuation">(</span><span class="token constant">Chunk</span> <span class="token string">"6"</span> <span class="token punctuation">(</span><span class="token constant">Chunk</span> <span class="token string">"7"</span> <span class="token punctuation">(</span><span class="token constant">Chunk</span> <span class="token string">"8"</span> <span class="token punctuation">(</span><span class="token constant">Chunk</span> <span class="token string">"9"</span> <span class="token punctuation">(</span><span class="token constant">Chunk</span> <span class="token string">":"</span> <span class="token punctuation">(</span><span class="token constant">Chunk</span> <span class="token string">";"</span> <span class="token punctuation">(</span><span class="token constant">Chunk</span> <span class="token string">"&lt;"</span>
<span class="token constant">Empty</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token builtin">foldr</span> <span class="token hvariable">B<span class="token punctuation">.</span>cons'</span> <span class="token hvariable">B<span class="token punctuation">.</span>empty</span> <span class="token punctuation">[</span><span class="token number">50</span><span class="token operator">..</span><span class="token number">60</span><span class="token punctuation">]</span>
<span class="token constant">Chunk</span> <span class="token string">"23456789:;&lt;"</span> <span class="token constant">Empty</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>As you can see <code>empty</code> makes an empty bytestring. See the difference between <code>cons</code> and <code>cons'</code>? With the <code>foldr</code>, we started with an empty bytestring and then went over the list of numbers from the right, adding each number to the beginning of the bytestring. When we used <code>cons</code>, we ended up with one chunk for every byte, which kind of defeats the purpose.</p></div><div><p>Otherwise, the bytestring modules have a load of functions that are analogous to those in <code>Data.List</code>, including, but not limited to, <code>head</code>, <code>tail</code>, <code>init</code>, <code>null</code>, <code>length</code>, <code>map</code>, <code>reverse</code>, <code>foldl</code>, <code>foldr</code>, <code>concat</code>, <code>takeWhile</code>, <code>filter</code>, etc.</p></div><div><p>It also has functions that have the same name and behave the same as some functions found in <code>System.IO</code>, only <code>String</code>s are replaced with <code>ByteString</code>s. For instance, the <code>readFile</code> function in <code>System.IO</code> has a type of <code>readFile :: FilePath -&gt; IO String</code>, while the <code>readFile</code> from the bytestring modules has a type of <code>readFile :: FilePath -&gt; IO ByteString</code>. Watch out, if you're using strict bytestrings and you attempt to read a file, it will read it into memory at once! With lazy bytestrings, it will read it into neat chunks.</p></div><div><p>Let's make a simple program that takes two filenames as command-line arguments and copies the first file into the second file. Note that <code>System.Directory</code> already has a function called <code>copyFile</code>, but we're going to implement our own file copying function and program anyway.</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token import-statement"><span class="token keyword">import</span> System<span class="token punctuation">.</span>Environment</span>
<span class="token import-statement"><span class="token keyword">import</span> <span class="token keyword">qualified</span> Data<span class="token punctuation">.</span>ByteString<span class="token punctuation">.</span>Lazy <span class="token keyword">as</span> B</span>

<span class="token hvariable">main</span> <span class="token operator">=</span> <span class="token keyword">do</span>
    <span class="token punctuation">(</span><span class="token hvariable">fileName1</span><span class="token operator">:</span><span class="token hvariable">fileName2</span><span class="token operator">:</span><span class="token hvariable">_</span><span class="token punctuation">)</span> <span class="token operator">&lt;-</span> <span class="token hvariable">getArgs</span>
    <span class="token hvariable">copyFile</span> <span class="token hvariable">fileName1</span> <span class="token hvariable">fileName2</span>

<span class="token hvariable">copyFile</span> <span class="token operator">::</span> <span class="token constant">FilePath</span> <span class="token operator">-&gt;</span> <span class="token constant">FilePath</span> <span class="token operator">-&gt;</span> <span class="token constant">IO</span> <span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token hvariable">copyFile</span> <span class="token hvariable">source</span> <span class="token hvariable">dest</span> <span class="token operator">=</span> <span class="token keyword">do</span>
    <span class="token hvariable">contents</span> <span class="token operator">&lt;-</span> <span class="token constant">B</span><span class="token punctuation">.</span><span class="token builtin">readFile</span> <span class="token hvariable">source</span>
    <span class="token constant">B</span><span class="token punctuation">.</span><span class="token builtin">writeFile</span> <span class="token hvariable">dest</span> <span class="token hvariable">contents</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>We make our own function that takes two <code>FilePath</code>s (remember, <code>FilePath</code> is just a synonym for <code>String</code>) and returns an I/O action that will copy one file into another using bytestring. In the <code>main</code> function, we just get the arguments and call our function with them to get the I/O action, which is then performed.</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token operator">$</span> <span class="token hvariable">runhaskell</span> <span class="token hvariable">bytestringcopy</span><span class="token punctuation">.</span><span class="token hvariable">hs</span> <span class="token hvariable">something</span><span class="token punctuation">.</span><span class="token hvariable">txt</span> <span class="token operator">../../</span><span class="token hvariable">something</span><span class="token punctuation">.</span><span class="token hvariable">txt</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Notice that a program that doesn't use bytestrings could look just like this, the only difference is that we used <code>B.readFile</code> and <code>B.writeFile</code> instead of <code>readFile</code> and <code>writeFile</code>. Many times, you can convert a program that uses normal strings to a program that uses bytestrings by just doing the necessary imports and then putting the qualified module names in front of some functions. Sometimes, you have to convert functions that you wrote to work on strings so that they work on bytestrings, but that's not hard.</p></div><div><p>Whenever you need better performance in a program that reads a lot of data into strings, give bytestrings a try, chances are you'll get some good performance boosts with very little effort on your part. I usually write programs by using normal strings and then convert them to use bytestrings if the performance is not satisfactory.</p></div><div><h2 data-heading="Exceptions" id="Exceptions" style="display: flex;"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>Exceptions</h2></div><div><p><span alt="LYHfGG_70_timber.png" src="LYHfGG_70_timber.png" class="internal-embed media-embed image-embed is-loaded"><img alt="LYHfGG_70_timber.png" src="курсы\learn-you-a-haskell-for-great-good!\картинки\lyhfgg_70_timber.png"></span></p></div><div><p>All languages have procedures, functions, and pieces of code that might fail in some way. That's just a fact of life. Different languages have different ways of handling those failures. In C, we usually use some abnormal return value (like <code>-1</code> or a null pointer) to indicate that what a function returned shouldn't be treated like a normal value. Java and C#, on the other hand, tend to use exceptions to handle failure. When an exception is thrown, the control flow jumps to some code that we've defined that does some cleanup and then maybe re-throws the exception so that some other error handling code can take care of some other stuff.</p></div><div><p>Haskell has a very good type system. Algebraic data types allow for types like <code>Maybe</code> and <code>Either</code> and we can use values of those types to represent results that may be there or not. In C, returning, say, <code>-1</code> on failure is completely a matter of convention. It only has special meaning to humans. If we're not careful, we might treat these abnormal values as ordinary ones and then they can cause havoc and dismay in our code. Haskell's type system gives us some much-needed safety in that aspect. A function <code>a -&gt; Maybe b</code> clearly indicates that it it may produce a <code>b</code> wrapped in <code>Just</code> or that it may return <code>Nothing</code>. The type is different from just plain <code>a -&gt; b</code> and if we try to use those two functions interchangeably, the compiler will complain at us.</p></div><div><p>Despite having expressive types that support failed computations, Haskell still has support for exceptions, because they make more sense in I/O contexts. A lot of things can go wrong when dealing with the outside world because it is so unreliable. For instance, when opening a file, a bunch of things can go wrong. The file might be locked, it might not be there at all or the hard disk drive or something might not be there at all. So it's good to be able to jump to some error handling part of our code when such an error occurs.</p></div><div><p>Okay, so I/O code (i.e. impure code) can throw exceptions. It makes sense. But what about pure code? Well, it can throw exceptions too. Think about the <code>div</code> and <code>head</code> functions. They have types of <code>(Integral a) =&gt; a -&gt; a -&gt; a</code> and <code>[a] -&gt; a</code>, respectively. No <code>Maybe</code> or <code>Either</code> in their return type and yet they can both fail! <code>div</code> explodes in your face if you try to divide by zero and <code>head</code> throws a tantrum when you give it an empty list.</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token number">4</span> <span class="token operator">`div`</span> <span class="token number">0</span>
<span class="token operator">***</span> <span class="token constant">Exception</span><span class="token operator">:</span> <span class="token hvariable">divide</span> <span class="token hvariable">by</span> <span class="token hvariable">zero</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token builtin">head</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
<span class="token operator">***</span> <span class="token constant">Exception</span><span class="token operator">:</span> <span class="token constant">Prelude</span><span class="token punctuation">.</span><span class="token builtin">head</span><span class="token operator">:</span> <span class="token hvariable">empty</span> <span class="token hvariable">list</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p><span alt="LYHfGG_71_police.png" src="LYHfGG_71_police.png" class="internal-embed media-embed image-embed is-loaded"><img alt="LYHfGG_71_police.png" src="курсы\learn-you-a-haskell-for-great-good!\картинки\lyhfgg_71_police.png"></span></p></div><div><p>Pure code can throw exceptions, but it they can only be caught in the I/O part of our code (when we're inside a <em>do</em> block that goes into <code>main</code>). That's because you don't know when (or if) anything will be evaluated in pure code, because it is lazy and doesn't have a well-defined order of execution, whereas I/O code does.</p></div><div><p>Earlier, we talked about how we should spend as little time as possible in the I/O part of our program. The logic of our program should reside mostly within our pure functions, because their results are dependant only on the parameters that the functions are called with. When dealing with pure functions, you only have to think about what a function returns, because it can't do anything else. This makes your life easier. Even though doing some logic in I/O is necessary (like opening files and the like), it should preferably be kept to a minimum. Pure functions are lazy by default, which means that we don't know when they will be evaluated and that it really shouldn't matter. However, once pure functions start throwing exceptions, it matters when they are evaluated. That's why we can only catch exceptions thrown from pure functions in the I/O part of our code. And that's bad, because we want to keep the I/O part as small as possible. However, if we don't catch them in the I/O part of our code, our program crashes. The solution? Don't mix exceptions and pure code. Take advantage of Haskell's powerful type system and use types like <code>Either</code> and <code>Maybe</code> to represent results that may have failed.</p></div><div><p>That's why we'll just be looking at how to use I/O exceptions for now. I/O exceptions are exceptions that are caused when something goes wrong while we are communicating with the outside world in an I/O action that's part of <code>main</code>. For example, we can try opening a file and then it turns out that the file has been deleted or something. Take a look at this program that opens a file whose name is given to it as a command line argument and tells us how many lines the file has.</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token import-statement"><span class="token keyword">import</span> System<span class="token punctuation">.</span>Environment</span>
<span class="token import-statement"><span class="token keyword">import</span> System<span class="token punctuation">.</span>IO</span>

<span class="token hvariable">main</span> <span class="token operator">=</span> <span class="token keyword">do</span> <span class="token punctuation">(</span><span class="token hvariable">fileName</span><span class="token operator">:</span><span class="token hvariable">_</span><span class="token punctuation">)</span> <span class="token operator">&lt;-</span> <span class="token hvariable">getArgs</span>
          <span class="token hvariable">contents</span> <span class="token operator">&lt;-</span> <span class="token builtin">readFile</span> <span class="token hvariable">fileName</span>
          <span class="token builtin">putStrLn</span> <span class="token operator">$</span> <span class="token string">"The file has "</span> <span class="token operator">++</span> <span class="token builtin">show</span> <span class="token punctuation">(</span><span class="token builtin">length</span> <span class="token punctuation">(</span><span class="token builtin">lines</span> <span class="token hvariable">contents</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">++</span> <span class="token string">" lines!"</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>A very simple program. We perform the <code>getArgs</code> I/O action and bind the first string in the list that it yields to <code>fileName</code>. Then we call the contents of the file with that name <code>contents</code>. Lastly, we apply <code>lines</code> to those contents to get a list of lines and then we get the length of that list and give it to <code>show</code> to get a string representation of that number. It works as expected, but what happens when we give it the name of a file that doesn't exist?</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token operator">$</span> <span class="token hvariable">runhaskell</span> <span class="token hvariable">linecount</span><span class="token punctuation">.</span><span class="token hvariable">hs</span> <span class="token hvariable">i_dont_exist</span><span class="token punctuation">.</span><span class="token hvariable">txt</span>
<span class="token hvariable">linecount</span><span class="token punctuation">.</span><span class="token hvariable">hs</span><span class="token operator">:</span> <span class="token hvariable">i_dont_exist</span><span class="token punctuation">.</span><span class="token hvariable">txt</span><span class="token operator">:</span> <span class="token hvariable">openFile</span><span class="token operator">:</span> <span class="token hvariable">does</span> <span class="token builtin">not</span> <span class="token hvariable">exist</span> <span class="token punctuation">(</span><span class="token constant">No</span> <span class="token hvariable">such</span> <span class="token hvariable">file</span> <span class="token builtin">or</span> <span class="token hvariable">directory</span><span class="token punctuation">)</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Aha, we get an error from GHC, telling us that the file does not exist. Our program crashes. What if we wanted to print out a nicer message if the file doesn't exist? One way to do that is to check if the file exists before trying to open it by using the <code>doesFileExist</code> function from <code>System.Directory</code>.</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token import-statement"><span class="token keyword">import</span> System<span class="token punctuation">.</span>Environment</span>
<span class="token import-statement"><span class="token keyword">import</span> System<span class="token punctuation">.</span>IO</span>
<span class="token import-statement"><span class="token keyword">import</span> System<span class="token punctuation">.</span>Directory</span>

<span class="token hvariable">main</span> <span class="token operator">=</span> <span class="token keyword">do</span> <span class="token punctuation">(</span><span class="token hvariable">fileName</span><span class="token operator">:</span><span class="token hvariable">_</span><span class="token punctuation">)</span> <span class="token operator">&lt;-</span> <span class="token hvariable">getArgs</span>
          <span class="token hvariable">fileExists</span> <span class="token operator">&lt;-</span> <span class="token hvariable">doesFileExist</span> <span class="token hvariable">fileName</span>
          <span class="token keyword">if</span> <span class="token hvariable">fileExists</span>
              <span class="token keyword">then</span> <span class="token keyword">do</span> <span class="token hvariable">contents</span> <span class="token operator">&lt;-</span> <span class="token builtin">readFile</span> <span class="token hvariable">fileName</span>
                      <span class="token builtin">putStrLn</span> <span class="token operator">$</span> <span class="token string">"The file has "</span> <span class="token operator">++</span> <span class="token builtin">show</span> <span class="token punctuation">(</span><span class="token builtin">length</span> <span class="token punctuation">(</span><span class="token builtin">lines</span> <span class="token hvariable">contents</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">++</span> <span class="token string">" lines!"</span>
              <span class="token keyword">else</span> <span class="token keyword">do</span> <span class="token builtin">putStrLn</span> <span class="token string">"The file doesn't exist!"</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>We did <code>fileExists &lt;- doesFileExist fileName</code> because <code>doesFileExist</code> has a type of <code>doesFileExist :: FilePath -&gt; IO Bool</code>, which means that it returns an I/O action that has as its result a boolean value which tells us if the file exists. We can't just use <code>doesFileExist</code> in an <em>if</em> expression directly.</p></div><div><p>Another solution here would be to use exceptions. It's perfectly acceptable to use them in this context. A file not existing is an exception that arises from I/O, so catching it in I/O is fine and dandy.</p></div><div><p>To deal with this by using exceptions, we're going to take advantage of the <code>catch</code> function from <code>System.IO.Error</code>. Its type is <code>catch :: IO a -&gt; (IOError -&gt; IO a) -&gt; IO a</code>. It takes two parameters. The first one is an I/O action. For instance, it could be an I/O action that tries to open a file. The second one is the so-called handler. If the first I/O action passed to <code>catch</code> throws an I/O exception, that exception gets passed to the handler, which then decides what to do. So the final result is an I/O action that will either act the same as the first parameter or it will do what the handler tells it if the first I/O action throws an exception.</p></div><div><p><span alt="LYHfGG_72_puppy.png" src="LYHfGG_72_puppy.png" class="internal-embed media-embed image-embed is-loaded"><img alt="LYHfGG_72_puppy.png" src="курсы\learn-you-a-haskell-for-great-good!\картинки\lyhfgg_72_puppy.png"></span></p></div><div><p>If you're familiar with <em>try-catch</em> blocks in languages like Java or Python, the <code>catch</code> function is similar to them. The first parameter is the thing to try, kind of like the stuff in the <em>try</em> block in other, imperative languages. The second parameter is the handler that takes an exception, just like most <em>catch</em> blocks take exceptions that you can then examine to see what happened. The handler is invoked if an exception is thrown.</p></div><div><p>The handler takes a value of type <code>IOError</code>, which is a value that signifies that an I/O exception occurred. It also carries information regarding the type of the exception that was thrown. How this type is implemented depends on the implementation of the language itself, which means that we can't inspect values of the type <code>IOError</code> by pattern matching against them, just like we can't pattern match against values of type <code>IO _something_</code>. We can use a bunch of useful predicates to find out stuff about values of type <code>IOError</code> as we'll learn in a second.</p></div><div><p>So let's put our new friend <code>catch</code> to use!</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token import-statement"><span class="token keyword">import</span> System<span class="token punctuation">.</span>Environment</span>
<span class="token import-statement"><span class="token keyword">import</span> System<span class="token punctuation">.</span>IO</span>
<span class="token import-statement"><span class="token keyword">import</span> System<span class="token punctuation">.</span>IO<span class="token punctuation">.</span>Error</span>

<span class="token hvariable">main</span> <span class="token operator">=</span> <span class="token hvariable">toTry</span> <span class="token operator">`catch`</span> <span class="token hvariable">handler</span>
            
<span class="token hvariable">toTry</span> <span class="token operator">::</span> <span class="token constant">IO</span> <span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token hvariable">toTry</span> <span class="token operator">=</span> <span class="token keyword">do</span> <span class="token punctuation">(</span><span class="token hvariable">fileName</span><span class="token operator">:</span><span class="token hvariable">_</span><span class="token punctuation">)</span> <span class="token operator">&lt;-</span> <span class="token hvariable">getArgs</span>
           <span class="token hvariable">contents</span> <span class="token operator">&lt;-</span> <span class="token builtin">readFile</span> <span class="token hvariable">fileName</span>
           <span class="token builtin">putStrLn</span> <span class="token operator">$</span> <span class="token string">"The file has "</span> <span class="token operator">++</span> <span class="token builtin">show</span> <span class="token punctuation">(</span><span class="token builtin">length</span> <span class="token punctuation">(</span><span class="token builtin">lines</span> <span class="token hvariable">contents</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">++</span> <span class="token string">" lines!"</span>

<span class="token hvariable">handler</span> <span class="token operator">::</span> <span class="token constant">IOError</span> <span class="token operator">-&gt;</span> <span class="token constant">IO</span> <span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token hvariable">handler</span> <span class="token hvariable">e</span> <span class="token operator">=</span> <span class="token builtin">putStrLn</span> <span class="token string">"Whoops, had some trouble!"</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>First of all, you'll see that put backticks around it so that we can use it as an infix function, because it takes two parameters. Using it as an infix function makes it more readable. So <code>toTry `catch` handler</code> is the same as <code>catch toTry handler</code>, which fits well with its type. <code>toTry</code> is the I/O action that we try to carry out and <code>handler</code> is the function that takes an <code>IOError</code> and returns an action to be carried out in case of an exception.</p></div><div><p>Let's give this a go:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token operator">$</span> <span class="token hvariable">runhaskell</span> <span class="token hvariable">count_lines</span><span class="token punctuation">.</span><span class="token hvariable">hs</span> <span class="token hvariable">i_exist</span><span class="token punctuation">.</span><span class="token hvariable">txt</span>
<span class="token constant">The</span> <span class="token hvariable">file</span> <span class="token hvariable">has</span> <span class="token number">3</span> <span class="token builtin">lines</span><span class="token operator">!</span>

<span class="token operator">$</span> <span class="token hvariable">runhaskell</span> <span class="token hvariable">count_lines</span><span class="token punctuation">.</span><span class="token hvariable">hs</span> <span class="token hvariable">i_dont_exist</span><span class="token punctuation">.</span><span class="token hvariable">txt</span>
<span class="token constant">Whoops</span><span class="token punctuation">,</span> <span class="token hvariable">had</span> <span class="token hvariable">some</span> <span class="token hvariable">trouble</span><span class="token operator">!</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>In the handler, we didn't check to see what kind of <code>IOError</code> we got. We just say <code>"Whoops, had some trouble!"</code> for any kind of error. Just catching all types of exceptions in one handler is bad practice in Haskell just like it is in most other languages. What if some other exception happens that we don't want to catch, like us interrupting the program or something? That's why we're going to do the same thing that's usually done in other languages as well: we'll check to see what kind of exception we got. If it's the kind of exception we're waiting to catch, we do our stuff. If it's not, we throw that exception back into the wild. Let's modify our program to catch only the exceptions caused by a file not existing.</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token import-statement"><span class="token keyword">import</span> System<span class="token punctuation">.</span>Environment</span>
<span class="token import-statement"><span class="token keyword">import</span> System<span class="token punctuation">.</span>IO</span>
<span class="token import-statement"><span class="token keyword">import</span> System<span class="token punctuation">.</span>IO<span class="token punctuation">.</span>Error</span>

<span class="token hvariable">main</span> <span class="token operator">=</span> <span class="token hvariable">toTry</span> <span class="token operator">`catch`</span> <span class="token hvariable">handler</span>
            
<span class="token hvariable">toTry</span> <span class="token operator">::</span> <span class="token constant">IO</span> <span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token hvariable">toTry</span> <span class="token operator">=</span> <span class="token keyword">do</span> <span class="token punctuation">(</span><span class="token hvariable">fileName</span><span class="token operator">:</span><span class="token hvariable">_</span><span class="token punctuation">)</span> <span class="token operator">&lt;-</span> <span class="token hvariable">getArgs</span>
           <span class="token hvariable">contents</span> <span class="token operator">&lt;-</span> <span class="token builtin">readFile</span> <span class="token hvariable">fileName</span>
           <span class="token builtin">putStrLn</span> <span class="token operator">$</span> <span class="token string">"The file has "</span> <span class="token operator">++</span> <span class="token builtin">show</span> <span class="token punctuation">(</span><span class="token builtin">length</span> <span class="token punctuation">(</span><span class="token builtin">lines</span> <span class="token hvariable">contents</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">++</span> <span class="token string">" lines!"</span>

<span class="token hvariable">handler</span> <span class="token operator">::</span> <span class="token constant">IOError</span> <span class="token operator">-&gt;</span> <span class="token constant">IO</span> <span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token hvariable">handler</span> <span class="token hvariable">e</span>
    <span class="token operator">|</span> <span class="token hvariable">isDoesNotExistError</span> <span class="token hvariable">e</span> <span class="token operator">=</span> <span class="token builtin">putStrLn</span> <span class="token string">"The file doesn't exist!"</span>
    <span class="token operator">|</span> <span class="token builtin">otherwise</span> <span class="token operator">=</span> <span class="token builtin">ioError</span> <span class="token hvariable">e</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Everything stays the same except the handler, which we modified to only catch a certain group of I/O exceptions. Here we used two new functions from <code>System.IO.Error</code> — <code>isDoesNotExistError</code> and <code>ioError</code>. <code>isDoesNotExistError</code> is a predicate over <code>IOError</code>s, which means that it's a function that takes an <code>IOError</code> and returns a <code>True</code> or <code>False</code>, meaning it has a type of <code>isDoesNotExistError :: IOError -&gt; Bool</code>. We use it on the exception that gets passed to our handler to see if it's an error caused by a file not existing. We use <a data-tooltip-position="top" aria-label="http://learnyouahaskell.com/syntax-in-functions#guards-guards" rel="noopener" class="external-link" href="http://learnyouahaskell.com/syntax-in-functions#guards-guards" target="_blank">guard</a> syntax here, but we could have also used an <em>if else</em>. If it's not caused by a file not existing, we re-throw the exception that was passed by the handler with the <code>ioError</code> function. It has a type of <code>ioError :: IOException -&gt; IO a</code>, so it takes an <code>IOError</code> and produces an I/O action that will throw it. The I/O action has a type of <code>IO a</code>, because it never actually yields a result, so it can act as <code>IO _anything_</code>.</p></div><div><p>So the exception thrown in the <code>toTry</code> I/O action that we glued together with a <em>do</em> block isn't caused by a file existing, <code>toTry `catch` handler</code> will catch that and then re-throw it. Pretty cool, huh?</p></div><div><p>There are several predicates that act on <code>IOError</code> and if a guard doesn't evaluate to <code>True</code>, evaluation falls through to the next guard. The predicates that act on <code>IOError</code> are:</p></div><div><ul class="has-list-bullet">
<li data-line="0"><div class="list-bullet"></div>isAlreadyExistsError</li>
<li data-line="1"><div class="list-bullet"></div>isDoesNotExistError</li>
<li data-line="2"><div class="list-bullet"></div>isAlreadyInUseError</li>
<li data-line="3"><div class="list-bullet"></div>isFullError</li>
<li data-line="4"><div class="list-bullet"></div>isEOFError</li>
<li data-line="5"><div class="list-bullet"></div>isIllegalOperation</li>
<li data-line="6"><div class="list-bullet"></div>isPermissionError</li>
<li data-line="7"><div class="list-bullet"></div>isUserError</li>
</ul></div><div><p>Most of these are pretty self-explanatory. <code>isUserError</code> evaluates to <code>True</code> when we use the function <code>userError</code> to make the exception, which is used for making exceptions from our code and equipping them with a string. For instance, you can do <code>ioError $ userError "remote computer unplugged!"</code>, although It's prefered you use types like <code>Either</code> and <code>Maybe</code> to express possible failure instead of throwing exceptions yourself with <code>userError</code>.</p></div><div><p>So you could have a handler that looks something like this:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">handler</span> <span class="token operator">::</span> <span class="token constant">IOError</span> <span class="token operator">-&gt;</span> <span class="token constant">IO</span> <span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token hvariable">handler</span> <span class="token hvariable">e</span>
    <span class="token operator">|</span> <span class="token hvariable">isDoesNotExistError</span> <span class="token hvariable">e</span> <span class="token operator">=</span> <span class="token builtin">putStrLn</span> <span class="token string">"The file doesn't exist!"</span>
    <span class="token operator">|</span> <span class="token hvariable">isFullError</span> <span class="token hvariable">e</span> <span class="token operator">=</span> <span class="token hvariable">freeSomeSpace</span>
    <span class="token operator">|</span> <span class="token hvariable">isIllegalOperation</span> <span class="token hvariable">e</span> <span class="token operator">=</span> <span class="token hvariable">notifyCops</span>
    <span class="token operator">|</span> <span class="token builtin">otherwise</span> <span class="token operator">=</span> <span class="token builtin">ioError</span> <span class="token hvariable">e</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Where <code>notifyCops</code> and <code>freeSomeSpace</code> are some I/O actions that you define. Be sure to re-throw exceptions if they don't match any of your criteria, otherwise you're causing your program to fail silently in some cases where it shouldn't.</p></div><div><p><code>System.IO.Error</code> also exports functions that enable us to ask our exceptions for some attributes, like what the handle of the file that caused the error is, or what the filename is. These start with <code>ioe</code> and you can see a <a data-tooltip-position="top" aria-label="http://www.haskell.org/ghc/docs/6.10.1/html/libraries/base/System-IO-Error.html#3" rel="noopener" class="external-link" href="http://www.haskell.org/ghc/docs/6.10.1/html/libraries/base/System-IO-Error.html#3" target="_blank">full list of them</a> in the documentation. Say we want to print the filename that caused our error. We can't print the <code>fileName</code> that we got from <code>getArgs</code>, because only the <code>IOError</code> is passed to the handler and the handler doesn't know about anything else. A function depends only on the parameters it was called with. That's why we can use the <code>ioeGetFileName</code> function, which has a type of <code>ioeGetFileName :: IOError -&gt; Maybe FilePath</code>. It takes an <code>IOError</code> as a parameter and maybe returns a <code>FilePath</code> (which is just a type synonym for <code>String</code>, remember, so it's kind of the same thing). Basically, what it does is it extracts the file path from the <code>IOError</code>, if it can. Let's modify our program to print out the file path that's responsible for the exception occurring.</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token import-statement"><span class="token keyword">import</span> System<span class="token punctuation">.</span>Environment</span>   
<span class="token import-statement"><span class="token keyword">import</span> System<span class="token punctuation">.</span>IO</span>   
<span class="token import-statement"><span class="token keyword">import</span> System<span class="token punctuation">.</span>IO<span class="token punctuation">.</span>Error</span>   
  
<span class="token hvariable">main</span> <span class="token operator">=</span> <span class="token hvariable">toTry</span> <span class="token operator">`catch`</span> <span class="token hvariable">handler</span>   
               
<span class="token hvariable">toTry</span> <span class="token operator">::</span> <span class="token constant">IO</span> <span class="token punctuation">(</span><span class="token punctuation">)</span>   
<span class="token hvariable">toTry</span> <span class="token operator">=</span> <span class="token keyword">do</span> <span class="token punctuation">(</span><span class="token hvariable">fileName</span><span class="token operator">:</span><span class="token hvariable">_</span><span class="token punctuation">)</span> <span class="token operator">&lt;-</span> <span class="token hvariable">getArgs</span>   
           <span class="token hvariable">contents</span> <span class="token operator">&lt;-</span> <span class="token builtin">readFile</span> <span class="token hvariable">fileName</span>   
           <span class="token builtin">putStrLn</span> <span class="token operator">$</span> <span class="token string">"The file has "</span> <span class="token operator">++</span> <span class="token builtin">show</span> <span class="token punctuation">(</span><span class="token builtin">length</span> <span class="token punctuation">(</span><span class="token builtin">lines</span> <span class="token hvariable">contents</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">++</span> <span class="token string">" lines!"</span>   
  
<span class="token hvariable">handler</span> <span class="token operator">::</span> <span class="token constant">IOError</span> <span class="token operator">-&gt;</span> <span class="token constant">IO</span> <span class="token punctuation">(</span><span class="token punctuation">)</span>   
<span class="token hvariable">handler</span> <span class="token hvariable">e</span>   
    <span class="token operator">|</span> <span class="token hvariable">isDoesNotExistError</span> <span class="token hvariable">e</span> <span class="token operator">=</span> 
        <span class="token keyword">case</span> <span class="token hvariable">ioeGetFileName</span> <span class="token hvariable">e</span> <span class="token keyword">of</span> <span class="token constant">Just</span> <span class="token hvariable">path</span> <span class="token operator">-&gt;</span> <span class="token builtin">putStrLn</span> <span class="token operator">$</span> <span class="token string">"Whoops! File does not exist at: "</span> <span class="token operator">++</span> <span class="token hvariable">path</span>
                                 <span class="token constant">Nothing</span> <span class="token operator">-&gt;</span> <span class="token builtin">putStrLn</span> <span class="token string">"Whoops! File does not exist at unknown location!"</span>
    <span class="token operator">|</span> <span class="token builtin">otherwise</span> <span class="token operator">=</span> <span class="token builtin">ioError</span> <span class="token hvariable">e</span>   
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>In the guard where <code>isDoesNotExistError</code> is <code>True</code>, we used a <em>case</em> expression to call <code>ioeGetFileName</code> with <code>e</code> and then pattern match against the <code>Maybe</code> value that it returned. Using <em>case</em> expressions is commonly used when you want to pattern match against something without bringing in a new function.</p></div><div><p>You don't have to use one handler to <code>catch</code> exceptions in your whole I/O part. You can just cover certain parts of your I/O code with <code>catch</code> or you can cover several of them with <code>catch</code> and use different handlers for them, like so:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">main</span> <span class="token operator">=</span> <span class="token keyword">do</span> <span class="token hvariable">toTry</span> <span class="token operator">`catch`</span> <span class="token hvariable">handler1</span>
          <span class="token hvariable">thenTryThis</span> <span class="token operator">`catch`</span> <span class="token hvariable">handler2</span>
          <span class="token hvariable">launchRockets</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Here, <code>toTry</code> uses <code>handler1</code> as the handler and <code>thenTryThis</code> uses <code>handler2</code>. <code>launchRockets</code> isn't a parameter to <code>catch</code>, so whichever exceptions it might throw will likely crash our program, unless <code>launchRockets</code> uses <code>catch</code> internally to handle its own exceptions. Of course <code>toTry</code>, <code>thenTryThis</code> and <code>launchRockets</code> are I/O actions that have been glued together using <em>do</em> syntax and hypothetically defined somewhere else. This is kind of similar to <em>try-catch</em> blocks of other languages, where you can surround your whole program in a single <em>try-catch</em> or you can use a more fine-grained approach and use different ones in different parts of your code to control what kind of error handling happens where.</p></div><div><p>Now you know how to deal with I/O exceptions! Throwing exceptions from pure code and dealing with them hasn't been covered here, mainly because, like we said, Haskell offers much better ways to indicate errors than reverting to I/O to catch them. Even when glueing together I/O actions that might fail, I prefer to have their type be something like <code>IO (Either a b)</code>, meaning that they're normal I/O actions but the result that they yield when performed is of type <code>Either a b</code>, meaning it's either <code>Left a</code> or <code>Right b</code>.</p></div><div><h1 data-heading="Functionally Solving Problems" id="Functionally_Solving_Problems">Functionally Solving Problems</h1></div><div><p>In this chapter, we'll take a look at a few interesting problems and how to think functionally to solve them as elegantly as possible. We probably won't be introducing any new concepts, we'll just be flexing our newly acquired Haskell muscles and practicing our coding skills. Each section will present a different problem. First we'll describe the problem, then we'll try and find out what the best (or least worst) way of solving it is.</p></div><div><h2 data-heading="Reverse Polish notation calculator" id="Reverse_Polish_notation_calculator" style="display: flex;"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>Reverse Polish notation calculator</h2></div><div><p>Usually when we write mathematical expressions in school, we write them in an infix manner. For instance, we write <code>10 - (4 + 3) * 2</code>. <code>+</code>, <code>*</code> and <code>-</code> are infix operators, just like the infix functions we met in Haskell (<code>+</code>, <code>`elem`</code>, etc.). This makes it handy because we, as humans, can parse it easily in our minds by looking at such an expression. The downside to it is that we have to use parentheses to denote precedence.</p></div><div><p><a data-tooltip-position="top" aria-label="http://en.wikipedia.org/wiki/Reverse_Polish_notation" rel="noopener" class="external-link" href="http://en.wikipedia.org/wiki/Reverse_Polish_notation" target="_blank">Reverse Polish notation</a> is another way of writing down mathematical expressions. Initially it looks a bit weird, but it's actually pretty easy to understand and use because there's no need for parentheses and it's very easy to punch into a calculator. While most modern calculators use infix notation, some people still swear by RPN calculators. This is what the previous infix expression looks like in RPN: <code>10 4 3 + 2 * -</code>. How do we calculate what the result of that is? Well, think of a stack. You go over the expression from left to right. Every time a number is encountered, push it on to the stack. When we encounter an operator, take the two numbers that are on top of the stack (we also say that we <em>pop</em> them), use the operator and those two and then push the resulting number back onto the stack. When you reach the end of the expression, you should be left with a single number if the expression was well-formed and that number represents the result.</p></div><div><p><span alt="LYHfGG_73_rpn.png" src="LYHfGG_73_rpn.png" class="internal-embed media-embed image-embed is-loaded"><img alt="LYHfGG_73_rpn.png" src="курсы\learn-you-a-haskell-for-great-good!\картинки\lyhfgg_73_rpn.png"></span></p></div><div><p>Let's go over the expression <code>10 4 3 + 2 * -</code> together! First we push <code>10</code> on to the stack and the stack is now <code>10</code>. The next item is <code>4</code>, so we push it to the stack as well. The stack is now <code>10, 4</code>. We do the same with <code>3</code> and the stack is now <code>10, 4, 3</code>. And now, we encounter an operator, namely <code>+</code>! We pop the two top numbers from the stack (so now the stack is just <code>10</code>), add those numbers together and push that result to the stack. The stack is now <code>10, 7</code>. We push <code>2</code> to the stack, the stack for now is <code>10, 7, 2</code>. We've encountered an operator again, so let's pop <code>7</code> and <code>2</code> off the stack, multiply them and push that result to the stack. Multiplying <code>7</code> and <code>2</code> produces a <code>14</code>, so the stack we have now is <code>10, 14</code>. Finally, there's a <code>-</code>. We pop <code>10</code> and <code>14</code> from the stack, subtract <code>14</code> from <code>10</code> and push that back. The number on the stack is now <code>-4</code> and because there are no more numbers or operators in our expression, that's our result!</p></div><div><p>Now that we know how we'd calculate any RPN expression by hand, let's think about how we could make a Haskell function that takes as its parameter a string that contains a RPN expression, like <code>"10 4 3 + 2 * -"</code> and gives us back its result.</p></div><div><p>What would the type of that function be? We want it to take a string as a parameter and produce a number as its result. So it will probably be something like <code>solveRPN :: (Num a) =&gt; String -&gt; a</code>.</p></div><div><blockquote>
<p><strong>Protip:</strong> it really helps to first think what the type declaration of a function should be before concerning ourselves with the implementation and then write it down. In Haskell, a function's type declaration tells us a whole lot about the function, due to the very strong type system.</p>
</blockquote></div><div><p><span alt="LYHfGG_74_calculator.png" src="LYHfGG_74_calculator.png" class="internal-embed media-embed image-embed is-loaded"><img alt="LYHfGG_74_calculator.png" src="курсы\learn-you-a-haskell-for-great-good!\картинки\lyhfgg_74_calculator.png"></span></p></div><div><p>Cool. When implementing a solution to a problem in Haskell, it's also good to think back on how you did it by hand and maybe try to see if you can gain any insight from that. Here we see that we treated every number or operator that was separated by a space as a single item. So it might help us if we start by breaking a string like <code>"10 4 3 + 2 * -"</code> into a list of items like <code>["10","4","3","+","2","*","-"]</code>.</p></div><div><p>Next up, what did we do with that list of items in our head? We went over it from left to right and kept a stack as we did that. Does the previous sentence remind you of anything? Remember, in the section about <a data-tooltip-position="top" aria-label="http://learnyouahaskell.com/higher-order-functions/#folds" rel="noopener" class="external-link" href="http://learnyouahaskell.com/higher-order-functions/#folds" target="_blank">folds</a>, we said that pretty much any function where you traverse a list from left to right or right to left one element by element and build up (accumulate) some result (whether it's a number, a list, a stack, whatever) can be implemented with a fold.</p></div><div><p>In this case, we're going to use a left fold, because we go over the list from left to right. The accumulator value will be our stack and hence, the result from the fold will also be a stack, only as we've seen, it will only have one item.</p></div><div><p>One more thing to think about is, well, how are we going to represent the stack? I propose we use a list. Also I propose that we keep the top of our stack at the head of the list. That's because adding to the head (beginning) of a list is much faster than adding to the end of it. So if we have a stack of, say, <code>10, 4, 3</code>, we'll represent that as the list <code>[3,4,10]</code>.</p></div><div><p>Now we have enough information to roughly sketch our function. It's going to take a string, like, <code>"10 4 3 + 2 * -"</code> and break it down into a list of items by using <code>words</code> to get <code>["10","4","3","+","2","*","-"]</code>. Next, we'll do a left fold over that list and end up with a stack that has a single item, so <code>[-4]</code>. We take that single item out of the list and that's our final result!</p></div><div><p>So here's a sketch of that function:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token import-statement"><span class="token keyword">import</span> Data<span class="token punctuation">.</span>List</span>

<span class="token hvariable">solveRPN</span> <span class="token operator">::</span> <span class="token punctuation">(</span><span class="token constant">Num</span> <span class="token hvariable">a</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token constant">String</span> <span class="token operator">-&gt;</span> <span class="token hvariable">a</span>
<span class="token hvariable">solveRPN</span> <span class="token hvariable">expression</span> <span class="token operator">=</span> <span class="token builtin">head</span> <span class="token punctuation">(</span><span class="token builtin">foldl</span> <span class="token hvariable">foldingFunction</span> <span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token punctuation">(</span><span class="token builtin">words</span> <span class="token hvariable">expression</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token keyword">where</span>   <span class="token hvariable">foldingFunction</span> <span class="token hvariable">stack</span> <span class="token hvariable">item</span> <span class="token operator">=</span> <span class="token operator">...</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>We take the expression and turn it into a list of items. Then we fold over that list of items with the folding function. Mind the <code>[]</code>, which represents the starting accumulator. The accumulator is our stack, so <code>[]</code> represents an empty stack, which is what we start with. After getting the final stack with a single item, we call <code>head</code> on that list to get the item out and then we apply <code>read</code>.</p></div><div><p>So all that's left now is to implement a folding function that will take a stack, like <code>[4,10]</code>, and an item, like <code>"3"</code> and return a new stack <code>[3,4,10]</code>. If the stack is <code>[4,10]</code> and the item <code>"*"</code>, then it will have to return <code>[40]</code>. But before that, let's turn our function into <a data-tooltip-position="top" aria-label="http://learnyouahaskell.com/higher-order-functions#composition" rel="noopener" class="external-link" href="http://learnyouahaskell.com/higher-order-functions#composition" target="_blank">point-free style</a> because it has a lot of parentheses that are kind of freaking me out:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token import-statement"><span class="token keyword">import</span> Data<span class="token punctuation">.</span>List</span>

<span class="token hvariable">solveRPN</span> <span class="token operator">::</span> <span class="token punctuation">(</span><span class="token constant">Num</span> <span class="token hvariable">a</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token constant">String</span> <span class="token operator">-&gt;</span> <span class="token hvariable">a</span>
<span class="token hvariable">solveRPN</span> <span class="token operator">=</span> <span class="token builtin">head</span> <span class="token operator">.</span> <span class="token builtin">foldl</span> <span class="token hvariable">foldingFunction</span> <span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">.</span> <span class="token builtin">words</span>
    <span class="token keyword">where</span>   <span class="token hvariable">foldingFunction</span> <span class="token hvariable">stack</span> <span class="token hvariable">item</span> <span class="token operator">=</span> <span class="token operator">...</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Ah, there we go. Much better. So, the folding function will take a stack and an item and return a new stack. We'll use pattern matching to get the top items of a stack and to pattern match against operators like <code>"*"</code> and <code>"-"</code>.</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">solveRPN</span> <span class="token operator">::</span> <span class="token punctuation">(</span><span class="token constant">Num</span> <span class="token hvariable">a</span><span class="token punctuation">,</span> <span class="token constant">Read</span> <span class="token hvariable">a</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token constant">String</span> <span class="token operator">-&gt;</span> <span class="token hvariable">a</span>
<span class="token hvariable">solveRPN</span> <span class="token operator">=</span> <span class="token builtin">head</span> <span class="token operator">.</span> <span class="token builtin">foldl</span> <span class="token hvariable">foldingFunction</span> <span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">.</span> <span class="token builtin">words</span>
    <span class="token keyword">where</span>   <span class="token hvariable">foldingFunction</span> <span class="token punctuation">(</span><span class="token hvariable">x</span><span class="token operator">:</span><span class="token hvariable">y</span><span class="token operator">:</span><span class="token hvariable">ys</span><span class="token punctuation">)</span> <span class="token string">"*"</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token hvariable">x</span> <span class="token operator">*</span> <span class="token hvariable">y</span><span class="token punctuation">)</span><span class="token operator">:</span><span class="token hvariable">ys</span>
            <span class="token hvariable">foldingFunction</span> <span class="token punctuation">(</span><span class="token hvariable">x</span><span class="token operator">:</span><span class="token hvariable">y</span><span class="token operator">:</span><span class="token hvariable">ys</span><span class="token punctuation">)</span> <span class="token string">"+"</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token hvariable">x</span> <span class="token operator">+</span> <span class="token hvariable">y</span><span class="token punctuation">)</span><span class="token operator">:</span><span class="token hvariable">ys</span>
            <span class="token hvariable">foldingFunction</span> <span class="token punctuation">(</span><span class="token hvariable">x</span><span class="token operator">:</span><span class="token hvariable">y</span><span class="token operator">:</span><span class="token hvariable">ys</span><span class="token punctuation">)</span> <span class="token string">"-"</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token hvariable">y</span> <span class="token operator">-</span> <span class="token hvariable">x</span><span class="token punctuation">)</span><span class="token operator">:</span><span class="token hvariable">ys</span>
            <span class="token hvariable">foldingFunction</span> <span class="token hvariable">xs</span> <span class="token hvariable">numberString</span> <span class="token operator">=</span> <span class="token builtin">read</span> <span class="token hvariable">numberString</span><span class="token operator">:</span><span class="token hvariable">xs</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>We laid this out as four patterns. The patterns will be tried from top to bottom. First the folding function will see if the current item is <code>"*"</code>. If it is, then it will take a list like <code>[3,4,9,3]</code> and call its first two elements <code>x</code> and <code>y</code> respectively. So in this case, <code>x</code> would be <code>3</code> and <code>y</code> would be <code>4</code>. <code>ys</code> would be <code>[9,3]</code>. It will return a list that's just like <code>ys</code>, only it has <code>x</code> and <code>y</code> multiplied as its head. So with this we pop the two topmost numbers off the stack, multiply them and push the result back on to the stack. If the item is not <code>"*"</code>, the pattern matching will fall through and <code>"+"</code> will be checked, and so on.</p></div><div><p>If the item is none of the operators, then we assume it's a string that represents a number. If it's a number, we just call <code>read</code> on that string to get a number from it and return the previous stack but with that number pushed to the top.</p></div><div><p>And that's it! Also noticed that we added an extra class constraint of <code>Read a</code> to the function declaration, because we call <code>read</code> on our string to get the number. So this declaration means that the result can be of any type that's part of the <code>Num</code> and <code>Read</code> typeclasses (like <code>Int</code>, <code>Float</code>, etc.).</p></div><div><p>For the list of items <code>["2","3","+"]</code>, our function will start folding from the left. The intial stack will be <code>[]</code>. It will call the folding function with <code>[]</code> as the stack (accumulator) and <code>"2"</code> as the item. Because that item is not an operator, it will be <code>read</code> and the added to the beginning of <code>[]</code>. So the new stack is now <code>[2]</code> and the folding function will be called with <code>[2]</code> as the stack and <code>["3"]</code> as the item, producing a new stack of <code>[3,2]</code>. Then, it's called for the third time with <code>[3,2]</code> as the stack and <code>"+"</code> as the item. This causes these two numbers to be popped off the stack, added together and pushed back. The final stack is <code>[5]</code>, which is the number that we return.</p></div><div><p>Let's play around with our function:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token hvariable">solveRPN</span> <span class="token string">"10 4 3 + 2 * -"</span>
<span class="token operator">-</span><span class="token number">4</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token hvariable">solveRPN</span> <span class="token string">"2 3 +"</span>
<span class="token number">5</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token hvariable">solveRPN</span> <span class="token string">"90 34 12 33 55 66 + * - +"</span>
<span class="token operator">-</span><span class="token number">3947</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token hvariable">solveRPN</span> <span class="token string">"90 34 12 33 55 66 + * - + -"</span>
<span class="token number">4037</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token hvariable">solveRPN</span> <span class="token string">"90 34 12 33 55 66 + * - + -"</span>
<span class="token number">4037</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token hvariable">solveRPN</span> <span class="token string">"90 3 -"</span>
<span class="token number">87</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Cool, it works! One nice thing about this function is that it can be easily modified to support various other operators. They don't even have to be binary operators. For instance, we can make an operator <code>"log"</code> that just pops one number off the stack and pushes back its logarithm. We can also make a ternary operators that pop three numbers off the stack and push back a result or operators like <code>"sum"</code> which pop off all the numbers and push back their sum.</p></div><div><p>Let's modify our function to take a few more operators. For simplicity's sake, we'll change its type declaration so that it returns a number of type <code>Float</code>.</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token import-statement"><span class="token keyword">import</span> Data<span class="token punctuation">.</span>List</span>

<span class="token hvariable">solveRPN</span> <span class="token operator">::</span> <span class="token constant">String</span> <span class="token operator">-&gt;</span> <span class="token constant">Float</span>
<span class="token hvariable">solveRPN</span> <span class="token operator">=</span> <span class="token builtin">head</span> <span class="token operator">.</span> <span class="token builtin">foldl</span> <span class="token hvariable">foldingFunction</span> <span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">.</span> <span class="token builtin">words</span>
    <span class="token keyword">where</span>   <span class="token hvariable">foldingFunction</span> <span class="token punctuation">(</span><span class="token hvariable">x</span><span class="token operator">:</span><span class="token hvariable">y</span><span class="token operator">:</span><span class="token hvariable">ys</span><span class="token punctuation">)</span> <span class="token string">"*"</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token hvariable">x</span> <span class="token operator">*</span> <span class="token hvariable">y</span><span class="token punctuation">)</span><span class="token operator">:</span><span class="token hvariable">ys</span>
            <span class="token hvariable">foldingFunction</span> <span class="token punctuation">(</span><span class="token hvariable">x</span><span class="token operator">:</span><span class="token hvariable">y</span><span class="token operator">:</span><span class="token hvariable">ys</span><span class="token punctuation">)</span> <span class="token string">"+"</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token hvariable">x</span> <span class="token operator">+</span> <span class="token hvariable">y</span><span class="token punctuation">)</span><span class="token operator">:</span><span class="token hvariable">ys</span>
            <span class="token hvariable">foldingFunction</span> <span class="token punctuation">(</span><span class="token hvariable">x</span><span class="token operator">:</span><span class="token hvariable">y</span><span class="token operator">:</span><span class="token hvariable">ys</span><span class="token punctuation">)</span> <span class="token string">"-"</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token hvariable">y</span> <span class="token operator">-</span> <span class="token hvariable">x</span><span class="token punctuation">)</span><span class="token operator">:</span><span class="token hvariable">ys</span>
            <span class="token hvariable">foldingFunction</span> <span class="token punctuation">(</span><span class="token hvariable">x</span><span class="token operator">:</span><span class="token hvariable">y</span><span class="token operator">:</span><span class="token hvariable">ys</span><span class="token punctuation">)</span> <span class="token string">"/"</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token hvariable">y</span> <span class="token operator">/</span> <span class="token hvariable">x</span><span class="token punctuation">)</span><span class="token operator">:</span><span class="token hvariable">ys</span>
            <span class="token hvariable">foldingFunction</span> <span class="token punctuation">(</span><span class="token hvariable">x</span><span class="token operator">:</span><span class="token hvariable">y</span><span class="token operator">:</span><span class="token hvariable">ys</span><span class="token punctuation">)</span> <span class="token string">"^"</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token hvariable">y</span> <span class="token operator">**</span> <span class="token hvariable">x</span><span class="token punctuation">)</span><span class="token operator">:</span><span class="token hvariable">ys</span>
            <span class="token hvariable">foldingFunction</span> <span class="token punctuation">(</span><span class="token hvariable">x</span><span class="token operator">:</span><span class="token hvariable">xs</span><span class="token punctuation">)</span> <span class="token string">"ln"</span> <span class="token operator">=</span> <span class="token builtin">log</span> <span class="token hvariable">x</span><span class="token operator">:</span><span class="token hvariable">xs</span>
            <span class="token hvariable">foldingFunction</span> <span class="token hvariable">xs</span> <span class="token string">"sum"</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token builtin">sum</span> <span class="token hvariable">xs</span><span class="token punctuation">]</span>
            <span class="token hvariable">foldingFunction</span> <span class="token hvariable">xs</span> <span class="token hvariable">numberString</span> <span class="token operator">=</span> <span class="token builtin">read</span> <span class="token hvariable">numberString</span><span class="token operator">:</span><span class="token hvariable">xs</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Wow, great! <code>/</code> is division of course and <code>**</code> is floating point exponentiation. With the logarithm operator, we just pattern match against a single element and the rest of the stack because we only need one element to perform its natural logarithm. With the sum operator, we just return a stack that has only one element, which is the sum of the stack so far.</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token hvariable">solveRPN</span> <span class="token string">"2.7 ln"</span>
<span class="token number">0.9932518</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token hvariable">solveRPN</span> <span class="token string">"10 10 10 10 sum 4 /"</span>
<span class="token number">10.0</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token hvariable">solveRPN</span> <span class="token string">"10 10 10 10 10 sum 4 /"</span>
<span class="token number">12.5</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token hvariable">solveRPN</span> <span class="token string">"10 2 ^"</span>
<span class="token number">100.0</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Notice that we can include floating point numbers in our expression because <code>read</code> knows how to read them.</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token hvariable">solveRPN</span> <span class="token string">"43.2425 0.5 ^"</span>
<span class="token number">6.575903</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>I think that making a function that can calculate arbitrary floating point RPN expressions and has the option to be easily extended in 10 lines is pretty awesome.</p></div><div><p>One thing to note about this function is that it's not really fault tolerant. When given input that doesn't make sense, it will just crash everything. We'll make a fault tolerant version of this with a type declaration of <code>solveRPN :: String -&gt; Maybe Float</code> once we get to know monads (they're not scary, trust me!). We could make one right now, but it would be a bit tedious because it would involve a lot of checking for <code>Nothing</code> on every step. If you're feeling up to the challenge though, you can go ahead and try it! Hint: you can use <code>reads</code> to see if a read was successful or not.</p></div><div><h2 data-heading="Heathrow to London" id="Heathrow_to_London" style="display: flex;"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>Heathrow to London</h2></div><div><p>Our next problem is this: your plane has just landed in England and you rent a car. You have a meeting really soon and you have to get from Heathrow Airport to London as fast as you can (but safely!).</p></div><div><p>There are two main roads going from Heathrow to London and there's a number of regional roads crossing them. It takes you a fixed amount of time to travel from one crossroads to another. It's up to you to find the optimal path to take so that you get to London as fast as you can! You start on the left side and can either cross to the other main road or go forward.</p></div><div><p><span alt="LYHfGG_75_roads.png" src="LYHfGG_75_roads.png" class="internal-embed media-embed image-embed is-loaded"><img alt="LYHfGG_75_roads.png" src="курсы\learn-you-a-haskell-for-great-good!\картинки\lyhfgg_75_roads.png"></span></p></div><div><p>As you can see in the picture, the shortest path from Heathrow to London in this case is to start on main road B, cross over, go forward on A, cross over again and then go forward twice on B. If we take this path, it takes us 75 minutes. Had we chosen any other path, it would take more than that.</p></div><div><p>Our job is to make a program that takes input that represents a road system and print out what the shortest path across it is. Here's what the input would look like for this case:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token number">50</span>
<span class="token number">10</span>
<span class="token number">30</span>
<span class="token number">5</span>
<span class="token number">90</span>
<span class="token number">20</span>
<span class="token number">40</span>
<span class="token number">2</span>
<span class="token number">25</span>
<span class="token number">10</span>
<span class="token number">8</span>
<span class="token number">0</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>To mentally parse the input file, read it in threes and mentally split the road system into sections. Each section is comprised of a road A, road B and a crossing road. To have it neatly fit into threes, we say that there's a last crossing section that takes 0 minutes to drive over. That's because we don't care where we arrive in London, as long as we're in London.</p></div><div><p>Just like we did when solving the RPN calculator problem, we're going to solve this problem in three steps:</p></div><div><ul class="has-list-bullet">
<li data-line="0"><div class="list-bullet"></div>Forget Haskell for a minute and think about how we'd solve the problem by hand</li>
<li data-line="1"><div class="list-bullet"></div>Think about how we're going to represent our data in Haskell</li>
<li data-line="2"><div class="list-bullet"></div>Figure out how to operate on that data in Haskell so that we produce at a solution</li>
</ul></div><div><p>In the RPN calculator section, we first figured out that when calculating an expression by hand, we'd keep a sort of stack in our minds and then go over the expression one item at a time. We decided to use a list of strings to represent our expression. Finally, we used a left fold to walk oevr the list of strings while keeping a stack to produce a solution.</p></div><div><p>Okay, so how would we figure out the shortest path from Heathrow to London by hand? Well, we can just sort of look at the whole picture and try to guess what the shortest path is and hopefully we'll make a guess that's right. That solution works for very small inputs, but what if we have a road that has 10,000 sections? Yikes! We also won't be able to say for certain that our solution is the optimal one, we can just sort of say that we're pretty sure.</p></div><div><p>That's not a good solution then. Here's a simplified picture of our road system:</p></div><div><p><span alt="LYHfGG_76_roads_simple.png" src="LYHfGG_76_roads_simple.png" class="internal-embed media-embed image-embed is-loaded"><img alt="LYHfGG_76_roads_simple.png" src="курсы\learn-you-a-haskell-for-great-good!\картинки\lyhfgg_76_roads_simple.png"></span></p></div><div><p>Alright, can you figure out what the shortest path to the first crossroads (the first blue dot on A, marked <em>A1</em>) on road A is? That's pretty trivial. We just see if it's shorter to go directly forward on A or if it's shorter to go forward on B and then cross over. Obviously, it's cheaper to go forward via B and then cross over because that takes 40 minutes, whereas going directly via A takes 50 minutes. What about crossroads <em>B1</em>? Same thing. We see that it's a lot cheaper to just go directly via B (incurring a cost of 10 minutes), because going via A and then crossing over would take us a whole 80 minutes!</p></div><div><p>Now we know what the cheapest path to <em>A1</em> is (go via B and then cross over, so we'll say that's <code>B, C</code> with a cost of 40) and we know what the cheapest path to <em>B1</em> is (go directly via B, so that's just <code>B</code>, going at 10). Does this knowledge help us at all if we want to know the cheapest path to the next crossroads on both main roads? Gee golly, it sure does!</p></div><div><p>Let's see what the shortest path to <em>A2</em> would be. To get to <em>A2</em>, we'll either go directly to <em>A2</em> from <em>A1</em> or we'll go forward from <em>B1</em> and then cross over (remember, we can only move forward or cross to the other side). And because we know the cost to <em>A1</em> and <em>B1</em>, we can easily figure out what the best path to <em>A2</em> is. It costs 40 to get to <em>A1</em> and then 5 to get from <em>A1</em> to <em>A2</em>, so that's <code>B, C, A</code> for a cost of 45. It costs only 10 to get to <em>B1</em>, but then it would take an additional 110 minutes to go to <em>B2</em> and then cross over! So obviously, the cheapest path to <em>A2</em> is <code>B, C, A</code>. In the same way, the cheapest way to <em>B2</em> is to go forward from <em>A1</em> and then cross over.</p></div><div><blockquote>
<p><strong>Maybe you're asking yourself</strong>: but what about getting to <em>A2</em> by first crossing over at <em>B1</em> and then going on forward? Well, we already covered crossing from <em>B1</em> to <em>A1</em> when we were looking for the best way to <em>A1</em>, so we don't have to take that into account in the next step as well.</p>
</blockquote></div><div><p>Now that we have the best path to <em>A2</em> and <em>B2</em>, we can repeat this indefinitely until we reach the end. Once we've gotten the best paths for <em>A4</em> and <em>B4</em>, the one that's cheaper is the optimal path!</p></div><div><p>So in essence, for the second section, we just repeat the step we did at first, only we take into account what the previous best paths on A and B. We could say that we also took into account the best paths on A and on B in the first step, only they were both empty paths with a cost of 0.</p></div><div><p>Here's a summary. To get the bast path from Heathrow to London, we do this: first we see what the best path to the next crossroads on main road A is. The two options are going directly forward or starting at the opposite road, going forward and then crossing over. We remember the cost and the path. We use the same method to see what the best path to the next crossroads on main road B is and remember that. Then, we see if the path to the next crossroads on A is cheaper if we go from the previous A crossroads or if we go from the previous B crossroads and then cross over. We remember the cheaper path and then we do the same for the crossroads opposite of it. We do this for every section until we reach the end. Once we've reached the end, the cheapest of the two paths that we have is our optimal path!</p></div><div><p>So in essence, we keep one shortest path on the A road and one shortest path on the B road and when we reach the end, the shorter of those two is our path. We now know how to figure out the shortest path by hand. If you had enough time, paper and pencils, you could figure out the shortest path through a road system with any number of sections.</p></div><div><p>Next step! How do we represent this road system with Haskell's data types? One way is to think of the starting points and crossroads as nodes of a graph that point to other crossroads. If we imagine that the starting points actually point to each other with a road that has a length of one, we see that every crossroads (or node) points to the node on the other side and also to the next one on its side. Except for the last nodes, they just point to the other side.</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token keyword">data</span> <span class="token constant">Node</span> <span class="token operator">=</span> <span class="token constant">Node</span> <span class="token constant">Road</span> <span class="token constant">Road</span> <span class="token operator">|</span> <span class="token constant">EndNode</span> <span class="token constant">Road</span>
<span class="token keyword">data</span> <span class="token constant">Road</span> <span class="token operator">=</span> <span class="token constant">Road</span> <span class="token constant">Int</span> <span class="token constant">Node</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>A node is either a normal node and has information about the road that leads to the other main road and the road that leads to the next node or an end node, which only has information about the road to the other main road. A road keeps information about how long it is and which node it points to. For instance, the first part of the road on the A main road would be <code>Road 50 a1</code> where <code>a1</code> would be a node <code>Node x y</code>, where <code>x</code> and <code>y</code> are roads that point to <em>B1</em> and <em>A2</em>.</p></div><div><p>Another way would be to use <code>Maybe</code> for the road parts that point forward. Each node has a road part that point to the opposite road, but only those nodes that aren't the end ones have road parts that point forward.</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token keyword">data</span> <span class="token constant">Node</span> <span class="token operator">=</span> <span class="token constant">Node</span> <span class="token constant">Road</span> <span class="token punctuation">(</span><span class="token constant">Maybe</span> <span class="token constant">Road</span><span class="token punctuation">)</span>
<span class="token keyword">data</span> <span class="token constant">Road</span> <span class="token operator">=</span> <span class="token constant">Road</span> <span class="token constant">Int</span> <span class="token constant">Node</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>This is an alright way to represent the road system in Haskell and we could certainly solve this problem with it, but maybe we could come up with something simpler? If we think back to our solution by hand, we always just checked the lengths of three road parts at once: the road part on the A road, its opposite part on the B road and part C, which touches those two parts and connects them. When we were looking for the shortest path to <em>A1</em> and <em>B1</em>, we only had to deal with the lengths of the first three parts, which have lengths of 50, 10 and 30. We'll call that one section. So the road system that we use for this example can be easily represented as four sections: <code>50, 10, 30</code>, <code>5, 90, 20</code>, <code>40, 2, 25</code>, and <code>10, 8, 0</code>.</p></div><div><p>It's always good to keep our data types as simple as possible, although not any simpler!</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token keyword">data</span> <span class="token constant">Section</span> <span class="token operator">=</span> <span class="token constant">Section</span> <span class="token punctuation">{</span> <span class="token hvariable">getA</span> <span class="token operator">::</span> <span class="token constant">Int</span><span class="token punctuation">,</span> <span class="token hvariable">getB</span> <span class="token operator">::</span> <span class="token constant">Int</span><span class="token punctuation">,</span> <span class="token hvariable">getC</span> <span class="token operator">::</span> <span class="token constant">Int</span> <span class="token punctuation">}</span> <span class="token keyword">deriving</span> <span class="token punctuation">(</span><span class="token constant">Show</span><span class="token punctuation">)</span>
<span class="token keyword">type</span> <span class="token constant">RoadSystem</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token constant">Section</span><span class="token punctuation">]</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>This is pretty much perfect! It's as simple as it goes and I have a feeling it'll work perfectly for implementing our solution. <code>Section</code> is a simple algebraic data type that holds three integers for the lenghts of its three road parts. We introduce a type synonym as well, saying that <code>RoadSystem</code> is a list of sections.</p></div><div><blockquote>
<p>We could also use a triple of <code>(Int, Int, Int)</code> to represent a road section. Using tuples instead of making your own algebraic data types is good for some small localized stuff, but it's usually better to make a new type for things like this. It gives the type system more information about what's what. We can use <code>(Int, Int, Int)</code> to represent a road section or a vector in 3D space and we can operate on those two, but that allows us to mix them up. If we use <code>Section</code> and <code>Vector</code> data types, then we can't accidentally add a vector to a section of a road system.</p>
</blockquote></div><div><p>Our road system from Heathrow to London can now be represented like this:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">heathrowToLondon</span> <span class="token operator">::</span> <span class="token constant">RoadSystem</span>
<span class="token hvariable">heathrowToLondon</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token constant">Section</span> <span class="token number">50</span> <span class="token number">10</span> <span class="token number">30</span><span class="token punctuation">,</span> <span class="token constant">Section</span> <span class="token number">5</span> <span class="token number">90</span> <span class="token number">20</span><span class="token punctuation">,</span> <span class="token constant">Section</span> <span class="token number">40</span> <span class="token number">2</span> <span class="token number">25</span><span class="token punctuation">,</span> <span class="token constant">Section</span> <span class="token number">10</span> <span class="token number">8</span> <span class="token number">0</span><span class="token punctuation">]</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>All we need to do now is to implement the solution that we came up with previously in Haskell. What should the type declaration for a function that calculates a shortest path for any given road system be? It should take a road system as a parameter and return a path. We'll represent a path as a list as well. Let's introduce a <code>Label</code> type that's just an enumeration of either <code>A</code>, <code>B</code> or <code>C</code>. We'll also make a type synonym: <code>Path</code>.</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token keyword">data</span> <span class="token constant">Label</span> <span class="token operator">=</span> <span class="token constant">A</span> <span class="token operator">|</span> <span class="token constant">B</span> <span class="token operator">|</span> <span class="token constant">C</span> <span class="token keyword">deriving</span> <span class="token punctuation">(</span><span class="token constant">Show</span><span class="token punctuation">)</span>
<span class="token keyword">type</span> <span class="token constant">Path</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">(</span><span class="token constant">Label</span><span class="token punctuation">,</span> <span class="token constant">Int</span><span class="token punctuation">)</span><span class="token punctuation">]</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Our function, we'll call it <code>optimalPath</code> should thus have a type declaration of <code>optimalPath :: RoadSystem -&gt; Path</code>. If called with the road system <code>heathrowToLondon</code>, it should return the following path:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token punctuation">[</span><span class="token punctuation">(</span><span class="token constant">B</span><span class="token punctuation">,</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token constant">C</span><span class="token punctuation">,</span><span class="token number">30</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token constant">A</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token constant">C</span><span class="token punctuation">,</span><span class="token number">20</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token constant">B</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token constant">B</span><span class="token punctuation">,</span><span class="token number">8</span><span class="token punctuation">)</span><span class="token punctuation">]</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>We're going to have to walk over the list with the sections from left to right and keep the optimal path on A and optimal path on B as we go along. We'll accumulate the best path as we walk over the list, left to right. What does that sound like? Ding, ding, ding! That's right, A LEFT FOLD!</p></div><div><p>When doing the solution by hand, there was a step that we repeated over and over again. It involed checking the optimal paths on A and B so far and the current section to produce the new optimal paths on A and B. For instance, at the beginning the optimal paths were <code>[]</code> and <code>[]</code> for A and B respectively. We examined the section <code>Section 50 10 30</code> and concluded that the new optimal path to <em>A1</em> is <code>[(B,10),(C,30)]</code> and the optimal path to <em>B1</em> is <code>[(B,10)]</code>. If you look at this step as a function, it takes a pair of paths and a section and produces a new pair of paths. The type is <code>(Path, Path) -&gt; Section -&gt; (Path, Path)</code>. Let's go ahead and implement this function, because it's bound to be useful.</p></div><div><blockquote>
<p><strong>Hint:</strong> it will be useful because <code>(Path, Path) -&gt; Section -&gt; (Path, Path)</code> can be used as the binary function for a left fold, which has to have a type of <code>a -&gt; b -&gt; a</code></p>
</blockquote></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">roadStep</span> <span class="token operator">::</span> <span class="token punctuation">(</span><span class="token constant">Path</span><span class="token punctuation">,</span> <span class="token constant">Path</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token constant">Section</span> <span class="token operator">-&gt;</span> <span class="token punctuation">(</span><span class="token constant">Path</span><span class="token punctuation">,</span> <span class="token constant">Path</span><span class="token punctuation">)</span>
<span class="token hvariable">roadStep</span> <span class="token punctuation">(</span><span class="token hvariable">pathA</span><span class="token punctuation">,</span> <span class="token hvariable">pathB</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token constant">Section</span> <span class="token hvariable">a</span> <span class="token hvariable">b</span> <span class="token hvariable">c</span><span class="token punctuation">)</span> <span class="token operator">=</span> 
    <span class="token keyword">let</span> <span class="token hvariable">priceA</span> <span class="token operator">=</span> <span class="token builtin">sum</span> <span class="token operator">$</span> <span class="token builtin">map</span> <span class="token builtin">snd</span> <span class="token hvariable">pathA</span>
        <span class="token hvariable">priceB</span> <span class="token operator">=</span> <span class="token builtin">sum</span> <span class="token operator">$</span> <span class="token builtin">map</span> <span class="token builtin">snd</span> <span class="token hvariable">pathB</span>
        <span class="token hvariable">forwardPriceToA</span> <span class="token operator">=</span> <span class="token hvariable">priceA</span> <span class="token operator">+</span> <span class="token hvariable">a</span>
        <span class="token hvariable">crossPriceToA</span> <span class="token operator">=</span> <span class="token hvariable">priceB</span> <span class="token operator">+</span> <span class="token hvariable">b</span> <span class="token operator">+</span> <span class="token hvariable">c</span>
        <span class="token hvariable">forwardPriceToB</span> <span class="token operator">=</span> <span class="token hvariable">priceB</span> <span class="token operator">+</span> <span class="token hvariable">b</span>
        <span class="token hvariable">crossPriceToB</span> <span class="token operator">=</span> <span class="token hvariable">priceA</span> <span class="token operator">+</span> <span class="token hvariable">a</span> <span class="token operator">+</span> <span class="token hvariable">c</span>
        <span class="token hvariable">newPathToA</span> <span class="token operator">=</span> <span class="token keyword">if</span> <span class="token hvariable">forwardPriceToA</span> <span class="token operator">&lt;=</span> <span class="token hvariable">crossPriceToA</span>
                        <span class="token keyword">then</span> <span class="token punctuation">(</span><span class="token constant">A</span><span class="token punctuation">,</span><span class="token hvariable">a</span><span class="token punctuation">)</span><span class="token operator">:</span><span class="token hvariable">pathA</span>
                        <span class="token keyword">else</span> <span class="token punctuation">(</span><span class="token constant">C</span><span class="token punctuation">,</span><span class="token hvariable">c</span><span class="token punctuation">)</span><span class="token operator">:</span><span class="token punctuation">(</span><span class="token constant">B</span><span class="token punctuation">,</span><span class="token hvariable">b</span><span class="token punctuation">)</span><span class="token operator">:</span><span class="token hvariable">pathB</span>
        <span class="token hvariable">newPathToB</span> <span class="token operator">=</span> <span class="token keyword">if</span> <span class="token hvariable">forwardPriceToB</span> <span class="token operator">&lt;=</span> <span class="token hvariable">crossPriceToB</span>
                        <span class="token keyword">then</span> <span class="token punctuation">(</span><span class="token constant">B</span><span class="token punctuation">,</span><span class="token hvariable">b</span><span class="token punctuation">)</span><span class="token operator">:</span><span class="token hvariable">pathB</span>
                        <span class="token keyword">else</span> <span class="token punctuation">(</span><span class="token constant">C</span><span class="token punctuation">,</span><span class="token hvariable">c</span><span class="token punctuation">)</span><span class="token operator">:</span><span class="token punctuation">(</span><span class="token constant">A</span><span class="token punctuation">,</span><span class="token hvariable">a</span><span class="token punctuation">)</span><span class="token operator">:</span><span class="token hvariable">pathA</span>
    <span class="token keyword">in</span>  <span class="token punctuation">(</span><span class="token hvariable">newPathToA</span><span class="token punctuation">,</span> <span class="token hvariable">newPathToB</span><span class="token punctuation">)</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p><span alt="LYHfGG_77_guycar.png" src="LYHfGG_77_guycar.png" class="internal-embed media-embed image-embed is-loaded"><img alt="LYHfGG_77_guycar.png" src="курсы\learn-you-a-haskell-for-great-good!\картинки\lyhfgg_77_guycar.png"></span></p></div><div><p>What's going on here? First, calculate the optimal price on road A based on the best so far on A and we do the same for B. We do <code>sum $ map snd pathA</code>, so if <code>pathA</code> is something like <code>[(A,100),(C,20)]</code>, <code>priceA</code> becomes <code>120</code>. <code>forwardPriceToA</code> is the price that we would pay if we went to the next crossroads on A if we went there directly from the previous crossroads on A. It equals the best price to our previous A, plus the length of the A part of the current section. <code>crossPriceToA</code> is the price that we would pay if we went to the next A by going forward from the previous B and then crossing over. It's the best price to the previous B so far plus the B length of the section plus the C length of the section. We determine <code>forwardPriceToB</code> and <code>crossPriceToB</code> in the same manner.</p></div><div><p>Now that we know what the best way to A and B is, we just need to make the new paths to A and B based on that. If it's cheaper to go to A by just going forwards, we set <code>newPathToA</code> to be <code>(A,a):pathA</code>. Basically we prepend the <code>Label</code> <code>A</code> and the section length <code>a</code> to the optimal path path on A so far. Basically, we say that the best path to the next A crossroads is the path to the previous A crossroads and then one section forward via A. Remember, <code>A</code> is just a label, whereas <code>a</code> has a type of <code>Int</code>. Why do we prepend instead of doing <code>pathA ++ [(A,a)]</code>? Well, adding an element to the beginning of a list (also known as consing) is much faster than adding it to the end. This means that the path will be the wrong way around once we fold over a list with this function, but it's easy to reverse the list later. If it's cheaper to get to the next A crossroads by going forward from road B and then crossing over, then <code>newPathToA</code> is the old path to B that then goes forward and crosses to A. We do the same thing for <code>newPathToB</code>, only everything's mirrored.</p></div><div><p>Finally, we return <code>newPathToA</code> and <code>newPathToB</code> in a pair.</p></div><div><p>Let's run this function on the first section of <code>heathrowToLondon</code>. Because it's the first section, the best paths on A and B parameter will be a pair of empty lists.</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token hvariable">roadStep</span> <span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token builtin">head</span> <span class="token hvariable">heathrowToLondon</span><span class="token punctuation">)</span>
<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">(</span><span class="token constant">C</span><span class="token punctuation">,</span><span class="token number">30</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token constant">B</span><span class="token punctuation">,</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token punctuation">(</span><span class="token constant">B</span><span class="token punctuation">,</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Remember, the paths are reversed, so read them from right to left. From this we can read that the best path to the next A is to start on B and then cross over to A and that the best path to the next B is to just go directly forward from the starting point at B.</p></div><div><blockquote>
<p><strong>Optimization tip:</strong> when we do <code>priceA = sum $ map snd pathA</code>, we're calculating the price from the path on every step. We wouldn't have to do that if we implemented <code>roadStep</code> as a <code>(Path, Path, Int, Int) -&gt; Section -&gt; (Path, Path, Int, Int)</code> function where the integers represent the best price on A and B.</p>
</blockquote></div><div><p>Now that we have a function that takes a pair of paths and a section and produces a new optimal path, we can just easily do a left fold over a list of sections. <code>roadStep</code> is called with <code>([],[])</code> and the first section and returns a pair of optimal paths to that section. Then, it's called with that pair of paths and the next section and so on. When we've walked over all the sections, we're left with a pair of optimal paths and the shorter of them is our answer. With this in mind, we can implement <code>optimalPath</code>.</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">optimalPath</span> <span class="token operator">::</span> <span class="token constant">RoadSystem</span> <span class="token operator">-&gt;</span> <span class="token constant">Path</span>
<span class="token hvariable">optimalPath</span> <span class="token hvariable">roadSystem</span> <span class="token operator">=</span>
    <span class="token keyword">let</span> <span class="token punctuation">(</span><span class="token hvariable">bestAPath</span><span class="token punctuation">,</span> <span class="token hvariable">bestBPath</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token builtin">foldl</span> <span class="token hvariable">roadStep</span> <span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token hvariable">roadSystem</span>
    <span class="token keyword">in</span>  <span class="token keyword">if</span> <span class="token builtin">sum</span> <span class="token punctuation">(</span><span class="token builtin">map</span> <span class="token builtin">snd</span> <span class="token hvariable">bestAPath</span><span class="token punctuation">)</span> <span class="token operator">&lt;=</span> <span class="token builtin">sum</span> <span class="token punctuation">(</span><span class="token builtin">map</span> <span class="token builtin">snd</span> <span class="token hvariable">bestBPath</span><span class="token punctuation">)</span>
            <span class="token keyword">then</span> <span class="token builtin">reverse</span> <span class="token hvariable">bestAPath</span>
            <span class="token keyword">else</span> <span class="token builtin">reverse</span> <span class="token hvariable">bestBPath</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>We left fold over <code>roadSystem</code> (remember, it's a list of sections) with the starting accumulator being a pair of empty paths. The result of that fold is a pair of paths, so we pattern match on the pair to get the paths themselves. Then, we check which one of these was cheaper and return it. Before returning it, we also reverse it, because the optimal paths so far were reversed due to us choosing consing over appending.</p></div><div><p>Let's test this!</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token hvariable">optimalPath</span> <span class="token hvariable">heathrowToLondon</span>
<span class="token punctuation">[</span><span class="token punctuation">(</span><span class="token constant">B</span><span class="token punctuation">,</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token constant">C</span><span class="token punctuation">,</span><span class="token number">30</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token constant">A</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token constant">C</span><span class="token punctuation">,</span><span class="token number">20</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token constant">B</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token constant">B</span><span class="token punctuation">,</span><span class="token number">8</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token constant">C</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">]</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>This is the result that we were supposed to get! Awesome! It differs from our expected result a bit because there's a step <code>(C,0)</code> at the end, which means that we cross over to the other road once we're in London, but because that crossing doesn't cost anything, this is still the correct result.</p></div><div><p>We have the function that finds an optimal path based on, now we just have to read a textual representation of a road system from the standard input, convert it into a type of <code>RoadSystem</code>, run that through our <code>optimalPath</code> function and print the path.</p></div><div><p>First off, let's make a function that takes a list and splits it into groups of the same size. We'll call it <code>groupsOf</code>. For a parameter of <code>[1..10]</code>, <code>groupsOf 3</code> should return <code>[[1,2,3],[4,5,6],[7,8,9],[10]]</code>.</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">groupsOf</span> <span class="token operator">::</span> <span class="token constant">Int</span> <span class="token operator">-&gt;</span> <span class="token punctuation">[</span><span class="token hvariable">a</span><span class="token punctuation">]</span> <span class="token operator">-&gt;</span> <span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token hvariable">a</span><span class="token punctuation">]</span><span class="token punctuation">]</span>
<span class="token hvariable">groupsOf</span> <span class="token number">0</span> <span class="token hvariable">_</span> <span class="token operator">=</span> <span class="token builtin">undefined</span>
<span class="token hvariable">groupsOf</span> <span class="token hvariable">_</span> <span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
<span class="token hvariable">groupsOf</span> <span class="token hvariable">n</span> <span class="token hvariable">xs</span> <span class="token operator">=</span> <span class="token builtin">take</span> <span class="token hvariable">n</span> <span class="token hvariable">xs</span> <span class="token operator">:</span> <span class="token hvariable">groupsOf</span> <span class="token hvariable">n</span> <span class="token punctuation">(</span><span class="token builtin">drop</span> <span class="token hvariable">n</span> <span class="token hvariable">xs</span><span class="token punctuation">)</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>A standard recursive function. For an <code>xs</code> of <code>[1..10]</code> and an <code>n</code> of <code>3</code>, this equals <code>[1,2,3] : groupsOf 3 [4,5,6,7,8,9,10]</code>. When the recursion is done, we get our list in groups of three. And here's our <code>main</code> function, which reads from the standard input, makes a <code>RoadSystem</code> out of it and prints out the shortest path:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token import-statement"><span class="token keyword">import</span> Data<span class="token punctuation">.</span>List</span>

<span class="token hvariable">main</span> <span class="token operator">=</span> <span class="token keyword">do</span>
    <span class="token hvariable">contents</span> <span class="token operator">&lt;-</span> <span class="token builtin">getContents</span>
    <span class="token keyword">let</span> <span class="token hvariable">threes</span> <span class="token operator">=</span> <span class="token hvariable">groupsOf</span> <span class="token number">3</span> <span class="token punctuation">(</span><span class="token builtin">map</span> <span class="token builtin">read</span> <span class="token operator">$</span> <span class="token builtin">lines</span> <span class="token hvariable">contents</span><span class="token punctuation">)</span>
        <span class="token hvariable">roadSystem</span> <span class="token operator">=</span> <span class="token builtin">map</span> <span class="token punctuation">(</span><span class="token operator">\</span><span class="token punctuation">[</span><span class="token hvariable">a</span><span class="token punctuation">,</span><span class="token hvariable">b</span><span class="token punctuation">,</span><span class="token hvariable">c</span><span class="token punctuation">]</span> <span class="token operator">-&gt;</span> <span class="token constant">Section</span> <span class="token hvariable">a</span> <span class="token hvariable">b</span> <span class="token hvariable">c</span><span class="token punctuation">)</span> <span class="token hvariable">threes</span>
        <span class="token hvariable">path</span> <span class="token operator">=</span> <span class="token hvariable">optimalPath</span> <span class="token hvariable">roadSystem</span>
        <span class="token hvariable">pathString</span> <span class="token operator">=</span> <span class="token builtin">concat</span> <span class="token operator">$</span> <span class="token builtin">map</span> <span class="token punctuation">(</span><span class="token builtin">show</span> <span class="token operator">.</span> <span class="token builtin">fst</span><span class="token punctuation">)</span> <span class="token hvariable">path</span>
        <span class="token hvariable">pathPrice</span> <span class="token operator">=</span> <span class="token builtin">sum</span> <span class="token operator">$</span> <span class="token builtin">map</span> <span class="token builtin">snd</span> <span class="token hvariable">path</span>
    <span class="token builtin">putStrLn</span> <span class="token operator">$</span> <span class="token string">"The best path to take is: "</span> <span class="token operator">++</span> <span class="token hvariable">pathString</span>
    <span class="token builtin">putStrLn</span> <span class="token operator">$</span> <span class="token string">"The price is: "</span> <span class="token operator">++</span> <span class="token builtin">show</span> <span class="token hvariable">pathPrice</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>First, we get all the contents from the standard input. Then, we call <code>lines</code> with our contents to convert something like <code>"50\n10\n30\n...</code> to <code>["50","10","30"..</code> and then we map <code>read</code> to that to convert it to a list of numbers. We call <code>groupsOf 3</code> on it so that we turn it to a list of lists of length 3. We map the lambda <code>(\[a,b,c] -&gt; Section a b c)</code> over that list of lists. As you can see, the lambda just takes a list of length 3 and turns it into a section. So <code>roadSystem</code> is now our system of roads and it even has the correct type, namely <code>RoadSystem</code> (or <code>[Section]</code>). We call <code>optimalPath</code> with that and then get the path and the price in a nice textual representation and print it out.</p></div><div><p>We save the following text</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token number">50</span>
<span class="token number">10</span>
<span class="token number">30</span>
<span class="token number">5</span>
<span class="token number">90</span>
<span class="token number">20</span>
<span class="token number">40</span>
<span class="token number">2</span>
<span class="token number">25</span>
<span class="token number">10</span>
<span class="token number">8</span>
<span class="token number">0</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>in a file called <code>paths.txt</code> and then feed it to our program.</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token operator">$</span> <span class="token hvariable">cat</span> <span class="token hvariable">paths</span><span class="token punctuation">.</span><span class="token hvariable">txt</span> <span class="token operator">|</span> <span class="token hvariable">runhaskell</span> <span class="token hvariable">heathrow</span><span class="token punctuation">.</span><span class="token hvariable">hs</span>
<span class="token constant">The</span> <span class="token hvariable">best</span> <span class="token hvariable">path</span> <span class="token hvariable">to</span> <span class="token builtin">take</span> <span class="token hvariable">is</span><span class="token operator">:</span> <span class="token constant">BCACBBC</span>
<span class="token constant">The</span> <span class="token hvariable">price</span> <span class="token hvariable">is</span><span class="token operator">:</span> <span class="token number">75</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Works like a charm! You can use your knowledge of the <code>Data.Random</code> module to generate a much longer system of roads, which you can then feed to what we just wrote. If you get stack overflows, try using <code>foldl'</code> instead of <code>foldl</code>, because <code>foldl'</code> is strict.</p></div><div><h1 data-heading="Functors, Applicative Functors and Monoids" id="Functors,_Applicative_Functors_and_Monoids">Functors, Applicative Functors and Monoids</h1></div><div><p>Haskell's combination of purity, higher order functions, parameterized algebraic data types, and typeclasses allows us to implement polymorphism on a much higher level than possible in other languages. We don't have to think about types belonging to a big hierarchy of types. Instead, we think about what the types can act like and then connect them with the appropriate typeclasses. An <code>Int</code> can act like a lot of things. It can act like an equatable thing, like an ordered thing, like an enumerable thing, etc.</p></div><div><p>Typeclasses are open, which means that we can define our own data type, think about what it can act like and connect it with the typeclasses that define its behaviors. Because of that and because of Haskell's great type system that allows us to know a lot about a function just by knowing its type declaration, we can define typeclasses that define behavior that's very general and abstract. We've met typeclasses that define operations for seeing if two things are equal or comparing two things by some ordering. Those are very abstract and elegant behaviors, but we just don't think of them as anything very special because we've been dealing with them for most of our lives. We recently met functors, which are basically things that can be mapped over. That's an example of a useful and yet still pretty abstract property that typeclasses can describe. In this chapter, we'll take a closer look at functors, along with slightly stronger and more useful versions of functors called applicative functors. We'll also take a look at monoids, which are sort of like socks.</p></div><div><h2 data-heading="Functors redux" id="Functors_redux" style="display: flex;"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>Functors redux</h2></div><div><p><span alt="LYHfGG_78_frogtor.png" src="LYHfGG_78_frogtor.png" class="internal-embed media-embed image-embed is-loaded"><img alt="LYHfGG_78_frogtor.png" src="курсы\learn-you-a-haskell-for-great-good!\картинки\lyhfgg_78_frogtor.png"></span></p></div><div><p>We've already talked about functors in <a data-tooltip-position="top" aria-label="http://learnyouahaskell.com/making-our-own-types-and-typeclasses#the-functor-typeclass" rel="noopener" class="external-link" href="http://learnyouahaskell.com/making-our-own-types-and-typeclasses#the-functor-typeclass" target="_blank">their own little section</a>. If you haven't read it yet, you should probably give it a glance right now, or maybe later when you have more time. Or you can just pretend you read it.</p></div><div><p>Still, here's a quick refresher: Functors are things that can be mapped over, like lists, <code>Maybe</code>s, trees, and such. In Haskell, they're described by the typeclass <code>Functor</code>, which has only one typeclass method, namely <code>fmap</code>, which has a type of <code>fmap :: (a -&gt; b) -&gt; f a -&gt; f b</code>. It says: give me a function that takes an <code>a</code> and returns a <code>b</code> and a box with an <code>a</code> (or several of them) inside it and I'll give you a box with a <code>b</code> (or several of them) inside it. It kind of applies the function to the element inside the box.</p></div><div><blockquote>
<p><strong>A word of advice.</strong> Many times the box analogy is used to help you get some intuition for how functors work, and later, we'll probably use the same analogy for applicative functors and monads. It's an okay analogy that helps people understand functors at first, just don't take it too literally, because for some functors the box analogy has to be stretched really thin to still hold some truth. A more correct term for what a functor is would be <em>computational context</em>. The context might be that the computation can have a value or it might have failed (<code>Maybe</code> and <code>Either a</code>) or that there might be more values (lists), stuff like that.</p>
</blockquote></div><div><p>If we want to make a type constructor an instance of <code>Functor</code>, it has to have a kind of <code>* -&gt; *</code>, which means that it has to take exactly one concrete type as a type parameter. For example, <code>Maybe</code> can be made an instance because it takes one type parameter to produce a concrete type, like <code>Maybe Int</code> or <code>Maybe String</code>. If a type constructor takes two parameters, like <code>Either</code>, we have to partially apply the type constructor until it only takes one type parameter. So we can't write <code>instance Functor Either where</code>, but we can write <code>instance Functor (Either a) where</code> and then if we imagine that <code>fmap</code> is only for <code>Either a</code>, it would have a type declaration of <code>fmap :: (b -&gt; c) -&gt; Either a b -&gt; Either a c</code>. As you can see, the <code>Either a</code> part is fixed, because <code>Either a</code> takes only one type parameter, whereas just <code>Either</code> takes two so <code>fmap :: (b -&gt; c) -&gt; Either b -&gt; Either c</code> wouldn't really make sense.</p></div><div><p>We've learned by now how a lot of types (well, type constructors really) are instances of <code>Functor</code>, like <code>[]</code>, <code>Maybe</code>, <code>Either a</code> and a <code>Tree</code> type that we made on our own. We saw how we can map functions over them for great good. In this section, we'll take a look at two more instances of functor, namely <code>IO</code> and <code>(-&gt;) r</code>.</p></div><div><p>If some value has a type of, say, <code>IO String</code>, that means that it's an I/O action that, when performed, will go out into the real world and get some string for us, which it will yield as a result. We can use <code>&lt;-</code> in <em>do</em> syntax to bind that result to a name. We mentioned that I/O actions are like boxes with little feet that go out and fetch some value from the outside world for us. We can inspect what they fetched, but after inspecting, we have to wrap the value back in <code>IO</code>. By thinking about this box with little feet analogy, we can see how <code>IO</code> acts like a functor.</p></div><div><p>Let's see how <code>IO</code> is an instance of <code>Functor</code>. When we <code>fmap</code> a function over an I/O action, we want to get back an I/O action that does the same thing, but has our function applied over its result value.</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token keyword">instance</span> <span class="token constant">Functor</span> <span class="token constant">IO</span> <span class="token keyword">where</span>
    <span class="token builtin">fmap</span> <span class="token hvariable">f</span> <span class="token hvariable">action</span> <span class="token operator">=</span> <span class="token keyword">do</span>
        <span class="token hvariable">result</span> <span class="token operator">&lt;-</span> <span class="token hvariable">action</span>
        <span class="token builtin">return</span> <span class="token punctuation">(</span><span class="token hvariable">f</span> <span class="token hvariable">result</span><span class="token punctuation">)</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>The result of mapping something over an I/O action will be an I/O action, so right off the bat we use <em>do</em> syntax to glue two actions and make a new one. In the implementation for <code>fmap</code>, we make a new I/O action that first performs the original I/O action and calls its result <code>result</code>. Then, we do <code>return (f result)</code>. <code>return</code> is, as you know, a function that makes an I/O action that doesn't do anything but only presents something as its result. The action that a <em>do</em> block produces will always have the result value of its last action. That's why we use return to make an I/O action that doesn't really do anything, it just presents <code>f result</code> as the result of the new I/O action.</p></div><div><p>We can play around with it to gain some intuition. It's pretty simple really. Check out this piece of code:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">main</span> <span class="token operator">=</span> <span class="token keyword">do</span> <span class="token hvariable">line</span> <span class="token operator">&lt;-</span> <span class="token builtin">getLine</span> 
          <span class="token keyword">let</span> <span class="token hvariable">line'</span> <span class="token operator">=</span> <span class="token builtin">reverse</span> <span class="token hvariable">line</span>
          <span class="token builtin">putStrLn</span> <span class="token operator">$</span> <span class="token string">"You said "</span> <span class="token operator">++</span> <span class="token hvariable">line'</span> <span class="token operator">++</span> <span class="token string">" backwards!"</span>
          <span class="token builtin">putStrLn</span> <span class="token operator">$</span> <span class="token string">"Yes, you really said"</span> <span class="token operator">++</span> <span class="token hvariable">line'</span> <span class="token operator">++</span> <span class="token string">" backwards!"</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>The user is prompted for a line and we give it back to the user, only reversed. Here's how to rewrite this by using <code>fmap</code>:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">main</span> <span class="token operator">=</span> <span class="token keyword">do</span> <span class="token hvariable">line</span> <span class="token operator">&lt;-</span> <span class="token builtin">fmap</span> <span class="token builtin">reverse</span> <span class="token builtin">getLine</span>
          <span class="token builtin">putStrLn</span> <span class="token operator">$</span> <span class="token string">"You said "</span> <span class="token operator">++</span> <span class="token hvariable">line</span> <span class="token operator">++</span> <span class="token string">" backwards!"</span>
          <span class="token builtin">putStrLn</span> <span class="token operator">$</span> <span class="token string">"Yes, you really said"</span> <span class="token operator">++</span> <span class="token hvariable">line</span> <span class="token operator">++</span> <span class="token string">" backwards!"</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p><span alt="LYHfGG_79_alien.png" src="LYHfGG_79_alien.png" class="internal-embed media-embed image-embed is-loaded"><img alt="LYHfGG_79_alien.png" src="курсы\learn-you-a-haskell-for-great-good!\картинки\lyhfgg_79_alien.png"></span></p></div><div><p>Just like when we <code>fmap</code> <code>reverse</code> over <code>Just "blah"</code> to get <code>Just "halb"</code>, we can <code>fmap</code> <code>reverse</code> over <code>getLine</code>. <code>getLine</code> is an I/O action that has a type of <code>IO String</code> and mapping <code>reverse</code> over it gives us an I/O action that will go out into the real world and get a line and then apply <code>reverse</code> to its result. Like we can apply a function to something that's inside a <code>Maybe</code> box, we can apply a function to what's inside an <code>IO</code> box, only it has to go out into the real world to get something. Then when we bind it to a name by using <code>&lt;-</code>, the name will reflect the result that already has <code>reverse</code> applied to it.</p></div><div><p>The I/O action <code>fmap (++"!") getLine</code> behaves just like <code>getLine</code>, only that its result always has <code>"!"</code> appended to it!</p></div><div><p>If we look at what <code>fmap</code>'s type would be if it were limited to <code>IO</code>, it would be <code>fmap :: (a -&gt; b) -&gt; IO a -&gt; IO b</code>. <code>fmap</code> takes a function and an I/O action and returns a new I/O action that's like the old one, except that the function is applied to its contained result.</p></div><div><p>If you ever find yourself binding the result of an I/O action to a name, only to apply a function to that and call that something else, consider using <code>fmap</code>, because it looks prettier. If you want to apply multiple transformations to some data inside a functor, you can declare your own function at the top level, make a lambda function or ideally, use function composition:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token import-statement"><span class="token keyword">import</span> Data<span class="token punctuation">.</span>Char</span>
<span class="token import-statement"><span class="token keyword">import</span> Data<span class="token punctuation">.</span>List</span>

<span class="token hvariable">main</span> <span class="token operator">=</span> <span class="token keyword">do</span> <span class="token hvariable">line</span> <span class="token operator">&lt;-</span> <span class="token builtin">fmap</span> <span class="token punctuation">(</span><span class="token hvariable">intersperse</span> <span class="token char string">'-'</span> <span class="token operator">.</span> <span class="token builtin">reverse</span> <span class="token operator">.</span> <span class="token builtin">map</span> <span class="token builtin">toUpper</span><span class="token punctuation">)</span> <span class="token builtin">getLine</span>
          <span class="token builtin">putStrLn</span> <span class="token hvariable">line</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token operator">$</span> <span class="token hvariable">runhaskell</span> <span class="token hvariable">fmapping_io</span><span class="token punctuation">.</span><span class="token hvariable">hs</span>
<span class="token hvariable">hello</span> <span class="token hvariable">there</span>
<span class="token constant">E</span><span class="token operator">-</span><span class="token constant">R</span><span class="token operator">-</span><span class="token constant">E</span><span class="token operator">-</span><span class="token constant">H</span><span class="token operator">-</span><span class="token constant">T</span><span class="token operator">-</span> <span class="token operator">-</span><span class="token constant">O</span><span class="token operator">-</span><span class="token constant">L</span><span class="token operator">-</span><span class="token constant">L</span><span class="token operator">-</span><span class="token constant">E</span><span class="token operator">-</span><span class="token constant">H</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>As you probably know, <code>intersperse '-' . reverse . map toUpper</code> is a function that takes a string, maps <code>toUpper</code> over it, the applies <code>reverse</code> to that result and then applies <code>intersperse '-'</code> to that result. It's like writing <code>(\xs -&gt; intersperse '-' (reverse (map toUpper xs)))</code>, only prettier.</p></div><div><p>Another instance of <code>Functor</code> that we've been dealing with all along but didn't know was a <code>Functor</code> is <code>(-&gt;) r</code>. You're probably slightly confused now, since what the heck does <code>(-&gt;) r</code> mean? The function type <code>r -&gt; a</code> can be rewritten as <code>(-&gt;) r a</code>, much like we can write <code>2 + 3</code> as <code>(+) 2 3</code>. When we look at it as <code>(-&gt;) r a</code>, we can see <code>(-&gt;)</code> in a slighty different light, because we see that it's just a type constructor that takes two type parameters, just like <code>Either</code>. But remember, we said that a type constructor has to take exactly one type parameter so that it can be made an instance of <code>Functor</code>. That's why we can't make <code>(-&gt;)</code> an instance of <code>Functor</code>, but if we partially apply it to <code>(-&gt;) r</code>, it doesn't pose any problems. If the syntax allowed for type constructors to be partially applied with sections (like we can partially apply <code>+</code> by doing <code>(2+)</code>, which is the same as <code>(+) 2</code>), you could write <code>(-&gt;) r</code> as <code>(r -&gt;)</code>. How are functions functors? Well, let's take a look at the implementation, which lies in <code>Control.Monad.Instances</code></p></div><div><blockquote>
<p>We usually mark functions that take anything and return anything as <code>a -&gt; b</code>. <code>r -&gt; a</code> is the same thing, we just used different letters for the type variables.</p>
</blockquote></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token keyword">instance</span> <span class="token constant">Functor</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token operator">-&gt;</span><span class="token punctuation">)</span> <span class="token hvariable">r</span><span class="token punctuation">)</span> <span class="token keyword">where</span>
    <span class="token builtin">fmap</span> <span class="token hvariable">f</span> <span class="token hvariable">g</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token operator">\</span><span class="token hvariable">x</span> <span class="token operator">-&gt;</span> <span class="token hvariable">f</span> <span class="token punctuation">(</span><span class="token hvariable">g</span> <span class="token hvariable">x</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>If the syntax allowed for it, it could have been written as</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token keyword">instance</span> <span class="token constant">Functor</span> <span class="token punctuation">(</span><span class="token hvariable">r</span> <span class="token operator">-&gt;</span><span class="token punctuation">)</span> <span class="token keyword">where</span>
    <span class="token builtin">fmap</span> <span class="token hvariable">f</span> <span class="token hvariable">g</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token operator">\</span><span class="token hvariable">x</span> <span class="token operator">-&gt;</span> <span class="token hvariable">f</span> <span class="token punctuation">(</span><span class="token hvariable">g</span> <span class="token hvariable">x</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>But it doesn't, so we have to write it in the former fashion.</p></div><div><p>First of all, let's think about <code>fmap</code>'s type. It's <code>fmap :: (a -&gt; b) -&gt; f a -&gt; f b</code>. Now what we'll do is mentally replace all the <code>f</code>'s, which are the role that our functor instance plays, with <code>(-&gt;) r</code>'s. We'll do that to see how <code>fmap</code> should behave for this particular instance. We get <code>fmap :: (a -&gt; b) -&gt; ((-&gt;) r a) -&gt; ((-&gt;) r b)</code>. Now what we can do is write the <code>(-&gt;) r a</code> and <code>(-&gt; r b)</code> types as infix <code>r -&gt; a</code> and <code>r -&gt; b</code>, like we normally do with functions. What we get now is <code>fmap :: (a -&gt; b) -&gt; (r -&gt; a) -&gt; (r -&gt; b)</code>.</p></div><div><p>Hmmm OK. Mapping one function over a function has to produce a function, just like mapping a function over a <code>Maybe</code> has to produce a <code>Maybe</code> and mapping a function over a list has to produce a list. What does the type <code>fmap :: (a -&gt; b) -&gt; (r -&gt; a) -&gt; (r -&gt; b)</code> for this instance tell us? Well, we see that it takes a function from <code>a</code> to <code>b</code> and a function from <code>r</code> to <code>a</code> and returns a function from <code>r</code> to <code>b</code>. Does this remind you of anything? Yes! Function composition! We pipe the output of <code>r -&gt; a</code> into the input of <code>a -&gt; b</code> to get a function <code>r -&gt; b</code>, which is exactly what function composition is about. If you look at how the instance is defined above, you'll see that it's just function composition. Another way to write this instance would be:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token keyword">instance</span> <span class="token constant">Functor</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token operator">-&gt;</span><span class="token punctuation">)</span> <span class="token hvariable">r</span><span class="token punctuation">)</span> <span class="token keyword">where</span>
    <span class="token builtin">fmap</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">.</span><span class="token punctuation">)</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>This makes the revelation that using <code>fmap</code> over functions is just composition sort of obvious. Do <code>:m + Control.Monad.Instances</code>, since that's where the instance is defined and then try playing with mapping over functions.</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token operator">:</span><span class="token hvariable">t</span> <span class="token builtin">fmap</span> <span class="token punctuation">(</span><span class="token operator">*</span><span class="token number">3</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token operator">+</span><span class="token number">100</span><span class="token punctuation">)</span>
<span class="token builtin">fmap</span> <span class="token punctuation">(</span><span class="token operator">*</span><span class="token number">3</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token operator">+</span><span class="token number">100</span><span class="token punctuation">)</span> <span class="token operator">::</span> <span class="token punctuation">(</span><span class="token constant">Num</span> <span class="token hvariable">a</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token hvariable">a</span> <span class="token operator">-&gt;</span> <span class="token hvariable">a</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token builtin">fmap</span> <span class="token punctuation">(</span><span class="token operator">*</span><span class="token number">3</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token operator">+</span><span class="token number">100</span><span class="token punctuation">)</span> <span class="token number">1</span>
<span class="token number">303</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token punctuation">(</span><span class="token operator">*</span><span class="token number">3</span><span class="token punctuation">)</span> <span class="token operator">`fmap`</span> <span class="token punctuation">(</span><span class="token operator">+</span><span class="token number">100</span><span class="token punctuation">)</span> <span class="token operator">$</span> <span class="token number">1</span>
<span class="token number">303</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token punctuation">(</span><span class="token operator">*</span><span class="token number">3</span><span class="token punctuation">)</span> <span class="token operator">.</span> <span class="token punctuation">(</span><span class="token operator">+</span><span class="token number">100</span><span class="token punctuation">)</span> <span class="token operator">$</span> <span class="token number">1</span>
<span class="token number">303</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token builtin">fmap</span> <span class="token punctuation">(</span><span class="token builtin">show</span> <span class="token operator">.</span> <span class="token punctuation">(</span><span class="token operator">*</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token operator">*</span><span class="token number">100</span><span class="token punctuation">)</span> <span class="token number">1</span>
<span class="token string">"300"</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>We can call <code>fmap</code> as an infix function so that the resemblance to <code>.</code> is clear. In the second input line, we're mapping <code>(*3)</code> over <code>(+100)</code>, which results in a function that will take an input, call <code>(+100)</code> on that and then call <code>(*3)</code> on that result. We call that function with <code>1</code>.</p></div><div><p>How does the box analogy hold here? Well, if you stretch it, it holds. When we use <code>fmap (+3)</code> over <code>Just 3</code>, it's easy to imagine the <code>Maybe</code> as a box that has some contents on which we apply the function <code>(+3)</code>. But what about when we're doing <code>fmap (*3) (+100)</code>? Well, you can think of the function <code>(+100)</code> as a box that contains its eventual result. Sort of like how an I/O action can be thought of as a box that will go out into the real world and fetch some result. Using <code>fmap (*3)</code> on <code>(+100)</code> will create another function that acts like <code>(+100)</code>, only before producing a result, <code>(*3)</code> will be applied to that result. Now we can see how <code>fmap</code> acts just like <code>.</code> for functions.</p></div><div><p>The fact that <code>fmap</code> is function composition when used on functions isn't so terribly useful right now, but at least it's very interesting. It also bends our minds a bit and let us see how things that act more like computations than boxes (<code>IO</code> and <code>(-&gt;) r</code>) can be functors. The function being mapped over a computation results in the same computation but the result of that computation is modified with the function.</p></div><div><p><span alt="LYHfGG_80_lifter.png" src="LYHfGG_80_lifter.png" class="internal-embed media-embed image-embed is-loaded"><img alt="LYHfGG_80_lifter.png" src="курсы\learn-you-a-haskell-for-great-good!\картинки\lyhfgg_80_lifter.png"></span></p></div><div><p>Before we go on to the rules that <code>fmap</code> should follow, let's think about the type of <code>fmap</code> once more. Its type is <code>fmap :: (a -&gt; b) -&gt; f a -&gt; f b</code>. We're missing the class constraint <code>(Functor f) =&gt;</code>, but we left it out here for brevity, because we're talking about functors anyway so we know what the <code>f</code> stands for. When we first learned about <a data-tooltip-position="top" aria-label="http://learnyouahaskell.com/higher-order-functions#curried-functions" rel="noopener" class="external-link" href="http://learnyouahaskell.com/higher-order-functions#curried-functions" target="_blank">curried functions</a>, we said that all Haskell functions actually take one parameter. A function <code>a -&gt; b -&gt; c</code> actually takes just one parameter of type <code>a</code> and then returns a function <code>b -&gt; c</code>, which takes one parameter and returns a <code>c</code>. That's how if we call a function with too few parameters (i.e. partially apply it), we get back a function that takes the number of parameters that we left out (if we're thinking about functions as taking several parameters again). So <code>a -&gt; b -&gt; c</code> can be written as <code>a -&gt; (b -&gt; c)</code>, to make the currying more apparent.</p></div><div><p>In the same vein, if we write <code>fmap :: (a -&gt; b) -&gt; (f a -&gt; f b)</code>, we can think of <code>fmap</code> not as a function that takes one function and a functor and returns a functor, but as a function that takes a function and returns a new function that's just like the old one, only it takes a functor as a parameter and returns a functor as the result. It takes an <code>a -&gt; b</code> function and returns a function <code>f a -&gt; f b</code>. This is called <em>lifting</em> a function. Let's play around with that idea by using GHCI's <code>:t</code> command:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token operator">:</span><span class="token hvariable">t</span> <span class="token builtin">fmap</span> <span class="token punctuation">(</span><span class="token operator">*</span><span class="token number">2</span><span class="token punctuation">)</span>
<span class="token builtin">fmap</span> <span class="token punctuation">(</span><span class="token operator">*</span><span class="token number">2</span><span class="token punctuation">)</span> <span class="token operator">::</span> <span class="token punctuation">(</span><span class="token constant">Num</span> <span class="token hvariable">a</span><span class="token punctuation">,</span> <span class="token constant">Functor</span> <span class="token hvariable">f</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token hvariable">f</span> <span class="token hvariable">a</span> <span class="token operator">-&gt;</span> <span class="token hvariable">f</span> <span class="token hvariable">a</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token operator">:</span><span class="token hvariable">t</span> <span class="token builtin">fmap</span> <span class="token punctuation">(</span><span class="token builtin">replicate</span> <span class="token number">3</span><span class="token punctuation">)</span>
<span class="token builtin">fmap</span> <span class="token punctuation">(</span><span class="token builtin">replicate</span> <span class="token number">3</span><span class="token punctuation">)</span> <span class="token operator">::</span> <span class="token punctuation">(</span><span class="token constant">Functor</span> <span class="token hvariable">f</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token hvariable">f</span> <span class="token hvariable">a</span> <span class="token operator">-&gt;</span> <span class="token hvariable">f</span> <span class="token punctuation">[</span><span class="token hvariable">a</span><span class="token punctuation">]</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>The expression <code>fmap (*2)</code> is a function that takes a functor <code>f</code> over numbers and returns a functor over numbers. That functor can be a list, a <code>Maybe</code> , an <code>Either String</code>, whatever. The expression <code>fmap (replicate 3)</code> will take a functor over any type and return a functor over a list of elements of that type.</p></div><div><blockquote>
<p>When we say <em>a functor over numbers</em>, you can think of that as <em>a functor that has numbers in it</em>. The former is a bit fancier and more technically correct, but the latter is usually easier to get.</p>
</blockquote></div><div><p>This is even more apparent if we partially apply, say, <code>fmap (++"!")</code> and then bind it to a name in GHCI.</p></div><div><p>You can think of <code>fmap</code> as either a function that takes a function and a functor and then maps that function over the functor, or you can think of it as a function that takes a function and lifts that function so that it operates on functors. Both views are correct and in Haskell, equivalent.</p></div><div><p>The type <code>fmap (replicate 3) :: (Functor f) =&gt; f a -&gt; f [a]</code> means that the function will work on any functor. What exactly it will do depends on which functor we use it on. If we use <code>fmap (replicate 3)</code> on a list, the list's implementation for <code>fmap</code> will be chosen, which is just <code>map</code>. If we use it on a <code>Maybe a</code>, it'll apply <code>replicate 3</code> to the value inside the <code>Just</code>, or if it's <code>Nothing</code>, then it stays <code>Nothing</code>.</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token builtin">fmap</span> <span class="token punctuation">(</span><span class="token builtin">replicate</span> <span class="token number">3</span><span class="token punctuation">)</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">]</span>
<span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">]</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token builtin">fmap</span> <span class="token punctuation">(</span><span class="token builtin">replicate</span> <span class="token number">3</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token constant">Just</span> <span class="token number">4</span><span class="token punctuation">)</span>
<span class="token constant">Just</span> <span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">]</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token builtin">fmap</span> <span class="token punctuation">(</span><span class="token builtin">replicate</span> <span class="token number">3</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token constant">Right</span> <span class="token string">"blah"</span><span class="token punctuation">)</span>
<span class="token constant">Right</span> <span class="token punctuation">[</span><span class="token string">"blah"</span><span class="token punctuation">,</span><span class="token string">"blah"</span><span class="token punctuation">,</span><span class="token string">"blah"</span><span class="token punctuation">]</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token builtin">fmap</span> <span class="token punctuation">(</span><span class="token builtin">replicate</span> <span class="token number">3</span><span class="token punctuation">)</span> <span class="token constant">Nothing</span>
<span class="token constant">Nothing</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token builtin">fmap</span> <span class="token punctuation">(</span><span class="token builtin">replicate</span> <span class="token number">3</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token constant">Left</span> <span class="token string">"foo"</span><span class="token punctuation">)</span>
<span class="token constant">Left</span> <span class="token string">"foo"</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Next up, we're going to look at the <strong>functor laws</strong>. In order for something to be a functor, it should satisfy some laws. All functors are expected to exhibit certain kinds of functor-like properties and behaviors. They should reliably behave as things that can be mapped over. Calling <code>fmap</code> on a functor should just map a function over the functor, nothing more. This behavior is described in the functor laws. There are two of them that all instances of <code>Functor</code> should abide by. They aren't enforced by Haskell automatically, so you have to test them out yourself.</p></div><div><p><strong>The first functor law states that if we map the id function over a functor, the functor that we get back should be the same as the original functor.</strong> If we write that a bit more formally, it means that <code>fmap id = id</code>. So essentially, this says that if we do <code>fmap id</code> over a functor, it should be the same as just calling <code>id</code> on the functor. Remember, <code>id</code> is the identity function, which just returns its parameter unmodified. It can also be written as <code>\x -&gt; x</code>. If we view the functor as something that can be mapped over, the <code>fmap id = id</code> law seems kind of trivial or obvious.</p></div><div><p>Let's see if this law holds for a few values of functors.</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token builtin">fmap</span> <span class="token builtin">id</span> <span class="token punctuation">(</span><span class="token constant">Just</span> <span class="token number">3</span><span class="token punctuation">)</span>
<span class="token constant">Just</span> <span class="token number">3</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token builtin">id</span> <span class="token punctuation">(</span><span class="token constant">Just</span> <span class="token number">3</span><span class="token punctuation">)</span>
<span class="token constant">Just</span> <span class="token number">3</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token builtin">fmap</span> <span class="token builtin">id</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token operator">..</span><span class="token number">5</span><span class="token punctuation">]</span>
<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">]</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token builtin">id</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token operator">..</span><span class="token number">5</span><span class="token punctuation">]</span>
<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">]</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token builtin">fmap</span> <span class="token builtin">id</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
<span class="token punctuation">[</span><span class="token punctuation">]</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token builtin">fmap</span> <span class="token builtin">id</span> <span class="token constant">Nothing</span>
<span class="token constant">Nothing</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>If we look at the implementation of <code>fmap</code> for, say, <code>Maybe</code>, we can figure out why the first functor law holds.</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token keyword">instance</span> <span class="token constant">Functor</span> <span class="token constant">Maybe</span> <span class="token keyword">where</span>
    <span class="token builtin">fmap</span> <span class="token hvariable">f</span> <span class="token punctuation">(</span><span class="token constant">Just</span> <span class="token hvariable">x</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token constant">Just</span> <span class="token punctuation">(</span><span class="token hvariable">f</span> <span class="token hvariable">x</span><span class="token punctuation">)</span>
    <span class="token builtin">fmap</span> <span class="token hvariable">f</span> <span class="token constant">Nothing</span> <span class="token operator">=</span> <span class="token constant">Nothing</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>We imagine that <code>id</code> plays the role of the <code>f</code> parameter in the implementation. We see that if wee <code>fmap id</code> over <code>Just x</code>, the result will be <code>Just (id x)</code>, and because <code>id</code> just returns its parameter, we can deduce that <code>Just (id x)</code> equals <code>Just x</code>. So now we know that if we map <code>id</code> over a <code>Maybe</code> value with a <code>Just</code> value constructor, we get that same value back.</p></div><div><p>Seeing that mapping <code>id</code> over a <code>Nothing</code> value returns the same value is trivial. So from these two equations in the implementation for <code>fmap</code>, we see that the law <code>fmap id = id</code> holds.</p></div><div><p><span alt="LYHfGG_81_justice.png" src="LYHfGG_81_justice.png" class="internal-embed media-embed image-embed is-loaded"><img alt="LYHfGG_81_justice.png" src="курсы\learn-you-a-haskell-for-great-good!\картинки\lyhfgg_81_justice.png"></span></p></div><div><p><strong>The second law says that composing two functions and then mapping the resulting function over a functor should be the same as first mapping one function over the functor and then mapping the other one.</strong> Formally written, that means that <code>fmap (f . g) = fmap f . fmap g</code>. Or to write it in another way, for any functor <em>F</em>, the following should hold: <code>fmap (f . g) F = fmap f (fmap g F)</code>.</p></div><div><p>If we can show that some type obeys both functor laws, we can rely on it having the same fundamental behaviors as other functors when it comes to mapping. We can know that when we use <code>fmap</code> on it, there won't be anything other than mapping going on behind the scenes and that it will act like a thing that can be mapped over, i.e. a functor. You figure out how the second law holds for some type by looking at the implementation of <code>fmap</code> for that type and then using the method that we used to check if <code>Maybe</code> obeys the first law.</p></div><div><p>If you want, we can check out how the second functor law holds for <code>Maybe</code>. If we do <code>fmap (f . g)</code> over <code>Nothing</code>, we get <code>Nothing</code>, because doing a <code>fmap</code> with any function over <code>Nothing</code> returns <code>Nothing</code>. If we do <code>fmap f (fmap g Nothing)</code>, we get <code>Nothing</code>, for the same reason. OK, seeing how the second law holds for <code>Maybe</code> if it's a <code>Nothing</code> value is pretty easy, almost trivial.</p></div><div><p>How about if it's a <code>Just _something_</code> value? Well, if we do <code>fmap (f . g) (Just x)</code>, we see from the implementation that it's implemented as <code>Just ((f . g) x)</code>, which is, of course, <code>Just (f (g x))</code>. If we do <code>fmap f (fmap g (Just x))</code>, we see from the implementation that <code>fmap g (Just x)</code> is <code>Just (g x)</code>. Ergo, <code>fmap f (fmap g (Just x))</code> equals <code>fmap f (Just (g x))</code> and from the implementation we see that this equals <code>Just (f (g x))</code>.</p></div><div><p>If you're a bit confused by this proof, don't worry. Be sure that you understand how <a data-tooltip-position="top" aria-label="http://learnyouahaskell.com/higher-order-functions#composition" rel="noopener" class="external-link" href="http://learnyouahaskell.com/higher-order-functions#composition" target="_blank">function composition</a> works. Many times, you can intuitively see how these laws hold because the types act like containers or functions. You can also just try them on a bunch of different values of a type and be able to say with some certainty that a type does indeed obey the laws.</p></div><div><p>Let's take a look at a pathological example of a type constructor being an instance of the <code>Functor</code> typeclass but not really being a functor, because it doesn't satisfy the laws. Let's say that we have a type:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token keyword">data</span> <span class="token constant">CMaybe</span> <span class="token hvariable">a</span> <span class="token operator">=</span> <span class="token constant">CNothing</span> <span class="token operator">|</span> <span class="token constant">CJust</span> <span class="token constant">Int</span> <span class="token hvariable">a</span> <span class="token keyword">deriving</span> <span class="token punctuation">(</span><span class="token constant">Show</span><span class="token punctuation">)</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>The C here stands for <em>counter</em>. It's a data type that looks much like <code>Maybe a</code>, only the <code>Just</code> part holds two fields instead of one. The first field in the <code>CJust</code> value constructor will always have a type of <code>Int</code>, and it will be some sort of counter and the second field is of type <code>a</code>, which comes from the type parameter and its type will, of course, depend on the concrete type that we choose for <code>CMaybe a</code>. Let's play with our new type to get some intuition for it.</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token constant">CNothing</span>
<span class="token constant">CNothing</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token constant">CJust</span> <span class="token number">0</span> <span class="token string">"haha"</span>
<span class="token constant">CJust</span> <span class="token number">0</span> <span class="token string">"haha"</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token operator">:</span><span class="token hvariable">t</span> <span class="token constant">CNothing</span>
<span class="token constant">CNothing</span> <span class="token operator">::</span> <span class="token constant">CMaybe</span> <span class="token hvariable">a</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token operator">:</span><span class="token hvariable">t</span> <span class="token constant">CJust</span> <span class="token number">0</span> <span class="token string">"haha"</span>
<span class="token constant">CJust</span> <span class="token number">0</span> <span class="token string">"haha"</span> <span class="token operator">::</span> <span class="token constant">CMaybe</span> <span class="token punctuation">[</span><span class="token constant">Char</span><span class="token punctuation">]</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token constant">CJust</span> <span class="token number">100</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">]</span>
<span class="token constant">CJust</span> <span class="token number">100</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">]</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>If we use the <code>CNothing</code> constructor, there are no fields, and if we use the <code>CJust</code> constructor, the first field is an integer and the second field can be any type. Let's make this an instance of <code>Functor</code> so that everytime we use <code>fmap</code>, the function gets applied to the second field, whereas the first field gets increased by 1.</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token keyword">instance</span> <span class="token constant">Functor</span> <span class="token constant">CMaybe</span> <span class="token keyword">where</span>
    <span class="token builtin">fmap</span> <span class="token hvariable">f</span> <span class="token constant">CNothing</span> <span class="token operator">=</span> <span class="token constant">CNothing</span>
    <span class="token builtin">fmap</span> <span class="token hvariable">f</span> <span class="token punctuation">(</span><span class="token constant">CJust</span> <span class="token hvariable">counter</span> <span class="token hvariable">x</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token constant">CJust</span> <span class="token punctuation">(</span><span class="token hvariable">counter</span><span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token hvariable">f</span> <span class="token hvariable">x</span><span class="token punctuation">)</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>This is kind of like the instance implementation for <code>Maybe</code>, except that when we do <code>fmap</code> over a value that doesn't represent an empty box (a <code>CJust</code> value), we don't just apply the function to the contents, we also increase the counter by 1. Everything seems cool so far, we can even play with this a bit:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token builtin">fmap</span> <span class="token punctuation">(</span><span class="token operator">++</span><span class="token string">"ha"</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token constant">CJust</span> <span class="token number">0</span> <span class="token string">"ho"</span><span class="token punctuation">)</span>
<span class="token constant">CJust</span> <span class="token number">1</span> <span class="token string">"hoha"</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token builtin">fmap</span> <span class="token punctuation">(</span><span class="token operator">++</span><span class="token string">"he"</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token builtin">fmap</span> <span class="token punctuation">(</span><span class="token operator">++</span><span class="token string">"ha"</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token constant">CJust</span> <span class="token number">0</span> <span class="token string">"ho"</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token constant">CJust</span> <span class="token number">2</span> <span class="token string">"hohahe"</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token builtin">fmap</span> <span class="token punctuation">(</span><span class="token operator">++</span><span class="token string">"blah"</span><span class="token punctuation">)</span> <span class="token constant">CNothing</span>
<span class="token constant">CNothing</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Does this obey the functor laws? In order to see that something doesn't obey a law, it's enough to find just one counter-example.</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token builtin">fmap</span> <span class="token builtin">id</span> <span class="token punctuation">(</span><span class="token constant">CJust</span> <span class="token number">0</span> <span class="token string">"haha"</span><span class="token punctuation">)</span>
<span class="token constant">CJust</span> <span class="token number">1</span> <span class="token string">"haha"</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token builtin">id</span> <span class="token punctuation">(</span><span class="token constant">CJust</span> <span class="token number">0</span> <span class="token string">"haha"</span><span class="token punctuation">)</span>
<span class="token constant">CJust</span> <span class="token number">0</span> <span class="token string">"haha"</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Ah! We know that the first functor law states that if we map <code>id</code> over a functor, it should be the same as just calling <code>id</code> with the same functor, but as we've seen from this example, this is not true for our <code>CMaybe</code> functor. Even though it's part of the <code>Functor</code> typeclass, it doesn't obey the functor laws and is therefore not a functor. If someone used our <code>CMaybe</code> type as a functor, they would expect it to obey the functor laws like a good functor. But <code>CMaybe</code> fails at being a functor even though it pretends to be one, so using it as a functor might lead to some faulty code. When we use a functor, it shouldn't matter if we first compose a few functions and then map them over the functor or if we just map each function over a functor in succession. But with <code>CMaybe</code>, it matters, because it keeps track of how many times it's been mapped over. Not cool! If we wanted <code>CMaybe</code> to obey the functor laws, we'd have to make it so that the <code>Int</code> field stays the same when we use <code>fmap</code>.</p></div><div><p>At first, the functor laws might seem a bit confusing and unnecessary, but then we see that if we know that a type obeys both laws, we can make certain assumptions about how it will act. If a type obeys the functor laws, we know that calling <code>fmap</code> on a value of that type will only map the function over it, nothing more. This leads to code that is more abstract and extensible, because we can use laws to reason about behaviors that any functor should have and make functions that operate reliably on any functor.</p></div><div><p>All the <code>Functor</code> instances in the standard library obey these laws, but you can check for yourself if you don't believe me. And the next time you make a type an instance of <code>Functor</code>, take a minute to make sure that it obeys the functor laws. Once you've dealt with enough functors, you kind of intuitively see the properties and behaviors that they have in common and it's not hard to intuitively see if a type obeys the functor laws. But even without the intuition, you can always just go over the implementation line by line and see if the laws hold or try to find a counter-example.</p></div><div><p>We can also look at functors as things that output values in a context. For instance, <code>Just 3</code> outputs the value <code>3</code> in the context that it might or not output any values at all. <code>[1,2,3]</code> outputs three values—<code>1</code>, <code>2</code>, and <code>3</code>, the context is that there may be multiple values or no values. The function <code>(+3)</code> will output a value, depending on which parameter it is given.</p></div><div><p>If you think of functors as things that output values, you can think of mapping over functors as attaching a transformation to the output of the functor that changes the value. When we do <code>fmap (+3) [1,2,3]</code>, we attach the transformation <code>(+3)</code> to the output of <code>[1,2,3]</code>, so whenever we look at a number that the list outputs, <code>(+3)</code> will be applied to it. Another example is mapping over functions. When we do <code>fmap (+3) (*3)</code>, we attach the transformation <code>(+3)</code> to the eventual output of <code>(*3)</code>. Looking at it this way gives us some intuition as to why using <code>fmap</code> on functions is just composition (<code>fmap (+3) (*3)</code> equals <code>(+3) . (*3)</code>, which equals <code>\x -&gt; ((x*3)+3)</code>), because we take a function like <code>(*3)</code> then we attach the transformation <code>(+3)</code> to its output. The result is still a function, only when we give it a number, it will be multiplied by three and then it will go through the attached transformation where it will be added to three. This is what happens with composition.</p></div><div><h2 data-heading="Applicative functors" id="Applicative_functors" style="display: flex;"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>Applicative functors</h2></div><div><p><span alt="LYHfGG_82_present.png" src="LYHfGG_82_present.png" class="internal-embed media-embed image-embed is-loaded"><img alt="LYHfGG_82_present.png" src="курсы\learn-you-a-haskell-for-great-good!\картинки\lyhfgg_82_present.png"></span></p></div><div><p>In this section, we'll take a look at applicative functors, which are beefed up functors, represented in Haskell by the <code>Applicative</code> typeclass, found in the <code>Control.Applicative</code> module.</p></div><div><p>As you know, functions in Haskell are curried by default, which means that a function that seems to take several parameters actually takes just one parameter and returns a function that takes the next parameter and so on. If a function is of type <code>a -&gt; b -&gt; c</code>, we usually say that it takes two parameters and returns a <code>c</code>, but actually it takes an <code>a</code> and returns a function <code>b -&gt; c</code>. That's why we can call a function as <code>f x y</code> or as <code>(f x) y</code>. This mechanism is what enables us to partially apply functions by just calling them with too few parameters, which results in functions that we can then pass on to other functions.</p></div><div><p>So far, when we were mapping functions over functors, we usually mapped functions that take only one parameter. But what happens when we map a function like <code>*</code>, which takes two parameters, over a functor? Let's take a look at a couple of concrete examples of this. If we have <code>Just 3</code> and we do <code>fmap (*) (Just 3)</code>, what do we get? From the instance implementation of <code>Maybe</code> for <code>Functor</code>, we know that if it's a <code>Just _something_</code> value, it will apply the function to the <code>_something_</code> inside the <code>Just</code>. Therefore, doing <code>fmap (*) (Just 3)</code> results in <code>Just ((*) 3)</code>, which can also be written as <code>Just (* 3)</code> if we use sections. Interesting! We get a function wrapped in a <code>Just</code>!</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token operator">:</span><span class="token hvariable">t</span> <span class="token builtin">fmap</span> <span class="token punctuation">(</span><span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token constant">Just</span> <span class="token string">"hey"</span><span class="token punctuation">)</span>
<span class="token builtin">fmap</span> <span class="token punctuation">(</span><span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token constant">Just</span> <span class="token string">"hey"</span><span class="token punctuation">)</span> <span class="token operator">::</span> <span class="token constant">Maybe</span> <span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token constant">Char</span><span class="token punctuation">]</span> <span class="token operator">-&gt;</span> <span class="token punctuation">[</span><span class="token constant">Char</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token operator">:</span><span class="token hvariable">t</span> <span class="token builtin">fmap</span> <span class="token builtin">compare</span> <span class="token punctuation">(</span><span class="token constant">Just</span> <span class="token char string">'a'</span><span class="token punctuation">)</span>
<span class="token builtin">fmap</span> <span class="token builtin">compare</span> <span class="token punctuation">(</span><span class="token constant">Just</span> <span class="token char string">'a'</span><span class="token punctuation">)</span> <span class="token operator">::</span> <span class="token constant">Maybe</span> <span class="token punctuation">(</span><span class="token constant">Char</span> <span class="token operator">-&gt;</span> <span class="token constant">Ordering</span><span class="token punctuation">)</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token operator">:</span><span class="token hvariable">t</span> <span class="token builtin">fmap</span> <span class="token builtin">compare</span> <span class="token string">"A LIST OF CHARS"</span>
<span class="token builtin">fmap</span> <span class="token builtin">compare</span> <span class="token string">"A LIST OF CHARS"</span> <span class="token operator">::</span> <span class="token punctuation">[</span><span class="token constant">Char</span> <span class="token operator">-&gt;</span> <span class="token constant">Ordering</span><span class="token punctuation">]</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token operator">:</span><span class="token hvariable">t</span> <span class="token builtin">fmap</span> <span class="token punctuation">(</span><span class="token operator">\</span><span class="token hvariable">x</span> <span class="token hvariable">y</span> <span class="token hvariable">z</span> <span class="token operator">-&gt;</span> <span class="token hvariable">x</span> <span class="token operator">+</span> <span class="token hvariable">y</span> <span class="token operator">/</span> <span class="token hvariable">z</span><span class="token punctuation">)</span> <span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">]</span>
<span class="token builtin">fmap</span> <span class="token punctuation">(</span><span class="token operator">\</span><span class="token hvariable">x</span> <span class="token hvariable">y</span> <span class="token hvariable">z</span> <span class="token operator">-&gt;</span> <span class="token hvariable">x</span> <span class="token operator">+</span> <span class="token hvariable">y</span> <span class="token operator">/</span> <span class="token hvariable">z</span><span class="token punctuation">)</span> <span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">]</span> <span class="token operator">::</span> <span class="token punctuation">(</span><span class="token constant">Fractional</span> <span class="token hvariable">a</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">[</span><span class="token hvariable">a</span> <span class="token operator">-&gt;</span> <span class="token hvariable">a</span> <span class="token operator">-&gt;</span> <span class="token hvariable">a</span><span class="token punctuation">]</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>If we map <code>compare</code>, which has a type of <code>(Ord a) =&gt; a -&gt; a -&gt; Ordering</code> over a list of characters, we get a list of functions of type <code>Char -&gt; Ordering</code>, because the function <code>compare</code> gets partially applied with the characters in the list. It's not a list of <code>(Ord a) =&gt; a -&gt; Ordering</code> function, because the first <code>a</code> that got applied was a <code>Char</code> and so the second <code>a</code> has to decide to be of type <code>Char</code>.</p></div><div><p>We see how by mapping "multi-parameter" functions over functors, we get functors that contain functions inside them. So now what can we do with them? Well for one, we can map functions that take these functions as parameters over them, because whatever is inside a functor will be given to the function that we're mapping over it as a parameter.</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token keyword">let</span> <span class="token hvariable">a</span> <span class="token operator">=</span> <span class="token builtin">fmap</span> <span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">)</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">]</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token operator">:</span><span class="token hvariable">t</span> <span class="token hvariable">a</span>
<span class="token hvariable">a</span> <span class="token operator">::</span> <span class="token punctuation">[</span><span class="token constant">Integer</span> <span class="token operator">-&gt;</span> <span class="token constant">Integer</span><span class="token punctuation">]</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token builtin">fmap</span> <span class="token punctuation">(</span><span class="token operator">\</span><span class="token hvariable">f</span> <span class="token operator">-&gt;</span> <span class="token hvariable">f</span> <span class="token number">9</span><span class="token punctuation">)</span> <span class="token hvariable">a</span>
<span class="token punctuation">[</span><span class="token number">9</span><span class="token punctuation">,</span><span class="token number">18</span><span class="token punctuation">,</span><span class="token number">27</span><span class="token punctuation">,</span><span class="token number">36</span><span class="token punctuation">]</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>But what if we have a functor value of <code>Just (3 *)</code> and a functor value of <code>Just 5</code> and we want to take out the function from <code>Just (3 *)</code> and map it over <code>Just 5</code>? With normal functors, we're out of luck, because all they support is just mapping normal functions over existing functors. Even when we mapped <code>\f -&gt; f 9</code> over a functor that contained functions inside it, we were just mapping a normal function over it. But we can't map a function that's inside a functor over another functor with what <code>fmap</code> offers us. We could pattern-match against the <code>Just</code> constructor to get the function out of it and then map it over <code>Just 5</code>, but we're looking for a more general and abstract way of doing that, which works across functors.</p></div><div><p>Meet the <code>Applicative</code> typeclass. It lies in the <code>Control.Applicative</code> module and it defines two methods, <code>pure</code> and <code>&lt;*&gt;</code>. It doesn't provide a default implementation for any of them, so we have to define them both if we want something to be an applicative functor. The class is defined like so:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token keyword">class</span> <span class="token punctuation">(</span><span class="token constant">Functor</span> <span class="token hvariable">f</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token constant">Applicative</span> <span class="token hvariable">f</span> <span class="token keyword">where</span>
    <span class="token hvariable">pure</span> <span class="token operator">::</span> <span class="token hvariable">a</span> <span class="token operator">-&gt;</span> <span class="token hvariable">f</span> <span class="token hvariable">a</span>
    <span class="token punctuation">(</span><span class="token operator">&lt;*&gt;</span><span class="token punctuation">)</span> <span class="token operator">::</span> <span class="token hvariable">f</span> <span class="token punctuation">(</span><span class="token hvariable">a</span> <span class="token operator">-&gt;</span> <span class="token hvariable">b</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token hvariable">f</span> <span class="token hvariable">a</span> <span class="token operator">-&gt;</span> <span class="token hvariable">f</span> <span class="token hvariable">b</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>This simple three line class definition tells us a lot! Let's start at the first line. It starts the definition of the <code>Applicative</code> class and it also introduces a class constraint. It says that if we want to make a type constructor part of the <code>Applicative</code> typeclass, it has to be in <code>Functor</code> first. That's why if we know that if a type constructor is part of the <code>Applicative</code> typeclass, it's also in <code>Functor</code>, so we can use <code>fmap</code> on it.</p></div><div><p>The first method it defines is called <code>pure</code>. Its type declaration is <code>pure :: a -&gt; f a</code>. <code>f</code> plays the role of our applicative functor instance here. Because Haskell has a very good type system and because everything a function can do is take some parameters and return some value, we can tell a lot from a type declaration and this is no exception. <code>pure</code> should take a value of any type and return an applicative functor with that value inside it. When we say <em>inside it</em>, we're using the box analogy again, even though we've seen that it doesn't always stand up to scrutiny. But the <code>a -&gt; f a</code> type declaration is still pretty descriptive. We take a value and we wrap it in an applicative functor that has that value as the result inside it.</p></div><div><p>A better way of thinking about <code>pure</code> would be to say that it takes a value and puts it in some sort of default (or pure) context—a minimal context that still yields that value.</p></div><div><p>The <code>&lt;*&gt;</code> function is really interesting. It has a type declaration of <code>f (a -&gt; b) -&gt; f a -&gt; f b</code>. Does this remind you of anything? Of course, <code>fmap :: (a -&gt; b) -&gt; f a -&gt; f b</code>. It's a sort of a beefed up <code>fmap</code>. Whereas <code>fmap</code> takes a function and a functor and applies the function inside the functor, <code>&lt;*&gt;</code> takes a functor that has a function in it and another functor and sort of extracts that function from the first functor and then maps it over the second one. When I say <em>extract</em>, I actually sort of mean <em>run</em> and then extract, maybe even <em>sequence</em>. We'll see why soon.</p></div><div><p>Let's take a look at the <code>Applicative</code> instance implementation for <code>Maybe</code>.</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token keyword">instance</span> <span class="token constant">Applicative</span> <span class="token constant">Maybe</span> <span class="token keyword">where</span>
    <span class="token hvariable">pure</span> <span class="token operator">=</span> <span class="token constant">Just</span>
    <span class="token constant">Nothing</span> <span class="token operator">&lt;*&gt;</span> <span class="token hvariable">_</span> <span class="token operator">=</span> <span class="token constant">Nothing</span>
    <span class="token punctuation">(</span><span class="token constant">Just</span> <span class="token hvariable">f</span><span class="token punctuation">)</span> <span class="token operator">&lt;*&gt;</span> <span class="token hvariable">something</span> <span class="token operator">=</span> <span class="token builtin">fmap</span> <span class="token hvariable">f</span> <span class="token hvariable">something</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Again, from the class definition we see that the <code>f</code> that plays the role of the applicative functor should take one concrete type as a parameter, so we write <code>instance Applicative Maybe where</code> instead of writing <code>instance Applicative (Maybe a) where</code>.</p></div><div><p>First off, <code>pure</code>. We said earlier that it's supposed to take something and wrap it in an applicative functor. We wrote <code>pure = Just</code>, because value constructors like <code>Just</code> are normal functions. We could have also written <code>pure x = Just x</code>.</p></div><div><p>Next up, we have the definition for <code>&lt;*&gt;</code>. We can't extract a function out of a <code>Nothing</code>, because it has no function inside it. So we say that if we try to extract a function from a <code>Nothing</code>, the result is a <code>Nothing</code>. If you look at the class definition for <code>Applicative</code>, you'll see that there's a <code>Functor</code> class constraint, which means that we can assume that both of <code>&lt;*&gt;</code>'s parameters are functors. If the first parameter is not a <code>Nothing</code>, but a <code>Just</code> with some function inside it, we say that we then want to map that function over the second parameter. This also takes care of the case where the second parameter is <code>Nothing</code>, because doing <code>fmap</code> with any function over a <code>Nothing</code> will return a <code>Nothing</code>.</p></div><div><p>So for <code>Maybe</code>, <code>&lt;*&gt;</code> extracts the function from the left value if it's a <code>Just</code> and maps it over the right value. If any of the parameters is <code>Nothing</code>, <code>Nothing</code> is the result.</p></div><div><p>OK cool great. Let's give this a whirl.</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token constant">Just</span> <span class="token punctuation">(</span><span class="token operator">+</span><span class="token number">3</span><span class="token punctuation">)</span> <span class="token operator">&lt;*&gt;</span> <span class="token constant">Just</span> <span class="token number">9</span>
<span class="token constant">Just</span> <span class="token number">12</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token hvariable">pure</span> <span class="token punctuation">(</span><span class="token operator">+</span><span class="token number">3</span><span class="token punctuation">)</span> <span class="token operator">&lt;*&gt;</span> <span class="token constant">Just</span> <span class="token number">10</span>
<span class="token constant">Just</span> <span class="token number">13</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token hvariable">pure</span> <span class="token punctuation">(</span><span class="token operator">+</span><span class="token number">3</span><span class="token punctuation">)</span> <span class="token operator">&lt;*&gt;</span> <span class="token constant">Just</span> <span class="token number">9</span>
<span class="token constant">Just</span> <span class="token number">12</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token constant">Just</span> <span class="token punctuation">(</span><span class="token operator">++</span><span class="token string">"hahah"</span><span class="token punctuation">)</span> <span class="token operator">&lt;*&gt;</span> <span class="token constant">Nothing</span>
<span class="token constant">Nothing</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token constant">Nothing</span> <span class="token operator">&lt;*&gt;</span> <span class="token constant">Just</span> <span class="token string">"woot"</span>
<span class="token constant">Nothing</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>We see how doing <code>pure (+3)</code> and <code>Just (+3)</code> is the same in this case. Use <code>pure</code> if you're dealing with <code>Maybe</code> values in an applicative context (i.e. using them with <code>&lt;*&gt;</code>), otherwise stick to <code>Just</code>. The first four input lines demonstrate how the function is extracted and then mapped, but in this case, they could have been achieved by just mapping unwrapped functions over functors. The last line is interesting, because we try to extract a function from a <code>Nothing</code> and then map it over something, which of course results in a <code>Nothing</code>.</p></div><div><p>With normal functors, you can just map a function over a functor and then you can't get the result out in any general way, even if the result is a partially applied function. Applicative functors, on the other hand, allow you to operate on several functors with a single function. Check out this piece of code:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token hvariable">pure</span> <span class="token punctuation">(</span><span class="token operator">+</span><span class="token punctuation">)</span> <span class="token operator">&lt;*&gt;</span> <span class="token constant">Just</span> <span class="token number">3</span> <span class="token operator">&lt;*&gt;</span> <span class="token constant">Just</span> <span class="token number">5</span>
<span class="token constant">Just</span> <span class="token number">8</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token hvariable">pure</span> <span class="token punctuation">(</span><span class="token operator">+</span><span class="token punctuation">)</span> <span class="token operator">&lt;*&gt;</span> <span class="token constant">Just</span> <span class="token number">3</span> <span class="token operator">&lt;*&gt;</span> <span class="token constant">Nothing</span>
<span class="token constant">Nothing</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token hvariable">pure</span> <span class="token punctuation">(</span><span class="token operator">+</span><span class="token punctuation">)</span> <span class="token operator">&lt;*&gt;</span> <span class="token constant">Nothing</span> <span class="token operator">&lt;*&gt;</span> <span class="token constant">Just</span> <span class="token number">5</span>
<span class="token constant">Nothing</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p><span alt="LYHfGG_83_whale.png" src="LYHfGG_83_whale.png" class="internal-embed media-embed image-embed is-loaded"><img alt="LYHfGG_83_whale.png" src="курсы\learn-you-a-haskell-for-great-good!\картинки\lyhfgg_83_whale.png"></span></p></div><div><p>What's going on here? Let's take a look, step by step. <code>&lt;*&gt;</code> is left-associative, which means that <code>pure (+) &lt;*&gt; Just 3 &lt;*&gt; Just 5</code> is the same as <code>(pure (+) &lt;*&gt; Just 3) &lt;*&gt; Just 5</code>. First, the <code>+</code> function is put in a functor, which is in this case a <code>Maybe</code> value that contains the function. So at first, we have <code>pure (+)</code>, which is <code>Just (+)</code>. Next, <code>Just (+) &lt;*&gt; Just 3</code> happens. The result of this is <code>Just (3+)</code>. This is because of partial application. Only applying <code>3</code> to the <code>+</code> function results in a function that takes one parameter and adds 3 to it. Finally, <code>Just (3+) &lt;*&gt; Just 5</code> is carried out, which results in a <code>Just 8</code>.</p></div><div><p>Isn't this awesome?! Applicative functors and the applicative style of doing <code>pure f &lt;*&gt; x &lt;*&gt; y &lt;*&gt; ...</code> allow us to take a function that expects parameters that aren't necessarily wrapped in functors and use that function to operate on several values that are in functor contexts. The function can take as many parameters as we want, because it's always partially applied step by step between occurences of <code>&lt;*&gt;</code>.</p></div><div><p>This becomes even more handy and apparent if we consider the fact that <code>pure f &lt;*&gt; x</code> equals <code>fmap f x</code>. This is one of the applicative laws. We'll take a closer look at them later, but for now, we can sort of intuitively see that this is so. Think about it, it makes sense. Like we said before, <code>pure</code> puts a value in a default context. If we just put a function in a default context and then extract and apply it to a value inside another applicative functor, we did the same as just mapping that function over that applicative functor. Instead of writing <code>pure f &lt;*&gt; x &lt;*&gt; y &lt;*&gt; ...</code>, we can write <code>fmap f x &lt;*&gt; y &lt;*&gt; ...</code>. This is why <code>Control.Applicative</code> exports a function called <code>&lt;$&gt;</code>, which is just <code>fmap</code> as an infix operator. Here's how it's defined:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token punctuation">(</span><span class="token operator">&lt;$&gt;</span><span class="token punctuation">)</span> <span class="token operator">::</span> <span class="token punctuation">(</span><span class="token constant">Functor</span> <span class="token hvariable">f</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">(</span><span class="token hvariable">a</span> <span class="token operator">-&gt;</span> <span class="token hvariable">b</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token hvariable">f</span> <span class="token hvariable">a</span> <span class="token operator">-&gt;</span> <span class="token hvariable">f</span> <span class="token hvariable">b</span>
<span class="token hvariable">f</span> <span class="token operator">&lt;$&gt;</span> <span class="token hvariable">x</span> <span class="token operator">=</span> <span class="token builtin">fmap</span> <span class="token hvariable">f</span> <span class="token hvariable">x</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><blockquote>
<p><strong>Yo!</strong> Quick reminder: type variables are independent of parameter names or other value names. The <code>f</code> in the function declaration here is a type variable with a class constraint saying that any type constructor that replaces <code>f</code> should be in the <code>Functor</code> typeclass. The <code>f</code> in the function body denotes a function that we map over <code>x</code>. The fact that we used <code>f</code> to represent both of those doesn't mean that they somehow represent the same thing.</p>
</blockquote></div><div><p>By using <code>&lt;$&gt;</code>, the applicative style really shines, because now if we want to apply a function <code>f</code> between three applicative functors, we can write <code>f &lt;$&gt; x &lt;*&gt; y &lt;*&gt; z</code>. If the parameters weren't applicative functors but normal values, we'd write <code>f x y z</code>.</p></div><div><p>Let's take a closer look at how this works. We have a value of <code>Just "johntra"</code> and a value of <code>Just "volta"</code> and we want to join them into one <code>String</code> inside a <code>Maybe</code> functor. We do this:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token punctuation">(</span><span class="token operator">++</span><span class="token punctuation">)</span> <span class="token operator">&lt;$&gt;</span> <span class="token constant">Just</span> <span class="token string">"johntra"</span> <span class="token operator">&lt;*&gt;</span> <span class="token constant">Just</span> <span class="token string">"volta"</span>
<span class="token constant">Just</span> <span class="token string">"johntravolta"</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Before we see how this happens, compare the above line with this:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token punctuation">(</span><span class="token operator">++</span><span class="token punctuation">)</span> <span class="token string">"johntra"</span> <span class="token string">"volta"</span>
<span class="token string">"johntravolta"</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Awesome! To use a normal function on applicative functors, just sprinkle some <code>&lt;$&gt;</code> and <code>&lt;*&gt;</code> about and the function will operate on applicatives and return an applicative. How cool is that?</p></div><div><p>Anyway, when we do <code>(++) &lt;$&gt; Just "johntra" &lt;*&gt; Just "volta"</code>, first <code>(++)</code>, which has a type of <code>(++) :: [a] -&gt; [a] -&gt; [a]</code> gets mapped over <code>Just "johntra"</code>, resulting in a value that's the same as <code>Just ("johntra"++)</code> and has a type of <code>Maybe ([Char] -&gt; [Char])</code>. Notice how the first parameter of <code>(++)</code> got eaten up and how the <code>a</code>s turned into <code>Char</code>s. And now <code>Just ("johntra"++) &lt;*&gt; Just "volta"</code> happens, which takes the function out of the <code>Just</code> and maps it over <code>Just "volta"</code>, resulting in <code>Just "johntravolta"</code>. Had any of the two values been <code>Nothing</code>, the result would have also been <code>Nothing</code>.</p></div><div><p>So far, we've only used <code>Maybe</code> in our examples and you might be thinking that applicative functors are all about <code>Maybe</code>. There are loads of other instances of <code>Applicative</code>, so let's go and meet them!</p></div><div><p>Lists (actually the list type constructor, <code>[]</code>) are applicative functors. What a suprise! Here's how <code>[]</code> is an instance of <code>Applicative</code>:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token keyword">instance</span> <span class="token constant">Applicative</span> <span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token keyword">where</span>
    <span class="token hvariable">pure</span> <span class="token hvariable">x</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token hvariable">x</span><span class="token punctuation">]</span>
    <span class="token hvariable">fs</span> <span class="token operator">&lt;*&gt;</span> <span class="token hvariable">xs</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token hvariable">f</span> <span class="token hvariable">x</span> <span class="token operator">|</span> <span class="token hvariable">f</span> <span class="token operator">&lt;-</span> <span class="token hvariable">fs</span><span class="token punctuation">,</span> <span class="token hvariable">x</span> <span class="token operator">&lt;-</span> <span class="token hvariable">xs</span><span class="token punctuation">]</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Earlier, we said that <code>pure</code> takes a value and puts it in a default context. Or in other words, a minimal context that still yields that value. The minimal context for lists would be the empty list, <code>[]</code>, but the empty list represents the lack of a value, so it can't hold in itself the value that we used <code>pure</code> on. That's why <code>pure</code> takes a value and puts it in a singleton list. Similarly, the minimal context for the <code>Maybe</code> applicative functor would be a <code>Nothing</code>, but it represents the lack of a value instead of a value, so <code>pure</code> is implemented as <code>Just</code> in the instance implementation for <code>Maybe</code>.</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token hvariable">pure</span> <span class="token string">"Hey"</span> <span class="token operator">::</span> <span class="token punctuation">[</span><span class="token constant">String</span><span class="token punctuation">]</span>
<span class="token punctuation">[</span><span class="token string">"Hey"</span><span class="token punctuation">]</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token hvariable">pure</span> <span class="token string">"Hey"</span> <span class="token operator">::</span> <span class="token constant">Maybe</span> <span class="token constant">String</span>
<span class="token constant">Just</span> <span class="token string">"Hey"</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>What about <code>&lt;*&gt;</code>? If we look at what <code>&lt;*&gt;</code>'s type would be if it were limited only to lists, we get <code>(&lt;*&gt;) :: [a -&gt; b] -&gt; [a] -&gt; [b]</code>. It's implemented with a <a data-tooltip-position="top" aria-label="http://learnyouahaskell.com/starting-out#im-a-list-comprehension" rel="noopener" class="external-link" href="http://learnyouahaskell.com/starting-out#im-a-list-comprehension" target="_blank">list comprehension</a>. <code>&lt;*&gt;</code> has to somehow extract the function out of its left parameter and then map it over the right parameter. But the thing here is that the left list can have zero functions, one function, or several functions inside it. The right list can also hold several values. That's why we use a list comprehension to draw from both lists. We apply every possible function from the left list to every possible value from the right list. The resulting list has every possible combination of applying a function from the left list to a value in the right one.</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token punctuation">[</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token operator">+</span><span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token operator">^</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token operator">&lt;*&gt;</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">]</span>
<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">101</span><span class="token punctuation">,</span><span class="token number">102</span><span class="token punctuation">,</span><span class="token number">103</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">9</span><span class="token punctuation">]</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>The left list has three functions and the right list has three values, so the resulting list will have nine elements. Every function in the left list is applied to every function in the right one. If we have a list of functions that take two parameters, we can apply those functions between two lists.</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token punctuation">[</span><span class="token punctuation">(</span><span class="token operator">+</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token operator">&lt;*&gt;</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">&lt;*&gt;</span> <span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">]</span>
<span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">,</span><span class="token number">8</span><span class="token punctuation">]</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Because <code>&lt;*&gt;</code> is left-associative, <code>[(+),(*)] &lt;*&gt; [1,2]</code> happens first, resulting in a list that's the same as <code>[(1+),(2+),(1*),(2*)]</code>, because every function on the left gets applied to every value on the right. Then, <code>[(1+),(2+),(1*),(2*)] &lt;*&gt; [3,4]</code> happens, which produces the final result.</p></div><div><p>Using the applicative style with lists is fun! Watch:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token punctuation">(</span><span class="token operator">++</span><span class="token punctuation">)</span> <span class="token operator">&lt;$&gt;</span> <span class="token punctuation">[</span><span class="token string">"ha"</span><span class="token punctuation">,</span><span class="token string">"heh"</span><span class="token punctuation">,</span><span class="token string">"hmm"</span><span class="token punctuation">]</span> <span class="token operator">&lt;*&gt;</span> <span class="token punctuation">[</span><span class="token string">"?"</span><span class="token punctuation">,</span><span class="token string">"!"</span><span class="token punctuation">,</span><span class="token string">"."</span><span class="token punctuation">]</span>
<span class="token punctuation">[</span><span class="token string">"ha?"</span><span class="token punctuation">,</span><span class="token string">"ha!"</span><span class="token punctuation">,</span><span class="token string">"ha."</span><span class="token punctuation">,</span><span class="token string">"heh?"</span><span class="token punctuation">,</span><span class="token string">"heh!"</span><span class="token punctuation">,</span><span class="token string">"heh."</span><span class="token punctuation">,</span><span class="token string">"hmm?"</span><span class="token punctuation">,</span><span class="token string">"hmm!"</span><span class="token punctuation">,</span><span class="token string">"hmm."</span><span class="token punctuation">]</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Again, see how we used a normal function that takes two strings between two applicative functors of strings just by inserting the appropriate applicative operators.</p></div><div><p>You can view lists as non-deterministic computations. A value like <code>100</code> or <code>"what"</code> can be viewed as a deterministic computation that has only one result, whereas a list like <code>[1,2,3]</code> can be viewed as a computation that can't decide on which result it wants to have, so it presents us with all of the possible results. So when you do something like <code>(+) &lt;$&gt; [1,2,3] &lt;*&gt; [4,5,6]</code>, you can think of it as adding together two non-deterministic computations with <code>+</code>, only to produce another non-deterministic computation that's even less sure about its result.</p></div><div><p>Using the applicative style on lists is often a good replacement for list comprehensions. In the second chapter, we wanted to see all the possible products of <code>[2,5,10]</code> and <code>[8,10,11]</code>, so we did this:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token punctuation">[</span> <span class="token hvariable">x</span><span class="token operator">*</span><span class="token hvariable">y</span> <span class="token operator">|</span> <span class="token hvariable">x</span> <span class="token operator">&lt;-</span> <span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">10</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token hvariable">y</span> <span class="token operator">&lt;-</span> <span class="token punctuation">[</span><span class="token number">8</span><span class="token punctuation">,</span><span class="token number">10</span><span class="token punctuation">,</span><span class="token number">11</span><span class="token punctuation">]</span><span class="token punctuation">]</span>   
<span class="token punctuation">[</span><span class="token number">16</span><span class="token punctuation">,</span><span class="token number">20</span><span class="token punctuation">,</span><span class="token number">22</span><span class="token punctuation">,</span><span class="token number">40</span><span class="token punctuation">,</span><span class="token number">50</span><span class="token punctuation">,</span><span class="token number">55</span><span class="token punctuation">,</span><span class="token number">80</span><span class="token punctuation">,</span><span class="token number">100</span><span class="token punctuation">,</span><span class="token number">110</span><span class="token punctuation">]</span>   
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>We're just drawing from two lists and applying a function between every combination of elements. This can be done in the applicative style as well:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">)</span> <span class="token operator">&lt;$&gt;</span> <span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">10</span><span class="token punctuation">]</span> <span class="token operator">&lt;*&gt;</span> <span class="token punctuation">[</span><span class="token number">8</span><span class="token punctuation">,</span><span class="token number">10</span><span class="token punctuation">,</span><span class="token number">11</span><span class="token punctuation">]</span>
<span class="token punctuation">[</span><span class="token number">16</span><span class="token punctuation">,</span><span class="token number">20</span><span class="token punctuation">,</span><span class="token number">22</span><span class="token punctuation">,</span><span class="token number">40</span><span class="token punctuation">,</span><span class="token number">50</span><span class="token punctuation">,</span><span class="token number">55</span><span class="token punctuation">,</span><span class="token number">80</span><span class="token punctuation">,</span><span class="token number">100</span><span class="token punctuation">,</span><span class="token number">110</span><span class="token punctuation">]</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>This seems clearer to me, because it's easier to see that we're just calling <code>*</code> between two non-deterministic computations. If we wanted all possible products of those two lists that are more than 50, we'd just do:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token builtin">filter</span> <span class="token punctuation">(</span><span class="token operator">&gt;</span><span class="token number">50</span><span class="token punctuation">)</span> <span class="token operator">$</span> <span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">)</span> <span class="token operator">&lt;$&gt;</span> <span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">10</span><span class="token punctuation">]</span> <span class="token operator">&lt;*&gt;</span> <span class="token punctuation">[</span><span class="token number">8</span><span class="token punctuation">,</span><span class="token number">10</span><span class="token punctuation">,</span><span class="token number">11</span><span class="token punctuation">]</span>
<span class="token punctuation">[</span><span class="token number">55</span><span class="token punctuation">,</span><span class="token number">80</span><span class="token punctuation">,</span><span class="token number">100</span><span class="token punctuation">,</span><span class="token number">110</span><span class="token punctuation">]</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>It's easy to see how <code>pure f &lt;*&gt; xs</code> equals <code>fmap f xs</code> with lists. <code>pure f</code> is just <code>[f]</code> and <code>[f] &lt;*&gt; xs</code> will apply every function in the left list to every value in the right one, but there's just one function in the left list, so it's like mapping.</p></div><div><p>Another instance of <code>Applicative</code> that we've already encountered is <code>IO</code>. This is how the instance is implemented:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token keyword">instance</span> <span class="token constant">Applicative</span> <span class="token constant">IO</span> <span class="token keyword">where</span>
    <span class="token hvariable">pure</span> <span class="token operator">=</span> <span class="token builtin">return</span>
    <span class="token hvariable">a</span> <span class="token operator">&lt;*&gt;</span> <span class="token hvariable">b</span> <span class="token operator">=</span> <span class="token keyword">do</span>
        <span class="token hvariable">f</span> <span class="token operator">&lt;-</span> <span class="token hvariable">a</span>
        <span class="token hvariable">x</span> <span class="token operator">&lt;-</span> <span class="token hvariable">b</span>
        <span class="token builtin">return</span> <span class="token punctuation">(</span><span class="token hvariable">f</span> <span class="token hvariable">x</span><span class="token punctuation">)</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p><span alt="LYHfGG_84_knight.png" src="LYHfGG_84_knight.png" class="internal-embed media-embed image-embed is-loaded"><img alt="LYHfGG_84_knight.png" src="курсы\learn-you-a-haskell-for-great-good!\картинки\lyhfgg_84_knight.png"></span></p></div><div><p>Since <code>pure</code> is all about putting a value in a minimal context that still holds it as its result, it makes sense that <code>pure</code> is just <code>return</code>, because <code>return</code> does exactly that; it makes an I/O action that doesn't do anything, it just yields some value as its result, but it doesn't really do any I/O operations like printing to the terminal or reading from a file.</p></div><div><p>If <code>&lt;*&gt;</code> were specialized for <code>IO</code> it would have a type of <code>(&lt;*&gt;) :: IO (a -&gt; b) -&gt; IO a -&gt; IO b</code>. It would take an I/O action that yields a function as its result and another I/O action and create a new I/O action from those two that, when performed, first performs the first one to get the function and then performs the second one to get the value and then it would yield that function applied to the value as its result. We used <em>do</em> syntax to implement it here. Remember, <em>do</em> syntax is about taking several I/O actions and gluing them into one, which is exactly what we do here.</p></div><div><p>With <code>Maybe</code> and <code>[]</code>, we could think of <code>&lt;*&gt;</code> as simply extracting a function from its left parameter and then sort of applying it over the right one. With <code>IO</code>, extracting is still in the game, but now we also have a notion of <em>sequencing</em>, because we're taking two I/O actions and we're sequencing, or gluing, them into one. We have to extract the function from the first I/O action, but to extract a result from an I/O action, it has to be performed.</p></div><div><p>Consider this:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">myAction</span> <span class="token operator">::</span> <span class="token constant">IO</span> <span class="token constant">String</span>
<span class="token hvariable">myAction</span> <span class="token operator">=</span> <span class="token keyword">do</span>
    <span class="token hvariable">a</span> <span class="token operator">&lt;-</span> <span class="token builtin">getLine</span>
    <span class="token hvariable">b</span> <span class="token operator">&lt;-</span> <span class="token builtin">getLine</span>
    <span class="token builtin">return</span> <span class="token operator">$</span> <span class="token hvariable">a</span> <span class="token operator">++</span> <span class="token hvariable">b</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>This is an I/O action that will prompt the user for two lines and yield as its result those two lines concatenated. We achieved it by gluing together two <code>getLine</code> I/O actions and a <code>return</code>, because we wanted our new glued I/O action to hold the result of <code>a ++ b</code>. Another way of writing this would be to use the applicative style.</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">myAction</span> <span class="token operator">::</span> <span class="token constant">IO</span> <span class="token constant">String</span>
<span class="token hvariable">myAction</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token operator">++</span><span class="token punctuation">)</span> <span class="token operator">&lt;$&gt;</span> <span class="token builtin">getLine</span> <span class="token operator">&lt;*&gt;</span> <span class="token builtin">getLine</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>What we were doing before was making an I/O action that applied a function between the results of two other I/O actions, and this is the same thing. Remember, <code>getLine</code> is an I/O action with the type <code>getLine :: IO String</code>. When we use <code>&lt;*&gt;</code> between two applicative functors, the result is an applicative functor, so this all makes sense.</p></div><div><p>If we regress to the box analogy, we can imagine <code>getLine</code> as a box that will go out into the real world and fetch us a string. Doing <code>(++) &lt;$&gt; getLine &lt;*&gt; getLine</code> makes a new, bigger box that sends those two boxes out to fetch lines from the terminal and then presents the concatenation of those two lines as its result.</p></div><div><p>The type of the expression <code>(++) &lt;$&gt; getLine &lt;*&gt; getLine</code> is <code>IO String</code>, which means that this expression is a completely normal I/O action like any other, which also holds a result value inside it, just like other I/O actions. That's why we can do stuff like:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">main</span> <span class="token operator">=</span> <span class="token keyword">do</span>
    <span class="token hvariable">a</span> <span class="token operator">&lt;-</span> <span class="token punctuation">(</span><span class="token operator">++</span><span class="token punctuation">)</span> <span class="token operator">&lt;$&gt;</span> <span class="token builtin">getLine</span> <span class="token operator">&lt;*&gt;</span> <span class="token builtin">getLine</span>
    <span class="token builtin">putStrLn</span> <span class="token operator">$</span> <span class="token string">"The two lines concatenated turn out to be: "</span> <span class="token operator">++</span> <span class="token hvariable">a</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>If you ever find yourself binding some I/O actions to names and then calling some function on them and presenting that as the result by using <code>return</code>, consider using the applicative style because it's arguably a bit more concise and terse.</p></div><div><p>Another instance of <code>Applicative</code> is <code>(-&gt;) r</code>, so functions. They are rarely used with the applicative style outside of code golf, but they're still interesting as applicatives, so let's take a look at how the function instance is implemented.</p></div><div><blockquote>
<p>If you're confused about what (-&gt;) r means, check out the previous section where we explain how (-&gt;) r is a functor.</p>
</blockquote></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token keyword">instance</span> <span class="token constant">Applicative</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token operator">-&gt;</span><span class="token punctuation">)</span> <span class="token hvariable">r</span><span class="token punctuation">)</span> <span class="token keyword">where</span>
    <span class="token hvariable">pure</span> <span class="token hvariable">x</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token operator">\</span><span class="token hvariable">_</span> <span class="token operator">-&gt;</span> <span class="token hvariable">x</span><span class="token punctuation">)</span>
    <span class="token hvariable">f</span> <span class="token operator">&lt;*&gt;</span> <span class="token hvariable">g</span> <span class="token operator">=</span> <span class="token operator">\</span><span class="token hvariable">x</span> <span class="token operator">-&gt;</span> <span class="token hvariable">f</span> <span class="token hvariable">x</span> <span class="token punctuation">(</span><span class="token hvariable">g</span> <span class="token hvariable">x</span><span class="token punctuation">)</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>When we wrap a value into an applicative functor with <code>pure</code>, the result it yields always has to be that value. A minimal default context that still yields that value as a result. That's why in the function instance implementation, <code>pure</code> takes a value and creates a function that ignores its parameter and always returns that value. If we look at the type for <code>pure</code>, but specialized for the <code>(-&gt;) r</code> instance, it's <code>pure :: a -&gt; (r -&gt; a)</code>.</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token punctuation">(</span><span class="token hvariable">pure</span> <span class="token number">3</span><span class="token punctuation">)</span> <span class="token string">"blah"</span>
<span class="token number">3</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Because of currying, function application is left-associative, so we can omit the parentheses.</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token hvariable">pure</span> <span class="token number">3</span> <span class="token string">"blah"</span>
<span class="token number">3</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>The instance implementation for <code>&lt;*&gt;</code> is a bit cryptic, so it's best if we just take a look at how to use functions as applicative functors in the applicative style.</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token operator">:</span><span class="token hvariable">t</span> <span class="token punctuation">(</span><span class="token operator">+</span><span class="token punctuation">)</span> <span class="token operator">&lt;$&gt;</span> <span class="token punctuation">(</span><span class="token operator">+</span><span class="token number">3</span><span class="token punctuation">)</span> <span class="token operator">&lt;*&gt;</span> <span class="token punctuation">(</span><span class="token operator">*</span><span class="token number">100</span><span class="token punctuation">)</span>
<span class="token punctuation">(</span><span class="token operator">+</span><span class="token punctuation">)</span> <span class="token operator">&lt;$&gt;</span> <span class="token punctuation">(</span><span class="token operator">+</span><span class="token number">3</span><span class="token punctuation">)</span> <span class="token operator">&lt;*&gt;</span> <span class="token punctuation">(</span><span class="token operator">*</span><span class="token number">100</span><span class="token punctuation">)</span> <span class="token operator">::</span> <span class="token punctuation">(</span><span class="token constant">Num</span> <span class="token hvariable">a</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token hvariable">a</span> <span class="token operator">-&gt;</span> <span class="token hvariable">a</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token punctuation">(</span><span class="token operator">+</span><span class="token punctuation">)</span> <span class="token operator">&lt;$&gt;</span> <span class="token punctuation">(</span><span class="token operator">+</span><span class="token number">3</span><span class="token punctuation">)</span> <span class="token operator">&lt;*&gt;</span> <span class="token punctuation">(</span><span class="token operator">*</span><span class="token number">100</span><span class="token punctuation">)</span> <span class="token operator">$</span> <span class="token number">5</span>
<span class="token number">508</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Calling <code>&lt;*&gt;</code> with two applicative functors results in an applicative functor, so if we use it on two functions, we get back a function. So what goes on here? When we do <code>(+) &lt;$&gt; (+3) &lt;*&gt; (*100)</code>, we're making a function that will use <code>+</code> on the results of <code>(+3)</code> and <code>(*100)</code> and return that. To demonstrate on a real example, when we did <code>(+) &lt;$&gt; (+3) &lt;*&gt; (*100) $ 5</code>, the <code>5</code> first got applied to <code>(+3)</code> and <code>(*100)</code>, resulting in <code>8</code> and <code>500</code>. Then, <code>+</code> gets called with <code>8</code> and <code>500</code>, resulting in <code>508</code>.</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token punctuation">(</span><span class="token operator">\</span><span class="token hvariable">x</span> <span class="token hvariable">y</span> <span class="token hvariable">z</span> <span class="token operator">-&gt;</span> <span class="token punctuation">[</span><span class="token hvariable">x</span><span class="token punctuation">,</span><span class="token hvariable">y</span><span class="token punctuation">,</span><span class="token hvariable">z</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">&lt;$&gt;</span> <span class="token punctuation">(</span><span class="token operator">+</span><span class="token number">3</span><span class="token punctuation">)</span> <span class="token operator">&lt;*&gt;</span> <span class="token punctuation">(</span><span class="token operator">*</span><span class="token number">2</span><span class="token punctuation">)</span> <span class="token operator">&lt;*&gt;</span> <span class="token punctuation">(</span><span class="token operator">/</span><span class="token number">2</span><span class="token punctuation">)</span> <span class="token operator">$</span> <span class="token number">5</span>
<span class="token punctuation">[</span><span class="token number">8.0</span><span class="token punctuation">,</span><span class="token number">10.0</span><span class="token punctuation">,</span><span class="token number">2.5</span><span class="token punctuation">]</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p><span alt="LYHfGG_85_jazzb.png" src="LYHfGG_85_jazzb.png" class="internal-embed media-embed image-embed is-loaded"><img alt="LYHfGG_85_jazzb.png" src="курсы\learn-you-a-haskell-for-great-good!\картинки\lyhfgg_85_jazzb.png"></span></p></div><div><p>Same here. We create a function that will call the function <code>\x y z -&gt; [x,y,z]</code> with the eventual results from <code>(+3)</code>, <code>(*2)</code> and <code>(/2)</code>. The <code>5</code> gets fed to each of the three functions and then <code>\x y z -&gt; [x, y, z]</code> gets called with those results.</p></div><div><p>You can think of functions as boxes that contain their eventual results, so doing <code>k &lt;$&gt; f &lt;*&gt; g</code> creates a function that will call <code>k</code> with the eventual results from <code>f</code> and <code>g</code>. When we do something like <code>(+) &lt;$&gt; Just 3 &lt;*&gt; Just 5</code>, we're using <code>+</code> on values that might or might not be there, which also results in a value that might or might not be there. When we do <code>(+) &lt;$&gt; (+10) &lt;*&gt; (+5)</code>, we're using <code>+</code> on the future return values of <code>(+10)</code> and <code>(+5)</code> and the result is also something that will produce a value only when called with a parameter.</p></div><div><p>We don't often use functions as applicatives, but this is still really interesting. It's not very important that you get how the <code>(-&gt;) r</code> instance for <code>Applicative</code> works, so don't despair if you're not getting this right now. Try playing with the applicative style and functions to build up an intuition for functions as applicatives.</p></div><div><p>An instance of <code>Applicative</code> that we haven't encountered yet is <code>ZipList</code>, and it lives in <code>Control.Applicative</code>.</p></div><div><p>It turns out there are actually more ways for lists to be applicative functors. One way is the one we already covered, which says that calling <code>&lt;*&gt;</code> with a list of functions and a list of values results in a list which has all the possible combinations of applying functions from the left list to the values in the right list. If we do <code>[(+3),(*2)] &lt;*&gt; [1,2]</code>, <code>(+3)</code> will be applied to both <code>1</code> and <code>2</code> and <code>(*2)</code> will also be applied to both <code>1</code> and <code>2</code>, resulting in a list that has four elements, namely <code>[4,5,2,4]</code>.</p></div><div><p>However, <code>[(+3),(*2)] &lt;*&gt; [1,2]</code> could also work in such a way that the first function in the left list gets applied to the first value in the right one, the second function gets applied to the second value, and so on. That would result in a list with two values, namely <code>[4,4]</code>. You could look at it as <code>[1 + 3, 2 * 2]</code>.</p></div><div><p>Because one type can't have two instances for the same typeclass, the <code>ZipList a</code> type was introduced, which has one constructor <code>ZipList</code> that has just one field, and that field is a list. Here's the instance:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token keyword">instance</span> <span class="token constant">Applicative</span> <span class="token constant">ZipList</span> <span class="token keyword">where</span>
        <span class="token hvariable">pure</span> <span class="token hvariable">x</span> <span class="token operator">=</span> <span class="token constant">ZipList</span> <span class="token punctuation">(</span><span class="token builtin">repeat</span> <span class="token hvariable">x</span><span class="token punctuation">)</span>
        <span class="token constant">ZipList</span> <span class="token hvariable">fs</span> <span class="token operator">&lt;*&gt;</span> <span class="token constant">ZipList</span> <span class="token hvariable">xs</span> <span class="token operator">=</span> <span class="token constant">ZipList</span> <span class="token punctuation">(</span><span class="token builtin">zipWith</span> <span class="token punctuation">(</span><span class="token operator">\</span><span class="token hvariable">f</span> <span class="token hvariable">x</span> <span class="token operator">-&gt;</span> <span class="token hvariable">f</span> <span class="token hvariable">x</span><span class="token punctuation">)</span> <span class="token hvariable">fs</span> <span class="token hvariable">xs</span><span class="token punctuation">)</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p><code>&lt;*&gt;</code> does just what we said. It applies the first function to the first value, the second function to the second value, etc. This is done with <code>zipWith (\f x -&gt; f x) fs xs</code>. Because of how <code>zipWith</code> works, the resulting list will be as long as the shorter of the two lists.</p></div><div><p><code>pure</code> is also interesting here. It takes a value and puts it in a list that just has that value repeating indefinitely. <code>pure "haha"</code> results in <code>ZipList (["haha","haha","haha"...</code>. This might be a bit confusing since we said that <code>pure</code> should put a value in a minimal context that still yields that value. And you might be thinking that an infinite list of something is hardly minimal. But it makes sense with zip lists, because it has to produce the value on every position. This also satisfies the law that <code>pure f &lt;*&gt; xs</code> should equal <code>fmap f xs</code>. If <code>pure 3</code> just returned <code>ZipList [3]</code>, <code>pure (*2) &lt;*&gt; ZipList [1,5,10]</code> would result in <code>ZipList [2]</code>, because the resulting list of two zipped lists has the length of the shorter of the two. If we zip a finite list with an infinite list, the length of the resulting list will always be equal to the length of the finite list.</p></div><div><p>So how do zip lists work in an applicative style? Let's see. Oh, the <code>ZipList a</code> type doesn't have a <code>Show</code> instance, so we have to use the <code>getZipList</code> function to extract a raw list out of a zip list.</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token hvariable">getZipList</span> <span class="token operator">$</span> <span class="token punctuation">(</span><span class="token operator">+</span><span class="token punctuation">)</span> <span class="token operator">&lt;$&gt;</span> <span class="token constant">ZipList</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">]</span> <span class="token operator">&lt;*&gt;</span> <span class="token constant">ZipList</span> <span class="token punctuation">[</span><span class="token number">100</span><span class="token punctuation">,</span><span class="token number">100</span><span class="token punctuation">,</span><span class="token number">100</span><span class="token punctuation">]</span>
<span class="token punctuation">[</span><span class="token number">101</span><span class="token punctuation">,</span><span class="token number">102</span><span class="token punctuation">,</span><span class="token number">103</span><span class="token punctuation">]</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token hvariable">getZipList</span> <span class="token operator">$</span> <span class="token punctuation">(</span><span class="token operator">+</span><span class="token punctuation">)</span> <span class="token operator">&lt;$&gt;</span> <span class="token constant">ZipList</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">]</span> <span class="token operator">&lt;*&gt;</span> <span class="token constant">ZipList</span> <span class="token punctuation">[</span><span class="token number">100</span><span class="token punctuation">,</span><span class="token number">100</span><span class="token operator">..</span><span class="token punctuation">]</span>
<span class="token punctuation">[</span><span class="token number">101</span><span class="token punctuation">,</span><span class="token number">102</span><span class="token punctuation">,</span><span class="token number">103</span><span class="token punctuation">]</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token hvariable">getZipList</span> <span class="token operator">$</span> <span class="token builtin">max</span> <span class="token operator">&lt;$&gt;</span> <span class="token constant">ZipList</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">]</span> <span class="token operator">&lt;*&gt;</span> <span class="token constant">ZipList</span> <span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">]</span>
<span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">]</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token hvariable">getZipList</span> <span class="token operator">$</span> <span class="token punctuation">(</span><span class="token punctuation">,</span><span class="token punctuation">,</span><span class="token punctuation">)</span> <span class="token operator">&lt;$&gt;</span> <span class="token constant">ZipList</span> <span class="token string">"dog"</span> <span class="token operator">&lt;*&gt;</span> <span class="token constant">ZipList</span> <span class="token string">"cat"</span> <span class="token operator">&lt;*&gt;</span> <span class="token constant">ZipList</span> <span class="token string">"rat"</span>
<span class="token punctuation">[</span><span class="token punctuation">(</span><span class="token char string">'d'</span><span class="token punctuation">,</span><span class="token char string">'c'</span><span class="token punctuation">,</span><span class="token char string">'r'</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token char string">'o'</span><span class="token punctuation">,</span><span class="token char string">'a'</span><span class="token punctuation">,</span><span class="token char string">'a'</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token char string">'g'</span><span class="token punctuation">,</span><span class="token char string">'t'</span><span class="token punctuation">,</span><span class="token char string">'t'</span><span class="token punctuation">)</span><span class="token punctuation">]</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><blockquote>
<p>The <code>(,,)</code> function is the same as <code>\x y z -&gt; (x,y,z)</code>. Also, the <code>(,)</code> function is the same as <code>\x y -&gt; (x,y)</code>.</p>
</blockquote></div><div><p>Aside from <code>zipWith</code>, the standard library has functions such as <code>zipWith3</code>, <code>zipWith4</code>, all the way up to 7. <code>zipWith</code> takes a function that takes two parameters and zips two lists with it. <code>zipWith3</code> takes a function that takes three parameters and zips three lists with it, and so on. By using zip lists with an applicative style, we don't have to have a separate zip function for each number of lists that we want to zip together. We just use the applicative style to zip together an arbitrary amount of lists with a function, and that's pretty cool.</p></div><div><p><code>Control.Applicative</code> defines a function that's called <code>liftA2</code>, which has a type of <code>liftA2 :: (Applicative f) =&gt; (a -&gt; b -&gt; c) -&gt; f a -&gt; f b -&gt; f c</code> . It's defined like this:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">liftA2</span> <span class="token operator">::</span> <span class="token punctuation">(</span><span class="token constant">Applicative</span> <span class="token hvariable">f</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">(</span><span class="token hvariable">a</span> <span class="token operator">-&gt;</span> <span class="token hvariable">b</span> <span class="token operator">-&gt;</span> <span class="token hvariable">c</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token hvariable">f</span> <span class="token hvariable">a</span> <span class="token operator">-&gt;</span> <span class="token hvariable">f</span> <span class="token hvariable">b</span> <span class="token operator">-&gt;</span> <span class="token hvariable">f</span> <span class="token hvariable">c</span>
<span class="token hvariable">liftA2</span> <span class="token hvariable">f</span> <span class="token hvariable">a</span> <span class="token hvariable">b</span> <span class="token operator">=</span> <span class="token hvariable">f</span> <span class="token operator">&lt;$&gt;</span> <span class="token hvariable">a</span> <span class="token operator">&lt;*&gt;</span> <span class="token hvariable">b</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Nothing special, it just applies a function between two applicatives, hiding the applicative style that we've become familiar with. The reason we're looking at it is because it clearly showcases why applicative functors are more powerful than just ordinary functors. With ordinary functors, we can just map functions over one functor. But with applicative functors, we can apply a function between several functors. It's also interesting to look at this function's type as <code>(a -&gt; b -&gt; c) -&gt; (f a -&gt; f b -&gt; f c)</code>. When we look at it like this, we can say that <code>liftA2</code> takes a normal binary function and promotes it to a function that operates on two functors.</p></div><div><p>Here's an interesting concept: we can take two applicative functors and combine them into one applicative functor that has inside it the results of those two applicative functors in a list. For instance, we have <code>Just 3</code> and <code>Just 4</code>. Let's assume that the second one has a singleton list inside it, because that's really easy to achieve:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token builtin">fmap</span> <span class="token punctuation">(</span><span class="token operator">\</span><span class="token hvariable">x</span> <span class="token operator">-&gt;</span> <span class="token punctuation">[</span><span class="token hvariable">x</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token constant">Just</span> <span class="token number">4</span><span class="token punctuation">)</span>
<span class="token constant">Just</span> <span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">]</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>OK, so let's say we have <code>Just 3</code> and <code>Just [4]</code>. How do we get <code>Just [3,4]</code>? Easy.</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token hvariable">liftA2</span> <span class="token punctuation">(</span><span class="token operator">:</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token constant">Just</span> <span class="token number">3</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token constant">Just</span> <span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
<span class="token constant">Just</span> <span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">]</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token punctuation">(</span><span class="token operator">:</span><span class="token punctuation">)</span> <span class="token operator">&lt;$&gt;</span> <span class="token constant">Just</span> <span class="token number">3</span> <span class="token operator">&lt;*&gt;</span> <span class="token constant">Just</span> <span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">]</span>
<span class="token constant">Just</span> <span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">]</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Remember, <code>:</code> is a function that takes an element and a list and returns a new list with that element at the beginning. Now that we have <code>Just [3,4]</code>, could we combine that with <code>Just 2</code> to produce <code>Just [2,3,4]</code>? Of course we could. It seems that we can combine any amount of applicatives into one applicative that has a list of the results of those applicatives inside it. Let's try implementing a function that takes a list of applicatives and returns an applicative that has a list as its result value. We'll call it <code>sequenceA</code>.</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">sequenceA</span> <span class="token operator">::</span> <span class="token punctuation">(</span><span class="token constant">Applicative</span> <span class="token hvariable">f</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">[</span><span class="token hvariable">f</span> <span class="token hvariable">a</span><span class="token punctuation">]</span> <span class="token operator">-&gt;</span> <span class="token hvariable">f</span> <span class="token punctuation">[</span><span class="token hvariable">a</span><span class="token punctuation">]</span>
<span class="token hvariable">sequenceA</span> <span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token hvariable">pure</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
<span class="token hvariable">sequenceA</span> <span class="token punctuation">(</span><span class="token hvariable">x</span><span class="token operator">:</span><span class="token hvariable">xs</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token operator">:</span><span class="token punctuation">)</span> <span class="token operator">&lt;$&gt;</span> <span class="token hvariable">x</span> <span class="token operator">&lt;*&gt;</span> <span class="token hvariable">sequenceA</span> <span class="token hvariable">xs</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Ah, recursion! First, we look at the type. It will transform a list of applicatives into an applicative with a list. From that, we can lay some groundwork for an edge condition. If we want to turn an empty list into an applicative with a list of results, well, we just put an empty list in a default context. Now comes the recursion. If we have a list with a head and a tail (remember, <code>x</code> is an applicative and <code>xs</code> is a list of them), we call <code>sequenceA</code> on the tail, which results in an applicative with a list. Then, we just prepend the value inside the applicative <code>x</code> into that applicative with a list, and that's it!</p></div><div><p>So if we do <code>sequenceA [Just 1, Just 2]</code>, that's <code>(:) &lt;$&gt; Just 1 &lt;*&gt; sequenceA [Just 2]</code> . That equals <code>(:) &lt;$&gt; Just 1 &lt;*&gt; ((:) &lt;$&gt; Just 2 &lt;*&gt; sequenceA [])</code>. Ah! We know that <code>sequenceA []</code> ends up as being <code>Just []</code>, so this expression is now <code>(:) &lt;$&gt; Just 1 &lt;*&gt; ((:) &lt;$&gt; Just 2 &lt;*&gt; Just [])</code>, which is <code>(:) &lt;$&gt; Just 1 &lt;*&gt; Just [2]</code>, which is <code>Just [1,2]</code>!</p></div><div><p>Another way to implement <code>sequenceA</code> is with a fold. Remember, pretty much any function where we go over a list element by element and accumulate a result along the way can be implemented with a fold.</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">sequenceA</span> <span class="token operator">::</span> <span class="token punctuation">(</span><span class="token constant">Applicative</span> <span class="token hvariable">f</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">[</span><span class="token hvariable">f</span> <span class="token hvariable">a</span><span class="token punctuation">]</span> <span class="token operator">-&gt;</span> <span class="token hvariable">f</span> <span class="token punctuation">[</span><span class="token hvariable">a</span><span class="token punctuation">]</span>
<span class="token hvariable">sequenceA</span> <span class="token operator">=</span> <span class="token builtin">foldr</span> <span class="token punctuation">(</span><span class="token hvariable">liftA2</span> <span class="token punctuation">(</span><span class="token operator">:</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token hvariable">pure</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>We approach the list from the right and start off with an accumulator value of <code>pure []</code>. We do <code>liftA2 (:)</code> between the accumulator and the last element of the list, which results in an applicative that has a singleton in it. Then we do <code>liftA2 (:)</code> with the now last element and the current accumulator and so on, until we're left with just the accumulator, which holds a list of the results of all the applicatives.</p></div><div><p>Let's give our function a whirl on some applicatives.</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token hvariable">sequenceA</span> <span class="token punctuation">[</span><span class="token constant">Just</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token constant">Just</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token constant">Just</span> <span class="token number">1</span><span class="token punctuation">]</span>
<span class="token constant">Just</span> <span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">]</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token hvariable">sequenceA</span> <span class="token punctuation">[</span><span class="token constant">Just</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token constant">Nothing</span><span class="token punctuation">,</span> <span class="token constant">Just</span> <span class="token number">1</span><span class="token punctuation">]</span>
<span class="token constant">Nothing</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token hvariable">sequenceA</span> <span class="token punctuation">[</span><span class="token punctuation">(</span><span class="token operator">+</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token operator">+</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token number">3</span>
<span class="token punctuation">[</span><span class="token number">6</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">]</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token hvariable">sequenceA</span> <span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">]</span><span class="token punctuation">]</span>
<span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">]</span><span class="token punctuation">]</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token hvariable">sequenceA</span> <span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">]</span>
<span class="token punctuation">[</span><span class="token punctuation">]</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Ah! Pretty cool. When used on <code>Maybe</code> values, <code>sequenceA</code> creates a <code>Maybe</code> value with all the results inside it as a list. If one of the values was <code>Nothing</code>, then the result is also a <code>Nothing</code>. This is cool when you have a list of <code>Maybe</code> values and you're interested in the values only if none of them is a <code>Nothing</code>.</p></div><div><p>When used with functions, <code>sequenceA</code> takes a list of functions and returns a function that returns a list. In our example, we made a function that took a number as a parameter and applied it to each function in the list and then returned a list of results. <code>sequenceA [(+3),(+2),(+1)] 3</code> will call <code>(+3)</code> with <code>3</code>, <code>(+2)</code> with <code>3</code> and <code>(+1)</code> with <code>3</code> and present all those results as a list.</p></div><div><p>Doing <code>(+) &lt;$&gt; (+3) &lt;*&gt; (*2)</code> will create a function that takes a parameter, feeds it to both <code>(+3)</code> and <code>(*2)</code> and then calls <code>+</code> with those two results. In the same vein, it makes sense that <code>sequenceA [(+3),(*2)]</code> makes a function that takes a parameter and feeds it to all of the functions in the list. Instead of calling <code>+</code> with the results of the functions, a combination of <code>:</code> and <code>pure []</code> is used to gather those results in a list, which is the result of that function.</p></div><div><p>Using <code>sequenceA</code> is cool when we have a list of functions and we want to feed the same input to all of them and then view the list of results. For instance, we have a number and we're wondering whether it satisfies all of the predicates in a list. One way to do that would be like so:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token builtin">map</span> <span class="token punctuation">(</span><span class="token operator">\</span><span class="token hvariable">f</span> <span class="token operator">-&gt;</span> <span class="token hvariable">f</span> <span class="token number">7</span><span class="token punctuation">)</span> <span class="token punctuation">[</span><span class="token punctuation">(</span><span class="token operator">&gt;</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token operator">&lt;</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token builtin">odd</span><span class="token punctuation">]</span>
<span class="token punctuation">[</span><span class="token constant">True</span><span class="token punctuation">,</span><span class="token constant">True</span><span class="token punctuation">,</span><span class="token constant">True</span><span class="token punctuation">]</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token builtin">and</span> <span class="token operator">$</span> <span class="token builtin">map</span> <span class="token punctuation">(</span><span class="token operator">\</span><span class="token hvariable">f</span> <span class="token operator">-&gt;</span> <span class="token hvariable">f</span> <span class="token number">7</span><span class="token punctuation">)</span> <span class="token punctuation">[</span><span class="token punctuation">(</span><span class="token operator">&gt;</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token operator">&lt;</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token builtin">odd</span><span class="token punctuation">]</span>
<span class="token constant">True</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Remember, <code>and</code> takes a list of booleans and returns <code>True</code> if they're all <code>True</code>. Another way to achieve the same thing would be with <code>sequenceA</code>:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token hvariable">sequenceA</span> <span class="token punctuation">[</span><span class="token punctuation">(</span><span class="token operator">&gt;</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token operator">&lt;</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token builtin">odd</span><span class="token punctuation">]</span> <span class="token number">7</span>
<span class="token punctuation">[</span><span class="token constant">True</span><span class="token punctuation">,</span><span class="token constant">True</span><span class="token punctuation">,</span><span class="token constant">True</span><span class="token punctuation">]</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token builtin">and</span> <span class="token operator">$</span> <span class="token hvariable">sequenceA</span> <span class="token punctuation">[</span><span class="token punctuation">(</span><span class="token operator">&gt;</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token operator">&lt;</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token builtin">odd</span><span class="token punctuation">]</span> <span class="token number">7</span>
<span class="token constant">True</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p><code>sequenceA [(&gt;4),(&lt;10),odd]</code> creates a function that will take a number and feed it to all of the predicates in <code>[(&gt;4),(&lt;10),odd]</code> and return a list of booleans. It turns a list with the type <code>(Num a) =&gt; [a -&gt; Bool]</code> into a function with the type <code>(Num a) =&gt; a -&gt; [Bool]</code>. Pretty neat, huh?</p></div><div><p>Because lists are homogenous, all the functions in the list have to be functions of the same type, of course. You can't have a list like <code>[ord, (+3)]</code>, because <code>ord</code> takes a character and returns a number, whereas <code>(+3)</code> takes a number and returns a number.</p></div><div><p>When used with <code>[]</code>, <code>sequenceA</code> takes a list of lists and returns a list of lists. Hmm, interesting. It actually creates lists that have all possible combinations of their elements. For illustration, here's the above done with <code>sequenceA</code> and then done with a list comprehension:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token hvariable">sequenceA</span> <span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">]</span><span class="token punctuation">]</span>
<span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">]</span><span class="token punctuation">]</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token hvariable">x</span><span class="token punctuation">,</span><span class="token hvariable">y</span><span class="token punctuation">]</span> <span class="token operator">|</span> <span class="token hvariable">x</span> <span class="token operator">&lt;-</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token hvariable">y</span> <span class="token operator">&lt;-</span> <span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">]</span><span class="token punctuation">]</span>
<span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">]</span><span class="token punctuation">]</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token hvariable">sequenceA</span> <span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">]</span>
<span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">]</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token hvariable">x</span><span class="token punctuation">,</span><span class="token hvariable">y</span><span class="token punctuation">]</span> <span class="token operator">|</span> <span class="token hvariable">x</span> <span class="token operator">&lt;-</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token hvariable">y</span> <span class="token operator">&lt;-</span> <span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">]</span>
<span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">]</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token hvariable">sequenceA</span> <span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">]</span><span class="token punctuation">]</span>
<span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">]</span><span class="token punctuation">]</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token hvariable">x</span><span class="token punctuation">,</span><span class="token hvariable">y</span><span class="token punctuation">,</span><span class="token hvariable">z</span><span class="token punctuation">]</span> <span class="token operator">|</span> <span class="token hvariable">x</span> <span class="token operator">&lt;-</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token hvariable">y</span> <span class="token operator">&lt;-</span> <span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token hvariable">z</span> <span class="token operator">&lt;-</span> <span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">]</span><span class="token punctuation">]</span>
<span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">]</span><span class="token punctuation">]</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>This might be a bit hard to grasp, but if you play with it for a while, you'll see how it works. Let's say that we're doing <code>sequenceA [[1,2],[3,4]]</code>. To see how this happens, let's use the <code>sequenceA (x:xs) = (:) &lt;$&gt; x &lt;*&gt; sequenceA xs</code> definition of <code>sequenceA</code> and the edge condition <code>sequenceA [] = pure []</code>. You don't have to follow this evaluation, but it might help you if have trouble imagining how <code>sequenceA</code> works on lists of lists, because it can be a bit mind-bending.</p></div><div><ul class="has-list-bullet">
<li data-line="0"><div class="list-bullet"></div>We start off with <code>sequenceA [[1,2],[3,4]]</code></li>
<li data-line="1"><div class="list-bullet"></div>That evaluates to <code>(:) &lt;$&gt; [1,2] &lt;*&gt; sequenceA [[3,4]]</code></li>
<li data-line="2"><div class="list-bullet"></div>Evaluating the inner sequenceA further, we get <code>(:) &lt;$&gt; [1,2] &lt;*&gt; ((:) &lt;$&gt; [3,4] &lt;*&gt; sequenceA [])</code></li>
<li data-line="3"><div class="list-bullet"></div>We've reached the edge condition, so this is now <code>(:) &lt;$&gt; [1,2] &lt;*&gt; ((:) &lt;$&gt; [3,4] &lt;*&gt; [[]])</code></li>
<li data-line="4"><div class="list-bullet"></div>Now, we evaluate the <code>(:) &lt;$&gt; [3,4] &lt;*&gt; [[]]</code> part, which will use <code>:</code> with every possible value in the left list (possible values are <code>3</code> and <code>4</code>) with every possible value on the right list (only possible value is <code>[]</code>), which results in <code>[3:[], 4:[]]</code>, which is <code>[[3],[4]]</code>. So now we have <code>(:) &lt;$&gt; [1,2] &lt;*&gt; [[3],[4]]</code></li>
<li data-line="5"><div class="list-bullet"></div>Now, : is used with every possible value from the left list (<code>1</code> and <code>2</code>) with every possible value in the right list (<code>[3]</code> and <code>[4]</code>), which results in <code>[1:[3], 1:[4], 2:[3], 2:[4]]</code>, which is <code>[[1,3],[1,4],[2,3],[2,4]</code></li>
</ul></div><div><p>Doing <code>(+) &lt;$&gt; [1,2] &lt;*&gt; [4,5,6]</code>results in a non-deterministic computation <code>x + y</code> where <code>x</code> takes on every value from <code>[1,2]</code> and <code>y</code> takes on every value from <code>[4,5,6]</code>. We represent that as a list which holds all of the possible results. Similarly, when we do <code>sequence [[1,2],[3,4],[5,6],[7,8]]</code>, the result is a non-deterministic computation <code>[x,y,z,w]</code>, where <code>x</code> takes on every value from <code>[1,2]</code>, <code>y</code> takes on every value from <code>[3,4]</code> and so on. To represent the result of that non-deterministic computation, we use a list, where each element in the list is one possible list. That's why the result is a list of lists.</p></div><div><p>When used with I/O actions, <code>sequenceA</code> is the same thing as <code>sequence</code>! It takes a list of I/O actions and returns an I/O action that will perform each of those actions and have as its result a list of the results of those I/O actions. That's because to turn an <code>[IO a]</code> value into an <code>IO [a]</code> value, to make an I/O action that yields a list of results when performed, all those I/O actions have to be sequenced so that they're then performed one after the other when evaluation is forced. You can't get the result of an I/O action without performing it.</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token hvariable">sequenceA</span> <span class="token punctuation">[</span><span class="token builtin">getLine</span><span class="token punctuation">,</span> <span class="token builtin">getLine</span><span class="token punctuation">,</span> <span class="token builtin">getLine</span><span class="token punctuation">]</span>
<span class="token hvariable">heyh</span>
<span class="token hvariable">ho</span>
<span class="token hvariable">woo</span>
<span class="token punctuation">[</span><span class="token string">"heyh"</span><span class="token punctuation">,</span><span class="token string">"ho"</span><span class="token punctuation">,</span><span class="token string">"woo"</span><span class="token punctuation">]</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Like normal functors, applicative functors come with a few laws. The most important one is the one that we already mentioned, namely that <code>pure f &lt;*&gt; x = fmap f x</code> holds. As an exercise, you can prove this law for some of the applicative functors that we've met in this chapter.The other functor laws are:</p></div><div><ul class="has-list-bullet">
<li data-line="0"><div class="list-bullet"></div>pure id &lt;*&gt; v = v</li>
<li data-line="1"><div class="list-bullet"></div>pure (.) &lt;<em>&gt; u &lt;</em>&gt; v &lt;<em>&gt; w = u &lt;</em>&gt; (v &lt;*&gt; w)</li>
<li data-line="2"><div class="list-bullet"></div>pure f &lt;*&gt; pure x = pure (f x)</li>
<li data-line="3"><div class="list-bullet"></div>u &lt;<em>&gt; pure y = pure ($ y) &lt;</em>&gt; u</li>
</ul></div><div><p>We won't go over them in detail right now because that would take up a lot of pages and it would probably be kind of boring, but if you're up to the task, you can take a closer look at them and see if they hold for some of the instances.</p></div><div><p>In conclusion, applicative functors aren't just interesting, they're also useful, because they allow us to combine different computations, such as I/O computations, non-deterministic computations, computations that might have failed, etc. by using the applicative style. Just by using <code>&lt;$&gt;</code> and <code>&lt;*&gt;</code> we can use normal functions to uniformly operate on any number of applicative functors and take advantage of the semantics of each one.</p></div><div><h2 data-heading="The newtype keyword" id="The_newtype_keyword" style="display: flex;"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>The newtype keyword</h2></div><div><p><span alt="LYHfGG_86_maoi.png" src="LYHfGG_86_maoi.png" class="internal-embed media-embed image-embed is-loaded"><img alt="LYHfGG_86_maoi.png" src="курсы\learn-you-a-haskell-for-great-good!\картинки\lyhfgg_86_maoi.png"></span></p></div><div><p>So far, we've learned how to make our own algebraic data types by using the <strong>data</strong> keyword. We've also learned how to give existing types synonyms with the <strong>type</strong> keyword. In this section, we'll be taking a look at how to make new types out of existing data types by using the <strong>newtype</strong> keyword and why we'd want to do that in the first place.</p></div><div><p>In the previous section, we saw that there are actually more ways for the list type to be an applicative functor. One way is to have <code>&lt;*&gt;</code> take every function out of the list that is its left parameter and apply it to every value in the list that is on the right, resulting in every possible combination of applying a function from the left list to a value in the right list.</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token punctuation">[</span><span class="token punctuation">(</span><span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token operator">&lt;*&gt;</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">]</span>
<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">100</span><span class="token punctuation">,</span><span class="token number">200</span><span class="token punctuation">,</span><span class="token number">300</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">10</span><span class="token punctuation">,</span><span class="token number">15</span><span class="token punctuation">]</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>The second way is to take the first function on the left side of <code>&lt;*&gt;</code> and apply it to the first value on the right, then take the second function from the list on the left side and apply it to the second value on the right, and so on. Ultimately, it's kind of like zipping the two lists together. But lists are already an instance of <code>Applicative</code>, so how did we also make lists an instance of <code>Applicative</code> in this second way? If you remember, we said that the <code>ZipList a</code> type was introduced for this reason, which has one value constructor, <code>ZipList</code>, that has just one field. We put the list that we're wrapping in that field. Then, <code>ZipList</code> was made an instance of <code>Applicative</code>, so that when we want to use lists as applicatives in the zipping manner, we just wrap them with the <code>ZipList</code> constructor and then once we're done, unwrap them with <code>getZipList</code>:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token hvariable">getZipList</span> <span class="token operator">$</span> <span class="token constant">ZipList</span> <span class="token punctuation">[</span><span class="token punctuation">(</span><span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token operator">&lt;*&gt;</span> <span class="token constant">ZipList</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">]</span>
<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">200</span><span class="token punctuation">,</span><span class="token number">15</span><span class="token punctuation">]</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>So, what does this have to do with this <em>newtype</em> keyword? Well, think about how we might write the data declaration for our <code>ZipList a</code> type. One way would be to do it like so:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token keyword">data</span> <span class="token constant">ZipList</span> <span class="token hvariable">a</span> <span class="token operator">=</span> <span class="token constant">ZipList</span> <span class="token punctuation">[</span><span class="token hvariable">a</span><span class="token punctuation">]</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>A type that has just one value constructor and that value constructor has just one field that is a list of things. We might also want to use record syntax so that we automatically get a function that extracts a list from a <code>ZipList</code>:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token keyword">data</span> <span class="token constant">ZipList</span> <span class="token hvariable">a</span> <span class="token operator">=</span> <span class="token constant">ZipList</span> <span class="token punctuation">{</span> <span class="token hvariable">getZipList</span> <span class="token operator">::</span> <span class="token punctuation">[</span><span class="token hvariable">a</span><span class="token punctuation">]</span> <span class="token punctuation">}</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>This looks fine and would actually work pretty well. We had two ways of making an existing type an instance of a type class, so we used the <em>data</em> keyword to just wrap that type into another type and made the other type an instance in the second way.</p></div><div><p>The <em>newtype</em> keyword in Haskell is made exactly for these cases when we want to just take one type and wrap it in something to present it as another type. In the actual libraries, <code>ZipList a</code> is defined like this:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token keyword">newtype</span> <span class="token constant">ZipList</span> <span class="token hvariable">a</span> <span class="token operator">=</span> <span class="token constant">ZipList</span> <span class="token punctuation">{</span> <span class="token hvariable">getZipList</span> <span class="token operator">::</span> <span class="token punctuation">[</span><span class="token hvariable">a</span><span class="token punctuation">]</span> <span class="token punctuation">}</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Instead of the <em>data</em> keyword, the <em>newtype</em> keyword is used. Now why is that? Well for one, <em>newtype</em> is faster. If you use the <em>data</em> keyword to wrap a type, there's some overhead to all that wrapping and unwrapping when your program is running. But if you use <em>newtype</em>, Haskell knows that you're just using it to wrap an existing type into a new type (hence the name), because you want it to be the same internally but have a different type. With that in mind, Haskell can get rid of the wrapping and unwrapping once it resolves which value is of what type.</p></div><div><p>So why not just use <em>newtype</em> all the time instead of <em>data</em> then? Well, when you make a new type from an existing type by using the <em>newtype</em> keyword, you can only have one value constructor and that value constructor can only have one field. But with <em>data</em>, you can make data types that have several value constructors and each constructor can have zero or more fields:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token keyword">data</span> <span class="token constant">Profession</span> <span class="token operator">=</span> <span class="token constant">Fighter</span> <span class="token operator">|</span> <span class="token constant">Archer</span> <span class="token operator">|</span> <span class="token constant">Accountant</span>

<span class="token keyword">data</span> <span class="token constant">Race</span> <span class="token operator">=</span> <span class="token constant">Human</span> <span class="token operator">|</span> <span class="token constant">Elf</span> <span class="token operator">|</span> <span class="token constant">Orc</span> <span class="token operator">|</span> <span class="token constant">Goblin</span>

<span class="token keyword">data</span> <span class="token constant">PlayerCharacter</span> <span class="token operator">=</span> <span class="token constant">PlayerCharacter</span> <span class="token constant">Race</span> <span class="token constant">Profession</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>When using <em>newtype</em>, you're restricted to just one constructor with one field.</p></div><div><p>We can also use the <em>deriving</em> keyword with <em>newtype</em> just like we would with <em>data</em>. We can derive instances for <code>Eq</code>, <code>Ord</code>, <code>Enum</code>, <code>Bounded</code>, <code>Show</code> and <code>Read</code>. If we derive the instance for a type class, the type that we're wrapping has to be in that type class to begin with. It makes sense, because <em>newtype</em> just wraps an existing type. So now if we do the following, we can print and equate values of our new type:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token keyword">newtype</span> <span class="token constant">CharList</span> <span class="token operator">=</span> <span class="token constant">CharList</span> <span class="token punctuation">{</span> <span class="token hvariable">getCharList</span> <span class="token operator">::</span> <span class="token punctuation">[</span><span class="token constant">Char</span><span class="token punctuation">]</span> <span class="token punctuation">}</span> <span class="token keyword">deriving</span> <span class="token punctuation">(</span><span class="token constant">Eq</span><span class="token punctuation">,</span> <span class="token constant">Show</span><span class="token punctuation">)</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Let's give that a go:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token constant">CharList</span> <span class="token string">"this will be shown!"</span>
<span class="token constant">CharList</span> <span class="token punctuation">{</span><span class="token hvariable">getCharList</span> <span class="token operator">=</span> <span class="token string">"this will be shown!"</span><span class="token punctuation">}</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token constant">CharList</span> <span class="token string">"benny"</span> <span class="token operator">==</span> <span class="token constant">CharList</span> <span class="token string">"benny"</span>
<span class="token constant">True</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token constant">CharList</span> <span class="token string">"benny"</span> <span class="token operator">==</span> <span class="token constant">CharList</span> <span class="token string">"oisters"</span>
<span class="token constant">False</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>In this particular <em>newtype</em>, the value constructor has the following type:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token constant">CharList</span> <span class="token operator">::</span> <span class="token punctuation">[</span><span class="token constant">Char</span><span class="token punctuation">]</span> <span class="token operator">-&gt;</span> <span class="token constant">CharList</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>It takes a <code>[Char]</code> value, such as <code>"my sharona"</code> and returns a <code>CharList</code> value. From the above examples where we used the <code>CharList</code> value constructor, we see that really is the case. Conversely, the <code>getCharList</code> function, which was generated for us because we used record syntax in our <em>newtype</em>, has this type:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">getCharList</span> <span class="token operator">::</span> <span class="token constant">CharList</span> <span class="token operator">-&gt;</span> <span class="token punctuation">[</span><span class="token constant">Char</span><span class="token punctuation">]</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>It takes a <code>CharList</code> value and converts it to a <code>[Char]</code> value. You can think of this as wrapping and unwrapping, but you can also think of it as converting values from one type to the other.</p></div><div><h3 data-heading="Using newtype to make type class instances" id="Using_newtype_to_make_type_class_instances" style="display: flex;"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>Using newtype to make type class instances</h3></div><div><p>Many times, we want to make our types instances of certain type classes, but the type parameters just don't match up for what we want to do. It's easy to make <code>Maybe</code> an instance of <code>Functor</code>, because the <code>Functor</code> type class is defined like this:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token keyword">class</span> <span class="token constant">Functor</span> <span class="token hvariable">f</span> <span class="token keyword">where</span>
    <span class="token builtin">fmap</span> <span class="token operator">::</span> <span class="token punctuation">(</span><span class="token hvariable">a</span> <span class="token operator">-&gt;</span> <span class="token hvariable">b</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token hvariable">f</span> <span class="token hvariable">a</span> <span class="token operator">-&gt;</span> <span class="token hvariable">f</span> <span class="token hvariable">b</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>So we just start out with:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token keyword">instance</span> <span class="token constant">Functor</span> <span class="token constant">Maybe</span> <span class="token keyword">where</span> 
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>And then implement <code>fmap</code>. All the type parameters add up because the <code>Maybe</code> takes the place of <code>f</code> in the definition of the <code>Functor</code> type class and so if we look at <code>fmap</code> like it only worked on <code>Maybe</code>, it ends up behaving like:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token builtin">fmap</span> <span class="token operator">::</span> <span class="token punctuation">(</span><span class="token hvariable">a</span> <span class="token operator">-&gt;</span> <span class="token hvariable">b</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token constant">Maybe</span> <span class="token hvariable">a</span> <span class="token operator">-&gt;</span> <span class="token constant">Maybe</span> <span class="token hvariable">b</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p><span alt="LYHfGG_87_krakatoa.png" src="LYHfGG_87_krakatoa.png" class="internal-embed media-embed image-embed is-loaded"><img alt="LYHfGG_87_krakatoa.png" src="курсы\learn-you-a-haskell-for-great-good!\картинки\lyhfgg_87_krakatoa.png"></span></p></div><div><p>Isn't that just peachy? Now what if we wanted to make the tuple an instance of <code>Functor</code> in such a way that when we <code>fmap</code> a function over a tuple, it gets applied to the first component of the tuple? That way, doing <code>fmap (+3) (1,1)</code> would result in <code>(4,1)</code>. It turns out that writing the instance for that is kind of hard. With <code>Maybe</code>, we just say <code>instance Functor Maybe where</code> because only type constructors that take exactly one parameter can be made an instance of <code>Functor</code>. But it seems like there's no way to do something like that with <code>(a,b)</code> so that the type parameter <code>a</code> ends up being the one that changes when we use <code>fmap</code>. To get around this, we can <em>newtype</em> our tuple in such a way that the second type parameter represents the type of the first component in the tuple:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token keyword">newtype</span> <span class="token constant">Pair</span> <span class="token hvariable">b</span> <span class="token hvariable">a</span> <span class="token operator">=</span> <span class="token constant">Pair</span> <span class="token punctuation">{</span> <span class="token hvariable">getPair</span> <span class="token operator">::</span> <span class="token punctuation">(</span><span class="token hvariable">a</span><span class="token punctuation">,</span><span class="token hvariable">b</span><span class="token punctuation">)</span> <span class="token punctuation">}</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>And now, we can make it an instance of <code>Functor</code> so that the function is mapped over the first component:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token keyword">instance</span> <span class="token constant">Functor</span> <span class="token punctuation">(</span><span class="token constant">Pair</span> <span class="token hvariable">c</span><span class="token punctuation">)</span> <span class="token keyword">where</span>
    <span class="token builtin">fmap</span> <span class="token hvariable">f</span> <span class="token punctuation">(</span><span class="token constant">Pair</span> <span class="token punctuation">(</span><span class="token hvariable">x</span><span class="token punctuation">,</span><span class="token hvariable">y</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token constant">Pair</span> <span class="token punctuation">(</span><span class="token hvariable">f</span> <span class="token hvariable">x</span><span class="token punctuation">,</span> <span class="token hvariable">y</span><span class="token punctuation">)</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>As you can see, we can pattern match on types defined with <em>newtype</em>. We pattern match to get the underlying tuple, then we apply the function <code>f</code> to the first component in the tuple and then we use the <code>Pair</code> value constructor to convert the tuple back to our <code>Pair b a</code>. If we imagine what the type <code>fmap</code> would be if it only worked on our new pairs, it would be:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token builtin">fmap</span> <span class="token operator">::</span> <span class="token punctuation">(</span><span class="token hvariable">a</span> <span class="token operator">-&gt;</span> <span class="token hvariable">b</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token constant">Pair</span> <span class="token hvariable">c</span> <span class="token hvariable">a</span> <span class="token operator">-&gt;</span> <span class="token constant">Pair</span> <span class="token hvariable">c</span> <span class="token hvariable">b</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Again, we said <code>instance Functor (Pair c) where</code> and so <code>Pair c</code> took the place of the <code>f</code> in the type class definition for <code>Functor</code>:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token keyword">class</span> <span class="token constant">Functor</span> <span class="token hvariable">f</span> <span class="token keyword">where</span>
    <span class="token builtin">fmap</span> <span class="token operator">::</span> <span class="token punctuation">(</span><span class="token hvariable">a</span> <span class="token operator">-&gt;</span> <span class="token hvariable">b</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token hvariable">f</span> <span class="token hvariable">a</span> <span class="token operator">-&gt;</span> <span class="token hvariable">f</span> <span class="token hvariable">b</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>So now, if we convert a tuple into a <code>Pair b a</code>, we can use <code>fmap</code> over it and the function will be mapped over the first component:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token hvariable">getPair</span> <span class="token operator">$</span> <span class="token builtin">fmap</span> <span class="token punctuation">(</span><span class="token operator">*</span><span class="token number">100</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token constant">Pair</span> <span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token punctuation">(</span><span class="token number">200</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">)</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token hvariable">getPair</span> <span class="token operator">$</span> <span class="token builtin">fmap</span> <span class="token builtin">reverse</span> <span class="token punctuation">(</span><span class="token constant">Pair</span> <span class="token punctuation">(</span><span class="token string">"london calling"</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token punctuation">(</span><span class="token string">"gnillac nodnol"</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">)</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><h3 data-heading="On newtype laziness" id="On_newtype_laziness" style="display: flex;"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>On newtype laziness</h3></div><div><p>We mentioned that <em>newtype</em> is usually faster than <em>data</em>. The only thing that can be done with <em>newtype</em> is turning an existing type into a new type, so internally, Haskell can represent the values of types defined with <em>newtype</em> just like the original ones, only it has to keep in mind that the their types are now distinct. This fact means that not only is <em>newtype</em> faster, it's also lazier. Let's take a look at what this means.</p></div><div><p>Like we've said before, Haskell is lazy by default, which means that only when we try to actually print the results of our functions will any computation take place. Furthemore, only those computations that are necessary for our function to tell us the result will get carried out. The <code>undefined</code> value in Haskell represents an erronous computation. If we try to evaluate it (that is, force Haskell to actually compute it) by printing it to the terminal, Haskell will throw a hissy fit (technically referred to as an exception):</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token builtin">undefined</span>
<span class="token operator">***</span> <span class="token constant">Exception</span><span class="token operator">:</span> <span class="token constant">Prelude</span><span class="token punctuation">.</span><span class="token builtin">undefined</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>However, if we make a list that has some <code>undefined</code> values in it but request only the head of the list, which is not <code>undefined</code>, everything will go smoothly because Haskell doesn't really need to evaluate any other elements in a list if we only want to see what the first element is:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token builtin">head</span> <span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token builtin">undefined</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token builtin">undefined</span><span class="token punctuation">]</span>
<span class="token number">3</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Now consider the following type:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token keyword">data</span> <span class="token constant">CoolBool</span> <span class="token operator">=</span> <span class="token constant">CoolBool</span> <span class="token punctuation">{</span> <span class="token hvariable">getCoolBool</span> <span class="token operator">::</span> <span class="token constant">Bool</span> <span class="token punctuation">}</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>It's your run-of-the-mill algebraic data type that was defined with the <em>data</em> keyword. It has one value constructor, which has one field whose type is <code>Bool</code>. Let's make a function that pattern matches on a <code>CoolBool</code> and returns the value <code>"hello"</code> regardless of whether the <code>Bool</code> inside the <code>CoolBool</code> was <code>True</code> or <code>False</code>:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">helloMe</span> <span class="token operator">::</span> <span class="token constant">CoolBool</span> <span class="token operator">-&gt;</span> <span class="token constant">String</span>
<span class="token hvariable">helloMe</span> <span class="token punctuation">(</span><span class="token constant">CoolBool</span> <span class="token hvariable">_</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token string">"hello"</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Instead of applying this function to a normal <code>CoolBool</code>, let's throw it a curveball and apply it to <code>undefined</code>!</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token hvariable">helloMe</span> <span class="token builtin">undefined</span>
"<span class="token operator">***</span> <span class="token constant">Exception</span><span class="token operator">:</span> <span class="token constant">Prelude</span><span class="token punctuation">.</span><span class="token builtin">undefined</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Yikes! An exception! Now why did this exception happen? Types defined with the <em>data</em> keyword can have multiple value constructors (even though <code>CoolBool</code> only has one). So in order to see if the value given to our function conforms to the <code>(CoolBool _)</code> pattern, Haskell has to evaluate the value just enough to see which value constructor was used when we made the value. And when we try to evaluate an <code>undefined</code> value, even a little, an exception is thrown.</p></div><div><p>Instead of using the <em>data</em> keyword for <code>CoolBool</code>, let's try using <em>newtype</em>:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token keyword">newtype</span> <span class="token constant">CoolBool</span> <span class="token operator">=</span> <span class="token constant">CoolBool</span> <span class="token punctuation">{</span> <span class="token hvariable">getCoolBool</span> <span class="token operator">::</span> <span class="token constant">Bool</span> <span class="token punctuation">}</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>We don't have to change our <code>helloMe</code> function, because the pattern matching syntax is the same if you use <em>newtype</em> or <em>data</em> to define your type. Let's do the same thing here and apply <code>helloMe</code> to an <code>undefined</code> value:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token hvariable">helloMe</span> <span class="token builtin">undefined</span>
<span class="token string">"hello"</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p><span alt="LYHfGG_88_shamrock.png" src="LYHfGG_88_shamrock.png" class="internal-embed media-embed image-embed is-loaded"><img alt="LYHfGG_88_shamrock.png" src="курсы\learn-you-a-haskell-for-great-good!\картинки\lyhfgg_88_shamrock.png"></span></p></div><div><p>It worked! Hmmm, why is that? Well, like we've said, when we use <em>newtype</em>, Haskell can internally represent the values of the new type in the same way as the original values. It doesn't have to add another box around them, it just has to be aware of the values being of different types. And because Haskell knows that types made with the <em>newtype</em> keyword can only have one constructor, it doesn't have to evaluate the value passed to the function to make sure that it conforms to the <code>(CoolBool _)</code> pattern because <em>newtype</em> types can only have one possible value constructor and one field!</p></div><div><p>This difference in behavior may seem trivial, but it's actually pretty important because it helps us realize that even though types defined with <em>data</em> and <em>newtype</em> behave similarly from the programmer's point of view because they both have value constructors and fields, they are actually two different mechanisms. Whereas <em>data</em> can be used to make your own types from scratch, <em>newtype</em> is for making a completely new type out of an existing type. Pattern matching on <em>newtype</em> values isn't like taking something out of a box (like it is with <em>data</em>), it's more about making a direct conversion from one type to another.</p></div><div><h3 data-heading="type vs. newtype vs. data" id="type_vs._newtype_vs._data" style="display: flex;"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>type vs. newtype vs. data</h3></div><div><p>At this point, you may be a bit confused about what exactly the difference between <em>type</em>, <em>data</em> and <em>newtype</em> is, so let's refresh our memory a bit.</p></div><div><p>The <strong>type</strong> keyword is for making type synonyms. What that means is that we just give another name to an already existing type so that the type is easier to refer to. Say we did the following:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token keyword">type</span> <span class="token constant">IntList</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token constant">Int</span><span class="token punctuation">]</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>All this does is to allow us to refer to the <code>[Int]</code> type as <code>IntList</code>. They can be used interchangeably. We don't get an <code>IntList</code> value constructor or anything like that. Because <code>[Int]</code> and <code>IntList</code> are only two ways to refer to the same type, it doesn't matter which name we use in our type annotations:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">]</span> <span class="token operator">::</span> <span class="token constant">IntList</span><span class="token punctuation">)</span> <span class="token operator">++</span> <span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">]</span> <span class="token operator">::</span> <span class="token punctuation">[</span><span class="token constant">Int</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">]</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>We use type synonyms when we want to make our type signatures more descriptive by giving types names that tell us something about their purpose in the context of the functions where they're being used. For instance, when we used an association list of type <code>[(String,String)]</code> to represent a phone book, we gave it the type synonym of <code>PhoneBook</code> so that the type signatures of our functions were easier to read.</p></div><div><p>The <strong>newtype</strong> keyword is for taking existing types and wrapping them in new types, mostly so that it's easier to make them instances of certain type classes. When we use <em>newtype</em> to wrap an existing type, the type that we get is separate from the original type. If we make the following <em>newtype</em>:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token keyword">newtype</span> <span class="token constant">CharList</span> <span class="token operator">=</span> <span class="token constant">CharList</span> <span class="token punctuation">{</span> <span class="token hvariable">getCharList</span> <span class="token operator">::</span> <span class="token punctuation">[</span><span class="token constant">Char</span><span class="token punctuation">]</span> <span class="token punctuation">}</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>We can't use <code>++</code> to put together a <code>CharList</code> and a list of type <code>[Char]</code>. We can't even use <code>++</code> to put together two <code>CharList</code>s, because <code>++</code> works only on lists and the <code>CharList</code> type isn't a list, even though it could be said that it contains one. We can, however, convert two <code>CharList</code>s to lists, <code>++</code> them and then convert that back to a <code>CharList</code>.</p></div><div><p>When we use record syntax in our <em>newtype</em> declarations, we get functions for converting between the new type and the original type: namely the value constructor of our <em>newtype</em> and the function for extracting the value in its field. The new type also isn't automatically made an instance of the type classes that the original type belongs to, so we have to derive or manually write them.</p></div><div><p>In practice, you can think of <em>newtype</em> declarations as <em>data</em> declarations that can only have one constructor and one field. If you catch yourself writing such a <em>data</em> declaration, consider using <em>newtype</em>.</p></div><div><p>The <strong>data</strong> keyword is for making your own data types and with them, you can go hog wild. They can have as many constructors and fields as you wish and can be used to implement any algebraic data type by yourself. Everything from lists and <code>Maybe</code>-like types to trees.</p></div><div><p>If you just want your type signatures to look cleaner and be more descriptive, you probably want type synonyms. If you want to take an existing type and wrap it in a new type in order to make it an instance of a type class, chances are you're looking for a <em>newtype</em>. And if you want to make something completely new, odds are good that you're looking for the <em>data</em> keyword.</p></div><div><h2 data-heading="Monoids" id="Monoids" style="display: flex;"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>Monoids</h2></div><div><p><span alt="LYHfGG_89_pirateship.png" src="LYHfGG_89_pirateship.png" class="internal-embed media-embed image-embed is-loaded"><img alt="LYHfGG_89_pirateship.png" src="курсы\learn-you-a-haskell-for-great-good!\картинки\lyhfgg_89_pirateship.png"></span></p></div><div><p>Type classes in Haskell are used to present an interface for types that have some behavior in common. We started out with simple type classes like <code>Eq</code>, which is for types whose values can be equated, and <code>Ord</code>, which is for things that can be put in an order and then moved on to more interesting ones, like <code>Functor</code> and <code>Applicative</code>.</p></div><div><p>When we make a type, we think about which behaviors it supports, i.e. what it can act like and then based on that we decide which type classes to make it an instance of. If it makes sense for values of our type to be equated, we make it an instance of the <code>Eq</code> type class. If we see that our type is some kind of functor, we make it an instance of <code>Functor</code>, and so on.</p></div><div><p>Now consider the following: <code>*</code> is a function that takes two numbers and multiplies them. If we multiply some number with a <code>1</code>, the result is always equal to that number. It doesn't matter if we do <code>1 * x</code> or <code>x * 1</code>, the result is always <code>x</code>. Similarly, <code>++</code> is also a function which takes two things and returns a third. Only instead of multiplying numbers, it takes two lists and concatenates them. And much like <code>*</code>, it also has a certain value which doesn't change the other one when used with <code>++</code>. That value is the empty list: <code>[]</code>.</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token number">4</span> <span class="token operator">*</span> <span class="token number">1</span>
<span class="token number">4</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token number">1</span> <span class="token operator">*</span> <span class="token number">9</span>
<span class="token number">9</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">]</span> <span class="token operator">++</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">]</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">++</span> <span class="token punctuation">[</span><span class="token number">0.5</span><span class="token punctuation">,</span> <span class="token number">2.5</span><span class="token punctuation">]</span>
<span class="token punctuation">[</span><span class="token number">0.5</span><span class="token punctuation">,</span><span class="token number">2.5</span><span class="token punctuation">]</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>It seems that both <code>*</code> together with <code>1</code> and <code>++</code> along with <code>[]</code> share some common properties:</p></div><div><ul class="has-list-bullet">
<li data-line="0"><div class="list-bullet"></div>The function takes two parameters.</li>
<li data-line="1"><div class="list-bullet"></div>The parameters and the returned value have the same type.</li>
<li data-line="2"><div class="list-bullet"></div>There exists such a value that doesn't change other values when used with the binary function.</li>
</ul></div><div><p>There's another thing that these two operations have in common that may not be as obvious as our previous observations: when we have three or more values and we want to use the binary function to reduce them to a single result, the order in which we apply the binary function to the values doesn't matter. It doesn't matter if we do <code>(3 * 4) * 5</code> or <code>3 * (4 * 5)</code>. Either way, the result is <code>60</code>. The same goes for <code>++</code>:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token punctuation">(</span><span class="token number">3</span> <span class="token operator">*</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token punctuation">(</span><span class="token number">8</span> <span class="token operator">*</span> <span class="token number">5</span><span class="token punctuation">)</span>
<span class="token number">240</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token number">3</span> <span class="token operator">*</span> <span class="token punctuation">(</span><span class="token number">2</span> <span class="token operator">*</span> <span class="token punctuation">(</span><span class="token number">8</span> <span class="token operator">*</span> <span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token number">240</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token string">"la"</span> <span class="token operator">++</span> <span class="token punctuation">(</span><span class="token string">"di"</span> <span class="token operator">++</span> <span class="token string">"da"</span><span class="token punctuation">)</span>
<span class="token string">"ladida"</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token punctuation">(</span><span class="token string">"la"</span> <span class="token operator">++</span> <span class="token string">"di"</span><span class="token punctuation">)</span> <span class="token operator">++</span> <span class="token string">"da"</span>
<span class="token string">"ladida"</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>We call this property <em>associativity</em>. <code>*</code> is associative, and so is <code>++</code>, but <code>-</code>, for example, is not. The expressions <code>(5 - 3) - 4</code> and <code>5 - (3 - 4)</code> result in different numbers.</p></div><div><p>By noticing and writing down these properties, we have chanced upon <em>monoids</em>! A monoid is when you have an associative binary function and a value which acts as an identity with respect to that function. When something acts as an identity with respect to a function, it means that when called with that function and some other value, the result is always equal to that other value. <code>1</code> is the identity with respect to <code>*</code> and <code>[]</code> is the identity with respect to <code>++</code>. There are a lot of other monoids to be found in the world of Haskell, which is why the <code>Monoid</code> type class exists. It's for types which can act like monoids. Let's see how the type class is defined:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token keyword">class</span> <span class="token constant">Monoid</span> <span class="token hvariable">m</span> <span class="token keyword">where</span>
    <span class="token hvariable">mempty</span> <span class="token operator">::</span> <span class="token hvariable">m</span>
    <span class="token hvariable">mappend</span> <span class="token operator">::</span> <span class="token hvariable">m</span> <span class="token operator">-&gt;</span> <span class="token hvariable">m</span> <span class="token operator">-&gt;</span> <span class="token hvariable">m</span>
    <span class="token hvariable">mconcat</span> <span class="token operator">::</span> <span class="token punctuation">[</span><span class="token hvariable">m</span><span class="token punctuation">]</span> <span class="token operator">-&gt;</span> <span class="token hvariable">m</span>
    <span class="token hvariable">mconcat</span> <span class="token operator">=</span> <span class="token builtin">foldr</span> <span class="token hvariable">mappend</span> <span class="token hvariable">mempty</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p><span alt="LYHfGG_90_balloondog.png" src="LYHfGG_90_balloondog.png" class="internal-embed media-embed image-embed is-loaded"><img alt="LYHfGG_90_balloondog.png" src="курсы\learn-you-a-haskell-for-great-good!\картинки\lyhfgg_90_balloondog.png"></span></p></div><div><p>The <code>Monoid</code> type class is defined in <code>import Data.Monoid</code>. Let's take some time and get properly acquainted with it.</p></div><div><p>First of all, we see that only concrete types can be made instances of <code>Monoid</code>, because the <code>m</code> in the type class definition doesn't take any type parameters. This is different from <code>Functor</code> and <code>Applicative</code>, which require their instances to be type constructors which take one parameter.</p></div><div><p>The first function is <code>mempty</code>. It's not really a function, since it doesn't take parameters, so it's a polymorphic constant, kind of like <code>minBound</code> from <code>Bounded</code>. <code>mempty</code> represents the identity value for a particular monoid.</p></div><div><p>Next up, we have <code>mappend</code>, which, as you've probably guessed, is the binary function. It takes two values of the same type and returns a value of that type as well. It's worth noting that the decision to name <code>mappend</code> as it's named was kind of unfortunate, because it implies that we're appending two things in some way. While <code>++</code> does take two lists and append one to the other, <code>*</code> doesn't really do any appending, it just multiplies two numbers together. When we meet other instances of <code>Monoid</code>, we'll see that most of them don't append values either, so avoid thinking in terms of appending and just think in terms of <code>mappend</code> being a binary function that takes two monoid values and returns a third.</p></div><div><p>The last function in this type class definition is <code>mconcat</code>. It takes a list of monoid values and reduces them to a single value by doing <code>mappend</code> between the list's elements. It has a default implementation, which just takes <code>mempty</code> as a starting value and folds the list from the right with <code>mappend</code>. Because the default implementation is fine for most instances, we won't concern ourselves with <code>mconcat</code> too much from now on. When making a type an instance of <code>Monoid</code>, it suffices to just implement <code>mempty</code> and <code>mappend</code>. The reason <code>mconcat</code> is there at all is because for some instances, there might be a more efficient way to implement <code>mconcat</code>, but for most instances the default implementation is just fine.</p></div><div><p>Before moving on to specific instances of <code>Monoid</code>, let's take a brief look at the monoid laws. We mentioned that there has to be a value that acts as the identity with respect to the binary function and that the binary function has to be associative. It's possible to make instances of <code>Monoid</code> that don't follow these rules, but such instances are of no use to anyone because when using the <code>Monoid</code> type class, we rely on its instances acting like monoids. Otherwise, what's the point? That's why when making instances, we have to make sure they follow these laws:</p></div><div><ul class="has-list-bullet">
<li data-line="0"><div class="list-bullet"></div><mark>mempty `mappend` x = x</mark></li>
<li data-line="1"><div class="list-bullet"></div><mark>x `mappend` mempty = x</mark></li>
<li data-line="2"><div class="list-bullet"></div><mark>(x `mappend` y) `mappend` z = x `mappend` (y `mappend` z)</mark></li>
</ul></div><div><p>The first two state that <code>mempty</code> has to act as the identity with respect to <code>mappend</code> and the third says that <code>mappend</code> has to be associative i.e. that it the order in which we use <code>mappend</code> to reduce several monoid values into one doesn't matter. Haskell doesn't enforce these laws, so we as the programmer have to be careful that our instances do indeed obey them.</p></div><div><h3 data-heading="Lists are monoids" id="Lists_are_monoids" style="display: flex;"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>Lists are monoids</h3></div><div><p>Yes, lists are monoids! Like we've seen, the <code>++</code> function and the empty list <code>[]</code> form a monoid. The instance is very simple:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token keyword">instance</span> <span class="token constant">Monoid</span> <span class="token punctuation">[</span><span class="token hvariable">a</span><span class="token punctuation">]</span> <span class="token keyword">where</span>
    <span class="token hvariable">mempty</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
    <span class="token hvariable">mappend</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token operator">++</span><span class="token punctuation">)</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Lists are an instance of the <code>Monoid</code> type class regardless of the type of the elements they hold. Notice that we wrote <code>instance Monoid [a]</code> and not <code>instance Monoid []</code>, because <code>Monoid</code> requires a concrete type for an instance.</p></div><div><p>Giving this a test run, we encounter no surprises:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">]</span> <span class="token operator">`mappend`</span> <span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">]</span>
<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">]</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token punctuation">(</span><span class="token string">"one"</span> <span class="token operator">`mappend`</span> <span class="token string">"two"</span><span class="token punctuation">)</span> <span class="token operator">`mappend`</span> <span class="token string">"tree"</span>
<span class="token string">"onetwotree"</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token string">"one"</span> <span class="token operator">`mappend`</span> <span class="token punctuation">(</span><span class="token string">"two"</span> <span class="token operator">`mappend`</span> <span class="token string">"tree"</span><span class="token punctuation">)</span>
<span class="token string">"onetwotree"</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token string">"one"</span> <span class="token operator">`mappend`</span> <span class="token string">"two"</span> <span class="token operator">`mappend`</span> <span class="token string">"tree"</span>
<span class="token string">"onetwotree"</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token string">"pang"</span> <span class="token operator">`mappend`</span> <span class="token hvariable">mempty</span>
<span class="token string">"pang"</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token hvariable">mconcat</span> <span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token number">9</span><span class="token punctuation">]</span><span class="token punctuation">]</span>
<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">,</span><span class="token number">9</span><span class="token punctuation">]</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token hvariable">mempty</span> <span class="token operator">::</span> <span class="token punctuation">[</span><span class="token hvariable">a</span><span class="token punctuation">]</span>
<span class="token punctuation">[</span><span class="token punctuation">]</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p><span alt="LYHfGG_91_smug.png" src="LYHfGG_91_smug.png" class="internal-embed media-embed image-embed is-loaded"><img alt="LYHfGG_91_smug.png" src="курсы\learn-you-a-haskell-for-great-good!\картинки\lyhfgg_91_smug.png"></span></p></div><div><p>Notice that in the last line, we had to write an explicit type annotation, because if we just did <code>mempty</code>, GHCi wouldn't know which instance to use, so we had to say we want the list instance. We were able to use the general type of <code>[a]</code> (as opposed to specifying <code>[Int]</code> or <code>[String]</code>) because the empty list can act as if it contains any type.</p></div><div><p>Because <code>mconcat</code> has a default implementation, we get it for free when we make something an instance of <code>Monoid</code>. In the case of the list, <code>mconcat</code> turns out to be just <code>concat</code>. It takes a list of lists and flattens it, because that's the equivalent of doing <code>++</code> between all the adjecent lists in a list.</p></div><div><p>The monoid laws do indeed hold for the list instance. When we have several lists and we <code>mappend</code> (or <code>++</code>) them together, it doesn't matter which ones we do first, because they're just joined at the ends anyway. Also, the empty list acts as the identity so all is well. Notice that monoids don't require that <code>a `mappend` b</code> be equal to <code>b `mappend` a</code>. In the case of the list, they clearly aren't:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token string">"one"</span> <span class="token operator">`mappend`</span> <span class="token string">"two"</span>
<span class="token string">"onetwo"</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token string">"two"</span> <span class="token operator">`mappend`</span> <span class="token string">"one"</span>
<span class="token string">"twoone"</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>And that's okay. The fact that for multiplication <code>3 * 5</code> and <code>5 * 3</code> are the same is just a property of multiplication, but it doesn't hold for all (and indeed, most) monoids.</p></div><div><h3 data-heading="Product and Sum" id="Product_and_Sum" style="display: flex;"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>Product and Sum</h3></div><div><p>We already examined one way for numbers to be considered monoids. Just have the binary function be <code>*</code> and the identity value <code>1</code>. It turns out that that's not the only way for numbers to be monoids. Another way is to have the binary function be <code>+</code> and the identity value <code>0</code>:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token number">0</span> <span class="token operator">+</span> <span class="token number">4</span>
<span class="token number">4</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token number">5</span> <span class="token operator">+</span> <span class="token number">0</span>
<span class="token number">5</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token punctuation">(</span><span class="token number">1</span> <span class="token operator">+</span> <span class="token number">3</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">5</span>
<span class="token number">9</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token number">1</span> <span class="token operator">+</span> <span class="token punctuation">(</span><span class="token number">3</span> <span class="token operator">+</span> <span class="token number">5</span><span class="token punctuation">)</span>
<span class="token number">9</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>The monoid laws hold, because if you add 0 to any number, the result is that number. And addition is also associative, so we get no problems there. So now that there are two equally valid ways for numbers to be monoids, which way do choose? Well, we don't have to. Remember, when there are several ways for some type to be an instance of the same type class, we can wrap that type in a <em>newtype</em> and then make the new type an instance of the type class in a different way. We can have our cake and eat it too.</p></div><div><p>The <code>Data.Monoid</code> module exports two types for this, namely <code>Product</code> and <code>Sum</code>. <code>Product</code> is defined like this:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token keyword">newtype</span> <span class="token constant">Product</span> <span class="token hvariable">a</span> <span class="token operator">=</span>  <span class="token constant">Product</span> <span class="token punctuation">{</span> <span class="token hvariable">getProduct</span> <span class="token operator">::</span> <span class="token hvariable">a</span> <span class="token punctuation">}</span>
    <span class="token keyword">deriving</span> <span class="token punctuation">(</span><span class="token constant">Eq</span><span class="token punctuation">,</span> <span class="token constant">Ord</span><span class="token punctuation">,</span> <span class="token constant">Read</span><span class="token punctuation">,</span> <span class="token constant">Show</span><span class="token punctuation">,</span> <span class="token constant">Bounded</span><span class="token punctuation">)</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Simple, just a <em>newtype</em> wrapper with one type parameter along with some derived instances. Its instance for <code>Monoid</code> goes a little something like this:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token keyword">instance</span> <span class="token constant">Num</span> <span class="token hvariable">a</span> <span class="token operator">=&gt;</span> <span class="token constant">Monoid</span> <span class="token punctuation">(</span><span class="token constant">Product</span> <span class="token hvariable">a</span><span class="token punctuation">)</span> <span class="token keyword">where</span>
    <span class="token hvariable">mempty</span> <span class="token operator">=</span> <span class="token constant">Product</span> <span class="token number">1</span>
    <span class="token constant">Product</span> <span class="token hvariable">x</span> <span class="token operator">`mappend`</span> <span class="token constant">Product</span> <span class="token hvariable">y</span> <span class="token operator">=</span> <span class="token constant">Product</span> <span class="token punctuation">(</span><span class="token hvariable">x</span> <span class="token operator">*</span> <span class="token hvariable">y</span><span class="token punctuation">)</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p><code>mempty</code> is just <code>1</code> wrapped in a <code>Product</code> constructor. <code>mappend</code> pattern matches on the <code>Product</code> constructor, multiplies the two numbers and then wraps the resulting number back. As you can see, there's a <code>Num a</code> class constraint. So this means that <code>Product a</code> is an instance of <code>Monoid</code> for all <code>a</code>'s that are already an instance of <code>Num</code>. To use <code>Producta a</code> as a monoid, we have to do some <em>newtype</em> wrapping and unwrapping:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token hvariable">getProduct</span> <span class="token operator">$</span> <span class="token constant">Product</span> <span class="token number">3</span> <span class="token operator">`mappend`</span> <span class="token constant">Product</span> <span class="token number">9</span>
<span class="token number">27</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token hvariable">getProduct</span> <span class="token operator">$</span> <span class="token constant">Product</span> <span class="token number">3</span> <span class="token operator">`mappend`</span> <span class="token hvariable">mempty</span>
<span class="token number">3</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token hvariable">getProduct</span> <span class="token operator">$</span> <span class="token constant">Product</span> <span class="token number">3</span> <span class="token operator">`mappend`</span> <span class="token constant">Product</span> <span class="token number">4</span> <span class="token operator">`mappend`</span> <span class="token constant">Product</span> <span class="token number">2</span>
<span class="token number">24</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token hvariable">getProduct</span> <span class="token operator">.</span> <span class="token hvariable">mconcat</span> <span class="token operator">.</span> <span class="token builtin">map</span> <span class="token constant">Product</span> <span class="token operator">$</span> <span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">]</span>
<span class="token number">24</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>This is nice as a showcase of the <code>Monoid</code> type class, but no one in their right mind would use this way of multiplying numbers instead of just writing <code>3 * 9</code> and <code>3 * 1</code>. But a bit later, we'll see how these <code>Monoid</code> instances that may seem trivial at this time can come in handy.</p></div><div><p><code>Sum</code> is defined like <code>Product</code> and the instance is similar as well. We use it in the same way:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token hvariable">getSum</span> <span class="token operator">$</span> <span class="token constant">Sum</span> <span class="token number">2</span> <span class="token operator">`mappend`</span> <span class="token constant">Sum</span> <span class="token number">9</span>
<span class="token number">11</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token hvariable">getSum</span> <span class="token operator">$</span> <span class="token hvariable">mempty</span> <span class="token operator">`mappend`</span> <span class="token constant">Sum</span> <span class="token number">3</span>
<span class="token number">3</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token hvariable">getSum</span> <span class="token operator">.</span> <span class="token hvariable">mconcat</span> <span class="token operator">.</span> <span class="token builtin">map</span> <span class="token constant">Sum</span> <span class="token operator">$</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">]</span>
<span class="token number">6</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><h3 data-heading="Any and All" id="Any_and_All" style="display: flex;"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>Any and All</h3></div><div><p>Another type which can act like a monoid in two distinct but equally valid ways is <code>Bool</code>. The first way is to have the <em>or</em> function <code>||</code> act as the binary function along with <code>False</code> as the identity value. The way <em>or</em> works in logic is that if any of its two parameters is <code>True</code>, it returns <code>True</code>, otherwise it returns <code>False</code>. So if we use <code>False</code> as the identity value, it will return <code>False</code> when <em>or</em>-ed with <code>False</code> and <code>True</code> when <em>or</em>-ed with <code>True</code>. The <code>Any</code> <em>newtype</em> constructor is an instance of <code>Monoid</code> in this fashion. It's defined like this:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token keyword">newtype</span> <span class="token constant">Any</span> <span class="token operator">=</span> <span class="token constant">Any</span> <span class="token punctuation">{</span> <span class="token hvariable">getAny</span> <span class="token operator">::</span> <span class="token constant">Bool</span> <span class="token punctuation">}</span>
    <span class="token keyword">deriving</span> <span class="token punctuation">(</span><span class="token constant">Eq</span><span class="token punctuation">,</span> <span class="token constant">Ord</span><span class="token punctuation">,</span> <span class="token constant">Read</span><span class="token punctuation">,</span> <span class="token constant">Show</span><span class="token punctuation">,</span> <span class="token constant">Bounded</span><span class="token punctuation">)</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Its instance looks goes like so:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token keyword">instance</span> <span class="token constant">Monoid</span> <span class="token constant">Any</span> <span class="token keyword">where</span>
        <span class="token hvariable">mempty</span> <span class="token operator">=</span> <span class="token constant">Any</span> <span class="token constant">False</span>
        <span class="token constant">Any</span> <span class="token hvariable">x</span> <span class="token operator">`mappend`</span> <span class="token constant">Any</span> <span class="token hvariable">y</span> <span class="token operator">=</span> <span class="token constant">Any</span> <span class="token punctuation">(</span><span class="token hvariable">x</span> <span class="token operator">||</span> <span class="token hvariable">y</span><span class="token punctuation">)</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>The reason it's called <code>Any</code> is because <code>x `mappend` y</code> will be <code>True</code> if <em>any</em> one of those two is <code>True</code>. Even if three or more <code>Any</code> wrapped <code>Bool</code>s are <code>mappend</code>ed together, the result will hold <code>True</code> if any of them are <code>True</code>:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token hvariable">getAny</span> <span class="token operator">$</span> <span class="token constant">Any</span> <span class="token constant">True</span> <span class="token operator">`mappend`</span> <span class="token constant">Any</span> <span class="token constant">False</span>
<span class="token constant">True</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token hvariable">getAny</span> <span class="token operator">$</span> <span class="token hvariable">mempty</span> <span class="token operator">`mappend`</span> <span class="token constant">Any</span> <span class="token constant">True</span>
<span class="token constant">True</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token hvariable">getAny</span> <span class="token operator">.</span> <span class="token hvariable">mconcat</span> <span class="token operator">.</span> <span class="token builtin">map</span> <span class="token constant">Any</span> <span class="token operator">$</span> <span class="token punctuation">[</span><span class="token constant">False</span><span class="token punctuation">,</span> <span class="token constant">False</span><span class="token punctuation">,</span> <span class="token constant">False</span><span class="token punctuation">,</span> <span class="token constant">True</span><span class="token punctuation">]</span>
<span class="token constant">True</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token hvariable">getAny</span> <span class="token operator">$</span> <span class="token hvariable">mempty</span> <span class="token operator">`mappend`</span> <span class="token hvariable">mempty</span>
<span class="token constant">False</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>The other way for <code>Bool</code> to be an instance of <code>Monoid</code> is to kind of do the opposite: have <code>&amp;&amp;</code> be the binary function and then make <code>True</code> the identity value. Logical <em>and</em> will return <code>True</code> only if both of its parameters are <code>True</code>. This is the <em>newtype</em> declaration, nothing fancy:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token keyword">newtype</span> <span class="token constant">All</span> <span class="token operator">=</span> <span class="token constant">All</span> <span class="token punctuation">{</span> <span class="token hvariable">getAll</span> <span class="token operator">::</span> <span class="token constant">Bool</span> <span class="token punctuation">}</span>
        <span class="token keyword">deriving</span> <span class="token punctuation">(</span><span class="token constant">Eq</span><span class="token punctuation">,</span> <span class="token constant">Ord</span><span class="token punctuation">,</span> <span class="token constant">Read</span><span class="token punctuation">,</span> <span class="token constant">Show</span><span class="token punctuation">,</span> <span class="token constant">Bounded</span><span class="token punctuation">)</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>And this is the instance:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token keyword">instance</span> <span class="token constant">Monoid</span> <span class="token constant">All</span> <span class="token keyword">where</span>
        <span class="token hvariable">mempty</span> <span class="token operator">=</span> <span class="token constant">All</span> <span class="token constant">True</span>
        <span class="token constant">All</span> <span class="token hvariable">x</span> <span class="token operator">`mappend`</span> <span class="token constant">All</span> <span class="token hvariable">y</span> <span class="token operator">=</span> <span class="token constant">All</span> <span class="token punctuation">(</span><span class="token hvariable">x</span> <span class="token operator">&amp;&amp;</span> <span class="token hvariable">y</span><span class="token punctuation">)</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>When we <code>mappend</code> values of the <code>All</code> type, the result will be <code>True</code> only if <em>all</em> the values used in the <code>mappend</code> operations are <code>True</code>:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token hvariable">getAll</span> <span class="token operator">$</span> <span class="token hvariable">mempty</span> <span class="token operator">`mappend`</span> <span class="token constant">All</span> <span class="token constant">True</span>
<span class="token constant">True</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token hvariable">getAll</span> <span class="token operator">$</span> <span class="token hvariable">mempty</span> <span class="token operator">`mappend`</span> <span class="token constant">All</span> <span class="token constant">False</span>
<span class="token constant">False</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token hvariable">getAll</span> <span class="token operator">.</span> <span class="token hvariable">mconcat</span> <span class="token operator">.</span> <span class="token builtin">map</span> <span class="token constant">All</span> <span class="token operator">$</span> <span class="token punctuation">[</span><span class="token constant">True</span><span class="token punctuation">,</span> <span class="token constant">True</span><span class="token punctuation">,</span> <span class="token constant">True</span><span class="token punctuation">]</span>
<span class="token constant">True</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token hvariable">getAll</span> <span class="token operator">.</span> <span class="token hvariable">mconcat</span> <span class="token operator">.</span> <span class="token builtin">map</span> <span class="token constant">All</span> <span class="token operator">$</span> <span class="token punctuation">[</span><span class="token constant">True</span><span class="token punctuation">,</span> <span class="token constant">True</span><span class="token punctuation">,</span> <span class="token constant">False</span><span class="token punctuation">]</span>
<span class="token constant">False</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Just like with multiplication and addition, we usually explicitly state the binary functions instead of wrapping them in _newtype_s and then using <code>mappend</code> and <code>mempty</code>. <code>mconcat</code> seems useful for <code>Any</code> and <code>All</code>, but usually it's easier to use the <code>or</code> and <code>and</code> functions, which take lists of <code>Bool</code>s and return <code>True</code> if any of them are <code>True</code> or if all of them are <code>True</code>, respectively.</p></div><div><h3 data-heading="The Ordering monoid" id="The_Ordering_monoid" style="display: flex;"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>The Ordering monoid</h3></div><div><p>Hey, remember the <code>Ordering</code> type? It's used as the result when comparing things and it can have three values: <code>LT</code>, <code>EQ</code> and <code>GT</code>, which stand for <em>less than</em>, <em>equal</em> and <em>greater than</em> respectively:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token number">1</span> <span class="token operator">`compare`</span> <span class="token number">2</span>
<span class="token constant">LT</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token number">2</span> <span class="token operator">`compare`</span> <span class="token number">2</span>
<span class="token constant">EQ</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token number">3</span> <span class="token operator">`compare`</span> <span class="token number">2</span>
<span class="token constant">GT</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>With lists, numbers and boolean values, finding monoids was just a matter of looking at already existing commonly used functions and seeing if they exhibit some sort of monoid behavior. With <code>Ordering</code>, we have to look a bit harder to recognize a monoid, but it turns out that its <code>Monoid</code> instance is just as intuitive as the ones we've met so far and also quite useful:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token keyword">instance</span> <span class="token constant">Monoid</span> <span class="token constant">Ordering</span> <span class="token keyword">where</span>
    <span class="token hvariable">mempty</span> <span class="token operator">=</span> <span class="token constant">EQ</span>
    <span class="token constant">LT</span> <span class="token operator">`mappend`</span> <span class="token hvariable">_</span> <span class="token operator">=</span> <span class="token constant">LT</span>
    <span class="token constant">EQ</span> <span class="token operator">`mappend`</span> <span class="token hvariable">y</span> <span class="token operator">=</span> <span class="token hvariable">y</span>
    <span class="token constant">GT</span> <span class="token operator">`mappend`</span> <span class="token hvariable">_</span> <span class="token operator">=</span> <span class="token constant">GT</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p><span alt="LYHfGG_92_bear.png" src="LYHfGG_92_bear.png" class="internal-embed media-embed image-embed is-loaded"><img alt="LYHfGG_92_bear.png" src="курсы\learn-you-a-haskell-for-great-good!\картинки\lyhfgg_92_bear.png"></span></p></div><div><p>The instance is set up like this: when we <code>mappend</code> two <code>Ordering</code> values, the one on the left is kept, unless the value on the left is <code>EQ</code>, in which case the right one is the result. The identity is <code>EQ</code>. At first, this may seem kind of arbitrary, but it actually resembles the way we alphabetically compare words. We compare the first two letters and if they differ, we can already decide which word would go first in a dictionary. However, if the first two letters are equal, then we move on to comparing the next pair of letters and repeat the process.</p></div><div><p>For instance, if we were to alphabetically compare the words <code>"ox"</code> and <code>"on"</code>, we'd first compare the first two letters of each word, see that they are equal and then move on to comparing the second letter of each word. We see that <code>'x'</code> is alphabetically greater than <code>'n'</code>, and so we know how the words compare. To gain some intuition for <code>EQ</code> being the identity, we can notice that if we were to cram the same letter in the same position in both words, it wouldn't change their alphabetical ordering. <code>"oix"</code> is still alphabetically greater than and <code>"oin"</code>.</p></div><div><p>It's important to note that in the <code>Monoid</code> instance for <code>Ordering</code>, <code>x `mappend` y</code> doesn't equal <code>y `mappend` x</code>. Because the first parameter is kept unless it's <code>EQ</code>, <code>LT `mappend` GT</code> will result in <code>LT</code>, whereas <code>GT `mappend` LT</code> will result in <code>GT</code>:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token constant">LT</span> <span class="token operator">`mappend`</span> <span class="token constant">GT</span>
<span class="token constant">LT</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token constant">GT</span> <span class="token operator">`mappend`</span> <span class="token constant">LT</span>
<span class="token constant">GT</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token hvariable">mempty</span> <span class="token operator">`mappend`</span> <span class="token constant">LT</span>
<span class="token constant">LT</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token hvariable">mempty</span> <span class="token operator">`mappend`</span> <span class="token constant">GT</span>
<span class="token constant">GT</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>OK, so how is this monoid useful? Let's say you were writing a function that takes two strings, compares their lengths, and returns an <code>Ordering</code>. But if the strings are of the same length, then instead of returning <code>EQ</code> right away, we want to compare them alphabetically. One way to write this would be like so:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">lengthCompare</span> <span class="token operator">::</span> <span class="token constant">String</span> <span class="token operator">-&gt;</span> <span class="token constant">String</span> <span class="token operator">-&gt;</span> <span class="token constant">Ordering</span>
<span class="token hvariable">lengthCompare</span> <span class="token hvariable">x</span> <span class="token hvariable">y</span> <span class="token operator">=</span> <span class="token keyword">let</span> <span class="token hvariable">a</span> <span class="token operator">=</span> <span class="token builtin">length</span> <span class="token hvariable">x</span> <span class="token operator">`compare`</span> <span class="token builtin">length</span> <span class="token hvariable">y</span> 
                        <span class="token hvariable">b</span> <span class="token operator">=</span> <span class="token hvariable">x</span> <span class="token operator">`compare`</span> <span class="token hvariable">y</span>
                    <span class="token keyword">in</span>  <span class="token keyword">if</span> <span class="token hvariable">a</span> <span class="token operator">==</span> <span class="token constant">EQ</span> <span class="token keyword">then</span> <span class="token hvariable">b</span> <span class="token keyword">else</span> <span class="token hvariable">a</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>We name the result of comparing the lengths <code>a</code> and the result of the alphabetical comparison <code>b</code> and then if it turns out that the lengths were equal, we return their alphabetical ordering.</p></div><div><p>But by employing our understanding of how <code>Ordering</code> is a monoid, we can rewrite this function in a much simpler manner:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token import-statement"><span class="token keyword">import</span> Data<span class="token punctuation">.</span>Monoid</span>

<span class="token hvariable">lengthCompare</span> <span class="token operator">::</span> <span class="token constant">String</span> <span class="token operator">-&gt;</span> <span class="token constant">String</span> <span class="token operator">-&gt;</span> <span class="token constant">Ordering</span>
<span class="token hvariable">lengthCompare</span> <span class="token hvariable">x</span> <span class="token hvariable">y</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token builtin">length</span> <span class="token hvariable">x</span> <span class="token operator">`compare`</span> <span class="token builtin">length</span> <span class="token hvariable">y</span><span class="token punctuation">)</span> <span class="token operator">`mappend`</span>
                    <span class="token punctuation">(</span><span class="token hvariable">x</span> <span class="token operator">`compare`</span> <span class="token hvariable">y</span><span class="token punctuation">)</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>We can try this out:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token hvariable">lengthCompare</span> <span class="token string">"zen"</span> <span class="token string">"ants"</span>
<span class="token constant">LT</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token hvariable">lengthCompare</span> <span class="token string">"zen"</span> <span class="token string">"ant"</span>
<span class="token constant">GT</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Remember, when we use <code>mappend</code>, its left parameter is always kept unless it's <code>EQ</code>, in which case the right one is kept. That's why we put the comparison that we consider to be the first, more important criterion as the first parameter. If we wanted to expand this function to also compare for the number of vowels and set this to be the second most important criterion for comparison, we'd just modify it like this:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token import-statement"><span class="token keyword">import</span> Data<span class="token punctuation">.</span>Monoid</span>

<span class="token hvariable">lengthCompare</span> <span class="token operator">::</span> <span class="token constant">String</span> <span class="token operator">-&gt;</span> <span class="token constant">String</span> <span class="token operator">-&gt;</span> <span class="token constant">Ordering</span>
<span class="token hvariable">lengthCompare</span> <span class="token hvariable">x</span> <span class="token hvariable">y</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token builtin">length</span> <span class="token hvariable">x</span> <span class="token operator">`compare`</span> <span class="token builtin">length</span> <span class="token hvariable">y</span><span class="token punctuation">)</span> <span class="token operator">`mappend`</span>
                    <span class="token punctuation">(</span><span class="token hvariable">vowels</span> <span class="token hvariable">x</span> <span class="token operator">`compare`</span> <span class="token hvariable">vowels</span> <span class="token hvariable">y</span><span class="token punctuation">)</span> <span class="token operator">`mappend`</span>
                    <span class="token punctuation">(</span><span class="token hvariable">x</span> <span class="token operator">`compare`</span> <span class="token hvariable">y</span><span class="token punctuation">)</span>
    <span class="token keyword">where</span> <span class="token hvariable">vowels</span> <span class="token operator">=</span> <span class="token builtin">length</span> <span class="token operator">.</span> <span class="token builtin">filter</span> <span class="token punctuation">(</span><span class="token operator">`elem`</span> <span class="token string">"aeiou"</span><span class="token punctuation">)</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>We made a helper function, which takes a string and tells us how many vowels it has by first filtering it only for letters that are in the string <code>"aeiou"</code> and then applying <code>length</code> to that.</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token hvariable">lengthCompare</span> <span class="token string">"zen"</span> <span class="token string">"anna"</span>
<span class="token constant">LT</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token hvariable">lengthCompare</span> <span class="token string">"zen"</span> <span class="token string">"ana"</span>
<span class="token constant">LT</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token hvariable">lengthCompare</span> <span class="token string">"zen"</span> <span class="token string">"ann"</span>
<span class="token constant">GT</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Very cool. Here, we see how in the first example the lengths are found to be different and so <code>LT</code> is returned, because the length of <code>"zen"</code> is less than the length of <code>"anna"</code>. In the second example, the lengths are the same, but the second string has more vowels, so <code>LT</code> is returned again. In the third example, they both have the same length and the same number of vowels, so they're compared alphabetically and <code>"zen"</code> wins.</p></div><div><p>The <code>Ordering</code> monoid is very cool because it allows us to easily compare things by many different criteria and put those criteria in an order themselves, ranging from the most important to the least.</p></div><div><h3 data-heading="Maybe the monoid" id="Maybe_the_monoid" style="display: flex;"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>Maybe the monoid</h3></div><div><p>Let's take a look at the various ways that <code>Maybe a</code> can be made an instance of <code>Monoid</code> and what those instances are useful for.</p></div><div><p>One way is to treat <code>Maybe a</code> as a monoid only if its type parameter <code>a</code> is a monoid as well and then implement <code>mappend</code> in such a way that it uses the <code>mappend</code> operation of the values that are wrapped with <code>Just</code>. We use <code>Nothing</code> as the identity, and so if one of the two values that we're <code>mappend</code>ing is <code>Nothing</code>, we keep the other value. Here's the instance declaration:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token keyword">instance</span> <span class="token constant">Monoid</span> <span class="token hvariable">a</span> <span class="token operator">=&gt;</span> <span class="token constant">Monoid</span> <span class="token punctuation">(</span><span class="token constant">Maybe</span> <span class="token hvariable">a</span><span class="token punctuation">)</span> <span class="token keyword">where</span>
    <span class="token hvariable">mempty</span> <span class="token operator">=</span> <span class="token constant">Nothing</span>
    <span class="token constant">Nothing</span> <span class="token operator">`mappend`</span> <span class="token hvariable">m</span> <span class="token operator">=</span> <span class="token hvariable">m</span>
    <span class="token hvariable">m</span> <span class="token operator">`mappend`</span> <span class="token constant">Nothing</span> <span class="token operator">=</span> <span class="token hvariable">m</span>
    <span class="token constant">Just</span> <span class="token hvariable">m1</span> <span class="token operator">`mappend`</span> <span class="token constant">Just</span> <span class="token hvariable">m2</span> <span class="token operator">=</span> <span class="token constant">Just</span> <span class="token punctuation">(</span><span class="token hvariable">m1</span> <span class="token operator">`mappend`</span> <span class="token hvariable">m2</span><span class="token punctuation">)</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Notice the class constraint. It says that <code>Maybe a</code> is an instance of <code>Monoid</code> only if <code>a</code> is an instance of <code>Monoid</code>. If we <code>mappend</code> something with a <code>Nothing</code>, the result is that something. If we <code>mappend</code> two <code>Just</code> values, the contents of the <code>Just</code>s get <code>mappended</code> and then wrapped back in a <code>Just</code>. We can do this because the class constraint ensures that the type of what's inside the <code>Just</code> is an instance of <code>Monoid</code>.</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token constant">Nothing</span> <span class="token operator">`mappend`</span> <span class="token constant">Just</span> <span class="token string">"andy"</span>
<span class="token constant">Just</span> <span class="token string">"andy"</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token constant">Just</span> <span class="token constant">LT</span> <span class="token operator">`mappend`</span> <span class="token constant">Nothing</span>
<span class="token constant">Just</span> <span class="token constant">LT</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token constant">Just</span> <span class="token punctuation">(</span><span class="token constant">Sum</span> <span class="token number">3</span><span class="token punctuation">)</span> <span class="token operator">`mappend`</span> <span class="token constant">Just</span> <span class="token punctuation">(</span><span class="token constant">Sum</span> <span class="token number">4</span><span class="token punctuation">)</span>
<span class="token constant">Just</span> <span class="token punctuation">(</span><span class="token constant">Sum</span> <span class="token punctuation">{</span><span class="token hvariable">getSum</span> <span class="token operator">=</span> <span class="token number">7</span><span class="token punctuation">}</span><span class="token punctuation">)</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>This comes in use when you're dealing with monoids as results of computations that may have failed. Because of this instance, we don't have to check if the computations have failed by seeing if they're a <code>Nothing</code> or <code>Just</code> value; we can just continue to treat them as normal monoids.</p></div><div><p>But what if the type of the contents of the <code>Maybe</code> aren't an instance of <code>Monoid</code>? Notice that in the previous instance declaration, the only case where we have to rely on the contents being monoids is when both parameters of <code>mappend</code> are <code>Just</code> values. But if we don't know if the contents are monoids, we can't use <code>mappend</code> between them, so what are we to do? Well, one thing we can do is to just discard the second value and keep the first one. For this, the <code>First a</code> type exists and this is its definition:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token keyword">newtype</span> <span class="token constant">First</span> <span class="token hvariable">a</span> <span class="token operator">=</span> <span class="token constant">First</span> <span class="token punctuation">{</span> <span class="token hvariable">getFirst</span> <span class="token operator">::</span> <span class="token constant">Maybe</span> <span class="token hvariable">a</span> <span class="token punctuation">}</span>
    <span class="token keyword">deriving</span> <span class="token punctuation">(</span><span class="token constant">Eq</span><span class="token punctuation">,</span> <span class="token constant">Ord</span><span class="token punctuation">,</span> <span class="token constant">Read</span><span class="token punctuation">,</span> <span class="token constant">Show</span><span class="token punctuation">)</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>We take a <code>Maybe a</code> and we wrap it with a <em>newtype</em>. The <code>Monoid</code> instance is as follows:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token keyword">instance</span> <span class="token constant">Monoid</span> <span class="token punctuation">(</span><span class="token constant">First</span> <span class="token hvariable">a</span><span class="token punctuation">)</span> <span class="token keyword">where</span>
    <span class="token hvariable">mempty</span> <span class="token operator">=</span> <span class="token constant">First</span> <span class="token constant">Nothing</span>
    <span class="token constant">First</span> <span class="token punctuation">(</span><span class="token constant">Just</span> <span class="token hvariable">x</span><span class="token punctuation">)</span> <span class="token operator">`mappend`</span> <span class="token hvariable">_</span> <span class="token operator">=</span> <span class="token constant">First</span> <span class="token punctuation">(</span><span class="token constant">Just</span> <span class="token hvariable">x</span><span class="token punctuation">)</span>
    <span class="token constant">First</span> <span class="token constant">Nothing</span> <span class="token operator">`mappend`</span> <span class="token hvariable">x</span> <span class="token operator">=</span> <span class="token hvariable">x</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Just like we said. <code>mempty</code> is just a <code>Nothing</code> wrapped with the <code>First</code> <em>newtype</em> constructor. If <code>mappend</code>'s first parameter is a <code>Just</code> value, we ignore the second one. If the first one is a <code>Nothing</code>, then we present the second parameter as a result, regardless of whether it's a <code>Just</code> or a <code>Nothing</code>:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token hvariable">getFirst</span> <span class="token operator">$</span> <span class="token constant">First</span> <span class="token punctuation">(</span><span class="token constant">Just</span> <span class="token char string">'a'</span><span class="token punctuation">)</span> <span class="token operator">`mappend`</span> <span class="token constant">First</span> <span class="token punctuation">(</span><span class="token constant">Just</span> <span class="token char string">'b'</span><span class="token punctuation">)</span>
<span class="token constant">Just</span> <span class="token char string">'a'</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token hvariable">getFirst</span> <span class="token operator">$</span> <span class="token constant">First</span> <span class="token constant">Nothing</span> <span class="token operator">`mappend`</span> <span class="token constant">First</span> <span class="token punctuation">(</span><span class="token constant">Just</span> <span class="token char string">'b'</span><span class="token punctuation">)</span>
<span class="token constant">Just</span> <span class="token char string">'b'</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token hvariable">getFirst</span> <span class="token operator">$</span> <span class="token constant">First</span> <span class="token punctuation">(</span><span class="token constant">Just</span> <span class="token char string">'a'</span><span class="token punctuation">)</span> <span class="token operator">`mappend`</span> <span class="token constant">First</span> <span class="token constant">Nothing</span>
<span class="token constant">Just</span> <span class="token char string">'a'</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p><code>First</code> is useful when we have a bunch of <code>Maybe</code> values and we just want to know if any of them is a <code>Just</code>. The <code>mconcat</code> function comes in handy:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token hvariable">getFirst</span> <span class="token operator">.</span> <span class="token hvariable">mconcat</span> <span class="token operator">.</span> <span class="token builtin">map</span> <span class="token constant">First</span> <span class="token operator">$</span> <span class="token punctuation">[</span><span class="token constant">Nothing</span><span class="token punctuation">,</span> <span class="token constant">Just</span> <span class="token number">9</span><span class="token punctuation">,</span> <span class="token constant">Just</span> <span class="token number">10</span><span class="token punctuation">]</span>
<span class="token constant">Just</span> <span class="token number">9</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>If we want a monoid on <code>Maybe a</code> such that the second parameter is kept if both parameters of <code>mappend</code> are <code>Just</code> values, <code>Data.Monoid</code> provides a the <code>Last a</code> type, which works like <code>First a</code>, only the last non-<code>Nothing</code> value is kept when <code>mappend</code>ing and using <code>mconcat</code>:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token hvariable">getLast</span> <span class="token operator">.</span> <span class="token hvariable">mconcat</span> <span class="token operator">.</span> <span class="token builtin">map</span> <span class="token constant">Last</span> <span class="token operator">$</span> <span class="token punctuation">[</span><span class="token constant">Nothing</span><span class="token punctuation">,</span> <span class="token constant">Just</span> <span class="token number">9</span><span class="token punctuation">,</span> <span class="token constant">Just</span> <span class="token number">10</span><span class="token punctuation">]</span>
<span class="token constant">Just</span> <span class="token number">10</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token hvariable">getLast</span> <span class="token operator">$</span> <span class="token constant">Last</span> <span class="token punctuation">(</span><span class="token constant">Just</span> <span class="token string">"one"</span><span class="token punctuation">)</span> <span class="token operator">`mappend`</span> <span class="token constant">Last</span> <span class="token punctuation">(</span><span class="token constant">Just</span> <span class="token string">"two"</span><span class="token punctuation">)</span>
<span class="token constant">Just</span> <span class="token string">"two"</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><h3 data-heading="Using monoids to fold data structures" id="Using_monoids_to_fold_data_structures" style="display: flex;"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>Using monoids to fold data structures</h3></div><div><p>One of the more interesting ways to put monoids to work is to make them help us define folds over various data structures. So far, we've only done folds over lists, but lists aren't the only data structure that can be folded over. We can define folds over almost any data structure. Trees especially lend themselves well to folding.</p></div><div><p>Because there are so many data structures that work nicely with folds, the <code>Foldable</code> type class was introduced. Much like <code>Functor</code> is for things that can be mapped over, <code>Foldable</code> is for things that can be folded up! It can be found in <code>Data.Foldable</code> and because it export functions whose names clash with the ones from the <code>Prelude</code>, it's best imported qualified (and served with basil):</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token import-statement"><span class="token keyword">import</span> <span class="token keyword">qualified</span> Foldable <span class="token keyword">as</span> F</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>To save ourselves precious keystrokes, we've chosen to import it qualified as <code>F</code>. Alright, so what are some of the functions that this type class defines? Well, among them are <code>foldr</code>, <code>foldl</code>, <code>foldr1</code> and <code>foldl1</code>. Huh? But we already know these functions, what's so new about this? Let's compare the types of <code>Foldable</code>'s <code>foldr</code> and the <code>foldr</code> from the <code>Prelude</code> to see how they differ:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token operator">:</span><span class="token hvariable">t</span> <span class="token builtin">foldr</span>
<span class="token builtin">foldr</span> <span class="token operator">::</span> <span class="token punctuation">(</span><span class="token hvariable">a</span> <span class="token operator">-&gt;</span> <span class="token hvariable">b</span> <span class="token operator">-&gt;</span> <span class="token hvariable">b</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token hvariable">b</span> <span class="token operator">-&gt;</span> <span class="token punctuation">[</span><span class="token hvariable">a</span><span class="token punctuation">]</span> <span class="token operator">-&gt;</span> <span class="token hvariable">b</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token operator">:</span><span class="token hvariable">t</span> <span class="token constant">F</span><span class="token punctuation">.</span><span class="token builtin">foldr</span>
<span class="token constant">F</span><span class="token punctuation">.</span><span class="token builtin">foldr</span> <span class="token operator">::</span> <span class="token punctuation">(</span><span class="token constant">F<span class="token punctuation">.</span>Foldable</span> <span class="token hvariable">t</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">(</span><span class="token hvariable">a</span> <span class="token operator">-&gt;</span> <span class="token hvariable">b</span> <span class="token operator">-&gt;</span> <span class="token hvariable">b</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token hvariable">b</span> <span class="token operator">-&gt;</span> <span class="token hvariable">t</span> <span class="token hvariable">a</span> <span class="token operator">-&gt;</span> <span class="token hvariable">b</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Ah! So whereas <code>foldr</code> takes a list and folds it up, the <code>foldr</code> from <code>Data.Foldable</code> accepts any type that can be folded up, not just lists! As expected, both <code>foldr</code> functions do the same for lists:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token builtin">foldr</span> <span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">)</span> <span class="token number">1</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">]</span>
<span class="token number">6</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token constant">F</span><span class="token punctuation">.</span><span class="token builtin">foldr</span> <span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">)</span> <span class="token number">1</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">]</span>
<span class="token number">6</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Okay then, what are some other data structures that support folds? Well, there's the <code>Maybe</code> we all know and love!</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token constant">F</span><span class="token punctuation">.</span><span class="token builtin">foldl</span> <span class="token punctuation">(</span><span class="token operator">+</span><span class="token punctuation">)</span> <span class="token number">2</span> <span class="token punctuation">(</span><span class="token constant">Just</span> <span class="token number">9</span><span class="token punctuation">)</span>
<span class="token number">11</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token constant">F</span><span class="token punctuation">.</span><span class="token builtin">foldr</span> <span class="token punctuation">(</span><span class="token operator">||</span><span class="token punctuation">)</span> <span class="token constant">False</span> <span class="token punctuation">(</span><span class="token constant">Just</span> <span class="token constant">True</span><span class="token punctuation">)</span>
<span class="token constant">True</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>But folding over a <code>Maybe</code> value isn't terribly interesting, because when it comes to folding, it just acts like a list with one element if it's a <code>Just</code> value and as an empty list if it's <code>Nothing</code>. So let's examine a data structure that's a little more complex then.</p></div><div><p>Remember the tree data structure from the <a data-tooltip-position="top" aria-label="http://learnyouahaskell.com/making-our-own-types-and-typeclasses#recursive-data-structures" rel="noopener" class="external-link" href="http://learnyouahaskell.com/making-our-own-types-and-typeclasses#recursive-data-structures" target="_blank">Making Our Own Types and Typeclasses</a> chapter? We defined it like this:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token keyword">data</span> <span class="token constant">Tree</span> <span class="token hvariable">a</span> <span class="token operator">=</span> <span class="token constant">Empty</span> <span class="token operator">|</span> <span class="token constant">Node</span> <span class="token hvariable">a</span> <span class="token punctuation">(</span><span class="token constant">Tree</span> <span class="token hvariable">a</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token constant">Tree</span> <span class="token hvariable">a</span><span class="token punctuation">)</span> <span class="token keyword">deriving</span> <span class="token punctuation">(</span><span class="token constant">Show</span><span class="token punctuation">,</span> <span class="token constant">Read</span><span class="token punctuation">,</span> <span class="token constant">Eq</span><span class="token punctuation">)</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>We said that a tree is either an empty tree that doesn't hold any values or it's a node that holds one value and also two other trees. After defining it, we made it an instance of <code>Functor</code> and with that we gained the ability to <code>fmap</code> functions over it. Now, we're going to make it an instance of <code>Foldable</code> so that we get the abilty to fold it up. One way to make a type constructor an instance of <code>Foldable</code> is to just directly implement <code>foldr</code> for it. But another, often much easier way, is to implement the <code>foldMap</code> function, which is also a part of the <code>Foldable</code> type class. The <code>foldMap</code> function has the following type:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">foldMap</span> <span class="token operator">::</span> <span class="token punctuation">(</span><span class="token constant">Monoid</span> <span class="token hvariable">m</span><span class="token punctuation">,</span> <span class="token constant">Foldable</span> <span class="token hvariable">t</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">(</span><span class="token hvariable">a</span> <span class="token operator">-&gt;</span> <span class="token hvariable">m</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token hvariable">t</span> <span class="token hvariable">a</span> <span class="token operator">-&gt;</span> <span class="token hvariable">m</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Its first parameter is a function that takes a value of the type that our foldable structure contains (denoted here with <code>a</code>) and returns a monoid value. Its second parameter is a foldable structure that contains values of type <code>a</code>. It maps that function over the foldable structure, thus producing a foldable structure that contains monoid values. Then, by doing <code>mappend</code> between those monoid values, it joins them all into a single monoid value. This function may sound kind of odd at the moment, but we'll see that it's very easy to implement. What's also cool is that implementing this function is all it takes for our type to be made an instance of <code>Foldable</code>. So if we just implement <code>foldMap</code> for some type, we get <code>foldr</code> and <code>foldl</code> on that type for free!</p></div><div><p>This is how we make <code>Tree</code> an instance of <code>Foldable</code>:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token keyword">instance</span> <span class="token constant">F<span class="token punctuation">.</span>Foldable</span> <span class="token constant">Tree</span> <span class="token keyword">where</span>
    <span class="token hvariable">foldMap</span> <span class="token hvariable">f</span> <span class="token constant">Empty</span> <span class="token operator">=</span> <span class="token hvariable">mempty</span>
    <span class="token hvariable">foldMap</span> <span class="token hvariable">f</span> <span class="token punctuation">(</span><span class="token constant">Node</span> <span class="token hvariable">x</span> <span class="token hvariable">l</span> <span class="token hvariable">r</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token hvariable">F<span class="token punctuation">.</span>foldMap</span> <span class="token hvariable">f</span> <span class="token hvariable">l</span> <span class="token operator">`mappend`</span>
                             <span class="token hvariable">f</span> <span class="token hvariable">x</span>           <span class="token operator">`mappend`</span>
                             <span class="token hvariable">F<span class="token punctuation">.</span>foldMap</span> <span class="token hvariable">f</span> <span class="token hvariable">r</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p><span alt="LYHfGG_93_accordion.png" src="LYHfGG_93_accordion.png" class="internal-embed media-embed image-embed is-loaded"><img alt="LYHfGG_93_accordion.png" src="курсы\learn-you-a-haskell-for-great-good!\картинки\lyhfgg_93_accordion.png"></span></p></div><div><p>We think like this: if we are provided with a function that takes an element of our tree and returns a monoid value, how do we reduce our whole tree down to one single monoid value? When we were doing <code>fmap</code> over our tree, we applied the function that we were mapping to a node and then we recursively mapped the function over the left sub-tree as well as the right one. Here, we're tasked with not only mapping a function, but with also joining up the results into a single monoid value by using <code>mappend</code>. First we consider the case of the empty tree — a sad and lonely tree that has no values or sub-trees. It doesn't hold any value that we can give to our monoid-making function, so we just say that if our tree is empty, the monoid value it becomes is <code>mempty</code>.</p></div><div><p>The case of a non-empty node is a bit more interesting. It contains two sub-trees as well as a value. In this case, we recursively <code>foldMap</code> the same function <code>f</code> over the left and the right sub-trees. Remember, our <code>foldMap</code> results in a single monoid value. We also apply our function <code>f</code> to the value in the node. Now we have three monoid values (two from our sub-trees and one from applying <code>f</code> to the value in the node) and we just have to bang them together into a single value. For this purpose we use <code>mappend</code>, and naturally the left sub-tree comes first, then the node value and then the right sub-tree.</p></div><div><p>Notice that we didn't have to provide the function that takes a value and returns a monoid value. We receive that function as a parameter to <code>foldMap</code> and all we have to decide is where to apply that function and how to join up the resulting monoids from it.</p></div><div><p>Now that we have a <code>Foldable</code> instance for our tree type, we get <code>foldr</code> and <code>foldl</code> for free! Consider this tree:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">testTree</span> <span class="token operator">=</span> <span class="token constant">Node</span> <span class="token number">5</span>
            <span class="token punctuation">(</span><span class="token constant">Node</span> <span class="token number">3</span>
                <span class="token punctuation">(</span><span class="token constant">Node</span> <span class="token number">1</span> <span class="token constant">Empty</span> <span class="token constant">Empty</span><span class="token punctuation">)</span>
                <span class="token punctuation">(</span><span class="token constant">Node</span> <span class="token number">6</span> <span class="token constant">Empty</span> <span class="token constant">Empty</span><span class="token punctuation">)</span>
            <span class="token punctuation">)</span>
            <span class="token punctuation">(</span><span class="token constant">Node</span> <span class="token number">9</span>
                <span class="token punctuation">(</span><span class="token constant">Node</span> <span class="token number">8</span> <span class="token constant">Empty</span> <span class="token constant">Empty</span><span class="token punctuation">)</span>
                <span class="token punctuation">(</span><span class="token constant">Node</span> <span class="token number">10</span> <span class="token constant">Empty</span> <span class="token constant">Empty</span><span class="token punctuation">)</span>
            <span class="token punctuation">)</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>It has <code>5</code> at its root and then its left node is has <code>3</code> with <code>1</code> on the left and <code>6</code> on the right. The root's right node has a <code>9</code> and then an <code>8</code> to its left and a <code>10</code> on the far right side. With a <code>Foldable</code> instance, we can do all of the folds that we can do on lists:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token constant">F</span><span class="token punctuation">.</span><span class="token builtin">foldl</span> <span class="token punctuation">(</span><span class="token operator">+</span><span class="token punctuation">)</span> <span class="token number">0</span> <span class="token hvariable">testTree</span>
<span class="token number">42</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token constant">F</span><span class="token punctuation">.</span><span class="token builtin">foldl</span> <span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">)</span> <span class="token number">1</span> <span class="token hvariable">testTree</span>
<span class="token number">64800</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>And also, <code>foldMap</code> isn't only useful for making new instances of <code>Foldable</code>; it comes in handy for reducing our structure to a single monoid value. For instance, if we want to know if any number in our tree is equal to <code>3</code>, we can do this:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token hvariable">getAny</span> <span class="token operator">$</span> <span class="token hvariable">F<span class="token punctuation">.</span>foldMap</span> <span class="token punctuation">(</span><span class="token operator">\</span><span class="token hvariable">x</span> <span class="token operator">-&gt;</span> <span class="token constant">Any</span> <span class="token operator">$</span> <span class="token hvariable">x</span> <span class="token operator">==</span> <span class="token number">3</span><span class="token punctuation">)</span> <span class="token hvariable">testTree</span>
<span class="token constant">True</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Here, <code>\x -&gt; Any $ x == 3</code> is a function that takes a number and returns a monoid value, namely a <code>Bool</code> wrapped in <code>Any</code>. <code>foldMap</code> applies this function to every element in our tree and then reduces the resulting monoids into a single monoid with <code>mappend</code>. If we do this:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token hvariable">getAny</span> <span class="token operator">$</span> <span class="token hvariable">F<span class="token punctuation">.</span>foldMap</span> <span class="token punctuation">(</span><span class="token operator">\</span><span class="token hvariable">x</span> <span class="token operator">-&gt;</span> <span class="token constant">Any</span> <span class="token operator">$</span> <span class="token hvariable">x</span> <span class="token operator">&gt;</span> <span class="token number">15</span><span class="token punctuation">)</span> <span class="token hvariable">testTree</span>
<span class="token constant">False</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>All of the nodes in our tree would hold the value <code>Any False</code> after having the function in the lambda applied to them. But to end up <code>True</code>, <code>mappend</code> for <code>Any</code> has to have at least one <code>True</code> value as a parameter. That's why the final result is <code>False</code>, which makes sense because no value in our tree is greater than <code>15</code>.</p></div><div><p>We can also easily turn our tree into a list by doing a <code>foldMap</code> with the <code>\x -&gt; [x]</code> function. By first projecting that function onto our tree, each element becomes a singleton list. The <code>mappend</code> action that takes place between all those singleton list results in a single list that holds all of the elements that are in our tree:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token hvariable">F<span class="token punctuation">.</span>foldMap</span> <span class="token punctuation">(</span><span class="token operator">\</span><span class="token hvariable">x</span> <span class="token operator">-&gt;</span> <span class="token punctuation">[</span><span class="token hvariable">x</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token hvariable">testTree</span>
<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">8</span><span class="token punctuation">,</span><span class="token number">9</span><span class="token punctuation">,</span><span class="token number">10</span><span class="token punctuation">]</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>What's cool is that all of these trick aren't limited to trees, they work on any instance of <code>Foldable</code>.</p></div><div><h1 data-heading="A Fistful of Monads" id="A_Fistful_of_Monads">A Fistful of Monads</h1></div><div><p>When we first talked about functors, we saw that they were a useful concept for values that can be mapped over. Then, we took that concept one step further by introducing applicative functors, which allow us to view values of certain data types as values with contexts and use normal functions on those values while preserving the meaning of those contexts.</p></div><div><p>In this chapter, we'll learn about monads, which are just beefed up applicative functors, much like applicative functors are only beefed up functors.</p></div><div><p><span alt="LYHfGG_94_smugpig.png" src="LYHfGG_94_smugpig.png" class="internal-embed media-embed image-embed is-loaded"><img alt="LYHfGG_94_smugpig.png" src="курсы\learn-you-a-haskell-for-great-good!\картинки\lyhfgg_94_smugpig.png"></span></p></div><div><p>When we started off with functors, we saw that it's possible to map functions over various data types. We saw that for this purpose, the <code>Functor</code> type class was introduced and it had us asking the question: when we have a function of type <code>a -&gt; b</code> and some data type <code>f a</code>, how do we map that function over the data type to end up with <code>f b</code>? We saw how to map something over a <code>Maybe a</code>, a list <code>[a]</code>, an <code>IO a</code> etc. We even saw how to map a function <code>a -&gt; b</code> over other functions of type <code>r -&gt; a</code> to get functions of type <code>r -&gt; b</code>. To answer this question of how to map a function over some data type, all we had to do was look at the type of <code>fmap</code>:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token builtin">fmap</span> <span class="token operator">::</span> <span class="token punctuation">(</span><span class="token constant">Functor</span> <span class="token hvariable">f</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">(</span><span class="token hvariable">a</span> <span class="token operator">-&gt;</span> <span class="token hvariable">b</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token hvariable">f</span> <span class="token hvariable">a</span> <span class="token operator">-&gt;</span> <span class="token hvariable">f</span> <span class="token hvariable">b</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>And then make it work for our data type by writing the appropriate <code>Functor</code> instance.</p></div><div><p>Then we saw a possible improvement of functors and said, hey, what if that function <code>a -&gt; b</code> is already wrapped inside a functor value? Like, what if we have <code>Just (*3)</code>, how do we apply that to <code>Just 5</code>? What if we don't want to apply it to <code>Just 5</code> but to a <code>Nothing</code> instead? Or if we have <code>[(*2),(+4)]</code>, how would we apply that to <code>[1,2,3]</code>? How would that work even? For this, the <code>Applicative</code> type class was introduced, in which we wanted the answer to the following type:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token punctuation">(</span><span class="token operator">&lt;*&gt;</span><span class="token punctuation">)</span> <span class="token operator">::</span> <span class="token punctuation">(</span><span class="token constant">Applicative</span> <span class="token hvariable">f</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token hvariable">f</span> <span class="token punctuation">(</span><span class="token hvariable">a</span> <span class="token operator">-&gt;</span> <span class="token hvariable">b</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token hvariable">f</span> <span class="token hvariable">a</span> <span class="token operator">-&gt;</span> <span class="token hvariable">f</span> <span class="token hvariable">b</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>We also saw that we can take a normal value and wrap it inside a data type. For instance, we can take a <code>1</code> and wrap it so that it becomes a <code>Just 1</code>. Or we can make it into a <code>[1]</code>. Or an I/O action that does nothing and just yields <code>1</code>. The function that does this is called <code>pure</code>.</p></div><div><p>Like we said, an applicative value can be seen as a value with an added context. A <em>fancy</em> value, to put it in technical terms. For instance, the character <code>'a'</code> is just a normal character, whereas <code>Just 'a'</code> has some added context. Instead of a <code>Char</code>, we have a <code>Maybe Char</code>, which tells us that its value might be a character, but it could also be an absence of a character.</p></div><div><p>It was neat to see how the <code>Applicative</code> type class allowed us to use normal functions on these values with context and how that context was preserved. Observe:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">)</span> <span class="token operator">&lt;$&gt;</span> <span class="token constant">Just</span> <span class="token number">2</span> <span class="token operator">&lt;*&gt;</span> <span class="token constant">Just</span> <span class="token number">8</span>
<span class="token constant">Just</span> <span class="token number">16</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token punctuation">(</span><span class="token operator">++</span><span class="token punctuation">)</span> <span class="token operator">&lt;$&gt;</span> <span class="token constant">Just</span> <span class="token string">"klingon"</span> <span class="token operator">&lt;*&gt;</span> <span class="token constant">Nothing</span>
<span class="token constant">Nothing</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token punctuation">(</span><span class="token operator">-</span><span class="token punctuation">)</span> <span class="token operator">&lt;$&gt;</span> <span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">]</span> <span class="token operator">&lt;*&gt;</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">]</span>
<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">]</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Ah, cool, so now that we treat them as applicative values, <code>Maybe a</code> values represent computations that might have failed, <code>[a]</code> values represent computations that have several results (non-deterministic computations), <code>IO a</code> values represent values that have side-effects, etc.</p></div><div><p>Monads are a natural extension of applicative functors and with them we're concerned with this: if you have a value with a context, <code>m a</code>, how do you apply to it a function that takes a normal <code>a</code> and returns a value with a context? That is, how do you apply a function of type <code>a -&gt; m b</code> to a value of type <code>m a</code>? So essentially, we will want this function:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token punctuation">(</span><span class="token operator">&gt;&gt;=</span><span class="token punctuation">)</span> <span class="token operator">::</span> <span class="token punctuation">(</span><span class="token constant">Monad</span> <span class="token hvariable">m</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token hvariable">m</span> <span class="token hvariable">a</span> <span class="token operator">-&gt;</span> <span class="token punctuation">(</span><span class="token hvariable">a</span> <span class="token operator">-&gt;</span> <span class="token hvariable">m</span> <span class="token hvariable">b</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token hvariable">m</span> <span class="token hvariable">b</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p><strong>If we have a fancy value and a function that takes a normal value but returns a fancy value, how do we feed that fancy value into the function?</strong> This is the main question that we will concern ourselves when dealing with monads. We write <code>m a</code> instead of <code>f a</code> because the <code>m</code> stands for <code>Monad</code>, but monads are just applicative functors that support <code>&gt;&gt;=</code>. The <code>&gt;&gt;=</code> function is pronounced as <em>bind</em>.</p></div><div><p>When we have a normal value <code>a</code> and a normal function <code>a -&gt; b</code> it's really easy to feed the value to the function — you just apply the function to the value normally and that's it. But when we're dealing with values that come with certain contexts, it takes a bit of thinking to see how these fancy values are fed to functions and how to take into account their behavior, but you'll see that it's easy as one two three.</p></div><div><h2 data-heading="Getting our feet wet with Maybe" id="Getting_our_feet_wet_with_Maybe" style="display: flex;"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>Getting our feet wet with Maybe</h2></div><div><p><span alt="LYHfGG_95_buddha.png" src="LYHfGG_95_buddha.png" class="internal-embed media-embed image-embed is-loaded"><img alt="LYHfGG_95_buddha.png" src="курсы\learn-you-a-haskell-for-great-good!\картинки\lyhfgg_95_buddha.png"></span></p></div><div><p>Now that we have a vague idea of what monads are about, let's see if we can make that idea a bit less vague.</p></div><div><p>Much to no one's surprise, <code>Maybe</code> is a monad, so let's explore it a bit more and see if we can combine it with what we know about monads.</p></div><div><blockquote>
<p>Make sure you understand <a data-tooltip-position="top" aria-label="http://learnyouahaskell.com/functors-applicative-functors-and-monoids#applicative-functors" rel="noopener" class="external-link" href="http://learnyouahaskell.com/functors-applicative-functors-and-monoids#applicative-functors" target="_blank">applicatives</a> at this point. It's good if you have a feel for how the various <code>Applicative</code> instances work and what kind of computations they represent, because monads are nothing more than taking our existing applicative knowledge and upgrading it.</p>
</blockquote></div><div><p>A value of type <code>Maybe a</code> represents a value of type <code>a</code> with the context of possible failure attached. A value of <code>Just "dharma"</code> means that the string <code>"dharma"</code> is there whereas a value of <code>Nothing</code> represents its absence, or if you look at the string as the result of a computation, it means that the computation has failed.</p></div><div><p>When we looked at <code>Maybe</code> as a functor, we saw that if we want to <code>fmap</code> a function over it, it gets mapped over the insides if it's a <code>Just</code> value, otherwise the <code>Nothing</code> is kept because there's nothing to map it over!</p></div><div><p>Like this:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token builtin">fmap</span> <span class="token punctuation">(</span><span class="token operator">++</span><span class="token string">"!"</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token constant">Just</span> <span class="token string">"wisdom"</span><span class="token punctuation">)</span>
<span class="token constant">Just</span> <span class="token string">"wisdom!"</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token builtin">fmap</span> <span class="token punctuation">(</span><span class="token operator">++</span><span class="token string">"!"</span><span class="token punctuation">)</span> <span class="token constant">Nothing</span>
<span class="token constant">Nothing</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>As an applicative functor, it functions similarly. However, applicatives also have the function wrapped. <code>Maybe</code> is an applicative functor in such a way that when we use <code>&lt;*&gt;</code> to apply a function inside a <code>Maybe</code> to a value that's inside a <code>Maybe</code>, they both have to be <code>Just</code> values for the result to be a <code>Just</code> value, otherwise the result is <code>Nothing</code>. It makes sense because if you're missing either the function or the thing you're applying it to, you can't make something up out of thin air, so you have to propagate the failure:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token constant">Just</span> <span class="token punctuation">(</span><span class="token operator">+</span><span class="token number">3</span><span class="token punctuation">)</span> <span class="token operator">&lt;*&gt;</span> <span class="token constant">Just</span> <span class="token number">3</span>
<span class="token constant">Just</span> <span class="token number">6</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token constant">Nothing</span> <span class="token operator">&lt;*&gt;</span> <span class="token constant">Just</span> <span class="token string">"greed"</span>
<span class="token constant">Nothing</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token constant">Just</span> <span class="token builtin">ord</span> <span class="token operator">&lt;*&gt;</span> <span class="token constant">Nothing</span>
<span class="token constant">Nothing</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>When we use the applicative style to have normal functions act on <code>Maybe</code> values, it's similar. All the values have to be <code>Just</code> values, otherwise it's all for <code>Nothing</code>!</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token builtin">max</span> <span class="token operator">&lt;$&gt;</span> <span class="token constant">Just</span> <span class="token number">3</span> <span class="token operator">&lt;*&gt;</span> <span class="token constant">Just</span> <span class="token number">6</span>
<span class="token constant">Just</span> <span class="token number">6</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token builtin">max</span> <span class="token operator">&lt;$&gt;</span> <span class="token constant">Just</span> <span class="token number">3</span> <span class="token operator">&lt;*&gt;</span> <span class="token constant">Nothing</span>
<span class="token constant">Nothing</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>And now, let's think about how we would do <code>&gt;&gt;=</code> for <code>Maybe</code>. Like we said, <code>&gt;&gt;=</code> takes a monadic value, and a function that takes a normal value and returns a monadic value and manages to apply that function to the monadic value. How does it do that, if the function takes a normal value? Well, to do that, it has to take into account the context of that monadic value.</p></div><div><p>In this case, <code>&gt;&gt;=</code> would take a <code>Maybe a</code> value and a function of type <code>a -&gt; Maybe b</code> and somehow apply the function to the <code>Maybe a</code>. To figure out how it does that, we can use the intuition that we have from <code>Maybe</code> being an applicative functor. Let's say that we have a function <code>\x -&gt; Just (x+1)</code>. It takes a number, adds <code>1</code> to it and wraps it in a <code>Just</code>:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token punctuation">(</span><span class="token operator">\</span><span class="token hvariable">x</span> <span class="token operator">-&gt;</span> <span class="token constant">Just</span> <span class="token punctuation">(</span><span class="token hvariable">x</span><span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token number">1</span>
<span class="token constant">Just</span> <span class="token number">2</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token punctuation">(</span><span class="token operator">\</span><span class="token hvariable">x</span> <span class="token operator">-&gt;</span> <span class="token constant">Just</span> <span class="token punctuation">(</span><span class="token hvariable">x</span><span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token number">100</span>
<span class="token constant">Just</span> <span class="token number">101</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>If we feed it <code>1</code>, it evaluates to <code>Just 2</code>. If we give it the number <code>100</code>, the result is <code>Just 101</code>. Very straightforward. Now here's the kicker: how do we feed a <code>Maybe</code> value to this function? If we think about how <code>Maybe</code> acts as an applicative functor, answering this is pretty easy. If we feed it a <code>Just</code> value, take what's inside the <code>Just</code> and apply the function to it. If give it a <code>Nothing</code>, hmm, well, then we're left with a function but <code>Nothing</code> to apply it to. In that case, let's just do what we did before and say that the result is <code>Nothing</code>.</p></div><div><p>Instead of calling it <code>&gt;&gt;=</code>, let's call it <code>applyMaybe</code> for now. It takes a <code>Maybe a</code> and a function that returns a <code>Maybe b</code> and manages to apply that function to the <code>Maybe a</code>. Here it is in code:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">applyMaybe</span> <span class="token operator">::</span> <span class="token constant">Maybe</span> <span class="token hvariable">a</span> <span class="token operator">-&gt;</span> <span class="token punctuation">(</span><span class="token hvariable">a</span> <span class="token operator">-&gt;</span> <span class="token constant">Maybe</span> <span class="token hvariable">b</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token constant">Maybe</span> <span class="token hvariable">b</span>
<span class="token hvariable">applyMaybe</span> <span class="token constant">Nothing</span> <span class="token hvariable">f</span>  <span class="token operator">=</span> <span class="token constant">Nothing</span>
<span class="token hvariable">applyMaybe</span> <span class="token punctuation">(</span><span class="token constant">Just</span> <span class="token hvariable">x</span><span class="token punctuation">)</span> <span class="token hvariable">f</span> <span class="token operator">=</span> <span class="token hvariable">f</span> <span class="token hvariable">x</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Okay, now let's play with it for a bit. We'll use it as an infix function so that the <code>Maybe</code> value is on the left side and the function on the right:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token constant">Just</span> <span class="token number">3</span> <span class="token operator">`applyMaybe`</span> <span class="token operator">\</span><span class="token hvariable">x</span> <span class="token operator">-&gt;</span> <span class="token constant">Just</span> <span class="token punctuation">(</span><span class="token hvariable">x</span><span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span>
<span class="token constant">Just</span> <span class="token number">4</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token constant">Just</span> <span class="token string">"smile"</span> <span class="token operator">`applyMaybe`</span> <span class="token operator">\</span><span class="token hvariable">x</span> <span class="token operator">-&gt;</span> <span class="token constant">Just</span> <span class="token punctuation">(</span><span class="token hvariable">x</span> <span class="token operator">++</span> <span class="token string">" :)"</span><span class="token punctuation">)</span>
<span class="token constant">Just</span> <span class="token string">"smile :)"</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token constant">Nothing</span> <span class="token operator">`applyMaybe`</span> <span class="token operator">\</span><span class="token hvariable">x</span> <span class="token operator">-&gt;</span> <span class="token constant">Just</span> <span class="token punctuation">(</span><span class="token hvariable">x</span><span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span>
<span class="token constant">Nothing</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token constant">Nothing</span> <span class="token operator">`applyMaybe`</span> <span class="token operator">\</span><span class="token hvariable">x</span> <span class="token operator">-&gt;</span> <span class="token constant">Just</span> <span class="token punctuation">(</span><span class="token hvariable">x</span> <span class="token operator">++</span> <span class="token string">" :)"</span><span class="token punctuation">)</span>
<span class="token constant">Nothing</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>In the above example, we see that when we used <code>applyMaybe</code> with a <code>Just</code> value and a function, the function simply got applied to the value inside the <code>Just</code>. When we tried to use it with a <code>Nothing</code>, the whole result was <code>Nothing</code>. What about if the function returns a <code>Nothing</code>? Let's see:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token constant">Just</span> <span class="token number">3</span> <span class="token operator">`applyMaybe`</span> <span class="token operator">\</span><span class="token hvariable">x</span> <span class="token operator">-&gt;</span> <span class="token keyword">if</span> <span class="token hvariable">x</span> <span class="token operator">&gt;</span> <span class="token number">2</span> <span class="token keyword">then</span> <span class="token constant">Just</span> <span class="token hvariable">x</span> <span class="token keyword">else</span> <span class="token constant">Nothing</span>
<span class="token constant">Just</span> <span class="token number">3</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token constant">Just</span> <span class="token number">1</span> <span class="token operator">`applyMaybe`</span> <span class="token operator">\</span><span class="token hvariable">x</span> <span class="token operator">-&gt;</span> <span class="token keyword">if</span> <span class="token hvariable">x</span> <span class="token operator">&gt;</span> <span class="token number">2</span> <span class="token keyword">then</span> <span class="token constant">Just</span> <span class="token hvariable">x</span> <span class="token keyword">else</span> <span class="token constant">Nothing</span>
<span class="token constant">Nothing</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Just what we expected. If the monadic value on the left is a <code>Nothing</code>, the whole thing is <code>Nothing</code>. And if the function on the right returns a <code>Nothing</code>, the result is <code>Nothing</code> again. This is very similar to when we used <code>Maybe</code> as an applicative and we got a <code>Nothing</code> result if somewhere in there was a <code>Nothing</code>.</p></div><div><p>It looks like that for <code>Maybe</code>, we've figured out how to take a fancy value and feed it to a function that takes a normal value and returns a fancy one. We did this by keeping in mind that a <code>Maybe</code> value represents a computation that might have failed.</p></div><div><p>You might be asking yourself, how is this useful? It may seem like applicative functors are stronger than monads, since applicative functors allow us to take a normal function and make it operate on values with contexts. We'll see that monads can do that as well because they're an upgrade of applicative functors, and that they can also do some cool stuff that applicative functors can't.</p></div><div><p>We'll come back to <code>Maybe</code> in a minute, but first, let's check out the type class that belongs to monads.</p></div><div><h2 data-heading="The Monad type class" id="The_Monad_type_class" style="display: flex;"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>The Monad type class</h2></div><div><p>Just like functors have the <code>Functor</code> type class and applicative functors have the <code>Applicative</code> type class, monads come with their own type class: <code>Monad</code>! Wow, who would have thought? This is what the type class looks like:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token keyword">class</span> <span class="token constant">Monad</span> <span class="token hvariable">m</span> <span class="token keyword">where</span>
    <span class="token builtin">return</span> <span class="token operator">::</span> <span class="token hvariable">a</span> <span class="token operator">-&gt;</span> <span class="token hvariable">m</span> <span class="token hvariable">a</span>

    <span class="token punctuation">(</span><span class="token operator">&gt;&gt;=</span><span class="token punctuation">)</span> <span class="token operator">::</span> <span class="token hvariable">m</span> <span class="token hvariable">a</span> <span class="token operator">-&gt;</span> <span class="token punctuation">(</span><span class="token hvariable">a</span> <span class="token operator">-&gt;</span> <span class="token hvariable">m</span> <span class="token hvariable">b</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token hvariable">m</span> <span class="token hvariable">b</span>

    <span class="token punctuation">(</span><span class="token operator">&gt;&gt;</span><span class="token punctuation">)</span> <span class="token operator">::</span> <span class="token hvariable">m</span> <span class="token hvariable">a</span> <span class="token operator">-&gt;</span> <span class="token hvariable">m</span> <span class="token hvariable">b</span> <span class="token operator">-&gt;</span> <span class="token hvariable">m</span> <span class="token hvariable">b</span>
    <span class="token hvariable">x</span> <span class="token operator">&gt;&gt;</span> <span class="token hvariable">y</span> <span class="token operator">=</span> <span class="token hvariable">x</span> <span class="token operator">&gt;&gt;=</span> <span class="token operator">\</span><span class="token hvariable">_</span> <span class="token operator">-&gt;</span> <span class="token hvariable">y</span>

    <span class="token builtin">fail</span> <span class="token operator">::</span> <span class="token constant">String</span> <span class="token operator">-&gt;</span> <span class="token hvariable">m</span> <span class="token hvariable">a</span>
    <span class="token builtin">fail</span> <span class="token hvariable">msg</span> <span class="token operator">=</span> <span class="token builtin">error</span> <span class="token hvariable">msg</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p><span alt="LYHfGG_96_kid.png" src="LYHfGG_96_kid.png" class="internal-embed media-embed image-embed is-loaded"><img alt="LYHfGG_96_kid.png" src="курсы\learn-you-a-haskell-for-great-good!\картинки\lyhfgg_96_kid.png"></span></p></div><div><p>Let's start with the first line. It says <code>class Monad m where</code>. But wait, didn't we say that monads are just beefed up applicative functors? Shouldn't there be a class constraint in there along the lines of <code>class (Applicative m) = &gt; Monad m where</code> so that a type has to be an applicative functor first before it can be made a monad? Well, there should, but when Haskell was made, it hadn't occured to people that applicative functors are a good fit for Haskell so they weren't in there. But rest assured, every monad is an applicative functor, even if the <code>Monad</code> class declaration doesn't say so.</p></div><div><p>The first function that the <code>Monad</code> type class defines is <code>return</code>. It's the same as <code>pure</code>, only with a different name. Its type is <code>(Monad m) =&gt; a -&gt; m a</code>. It takes a value and puts it in a minimal default context that still holds that value. In other words, it takes something and wraps it in a monad. It always does the same thing as the <code>pure</code> function from the <code>Applicative</code> type class, which means we're already acquainted with <code>return</code>. We already used <code>return</code> when doing I/O. We used it to take a value and make a bogus I/O action that does nothing but yield that value. For <code>Maybe</code> it takes a value and wraps it in a <code>Just</code>.</p></div><div><blockquote>
<p>Just a reminder: <code>return</code> is nothing like the <code>return</code> that's in most other languages. It doesn't end function execution or anything, it just takes a normal value and puts it in a context.</p>
</blockquote></div><div><p><span alt="LYHfGG_97_tur2.png" src="LYHfGG_97_tur2.png" class="internal-embed media-embed image-embed is-loaded"><img alt="LYHfGG_97_tur2.png" src="курсы\learn-you-a-haskell-for-great-good!\картинки\lyhfgg_97_tur2.png"></span></p></div><div><p>The next function is <code>&gt;&gt;=</code>, or bind. It's like function application, only instead of taking a normal value and feeding it to a normal function, it takes a monadic value (that is, a value with a context) and feeds it to a function that takes a normal value but returns a monadic value.</p></div><div><p>Next up, we have <code>&gt;&gt;</code>. We won't pay too much attention to it for now because it comes with a default implementation and we pretty much never implement it when making <code>Monad</code> instances.</p></div><div><p>The final function of the <code>Monad</code> type class is <code>fail</code>. We never use it explicitly in our code. Instead, it's used by Haskell to enable failure in a special syntactic construct for monads that we'll meet later. We don't need to concern ourselves with <code>fail</code> too much for now.</p></div><div><p>Now that we know what the <code>Monad</code> type class looks like, let's take a look at how <code>Maybe</code> is an instance of <code>Monad</code>!</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token keyword">instance</span> <span class="token constant">Monad</span> <span class="token constant">Maybe</span> <span class="token keyword">where</span>
    <span class="token builtin">return</span> <span class="token hvariable">x</span> <span class="token operator">=</span> <span class="token constant">Just</span> <span class="token hvariable">x</span>
    <span class="token constant">Nothing</span> <span class="token operator">&gt;&gt;=</span> <span class="token hvariable">f</span> <span class="token operator">=</span> <span class="token constant">Nothing</span>
    <span class="token constant">Just</span> <span class="token hvariable">x</span> <span class="token operator">&gt;&gt;=</span> <span class="token hvariable">f</span>  <span class="token operator">=</span> <span class="token hvariable">f</span> <span class="token hvariable">x</span>
    <span class="token builtin">fail</span> <span class="token hvariable">_</span> <span class="token operator">=</span> <span class="token constant">Nothing</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p><code>return</code> is the same as <code>pure</code>, so that one's a no-brainer. We do what we did in the <code>Applicative</code> type class and wrap it in a <code>Just</code>.</p></div><div><p>The <code>&gt;&gt;=</code> function is the same as our <code>applyMaybe</code>. When feeding the <code>Maybe a</code> to our function, we keep in mind the context and return a <code>Nothing</code> if the value on the left is <code>Nothing</code> because if there's no value then there's no way to apply our function to it. If it's a <code>Just</code> we take what's inside and apply <code>f</code> to it.</p></div><div><p>We can play around with <code>Maybe</code> as a monad:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token builtin">return</span> <span class="token string">"WHAT"</span> <span class="token operator">::</span> <span class="token constant">Maybe</span> <span class="token constant">String</span>
<span class="token constant">Just</span> <span class="token string">"WHAT"</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token constant">Just</span> <span class="token number">9</span> <span class="token operator">&gt;&gt;=</span> <span class="token operator">\</span><span class="token hvariable">x</span> <span class="token operator">-&gt;</span> <span class="token builtin">return</span> <span class="token punctuation">(</span><span class="token hvariable">x</span><span class="token operator">*</span><span class="token number">10</span><span class="token punctuation">)</span>
<span class="token constant">Just</span> <span class="token number">90</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token constant">Nothing</span> <span class="token operator">&gt;&gt;=</span> <span class="token operator">\</span><span class="token hvariable">x</span> <span class="token operator">-&gt;</span> <span class="token builtin">return</span> <span class="token punctuation">(</span><span class="token hvariable">x</span><span class="token operator">*</span><span class="token number">10</span><span class="token punctuation">)</span>
<span class="token constant">Nothing</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Nothing new or exciting on the first line since we already used <code>pure</code> with <code>Maybe</code> and we know that <code>return</code> is just <code>pure</code> with a different name. The next two lines showcase <code>&gt;&gt;=</code> a bit more.</p></div><div><p>Notice how when we fed <code>Just 9</code> to the function <code>\x -&gt; return (x*10)</code>, the <code>x</code> took on the value <code>9</code> inside the function. It seems as though we were able to extract the value from a <code>Maybe</code> without pattern-matching. And we still didn't lose the context of our <code>Maybe</code> value, because when it's <code>Nothing</code>, the result of using <code>&gt;&gt;=</code> will be <code>Nothing</code> as well.</p></div><div><h2 data-heading="Walk the line" id="Walk_the_line" style="display: flex;"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>Walk the line</h2></div><div><p><span alt="LYHfGG_98_pierre.png" src="LYHfGG_98_pierre.png" class="internal-embed media-embed image-embed is-loaded"><img alt="LYHfGG_98_pierre.png" src="курсы\learn-you-a-haskell-for-great-good!\картинки\lyhfgg_98_pierre.png"></span></p></div><div><p>Now that we know how to feed a <code>Maybe a</code> value to a function of type <code>a -&gt; Maybe b</code> while taking into account the context of possible failure, let's see how we can use <code>&gt;&gt;=</code> repeatedly to handle computations of several <code>Maybe a</code> values.</p></div><div><p>Pierre has decided to take a break from his job at the fish farm and try tightrope walking. He's not that bad at it, but he does have one problem: birds keep landing on his balancing pole! They come and they take a short rest, chat with their avian friends and then take off in search of breadcrumbs. This wouldn't bother him so much if the number of birds on the left side of the pole was always equal to the number of birds on the right side. But sometimes, all the birds decide that they like one side better and so they throw him off balance, which results in an embarrassing tumble for Pierre (he's using a safety net).</p></div><div><p>Let's say that he keeps his balance if the number of birds on the left side of the pole and on the right side of the pole is within three. So if there's one bird on the right side and four birds on the left side, he's okay. But if a fifth bird lands on the left side, then he loses his balance and takes a dive.</p></div><div><p>We're going to simulate birds landing on and flying away from the pole and see if Pierre is still at it after a certain number of birdy arrivals and departures. For instance, we want to see what happens to Pierre if first one bird arrives on the left side, then four birds occupy the right side and then the bird that was on the left side decides to fly away.</p></div><div><p>We can represent the pole with a simple pair of integers. The first component will signify the number of birds on the left side and the second component the number of birds on the right side:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token keyword">type</span> <span class="token constant">Birds</span> <span class="token operator">=</span> <span class="token constant">Int</span>
<span class="token keyword">type</span> <span class="token constant">Pole</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token constant">Birds</span><span class="token punctuation">,</span><span class="token constant">Birds</span><span class="token punctuation">)</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>First we made a type synonym for <code>Int</code>, called <code>Birds</code>, because we're using integers to represent how many birds there are. And then we made a type synonym <code>(Birds,Birds)</code> and we called it <code>Pole</code> (not to be confused with a person of Polish descent).</p></div><div><p>Next up, how about we make a function that takes a number of birds and lands them on one side of the pole. Here are the functions:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">landLeft</span> <span class="token operator">::</span> <span class="token constant">Birds</span> <span class="token operator">-&gt;</span> <span class="token constant">Pole</span> <span class="token operator">-&gt;</span> <span class="token constant">Pole</span>
<span class="token hvariable">landLeft</span> <span class="token hvariable">n</span> <span class="token punctuation">(</span><span class="token hvariable">left</span><span class="token punctuation">,</span><span class="token hvariable">right</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token hvariable">left</span> <span class="token operator">+</span> <span class="token hvariable">n</span><span class="token punctuation">,</span><span class="token hvariable">right</span><span class="token punctuation">)</span>

<span class="token hvariable">landRight</span> <span class="token operator">::</span> <span class="token constant">Birds</span> <span class="token operator">-&gt;</span> <span class="token constant">Pole</span> <span class="token operator">-&gt;</span> <span class="token constant">Pole</span>
<span class="token hvariable">landRight</span> <span class="token hvariable">n</span> <span class="token punctuation">(</span><span class="token hvariable">left</span><span class="token punctuation">,</span><span class="token hvariable">right</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token hvariable">left</span><span class="token punctuation">,</span><span class="token hvariable">right</span> <span class="token operator">+</span> <span class="token hvariable">n</span><span class="token punctuation">)</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Pretty straightforward stuff. Let's try them out:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token hvariable">landLeft</span> <span class="token number">2</span> <span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">)</span>
<span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">)</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token hvariable">landRight</span> <span class="token number">1</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">)</span>
<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">)</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token hvariable">landRight</span> <span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">)</span>
<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">)</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>To make birds fly away we just had a negative number of birds land on one side. Because landing a bird on the <code>Pole</code> returns a <code>Pole</code>, we can chain applications of <code>landLeft</code> and <code>landRight</code>:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token hvariable">landLeft</span> <span class="token number">2</span> <span class="token punctuation">(</span><span class="token hvariable">landRight</span> <span class="token number">1</span> <span class="token punctuation">(</span><span class="token hvariable">landLeft</span> <span class="token number">1</span> <span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">)</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>When we apply the function <code>landLeft 1</code> to <code>(0,0)</code> we get <code>(1,0)</code>. Then, we land a bird on the right side, resulting in <code>(1,1)</code>. Finally two birds land on the left side, resulting in <code>(3,1)</code>. We apply a function to something by first writing the function and then writing its parameter, but here it would be better if the pole went first and then the landing function. If we make a function like this:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">x</span> <span class="token operator">-:</span> <span class="token hvariable">f</span> <span class="token operator">=</span> <span class="token hvariable">f</span> <span class="token hvariable">x</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>We can apply functions by first writing the parameter and then the function:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token number">100</span> <span class="token operator">-:</span> <span class="token punctuation">(</span><span class="token operator">*</span><span class="token number">3</span><span class="token punctuation">)</span>
<span class="token number">300</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token constant">True</span> <span class="token operator">-:</span> <span class="token builtin">not</span>
<span class="token constant">False</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">-:</span> <span class="token hvariable">landLeft</span> <span class="token number">2</span>
<span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">)</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>By using this, we can repeatedly land birds on the pole in a more readable manner:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">-:</span> <span class="token hvariable">landLeft</span> <span class="token number">1</span> <span class="token operator">-:</span> <span class="token hvariable">landRight</span> <span class="token number">1</span> <span class="token operator">-:</span> <span class="token hvariable">landLeft</span> <span class="token number">2</span>
<span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">)</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Pretty cool! This example is equivalent to the one before where we repeatedly landed birds on the pole, only it looks neater. Here, it's more obvious that we start off with <code>(0,0)</code> and then land one bird one the left, then one on the right and finally two on the left.</p></div><div><p>So far so good, but what happens if 10 birds land on one side?</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token hvariable">landLeft</span> <span class="token number">10</span> <span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">)</span>
<span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">)</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>10 birds on the left side and only 3 on the right? That's sure to send poor Pierre falling through the air! This is pretty obvious here but what if we had a sequence of landings like this:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">-:</span> <span class="token hvariable">landLeft</span> <span class="token number">1</span> <span class="token operator">-:</span> <span class="token hvariable">landRight</span> <span class="token number">4</span> <span class="token operator">-:</span> <span class="token hvariable">landLeft</span> <span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">-:</span> <span class="token hvariable">landRight</span> <span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">2</span><span class="token punctuation">)</span>
<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">)</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>It might seem like everything is okay but if you follow the steps here, you'll see that at one time there are 4 birds on the right side and no birds on the left! To fix this, we have to take another look at our <code>landLeft</code> and <code>landRight</code> functions. From what we've seen, we want these functions to be able to fail. That is, we want them to return a new pole if the balance is okay but fail if the birds land in a lopsided manner. And what better way to add a context of failure to value than by using <code>Maybe</code>! Let's rework these functions:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">landLeft</span> <span class="token operator">::</span> <span class="token constant">Birds</span> <span class="token operator">-&gt;</span> <span class="token constant">Pole</span> <span class="token operator">-&gt;</span> <span class="token constant">Maybe</span> <span class="token constant">Pole</span>
<span class="token hvariable">landLeft</span> <span class="token hvariable">n</span> <span class="token punctuation">(</span><span class="token hvariable">left</span><span class="token punctuation">,</span><span class="token hvariable">right</span><span class="token punctuation">)</span>
    <span class="token operator">|</span> <span class="token builtin">abs</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token hvariable">left</span> <span class="token operator">+</span> <span class="token hvariable">n</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token hvariable">right</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token number">4</span> <span class="token operator">=</span> <span class="token constant">Just</span> <span class="token punctuation">(</span><span class="token hvariable">left</span> <span class="token operator">+</span> <span class="token hvariable">n</span><span class="token punctuation">,</span> <span class="token hvariable">right</span><span class="token punctuation">)</span>
    <span class="token operator">|</span> <span class="token builtin">otherwise</span>                    <span class="token operator">=</span> <span class="token constant">Nothing</span>

<span class="token hvariable">landRight</span> <span class="token operator">::</span> <span class="token constant">Birds</span> <span class="token operator">-&gt;</span> <span class="token constant">Pole</span> <span class="token operator">-&gt;</span> <span class="token constant">Maybe</span> <span class="token constant">Pole</span>
<span class="token hvariable">landRight</span> <span class="token hvariable">n</span> <span class="token punctuation">(</span><span class="token hvariable">left</span><span class="token punctuation">,</span><span class="token hvariable">right</span><span class="token punctuation">)</span>
    <span class="token operator">|</span> <span class="token builtin">abs</span> <span class="token punctuation">(</span><span class="token hvariable">left</span> <span class="token operator">-</span> <span class="token punctuation">(</span><span class="token hvariable">right</span> <span class="token operator">+</span> <span class="token hvariable">n</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token number">4</span> <span class="token operator">=</span> <span class="token constant">Just</span> <span class="token punctuation">(</span><span class="token hvariable">left</span><span class="token punctuation">,</span> <span class="token hvariable">right</span> <span class="token operator">+</span> <span class="token hvariable">n</span><span class="token punctuation">)</span>
    <span class="token operator">|</span> <span class="token builtin">otherwise</span>                    <span class="token operator">=</span> <span class="token constant">Nothing</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Instead of returning a <code>Pole</code> these functions now return a <code>Maybe Pole</code>. They still take the number of birds and the old pole as before, but then they check if landing that many birds on the pole would throw Pierre off balance. We use guards to check if the difference between the number of birds on the new pole is less than 4. If it is, we wrap the new pole in a <code>Just</code> and return that. If it isn't, we return a <code>Nothing</code>, indicating failure.</p></div><div><p>Let's give these babies a go:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token hvariable">landLeft</span> <span class="token number">2</span> <span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">)</span>
<span class="token constant">Just</span> <span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">)</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token hvariable">landLeft</span> <span class="token number">10</span> <span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">)</span>
<span class="token constant">Nothing</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Nice! When we land birds without throwing Pierre off balance, we get a new pole wrapped in a <code>Just</code>. But when many more birds end up on one side of the pole, we get a <code>Nothing</code>. This is cool, but we seem to have lost the ability to repeatedly land birds on the pole. We can't do <code>landLeft 1 (landRight 1 (0,0))</code> anymore because when we apply <code>landRight 1</code> to <code>(0,0)</code>, we don't get a <code>Pole</code>, but a <code>Maybe Pole</code>. <code>landLeft 1</code> takes a <code>Pole</code> and not a <code>Maybe Pole</code>.</p></div><div><p>We need a way of taking a <code>Maybe Pole</code> and feeding it to a function that takes a <code>Pole</code> and returns a <code>Maybe Pole</code>. Luckily, we have <code>&gt;&gt;=</code>, which does just that for <code>Maybe</code>. Let's give it a go:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token hvariable">landRight</span> <span class="token number">1</span> <span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">&gt;&gt;=</span> <span class="token hvariable">landLeft</span> <span class="token number">2</span>
<span class="token constant">Just</span> <span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">)</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Remember, <code>landLeft 2</code> has a type of <code>Pole -&gt; Maybe Pole</code>. We couldn't just feed it the <code>Maybe Pole</code> that is the result of <code>landRight 1 (0,0)</code>, so we use <code>&gt;&gt;=</code> to take that value with a context and give it to <code>landLeft 2</code>. <code>&gt;&gt;=</code> does indeed allow us to treat the <code>Maybe</code> value as a value with context because if we feed a <code>Nothing</code> into <code>landLeft 2</code>, the result is <code>Nothing</code> and the failure is propagated:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token constant">Nothing</span> <span class="token operator">&gt;&gt;=</span> <span class="token hvariable">landLeft</span> <span class="token number">2</span>
<span class="token constant">Nothing</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>With this, we can now chain landings that may fail because <code>&gt;&gt;=</code> allows us to feed a monadic value to a function that takes a normal one.</p></div><div><p>Here's a sequence of birdy landings:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token builtin">return</span> <span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">&gt;&gt;=</span> <span class="token hvariable">landRight</span> <span class="token number">2</span> <span class="token operator">&gt;&gt;=</span> <span class="token hvariable">landLeft</span> <span class="token number">2</span> <span class="token operator">&gt;&gt;=</span> <span class="token hvariable">landRight</span> <span class="token number">2</span>
<span class="token constant">Just</span> <span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">)</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>At the beginning, we used <code>return</code> to take a pole and wrap it in a <code>Just</code>. We could have just applied <code>landRight 2</code> to <code>(0,0)</code>, it would have been the same, but this way we can be more consistent by using <code>&gt;&gt;=</code> for every function. <code>Just (0,0)</code> gets fed to <code>landRight 2</code>, resulting in <code>Just (0,2)</code>. This, in turn, gets fed to <code>landLeft 2</code>, resulting in <code>Just (2,2)</code>, and so on.</p></div><div><p>Remember this example from before we introduced failure into Pierre's routine:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">-:</span> <span class="token hvariable">landLeft</span> <span class="token number">1</span> <span class="token operator">-:</span> <span class="token hvariable">landRight</span> <span class="token number">4</span> <span class="token operator">-:</span> <span class="token hvariable">landLeft</span> <span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">-:</span> <span class="token hvariable">landRight</span> <span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">2</span><span class="token punctuation">)</span>
<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">)</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>It didn't simulate his interaction with birds very well because in the middle there his balance was off but the result didn't reflect that. But let's give that a go now by using monadic application (<code>&gt;&gt;=</code>) instead of normal application:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token builtin">return</span> <span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">&gt;&gt;=</span> <span class="token hvariable">landLeft</span> <span class="token number">1</span> <span class="token operator">&gt;&gt;=</span> <span class="token hvariable">landRight</span> <span class="token number">4</span> <span class="token operator">&gt;&gt;=</span> <span class="token hvariable">landLeft</span> <span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">&gt;&gt;=</span> <span class="token hvariable">landRight</span> <span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">2</span><span class="token punctuation">)</span>
<span class="token constant">Nothing</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p><span alt="LYHfGG_99_banana.png" src="LYHfGG_99_banana.png" class="internal-embed media-embed image-embed is-loaded"><img alt="LYHfGG_99_banana.png" src="курсы\learn-you-a-haskell-for-great-good!\картинки\lyhfgg_99_banana.png"></span></p></div><div><p>Awesome. The final result represents failure, which is what we expected. Let's see how this result was obtained. First, <code>return</code> puts <code>(0,0)</code> into a default context, making it a <code>Just (0,0)</code>. Then, <code>Just (0,0) &gt;&gt;= landLeft 1</code> happens. Since the <code>Just (0,0)</code> is a <code>Just</code> value, <code>landLeft 1</code> gets applied to <code>(0,0)</code>, resulting in a <code>Just (1,0)</code>, because the birds are still relatively balanced. Next, <code>Just (1,0) &gt;&gt;= landRight 4</code> takes place and the result is <code>Just (1,4)</code> as the balance of the birds is still intact, although just barely. <code>Just (1,4)</code> gets fed to <code>landLeft (-1)</code>. This means that <code>landLeft (-1) (1,4)</code> takes place. Now because of how <code>landLeft</code> works, this results in a <code>Nothing</code>, because the resulting pole is off balance. Now that we have a <code>Nothing</code>, it gets fed to <code>landRight (-2)</code>, but because it's a <code>Nothing</code>, the result is automatically <code>Nothing</code>, as we have nothing to apply <code>landRight (-2)</code> to.</p></div><div><p>We couldn't have achieved this by just using <code>Maybe</code> as an applicative. If you try it, you'll get stuck, because applicative functors don't allow for the applicative values to interact with each other very much. They can, at best, be used as parameters to a function by using the applicative style. The applicative operators will fetch their results and feed them to the function in a manner appropriate for each applicative and then put the final applicative value together, but there isn't that much interaction going on between them. Here, however, each step relies on the previous one's result. On every landing, the possible result from the previous one is examined and the pole is checked for balance. This determines whether the landing will succeed or fail.</p></div><div><p>We may also devise a function that ignores the current number of birds on the balancing pole and just makes Pierre slip and fall. We can call it <code>banana</code>:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">banana</span> <span class="token operator">::</span> <span class="token constant">Pole</span> <span class="token operator">-&gt;</span> <span class="token constant">Maybe</span> <span class="token constant">Pole</span>
<span class="token hvariable">banana</span> <span class="token hvariable">_</span> <span class="token operator">=</span> <span class="token constant">Nothing</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Now we can chain it together with our bird landings. It will always cause our walker to fall, because it ignores whatever's passed to it and always returns a failure. Check it:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token builtin">return</span> <span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">&gt;&gt;=</span> <span class="token hvariable">landLeft</span> <span class="token number">1</span> <span class="token operator">&gt;&gt;=</span> <span class="token hvariable">banana</span> <span class="token operator">&gt;&gt;=</span> <span class="token hvariable">landRight</span> <span class="token number">1</span>
<span class="token constant">Nothing</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>The value <code>Just (1,0)</code> gets fed to <code>banana</code>, but it produces a <code>Nothing</code>, which causes everything to result in a <code>Nothing</code>. How unfortunate!</p></div><div><p>Instead of making functions that ignore their input and just return a predetermined monadic value, we can use the <code>&gt;&gt;</code> function, whose default implementation is this:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token punctuation">(</span><span class="token operator">&gt;&gt;</span><span class="token punctuation">)</span> <span class="token operator">::</span> <span class="token punctuation">(</span><span class="token constant">Monad</span> <span class="token hvariable">m</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token hvariable">m</span> <span class="token hvariable">a</span> <span class="token operator">-&gt;</span> <span class="token hvariable">m</span> <span class="token hvariable">b</span> <span class="token operator">-&gt;</span> <span class="token hvariable">m</span> <span class="token hvariable">b</span>
<span class="token hvariable">m</span> <span class="token operator">&gt;&gt;</span> <span class="token hvariable">n</span> <span class="token operator">=</span> <span class="token hvariable">m</span> <span class="token operator">&gt;&gt;=</span> <span class="token operator">\</span><span class="token hvariable">_</span> <span class="token operator">-&gt;</span> <span class="token hvariable">n</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Normally, passing some value to a function that ignores its parameter and always just returns some predetermined value would always result in that predetermined value. With monads however, their context and meaning has to be considered as well. Here's how <code>&gt;&gt;</code> acts with <code>Maybe</code>:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token constant">Nothing</span> <span class="token operator">&gt;&gt;</span> <span class="token constant">Just</span> <span class="token number">3</span>
<span class="token constant">Nothing</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token constant">Just</span> <span class="token number">3</span> <span class="token operator">&gt;&gt;</span> <span class="token constant">Just</span> <span class="token number">4</span>
<span class="token constant">Just</span> <span class="token number">4</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token constant">Just</span> <span class="token number">3</span> <span class="token operator">&gt;&gt;</span> <span class="token constant">Nothing</span>
<span class="token constant">Nothing</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>If you replace <code>&gt;&gt;</code> with <code>&gt;&gt;= \_ -&gt;</code>, it's easy to see why it acts like it does.</p></div><div><p>We can replace our <code>banana</code> function in the chain with a <code>&gt;&gt;</code> and then a <code>Nothing</code>:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token builtin">return</span> <span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">&gt;&gt;=</span> <span class="token hvariable">landLeft</span> <span class="token number">1</span> <span class="token operator">&gt;&gt;</span> <span class="token constant">Nothing</span> <span class="token operator">&gt;&gt;=</span> <span class="token hvariable">landRight</span> <span class="token number">1</span>
<span class="token constant">Nothing</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>There we go, guaranteed and obvious failure!</p></div><div><p>It's also worth taking a look at what this would look like if we hadn't made the clever choice of treating <code>Maybe</code> values as values with a failure context and feeding them to functions like we did. Here's how a series of bird landings would look like:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">routine</span> <span class="token operator">::</span> <span class="token constant">Maybe</span> <span class="token constant">Pole</span>
<span class="token hvariable">routine</span> <span class="token operator">=</span> <span class="token keyword">case</span> <span class="token hvariable">landLeft</span> <span class="token number">1</span> <span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">of</span>
    <span class="token constant">Nothing</span> <span class="token operator">-&gt;</span> <span class="token constant">Nothing</span>
    <span class="token constant">Just</span> <span class="token hvariable">pole1</span> <span class="token operator">-&gt;</span> <span class="token keyword">case</span> <span class="token hvariable">landRight</span> <span class="token number">4</span> <span class="token hvariable">pole1</span> <span class="token keyword">of</span> 
        <span class="token constant">Nothing</span> <span class="token operator">-&gt;</span> <span class="token constant">Nothing</span>
        <span class="token constant">Just</span> <span class="token hvariable">pole2</span> <span class="token operator">-&gt;</span> <span class="token keyword">case</span> <span class="token hvariable">landLeft</span> <span class="token number">2</span> <span class="token hvariable">pole2</span> <span class="token keyword">of</span>
            <span class="token constant">Nothing</span> <span class="token operator">-&gt;</span> <span class="token constant">Nothing</span>
            <span class="token constant">Just</span> <span class="token hvariable">pole3</span> <span class="token operator">-&gt;</span> <span class="token hvariable">landLeft</span> <span class="token number">1</span> <span class="token hvariable">pole3</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p><span alt="LYHfGG_100_centaur.png" src="LYHfGG_100_centaur.png" class="internal-embed media-embed image-embed is-loaded"><img alt="LYHfGG_100_centaur.png" src="курсы\learn-you-a-haskell-for-great-good!\картинки\lyhfgg_100_centaur.png"></span></p></div><div><p>We land a bird on the left and then we examine the possibility of failure and the possibility of success. In the case of failure, we return a <code>Nothing</code>. In the case of success, we land birds on the right and then do the same thing all over again. Converting this monstrosity into a neat chain of monadic applications with <code>&gt;&gt;=</code> is a classic example of how the <code>Maybe</code> monad saves us a lot of time when we have to successively do computations that are based on computations that might have failed.</p></div><div><p>Notice how the <code>Maybe</code> implementation of <code>&gt;&gt;=</code> features exactly this logic of seeing if a value is <code>Nothing</code> and if it is, returning a <code>Nothing</code> right away and if it isn't, going forward with what's inside the <code>Just</code>.</p></div><div><p>In this section, we took some functions that we had and saw that they would work better if the values that they returned supported failure. By turning those values into <code>Maybe</code> values and replacing normal function application with <code>&gt;&gt;=</code>, we got a mechanism for handling failure pretty much for free, because <code>&gt;&gt;=</code> is supposed to preserve the context of the value to which it applies functions. In this case, the context was that our values were values with failure and so when we applied functions to such values, the possibility of failure was always taken into account.</p></div><div><h2 data-heading="do notation" id="do_notation" style="display: flex;"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>do notation</h2></div><div><p>Monads in Haskell are so useful that they got their own special syntax called <code>do</code> notation. We've already encountered <code>do</code> notation when we were doing I/O and there we said that it was for gluing together several I/O actions into one. Well, as it turns out, <code>do</code> notation isn't just for <code>IO</code>, but can be used for any monad. Its principle is still the same: gluing together monadic values in sequence. We're going to take a look at how <code>do</code> notation works and why it's useful.</p></div><div><p>Consider this familiar example of monadic application:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token constant">Just</span> <span class="token number">3</span> <span class="token operator">&gt;&gt;=</span> <span class="token punctuation">(</span><span class="token operator">\</span><span class="token hvariable">x</span> <span class="token operator">-&gt;</span> <span class="token constant">Just</span> <span class="token punctuation">(</span><span class="token builtin">show</span> <span class="token hvariable">x</span> <span class="token operator">++</span> <span class="token string">"!"</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token constant">Just</span> <span class="token string">"3!"</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Been there, done that. Feeding a monadic value to a function that returns one, no big deal. Notice how when we do this, <code>x</code> becomes <code>3</code> inside the lambda. Once we're inside that lambda, it's just a normal value rather than a monadic value. Now, what if we had another <code>&gt;&gt;=</code> inside that function? Check this out:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token constant">Just</span> <span class="token number">3</span> <span class="token operator">&gt;&gt;=</span> <span class="token punctuation">(</span><span class="token operator">\</span><span class="token hvariable">x</span> <span class="token operator">-&gt;</span> <span class="token constant">Just</span> <span class="token string">"!"</span> <span class="token operator">&gt;&gt;=</span> <span class="token punctuation">(</span><span class="token operator">\</span><span class="token hvariable">y</span> <span class="token operator">-&gt;</span> <span class="token constant">Just</span> <span class="token punctuation">(</span><span class="token builtin">show</span> <span class="token hvariable">x</span> <span class="token operator">++</span> <span class="token hvariable">y</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token constant">Just</span> <span class="token string">"3!"</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Ah, a nested use of <code>&gt;&gt;=</code>! In the outermost lambda, we feed <code>Just "!"</code> to the lambda <code>\y -&gt; Just (show x ++ y)</code>. Inside this lambda, the <code>y</code> becomes <code>"!"</code>. <code>x</code> is still <code>3</code> because we got it from the outer lambda. All this sort of reminds me of the following expression:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token keyword">let</span> <span class="token hvariable">x</span> <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span> <span class="token hvariable">y</span> <span class="token operator">=</span> <span class="token string">"!"</span> <span class="token keyword">in</span> <span class="token builtin">show</span> <span class="token hvariable">x</span> <span class="token operator">++</span> <span class="token hvariable">y</span>
<span class="token string">"3!"</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>The main difference between these two is that the values in the former example are monadic. They're values with a failure context. We can replace any of them with a failure:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token constant">Nothing</span> <span class="token operator">&gt;&gt;=</span> <span class="token punctuation">(</span><span class="token operator">\</span><span class="token hvariable">x</span> <span class="token operator">-&gt;</span> <span class="token constant">Just</span> <span class="token string">"!"</span> <span class="token operator">&gt;&gt;=</span> <span class="token punctuation">(</span><span class="token operator">\</span><span class="token hvariable">y</span> <span class="token operator">-&gt;</span> <span class="token constant">Just</span> <span class="token punctuation">(</span><span class="token builtin">show</span> <span class="token hvariable">x</span> <span class="token operator">++</span> <span class="token hvariable">y</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token constant">Nothing</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token constant">Just</span> <span class="token number">3</span> <span class="token operator">&gt;&gt;=</span> <span class="token punctuation">(</span><span class="token operator">\</span><span class="token hvariable">x</span> <span class="token operator">-&gt;</span> <span class="token constant">Nothing</span> <span class="token operator">&gt;&gt;=</span> <span class="token punctuation">(</span><span class="token operator">\</span><span class="token hvariable">y</span> <span class="token operator">-&gt;</span> <span class="token constant">Just</span> <span class="token punctuation">(</span><span class="token builtin">show</span> <span class="token hvariable">x</span> <span class="token operator">++</span> <span class="token hvariable">y</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token constant">Nothing</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token constant">Just</span> <span class="token number">3</span> <span class="token operator">&gt;&gt;=</span> <span class="token punctuation">(</span><span class="token operator">\</span><span class="token hvariable">x</span> <span class="token operator">-&gt;</span> <span class="token constant">Just</span> <span class="token string">"!"</span> <span class="token operator">&gt;&gt;=</span> <span class="token punctuation">(</span><span class="token operator">\</span><span class="token hvariable">y</span> <span class="token operator">-&gt;</span> <span class="token constant">Nothing</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token constant">Nothing</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>In the first line, feeding a <code>Nothing</code> to a function naturally results in a <code>Nothing</code>. In the second line, we feed <code>Just 3</code> to a function and the <code>x</code> becomes <code>3</code>, but then we feed a <code>Nothing</code> to the inner lambda and the result of that is <code>Nothing</code>, which causes the outer lambda to produce <code>Nothing</code> as well. So this is sort of like assigning values to variables in <code>let</code> expressions, only that the values in question are monadic values.</p></div><div><p>To further illustrate this point, let's write this in a script and have each <code>Maybe</code> value take up its own line:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">foo</span> <span class="token operator">::</span> <span class="token constant">Maybe</span> <span class="token constant">String</span>
<span class="token hvariable">foo</span> <span class="token operator">=</span> <span class="token constant">Just</span> <span class="token number">3</span>   <span class="token operator">&gt;&gt;=</span> <span class="token punctuation">(</span><span class="token operator">\</span><span class="token hvariable">x</span> <span class="token operator">-&gt;</span>
      <span class="token constant">Just</span> <span class="token string">"!"</span> <span class="token operator">&gt;&gt;=</span> <span class="token punctuation">(</span><span class="token operator">\</span><span class="token hvariable">y</span> <span class="token operator">-&gt;</span>
      <span class="token constant">Just</span> <span class="token punctuation">(</span><span class="token builtin">show</span> <span class="token hvariable">x</span> <span class="token operator">++</span> <span class="token hvariable">y</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>To save us from writing all these annoying lambdas, Haskell gives us <code>do</code> notation. It allows us to write the previous piece of code like this:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">foo</span> <span class="token operator">::</span> <span class="token constant">Maybe</span> <span class="token constant">String</span>
<span class="token hvariable">foo</span> <span class="token operator">=</span> <span class="token keyword">do</span>
    <span class="token hvariable">x</span> <span class="token operator">&lt;-</span> <span class="token constant">Just</span> <span class="token number">3</span>
    <span class="token hvariable">y</span> <span class="token operator">&lt;-</span> <span class="token constant">Just</span> <span class="token string">"!"</span>
    <span class="token constant">Just</span> <span class="token punctuation">(</span><span class="token builtin">show</span> <span class="token hvariable">x</span> <span class="token operator">++</span> <span class="token hvariable">y</span><span class="token punctuation">)</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p><span alt="LYHfGG_101_owld.png" src="LYHfGG_101_owld.png" class="internal-embed media-embed image-embed is-loaded"><img alt="LYHfGG_101_owld.png" src="курсы\learn-you-a-haskell-for-great-good!\картинки\lyhfgg_101_owld.png"></span></p></div><div><p>It would seem as though we've gained the ability to temporarily extract things from <code>Maybe</code> values without having to check if the <code>Maybe</code> values are <code>Just</code> values or <code>Nothing</code> values at every step. How cool! If any of the values that we try to extract from are <code>Nothing</code>, the whole <code>do</code> expression will result in a <code>Nothing</code>. We're yanking out their (possibly existing) values and letting <code>&gt;&gt;=</code> worry about the context that comes with those values. It's important to remember that <code>do</code> expressions are just different syntax for chaining monadic values.</p></div><div><p>In a <code>do</code> expression, every line is a monadic value. To inspect its result, we use <code>&lt;-</code>. If we have a <code>Maybe String</code> and we bind it with <code>&lt;-</code> to a variable, that variable will be a <code>String</code>, just like when we used <code>&gt;&gt;=</code> to feed monadic values to lambdas. The last monadic value in a <code>do</code> expression, like <code>Just (show x ++ y)</code> here, can't be used with <code>&lt;-</code> to bind its result, because that wouldn't make sense if we translated the <code>do</code> expression back to a chain of <code>&gt;&gt;=</code> applications. Rather, its result is the result of the whole glued up monadic value, taking into account the possible failure of any of the previous ones.</p></div><div><p>For instance, examine the following line:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token constant">Just</span> <span class="token number">9</span> <span class="token operator">&gt;&gt;=</span> <span class="token punctuation">(</span><span class="token operator">\</span><span class="token hvariable">x</span> <span class="token operator">-&gt;</span> <span class="token constant">Just</span> <span class="token punctuation">(</span><span class="token hvariable">x</span> <span class="token operator">&gt;</span> <span class="token number">8</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token constant">Just</span> <span class="token constant">True</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Because the left parameter of <code>&gt;&gt;=</code> is a <code>Just</code> value, the lambda is applied to <code>9</code> and the result is a <code>Just True</code>. If we rewrite this in <code>do</code> notation, we get:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">marySue</span> <span class="token operator">::</span> <span class="token constant">Maybe</span> <span class="token constant">Bool</span>
<span class="token hvariable">marySue</span> <span class="token operator">=</span> <span class="token keyword">do</span> 
    <span class="token hvariable">x</span> <span class="token operator">&lt;-</span> <span class="token constant">Just</span> <span class="token number">9</span>
    <span class="token constant">Just</span> <span class="token punctuation">(</span><span class="token hvariable">x</span> <span class="token operator">&gt;</span> <span class="token number">8</span><span class="token punctuation">)</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>If we compare these two, it's easy to see why the result of the whole monadic value is the result of the last monadic value in the <code>do</code> expression with all the previous ones chained into it.</p></div><div><p>Our tightwalker's routine can also be expressed with <code>do</code> notation. <code>landLeft</code> and <code>landRight</code> take a number of birds and a pole and produce a pole wrapped in a <code>Just</code>, unless the tightwalker slips, in which case a <code>Nothing</code> is produced. We used <code>&gt;&gt;=</code> to chain successive steps because each one relied on the previous one and each one had an added context of possible failure. Here's two birds landing on the left side, then two birds landing on the right and then one bird landing on the left:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">routine</span> <span class="token operator">::</span> <span class="token constant">Maybe</span> <span class="token constant">Pole</span>
<span class="token hvariable">routine</span> <span class="token operator">=</span> <span class="token keyword">do</span>
    <span class="token hvariable">start</span> <span class="token operator">&lt;-</span> <span class="token builtin">return</span> <span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">)</span>
    <span class="token hvariable">first</span> <span class="token operator">&lt;-</span> <span class="token hvariable">landLeft</span> <span class="token number">2</span> <span class="token hvariable">start</span>
    <span class="token hvariable">second</span> <span class="token operator">&lt;-</span> <span class="token hvariable">landRight</span> <span class="token number">2</span> <span class="token hvariable">first</span>
    <span class="token hvariable">landLeft</span> <span class="token number">1</span> <span class="token hvariable">second</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Let's see if he succeeds:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token hvariable">routine</span>
<span class="token constant">Just</span> <span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">)</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>He does! Great. When we were doing these routines by explicitly writing <code>&gt;&gt;=</code>, we usually said something like <code>return (0,0) &gt;&gt;= landLeft 2</code>, because <code>landLeft 2</code> is a function that returns a <code>Maybe</code> value. With <code>do</code> expressions however, each line must feature a monadic value. So we explicitly pass the previous <code>Pole</code> to the <code>landLeft</code> <code>landRight</code> functions. If we examined the variables to which we bound our <code>Maybe</code> values, <code>start</code> would be <code>(0,0)</code>, <code>first</code> would be <code>(2,0)</code> and so on.</p></div><div><p>Because <code>do</code> expressions are written line by line, they may look like imperative code to some people. But the thing is, they're just sequential, as each value in each line relies on the result of the previous ones, along with their contexts (in this case, whether they succeeded or failed).</p></div><div><p>Again, let's take a look at what this piece of code would look like if we hadn't used the monadic aspects of <code>Maybe</code>:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">routine</span> <span class="token operator">::</span> <span class="token constant">Maybe</span> <span class="token constant">Pole</span>
<span class="token hvariable">routine</span> <span class="token operator">=</span> 
    <span class="token keyword">case</span> <span class="token constant">Just</span> <span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">of</span> 
        <span class="token constant">Nothing</span> <span class="token operator">-&gt;</span> <span class="token constant">Nothing</span>
        <span class="token constant">Just</span> <span class="token hvariable">start</span> <span class="token operator">-&gt;</span> <span class="token keyword">case</span> <span class="token hvariable">landLeft</span> <span class="token number">2</span> <span class="token hvariable">start</span> <span class="token keyword">of</span>
            <span class="token constant">Nothing</span> <span class="token operator">-&gt;</span> <span class="token constant">Nothing</span>
            <span class="token constant">Just</span> <span class="token hvariable">first</span> <span class="token operator">-&gt;</span> <span class="token keyword">case</span> <span class="token hvariable">landRight</span> <span class="token number">2</span> <span class="token hvariable">first</span> <span class="token keyword">of</span>
                <span class="token constant">Nothing</span> <span class="token operator">-&gt;</span> <span class="token constant">Nothing</span>
                <span class="token constant">Just</span> <span class="token hvariable">second</span> <span class="token operator">-&gt;</span> <span class="token hvariable">landLeft</span> <span class="token number">1</span> <span class="token hvariable">second</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>See how in the case of success, the tuple inside <code>Just (0,0)</code> becomes <code>start</code>, the result of <code>landLeft 2 start</code> becomes <code>first</code>, etc.</p></div><div><p>If we want to throw the Pierre a banana peel in <code>do</code> notation, we can do the following:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">routine</span> <span class="token operator">::</span> <span class="token constant">Maybe</span> <span class="token constant">Pole</span>
<span class="token hvariable">routine</span> <span class="token operator">=</span> <span class="token keyword">do</span>
    <span class="token hvariable">start</span> <span class="token operator">&lt;-</span> <span class="token builtin">return</span> <span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">)</span>
    <span class="token hvariable">first</span> <span class="token operator">&lt;-</span> <span class="token hvariable">landLeft</span> <span class="token number">2</span> <span class="token hvariable">start</span>
    <span class="token constant">Nothing</span>
    <span class="token hvariable">second</span> <span class="token operator">&lt;-</span> <span class="token hvariable">landRight</span> <span class="token number">2</span> <span class="token hvariable">first</span>
    <span class="token hvariable">landLeft</span> <span class="token number">1</span> <span class="token hvariable">second</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>When we write a line in <code>do</code> notation without binding the monadic value with <code>&lt;-</code>, it's just like putting <code>&gt;&gt;</code> after the monadic value whose result we want to ignore. We sequence the monadic value but we ignore its result because we don't care what it is and it's prettier than writing <code>_ &lt;- Nothing</code>, which is equivalent to the above.</p></div><div><p>When to use <code>do</code> notation and when to explicitly use <code>&gt;&gt;=</code> is up to you. I think this example lends itself to explicitly writing <code>&gt;&gt;=</code> because each step relies specifically on the result of the previous one. With <code>do</code> notation, we had to specifically write on which pole the birds are landing, but every time we used that came directly before. But still, it gave us some insight into <code>do</code> notation.</p></div><div><p>In <code>do</code> notation, when we bind monadic values to names, we can utilize pattern matching, just like in <code>let</code> expressions and function parameters. Here's an example of pattern matching in a <code>do</code> expression:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">justH</span> <span class="token operator">::</span> <span class="token constant">Maybe</span> <span class="token constant">Char</span>
<span class="token hvariable">justH</span> <span class="token operator">=</span> <span class="token keyword">do</span>
    <span class="token punctuation">(</span><span class="token hvariable">x</span><span class="token operator">:</span><span class="token hvariable">xs</span><span class="token punctuation">)</span> <span class="token operator">&lt;-</span> <span class="token constant">Just</span> <span class="token string">"hello"</span>
    <span class="token builtin">return</span> <span class="token hvariable">x</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>We use pattern matching to get the first character of the string <code>"hello"</code> and then we present it as the result. So <code>justH</code> evaluates to <code>Just 'h'</code>.</p></div><div><p>What if this pattern matching were to fail? When matching on a pattern in a function fails, the next pattern is matched. If the matching falls through all the patterns for a given function, an error is thrown and our program crashes. On the other hand, failed pattern matching in <code>let</code> expressions results in an error being produced right away, because the mechanism of falling through patterns isn't present in <code>let</code> expressions. When pattern matching fails in a <code>do</code> expression, the <code>fail</code> function is called. It's part of the <code>Monad</code> type class and it enables failed pattern matching to result in a failure in the context of the current monad instead of making our program crash. Its default implementation is this:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token builtin">fail</span> <span class="token operator">::</span> <span class="token punctuation">(</span><span class="token constant">Monad</span> <span class="token hvariable">m</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token constant">String</span> <span class="token operator">-&gt;</span> <span class="token hvariable">m</span> <span class="token hvariable">a</span>
<span class="token builtin">fail</span> <span class="token hvariable">msg</span> <span class="token operator">=</span> <span class="token builtin">error</span> <span class="token hvariable">msg</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>So by default it does make our program crash, but monads that incorporate a context of possible failure (like <code>Maybe</code>) usually implement it on their own. For <code>Maybe</code>, its implemented like so:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token builtin">fail</span> <span class="token hvariable">_</span> <span class="token operator">=</span> <span class="token constant">Nothing</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>It ignores the error message and makes a <code>Nothing</code>. So when pattern matching fails in a <code>Maybe</code> value that's written in <code>do</code> notation, the whole value results in a <code>Nothing</code>. This is preferable to having our program crash. Here's a <code>do</code> expression with a pattern that's bound to fail:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">wopwop</span> <span class="token operator">::</span> <span class="token constant">Maybe</span> <span class="token constant">Char</span>
<span class="token hvariable">wopwop</span> <span class="token operator">=</span> <span class="token keyword">do</span>
    <span class="token punctuation">(</span><span class="token hvariable">x</span><span class="token operator">:</span><span class="token hvariable">xs</span><span class="token punctuation">)</span> <span class="token operator">&lt;-</span> <span class="token constant">Just</span> <span class="token string">""</span>
    <span class="token builtin">return</span> <span class="token hvariable">x</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>The pattern matching fails, so the effect is the same as if the whole line with the pattern was replaced with a <code>Nothing</code>. Let's try this out:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token hvariable">wopwop</span>
<span class="token constant">Nothing</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>The failed pattern matching has caused a failure within the context of our monad instead of causing a program-wide failure, which is pretty neat.</p></div><div><h2 data-heading="The list monad" id="The_list_monad" style="display: flex;"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>The list monad</h2></div><div><p><span alt="LYHfGG_102_deadcat.png" src="LYHfGG_102_deadcat.png" class="internal-embed media-embed image-embed is-loaded"><img alt="LYHfGG_102_deadcat.png" src="курсы\learn-you-a-haskell-for-great-good!\картинки\lyhfgg_102_deadcat.png"></span></p></div><div><p>So far, we've seen how <code>Maybe</code> values can be viewed as values with a failure context and how we can incorporate failure handling into our code by using <code>&gt;&gt;=</code> to feed them to functions. In this section, we're going to take a look at how to use the monadic aspects of lists to bring non-determinism into our code in a clear and readable manner.</p></div><div><p>We've already talked about how lists represent non-deterministic values when they're used as applicatives. A value like <code>5</code> is deterministic. It has only one result and we know exactly what it is. On the other hand, a value like <code>[3,8,9]</code> contains several results, so we can view it as one value that is actually many values at the same time. Using lists as applicative functors showcases this non-determinism nicely:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">)</span> <span class="token operator">&lt;$&gt;</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">]</span> <span class="token operator">&lt;*&gt;</span> <span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">,</span><span class="token number">100</span><span class="token punctuation">,</span><span class="token number">1000</span><span class="token punctuation">]</span>
<span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">,</span><span class="token number">100</span><span class="token punctuation">,</span><span class="token number">1000</span><span class="token punctuation">,</span><span class="token number">20</span><span class="token punctuation">,</span><span class="token number">200</span><span class="token punctuation">,</span><span class="token number">2000</span><span class="token punctuation">,</span><span class="token number">30</span><span class="token punctuation">,</span><span class="token number">300</span><span class="token punctuation">,</span><span class="token number">3000</span><span class="token punctuation">]</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>All the possible combinations of multiplying elements from the left list with elements from the right list are included in the resulting list. When dealing with non-determinism, there are many choices that we can make, so we just try all of them, and so the result is a non-deterministic value as well, only it has many more results.</p></div><div><p>This context of non-determinism translates to monads very nicely. Let's go ahead and see what the <code>Monad</code> instance for lists looks like:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token keyword">instance</span> <span class="token constant">Monad</span> <span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token keyword">where</span>
    <span class="token builtin">return</span> <span class="token hvariable">x</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token hvariable">x</span><span class="token punctuation">]</span>
    <span class="token hvariable">xs</span> <span class="token operator">&gt;&gt;=</span> <span class="token hvariable">f</span> <span class="token operator">=</span> <span class="token builtin">concat</span> <span class="token punctuation">(</span><span class="token builtin">map</span> <span class="token hvariable">f</span> <span class="token hvariable">xs</span><span class="token punctuation">)</span>
    <span class="token builtin">fail</span> <span class="token hvariable">_</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p><code>return</code> does the same thing as <code>pure</code>, so we should already be familiar with <code>return</code> for lists. It takes a value and puts it in a minimal default context that still yields that value. In other words, it makes a list that has only that one value as its result. This is useful for when we want to just wrap a normal value into a list so that it can interact with non-deterministic values.</p></div><div><p>To understand how <code>&gt;&gt;=</code> works for lists, it's best if we take a look at it in action to gain some intuition first. <code>&gt;&gt;=</code> is about taking a value with a context (a monadic value) and feeding it to a function that takes a normal value and returns one that has context. If that function just produced a normal value instead of one with a context, <code>&gt;&gt;=</code> wouldn't be so useful because after one use, the context would be lost. Anyway, let's try feeding a non-deterministic value to a function:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">]</span> <span class="token operator">&gt;&gt;=</span> <span class="token operator">\</span><span class="token hvariable">x</span> <span class="token operator">-&gt;</span> <span class="token punctuation">[</span><span class="token hvariable">x</span><span class="token punctuation">,</span><span class="token operator">-</span><span class="token hvariable">x</span><span class="token punctuation">]</span>
<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">5</span><span class="token punctuation">]</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>When we used <code>&gt;&gt;=</code> with <code>Maybe</code>, the monadic value was fed into the function while taking care of possible failures. Here, it takes care of non-determinism for us. <code>[3,4,5]</code> is a non-deterministic value and we feed it into a function that returns a non-deterministic value as well. The result is also non-deterministic, and it features all the possible results of taking elements from the list <code>[3,4,5]</code> and passing them to the function <code>\x -&gt; [x,-x]</code>. This function takes a number and produces two results: one negated and one that's unchanged. So when we use <code>&gt;&gt;=</code> to feed this list to the function, every number is negated and also kept unchanged. The <code>x</code> from the lambda takes on every value from the list that's fed to it.</p></div><div><p>To see how this is achieved, we can just follow the implementation. First, we start off with the list <code>[3,4,5]</code>. Then, we map the lambda over it and the result is the following:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">]</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>The lambda is applied to every element and we get a list of lists. Finally, we just flatten the list and voila! We've applied a non-deterministic function to a non-deterministic value!</p></div><div><p>Non-determinism also includes support for failure. The empty list <code>[]</code> is pretty much the equivalent of <code>Nothing</code>, because it signifies the absence of a result. That's why failing is just defined as the empty list. The error message gets thrown away. Let's play around with lists that fail:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">&gt;&gt;=</span> <span class="token operator">\</span><span class="token hvariable">x</span> <span class="token operator">-&gt;</span> <span class="token punctuation">[</span><span class="token string">"bad"</span><span class="token punctuation">,</span><span class="token string">"mad"</span><span class="token punctuation">,</span><span class="token string">"rad"</span><span class="token punctuation">]</span>
<span class="token punctuation">[</span><span class="token punctuation">]</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">]</span> <span class="token operator">&gt;&gt;=</span> <span class="token operator">\</span><span class="token hvariable">x</span> <span class="token operator">-&gt;</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
<span class="token punctuation">[</span><span class="token punctuation">]</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>In the first line, an empty list is fed into the lambda. Because the list has no elements, none of them can be passed to the function and so the result is an empty list. This is similar to feeding <code>Nothing</code> to a function. In the second line, each element gets passed to the function, but the element is ignored and the function just returns an empty list. Because the function fails for every element that goes in it, the result is a failure.</p></div><div><p>Just like with <code>Maybe</code> values, we can chain several lists with <code>&gt;&gt;=</code>, propagating the non-determinism:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">&gt;&gt;=</span> <span class="token operator">\</span><span class="token hvariable">n</span> <span class="token operator">-&gt;</span> <span class="token punctuation">[</span><span class="token char string">'a'</span><span class="token punctuation">,</span><span class="token char string">'b'</span><span class="token punctuation">]</span> <span class="token operator">&gt;&gt;=</span> <span class="token operator">\</span><span class="token hvariable">ch</span> <span class="token operator">-&gt;</span> <span class="token builtin">return</span> <span class="token punctuation">(</span><span class="token hvariable">n</span><span class="token punctuation">,</span><span class="token hvariable">ch</span><span class="token punctuation">)</span>
<span class="token punctuation">[</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token char string">'a'</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token char string">'b'</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token char string">'a'</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token char string">'b'</span><span class="token punctuation">)</span><span class="token punctuation">]</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p><span alt="LYHfGG_103_concatmap.png" src="LYHfGG_103_concatmap.png" class="internal-embed media-embed image-embed is-loaded"><img alt="LYHfGG_103_concatmap.png" src="курсы\learn-you-a-haskell-for-great-good!\картинки\lyhfgg_103_concatmap.png"></span></p></div><div><p>The list <code>[1,2]</code> gets bound to <code>n</code> and <code>['a','b']</code> gets bound to <code>ch</code>. Then, we do <code>return (n,ch)</code> (or <code>[(n,ch)]</code>), which means taking a pair of <code>(n,ch)</code> and putting it in a default minimal context. In this case, it's making the smallest possible list that still presents <code>(n,ch)</code> as the result and features as little non-determinism as possible. Its effect on the context is minimal. What we're saying here is this: for every element in <code>[1,2]</code>, go over every element in <code>['a','b']</code> and produce a tuple of one element from each list.</p></div><div><p>Generally speaking, because <code>return</code> takes a value and wraps it in a minimal context, it doesn't have any extra effect (like failing in <code>Maybe</code> or resulting in more non-determinism for lists) but it does present something as its result.</p></div><div><blockquote>
<p>When you have non-deterministic values interacting, you can view their computation as a tree where every possible result in a list represents a separate branch.</p>
</blockquote></div><div><p>Here's the previous expression rewritten in <code>do</code> notation:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">listOfTuples</span> <span class="token operator">::</span> <span class="token punctuation">[</span><span class="token punctuation">(</span><span class="token constant">Int</span><span class="token punctuation">,</span><span class="token constant">Char</span><span class="token punctuation">)</span><span class="token punctuation">]</span>
<span class="token hvariable">listOfTuples</span> <span class="token operator">=</span> <span class="token keyword">do</span>
    <span class="token hvariable">n</span> <span class="token operator">&lt;-</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">]</span>
    <span class="token hvariable">ch</span> <span class="token operator">&lt;-</span> <span class="token punctuation">[</span><span class="token char string">'a'</span><span class="token punctuation">,</span><span class="token char string">'b'</span><span class="token punctuation">]</span>
    <span class="token builtin">return</span> <span class="token punctuation">(</span><span class="token hvariable">n</span><span class="token punctuation">,</span><span class="token hvariable">ch</span><span class="token punctuation">)</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>This makes it a bit more obvious that <code>n</code> takes on every value from <code>[1,2]</code> and <code>ch</code> takes on every value from <code>['a','b']</code>. Just like with <code>Maybe</code>, we're extracting the elements from the monadic values and treating them like normal values and <code>&gt;&gt;=</code> takes care of the context for us. The context in this case is non-determinism.</p></div><div><p>Using lists with <code>do</code> notation really reminds me of something we've seen before. Check out the following piece of code:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token punctuation">[</span> <span class="token punctuation">(</span><span class="token hvariable">n</span><span class="token punctuation">,</span><span class="token hvariable">ch</span><span class="token punctuation">)</span> <span class="token operator">|</span> <span class="token hvariable">n</span> <span class="token operator">&lt;-</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token hvariable">ch</span> <span class="token operator">&lt;-</span> <span class="token punctuation">[</span><span class="token char string">'a'</span><span class="token punctuation">,</span><span class="token char string">'b'</span><span class="token punctuation">]</span> <span class="token punctuation">]</span>
<span class="token punctuation">[</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token char string">'a'</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token char string">'b'</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token char string">'a'</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token char string">'b'</span><span class="token punctuation">)</span><span class="token punctuation">]</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Yes! List comprehensions! In our <code>do</code> notation example, <code>n</code> became every result from <code>[1,2]</code> and for every such result, <code>ch</code> was assigned a result from <code>['a','b']</code> and then the final line put <code>(n,ch)</code> into a default context (a singleton list) to present it as the result without introducing any additional non-determinism. In this list comprehension, the same thing happened, only we didn't have to write <code>return</code> at the end to present <code>(n,ch)</code> as the result because the output part of a list comprehension did that for us.</p></div><div><p>In fact, list comprehensions are just syntactic sugar for using lists as monads. In the end, list comprehensions and lists in <code>do</code> notation translate to using <code>&gt;&gt;=</code> to do computations that feature non-determinism.</p></div><div><p>List comprehensions allow us to filter our output. For instance, we can filter a list of numbers to search only for that numbers whose digits contain a <code>7</code>:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token punctuation">[</span> <span class="token hvariable">x</span> <span class="token operator">|</span> <span class="token hvariable">x</span> <span class="token operator">&lt;-</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token operator">..</span><span class="token number">50</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token char string">'7'</span> <span class="token operator">`elem`</span> <span class="token builtin">show</span> <span class="token hvariable">x</span> <span class="token punctuation">]</span>
<span class="token punctuation">[</span><span class="token number">7</span><span class="token punctuation">,</span><span class="token number">17</span><span class="token punctuation">,</span><span class="token number">27</span><span class="token punctuation">,</span><span class="token number">37</span><span class="token punctuation">,</span><span class="token number">47</span><span class="token punctuation">]</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>We apply <code>show</code> to <code>x</code> to turn our number into a string and then we check if the character <code>'7'</code> is part of that string. Pretty clever. To see how filtering in list comprehensions translates to the list monad, we have to check out the <code>guard</code> function and the <code>MonadPlus</code> type class. The <code>MonadPlus</code> type class is for monads that can also act as monoids. Here's its definition:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token keyword">class</span> <span class="token constant">Monad</span> <span class="token hvariable">m</span> <span class="token operator">=&gt;</span> <span class="token constant">MonadPlus</span> <span class="token hvariable">m</span> <span class="token keyword">where</span>
    <span class="token hvariable">mzero</span> <span class="token operator">::</span> <span class="token hvariable">m</span> <span class="token hvariable">a</span>
    <span class="token hvariable">mplus</span> <span class="token operator">::</span> <span class="token hvariable">m</span> <span class="token hvariable">a</span> <span class="token operator">-&gt;</span> <span class="token hvariable">m</span> <span class="token hvariable">a</span> <span class="token operator">-&gt;</span> <span class="token hvariable">m</span> <span class="token hvariable">a</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p><code>mzero</code> is synonymous to <code>mempty</code> from the <code>Monoid</code> type class and <code>mplus</code> corresponds to <code>mappend</code>. Because lists are monoids as well as monads, they can be made an instance of this type class:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token keyword">instance</span> <span class="token constant">MonadPlus</span> <span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token keyword">where</span>
    <span class="token hvariable">mzero</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
    <span class="token hvariable">mplus</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token operator">++</span><span class="token punctuation">)</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>For lists <code>mzero</code> represents a non-deterministic computation that has no results at all — a failed computation. <code>mplus</code> joins two non-deterministic values into one. The <code>guard</code> function is defined like this:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">guard</span> <span class="token operator">::</span> <span class="token punctuation">(</span><span class="token constant">MonadPlus</span> <span class="token hvariable">m</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token constant">Bool</span> <span class="token operator">-&gt;</span> <span class="token hvariable">m</span> <span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token hvariable">guard</span> <span class="token constant">True</span> <span class="token operator">=</span> <span class="token builtin">return</span> <span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token hvariable">guard</span> <span class="token constant">False</span> <span class="token operator">=</span> <span class="token hvariable">mzero</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>It takes a boolean value and if it's <code>True</code>, takes a <code>()</code> and puts it in a minimal default context that still succeeds. Otherwise, it makes a failed monadic value. Here it is in action:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token hvariable">guard</span> <span class="token punctuation">(</span><span class="token number">5</span> <span class="token operator">&gt;</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token operator">::</span> <span class="token constant">Maybe</span> <span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token constant">Just</span> <span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token hvariable">guard</span> <span class="token punctuation">(</span><span class="token number">1</span> <span class="token operator">&gt;</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token operator">::</span> <span class="token constant">Maybe</span> <span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token constant">Nothing</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token hvariable">guard</span> <span class="token punctuation">(</span><span class="token number">5</span> <span class="token operator">&gt;</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token operator">::</span> <span class="token punctuation">[</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">]</span>
<span class="token punctuation">[</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">]</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token hvariable">guard</span> <span class="token punctuation">(</span><span class="token number">1</span> <span class="token operator">&gt;</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token operator">::</span> <span class="token punctuation">[</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">]</span>
<span class="token punctuation">[</span><span class="token punctuation">]</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Looks interesting, but how is it useful? In the list monad, we use it to filter out non-deterministic computations. Observe:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token operator">..</span><span class="token number">50</span><span class="token punctuation">]</span> <span class="token operator">&gt;&gt;=</span> <span class="token punctuation">(</span><span class="token operator">\</span><span class="token hvariable">x</span> <span class="token operator">-&gt;</span> <span class="token hvariable">guard</span> <span class="token punctuation">(</span><span class="token char string">'7'</span> <span class="token operator">`elem`</span> <span class="token builtin">show</span> <span class="token hvariable">x</span><span class="token punctuation">)</span> <span class="token operator">&gt;&gt;</span> <span class="token builtin">return</span> <span class="token hvariable">x</span><span class="token punctuation">)</span>
<span class="token punctuation">[</span><span class="token number">7</span><span class="token punctuation">,</span><span class="token number">17</span><span class="token punctuation">,</span><span class="token number">27</span><span class="token punctuation">,</span><span class="token number">37</span><span class="token punctuation">,</span><span class="token number">47</span><span class="token punctuation">]</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>The result here is the same as the result of our previous list comprehension. How does <code>guard</code> achieve this? Let's first see how <code>guard</code> functions in conjunction with <code>&gt;&gt;</code>:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token hvariable">guard</span> <span class="token punctuation">(</span><span class="token number">5</span> <span class="token operator">&gt;</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token operator">&gt;&gt;</span> <span class="token builtin">return</span> <span class="token string">"cool"</span> <span class="token operator">::</span> <span class="token punctuation">[</span><span class="token constant">String</span><span class="token punctuation">]</span>
<span class="token punctuation">[</span><span class="token string">"cool"</span><span class="token punctuation">]</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token hvariable">guard</span> <span class="token punctuation">(</span><span class="token number">1</span> <span class="token operator">&gt;</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token operator">&gt;&gt;</span> <span class="token builtin">return</span> <span class="token string">"cool"</span> <span class="token operator">::</span> <span class="token punctuation">[</span><span class="token constant">String</span><span class="token punctuation">]</span>
<span class="token punctuation">[</span><span class="token punctuation">]</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>If <code>guard</code> succeeds, the result contained within it is an empty tuple. So then, we use <code>&gt;&gt;</code> to ignore that empty tuple and present something else as the result. However, if <code>guard</code> fails, then so will the <code>return</code> later on, because feeding an empty list to a function with <code>&gt;&gt;=</code> always results in an empty list. A <code>guard</code> basically says: if this boolean is <code>False</code> then produce a failure right here, otherwise make a successful value that has a dummy result of <code>()</code> inside it. All this does is to allow the computation to continue.</p></div><div><p>Here's the previous example rewritten in <code>do</code> notation:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">sevensOnly</span> <span class="token operator">::</span> <span class="token punctuation">[</span><span class="token constant">Int</span><span class="token punctuation">]</span>
<span class="token hvariable">sevensOnly</span> <span class="token operator">=</span> <span class="token keyword">do</span>
    <span class="token hvariable">x</span> <span class="token operator">&lt;-</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token operator">..</span><span class="token number">50</span><span class="token punctuation">]</span>
    <span class="token hvariable">guard</span> <span class="token punctuation">(</span><span class="token char string">'7'</span> <span class="token operator">`elem`</span> <span class="token builtin">show</span> <span class="token hvariable">x</span><span class="token punctuation">)</span>
    <span class="token builtin">return</span> <span class="token hvariable">x</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Had we forgotten to present <code>x</code> as the final result by using <code>return</code>, the resulting list would just be a list of empty tuples. Here's this again in the form of a list comprehension:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token punctuation">[</span> <span class="token hvariable">x</span> <span class="token operator">|</span> <span class="token hvariable">x</span> <span class="token operator">&lt;-</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token operator">..</span><span class="token number">50</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token char string">'7'</span> <span class="token operator">`elem`</span> <span class="token builtin">show</span> <span class="token hvariable">x</span> <span class="token punctuation">]</span>
<span class="token punctuation">[</span><span class="token number">7</span><span class="token punctuation">,</span><span class="token number">17</span><span class="token punctuation">,</span><span class="token number">27</span><span class="token punctuation">,</span><span class="token number">37</span><span class="token punctuation">,</span><span class="token number">47</span><span class="token punctuation">]</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>So filtering in list comprehensions is the same as using <code>guard</code>.</p></div><div><h3 data-heading="A knight's quest" id="A_knight's_quest" style="display: flex;"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>A knight's quest</h3></div><div><p>Here's a problem that really lends itself to being solved with non-determinism. Say you have a chess board and only one knight piece on it. We want to find out if the knight can reach a certain position in three moves. We'll just use a pair of numbers to represent the knight's position on the chess board. The first number will determine the column he's in and the second number will determine the row.</p></div><div><p><span alt="LYHfGG_104_chess.png" src="LYHfGG_104_chess.png" class="internal-embed media-embed image-embed is-loaded"><img alt="LYHfGG_104_chess.png" src="курсы\learn-you-a-haskell-for-great-good!\картинки\lyhfgg_104_chess.png"></span></p></div><div><p>Let's make a type synonym for the knight's current position on the chess board:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token keyword">type</span> <span class="token constant">KnightPos</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token constant">Int</span><span class="token punctuation">,</span><span class="token constant">Int</span><span class="token punctuation">)</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>So let's say that the knight starts at <code>(6,2)</code>. Can he get to <code>(6,1)</code> in exactly three moves? Let's see. If we start off at <code>(6,2)</code> what's the best move to make next? I know, how about all of them! We have non-determinism at our disposal, so instead of picking one move, let's just pick all of them at once. Here's a function that takes the knight's position and returns all of its next moves:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">moveKnight</span> <span class="token operator">::</span> <span class="token constant">KnightPos</span> <span class="token operator">-&gt;</span> <span class="token punctuation">[</span><span class="token constant">KnightPos</span><span class="token punctuation">]</span>
<span class="token hvariable">moveKnight</span> <span class="token punctuation">(</span><span class="token hvariable">c</span><span class="token punctuation">,</span><span class="token hvariable">r</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token keyword">do</span>
    <span class="token punctuation">(</span><span class="token hvariable">c'</span><span class="token punctuation">,</span><span class="token hvariable">r'</span><span class="token punctuation">)</span> <span class="token operator">&lt;-</span> <span class="token punctuation">[</span><span class="token punctuation">(</span><span class="token hvariable">c</span><span class="token operator">+</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token hvariable">r</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token hvariable">c</span><span class="token operator">+</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token hvariable">r</span><span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token hvariable">c</span><span class="token operator">-</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token hvariable">r</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token hvariable">c</span><span class="token operator">-</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token hvariable">r</span><span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span>
               <span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token hvariable">c</span><span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token hvariable">r</span><span class="token operator">-</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token hvariable">c</span><span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token hvariable">r</span><span class="token operator">+</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token hvariable">c</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token hvariable">r</span><span class="token operator">-</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token hvariable">c</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token hvariable">r</span><span class="token operator">+</span><span class="token number">2</span><span class="token punctuation">)</span>
               <span class="token punctuation">]</span>
    <span class="token hvariable">guard</span> <span class="token punctuation">(</span><span class="token hvariable">c'</span> <span class="token operator">`elem`</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token operator">..</span><span class="token number">8</span><span class="token punctuation">]</span> <span class="token operator">&amp;&amp;</span> <span class="token hvariable">r'</span> <span class="token operator">`elem`</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token operator">..</span><span class="token number">8</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
    <span class="token builtin">return</span> <span class="token punctuation">(</span><span class="token hvariable">c'</span><span class="token punctuation">,</span><span class="token hvariable">r'</span><span class="token punctuation">)</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>The knight can always take one step horizontally or vertically and two steps horizontally or vertically but its movement has to be both horizontal and vertical. <code>(c',r')</code> takes on every value from the list of movements and then <code>guard</code> makes sure that the new move, <code>(c',r')</code> is still on the board. If it it's not, it produces an empty list, which causes a failure and <code>return (c',r')</code> isn't carried out for that position.</p></div><div><p>This function can also be written without the use of lists as a monad, but we did it here just for kicks. Here is the same function done with <code>filter</code>:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">moveKnight</span> <span class="token operator">::</span> <span class="token constant">KnightPos</span> <span class="token operator">-&gt;</span> <span class="token punctuation">[</span><span class="token constant">KnightPos</span><span class="token punctuation">]</span>
<span class="token hvariable">moveKnight</span> <span class="token punctuation">(</span><span class="token hvariable">c</span><span class="token punctuation">,</span><span class="token hvariable">r</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token builtin">filter</span> <span class="token hvariable">onBoard</span>
    <span class="token punctuation">[</span><span class="token punctuation">(</span><span class="token hvariable">c</span><span class="token operator">+</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token hvariable">r</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token hvariable">c</span><span class="token operator">+</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token hvariable">r</span><span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token hvariable">c</span><span class="token operator">-</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token hvariable">r</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token hvariable">c</span><span class="token operator">-</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token hvariable">r</span><span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span>
    <span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token hvariable">c</span><span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token hvariable">r</span><span class="token operator">-</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token hvariable">c</span><span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token hvariable">r</span><span class="token operator">+</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token hvariable">c</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token hvariable">r</span><span class="token operator">-</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token hvariable">c</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token hvariable">r</span><span class="token operator">+</span><span class="token number">2</span><span class="token punctuation">)</span>
    <span class="token punctuation">]</span>
    <span class="token keyword">where</span> <span class="token hvariable">onBoard</span> <span class="token punctuation">(</span><span class="token hvariable">c</span><span class="token punctuation">,</span><span class="token hvariable">r</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token hvariable">c</span> <span class="token operator">`elem`</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token operator">..</span><span class="token number">8</span><span class="token punctuation">]</span> <span class="token operator">&amp;&amp;</span> <span class="token hvariable">r</span> <span class="token operator">`elem`</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token operator">..</span><span class="token number">8</span><span class="token punctuation">]</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Both of these do the same thing, so pick one that you think looks nicer. Let's give it a whirl:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token hvariable">moveKnight</span> <span class="token punctuation">(</span><span class="token number">6</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">)</span>
<span class="token punctuation">[</span><span class="token punctuation">(</span><span class="token number">8</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token number">8</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token number">7</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">]</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token hvariable">moveKnight</span> <span class="token punctuation">(</span><span class="token number">8</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">)</span>
<span class="token punctuation">[</span><span class="token punctuation">(</span><span class="token number">6</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token number">7</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">]</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Works like a charm! We take one position and we just carry out all the possible moves at once, so to speak. So now that we have a non-deterministic next position, we just use <code>&gt;&gt;=</code> to feed it to <code>moveKnight</code>. Here's a function that takes a position and returns all the positions that you can reach from it in three moves:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">in3</span> <span class="token operator">::</span> <span class="token constant">KnightPos</span> <span class="token operator">-&gt;</span> <span class="token punctuation">[</span><span class="token constant">KnightPos</span><span class="token punctuation">]</span>
<span class="token hvariable">in3</span> <span class="token hvariable">start</span> <span class="token operator">=</span> <span class="token keyword">do</span> 
    <span class="token hvariable">first</span> <span class="token operator">&lt;-</span> <span class="token hvariable">moveKnight</span> <span class="token hvariable">start</span>
    <span class="token hvariable">second</span> <span class="token operator">&lt;-</span> <span class="token hvariable">moveKnight</span> <span class="token hvariable">first</span>
    <span class="token hvariable">moveKnight</span> <span class="token hvariable">second</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>If you pass it <code>(6,2)</code>, the resulting list is quite big, because if there are several ways to reach some position in three moves, it crops up in the list several times. The above without <code>do</code> notation:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">in3</span> <span class="token hvariable">start</span> <span class="token operator">=</span> <span class="token builtin">return</span> <span class="token hvariable">start</span> <span class="token operator">&gt;&gt;=</span> <span class="token hvariable">moveKnight</span> <span class="token operator">&gt;&gt;=</span> <span class="token hvariable">moveKnight</span> <span class="token operator">&gt;&gt;=</span> <span class="token hvariable">moveKnight</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Using <code>&gt;&gt;=</code> once gives us all possible moves from the start and then when we use <code>&gt;&gt;=</code> the second time, for every possible first move, every possible next move is computed, and the same goes for the last move.</p></div><div><p>Putting a value in a default context by applying <code>return</code> to it and then feeding it to a function with <code>&gt;&gt;=</code> is the same as just normally applying the function to that value, but we did it here anyway for style.</p></div><div><p>Now, let's make a function that takes two positions and tells us if you can get from one to the other in exactly three steps:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">canReachIn3</span> <span class="token operator">::</span> <span class="token constant">KnightPos</span> <span class="token operator">-&gt;</span> <span class="token constant">KnightPos</span> <span class="token operator">-&gt;</span> <span class="token constant">Bool</span>
<span class="token hvariable">canReachIn3</span> <span class="token hvariable">start</span> <span class="token hvariable">end</span> <span class="token operator">=</span> <span class="token hvariable">end</span> <span class="token operator">`elem`</span> <span class="token hvariable">in3</span> <span class="token hvariable">start</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>We generate all the possible positions in three steps and then we see if the position we're looking for is among them. So let's see if we can get from <code>(6,2)</code> to <code>(6,1)</code> in three moves:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token punctuation">(</span><span class="token number">6</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">)</span> <span class="token operator">`canReachIn3`</span> <span class="token punctuation">(</span><span class="token number">6</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">)</span>
<span class="token constant">True</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Yes! How about from <code>(6,2)</code> to <code>(7,3)</code>?</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token punctuation">(</span><span class="token number">6</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">)</span> <span class="token operator">`canReachIn3`</span> <span class="token punctuation">(</span><span class="token number">7</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">)</span>
<span class="token constant">False</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>No! As an exercise, you can change this function so that when you can reach one position from the other, it tells you which moves to take. Later on, we'll see how to modify this function so that we also pass it the number of moves to take instead of that number being hardcoded like it is now.</p></div><div><h2 data-heading="Monad laws" id="Monad_laws" style="display: flex;"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>Monad laws</h2></div><div><p><span alt="LYHfGG_105_judgedog.png" src="LYHfGG_105_judgedog.png" class="internal-embed media-embed image-embed is-loaded"><img alt="LYHfGG_105_judgedog.png" src="курсы\learn-you-a-haskell-for-great-good!\картинки\lyhfgg_105_judgedog.png"></span></p></div><div><p>Just like applicative functors, and functors before them, monads come with a few laws that all monad instances must abide by. Just because something is made an instance of the <code>Monad</code> type class doesn't mean that it's a monad, it just means that it was made an instance of a type class. For a type to truly be a monad, the monad laws must hold for that type. These laws allow us to make reasonable assumptions about the type and its behavior.</p></div><div><p>Haskell allows any type to be an instance of any type class as long as the types check out. It can't check if the monad laws hold for a type though, so if we're making a new instance of the <code>Monad</code> type class, we have to be reasonably sure that all is well with the monad laws for that type. We can rely on the types that come with the standard library to satisfy the laws, but later when we go about making our own monads, we're going to have to manually check the if the laws hold. But don't worry, they're not complicated.</p></div><div><h3 data-heading="Left identity" id="Left_identity" style="display: flex;"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>Left identity</h3></div><div><p>The first monad law states that if we take a value, put it in a default context with <code>return</code> and then feed it to a function by using <code>&gt;&gt;=</code>, it's the same as just taking the value and applying the function to it. To put it formally:</p></div><div><ul class="has-list-bullet">
<li data-line="0"><div class="list-bullet"></div><code>return x &gt;&gt;= f</code> is the same damn thing as <code>f x</code></li>
</ul></div><div><p>If you look at monadic values as values with a context and <code>return</code> as taking a value and putting it in a default minimal context that still presents that value as its result, it makes sense, because if that context is really minimal, feeding this monadic value to a function shouldn't be much different than just applying the function to the normal value, and indeed it isn't different at all.</p></div><div><p>For the <code>Maybe</code> monad <code>return</code> is defined as <code>Just</code>. The <code>Maybe</code> monad is all about possible failure, and if we have a value and want to put it in such a context, it makes sense that we treat it as a successful computation because, well, we know what the value is. Here's some <code>return</code> usage with <code>Maybe</code>:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token builtin">return</span> <span class="token number">3</span> <span class="token operator">&gt;&gt;=</span> <span class="token punctuation">(</span><span class="token operator">\</span><span class="token hvariable">x</span> <span class="token operator">-&gt;</span> <span class="token constant">Just</span> <span class="token punctuation">(</span><span class="token hvariable">x</span><span class="token operator">+</span><span class="token number">100000</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token constant">Just</span> <span class="token number">100003</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token punctuation">(</span><span class="token operator">\</span><span class="token hvariable">x</span> <span class="token operator">-&gt;</span> <span class="token constant">Just</span> <span class="token punctuation">(</span><span class="token hvariable">x</span><span class="token operator">+</span><span class="token number">100000</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token number">3</span>
<span class="token constant">Just</span> <span class="token number">100003</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>For the list monad <code>return</code> puts something in a singleton list. The <code>&gt;&gt;=</code> implementation for lists goes over all the values in the list and applies the function to them, but since there's only one value in a singleton list, it's the same as applying the function to that value:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token builtin">return</span> <span class="token string">"WoM"</span> <span class="token operator">&gt;&gt;=</span> <span class="token punctuation">(</span><span class="token operator">\</span><span class="token hvariable">x</span> <span class="token operator">-&gt;</span> <span class="token punctuation">[</span><span class="token hvariable">x</span><span class="token punctuation">,</span><span class="token hvariable">x</span><span class="token punctuation">,</span><span class="token hvariable">x</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
<span class="token punctuation">[</span><span class="token string">"WoM"</span><span class="token punctuation">,</span><span class="token string">"WoM"</span><span class="token punctuation">,</span><span class="token string">"WoM"</span><span class="token punctuation">]</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token punctuation">(</span><span class="token operator">\</span><span class="token hvariable">x</span> <span class="token operator">-&gt;</span> <span class="token punctuation">[</span><span class="token hvariable">x</span><span class="token punctuation">,</span><span class="token hvariable">x</span><span class="token punctuation">,</span><span class="token hvariable">x</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token string">"WoM"</span>
<span class="token punctuation">[</span><span class="token string">"WoM"</span><span class="token punctuation">,</span><span class="token string">"WoM"</span><span class="token punctuation">,</span><span class="token string">"WoM"</span><span class="token punctuation">]</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>We said that for <code>IO</code>, using <code>return</code> makes an I/O action that has no side-effects but just presents a value as its result. So it makes sense that this law holds for <code>IO</code> as well.</p></div><div><h3 data-heading="Right identity" id="Right_identity" style="display: flex;"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>Right identity</h3></div><div><p>The second law states that if we have a monadic value and we use <code>&gt;&gt;=</code> to feed it to <code>return</code>, the result is our original monadic value. Formally:</p></div><div><ul class="has-list-bullet">
<li data-line="0"><div class="list-bullet"></div><code>m &gt;&gt;= return</code> is no different than just <code>m</code></li>
</ul></div><div><p>This one might be a bit less obvious than the first one, but let's take a look at why it should hold. When we feed monadic values to functions by using <code>&gt;&gt;=</code>, those functions take normal values and return monadic ones. <code>return</code> is also one such function, if you consider its type. Like we said, <code>return</code> puts a value in a minimal context that still presents that value as its result. This means that, for instance, for <code>Maybe</code>, it doesn't introduce any failure and for lists, it doesn't introduce any extra non-determinism. Here's a test run for a few monads:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token constant">Just</span> <span class="token string">"move on up"</span> <span class="token operator">&gt;&gt;=</span> <span class="token punctuation">(</span><span class="token operator">\</span><span class="token hvariable">x</span> <span class="token operator">-&gt;</span> <span class="token builtin">return</span> <span class="token hvariable">x</span><span class="token punctuation">)</span>
<span class="token constant">Just</span> <span class="token string">"move on up"</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">]</span> <span class="token operator">&gt;&gt;=</span> <span class="token punctuation">(</span><span class="token operator">\</span><span class="token hvariable">x</span> <span class="token operator">-&gt;</span> <span class="token builtin">return</span> <span class="token hvariable">x</span><span class="token punctuation">)</span>
<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">]</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token builtin">putStrLn</span> <span class="token string">"Wah!"</span> <span class="token operator">&gt;&gt;=</span> <span class="token punctuation">(</span><span class="token operator">\</span><span class="token hvariable">x</span> <span class="token operator">-&gt;</span> <span class="token builtin">return</span> <span class="token hvariable">x</span><span class="token punctuation">)</span>
<span class="token constant">Wah</span><span class="token operator">!</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>If we take a closer look at the list example, the implementation for <code>&gt;&gt;=</code> is:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">xs</span> <span class="token operator">&gt;&gt;=</span> <span class="token hvariable">f</span> <span class="token operator">=</span> <span class="token builtin">concat</span> <span class="token punctuation">(</span><span class="token builtin">map</span> <span class="token hvariable">f</span> <span class="token hvariable">xs</span><span class="token punctuation">)</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>So when we feed <code>[1,2,3,4]</code> to <code>return</code>, first <code>return</code> gets mapped over <code>[1,2,3,4]</code>, resulting in <code>[[1],[2],[3],[4]]</code> and then this gets concatenated and we have our original list.</p></div><div><p>Left identity and right identity are basically laws that describe how <code>return</code> should behave. It's an important function for making normal values into monadic ones and it wouldn't be good if the monadic value that it produced did a lot of other stuff.</p></div><div><h3 data-heading="Associativity" id="Associativity" style="display: flex;"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>Associativity</h3></div><div><p>The final monad law says that when we have a chain of monadic function applications with <code>&gt;&gt;=</code>, it shouldn't matter how they're nested. Formally written:</p></div><div><ul class="has-list-bullet">
<li data-line="0"><div class="list-bullet"></div>Doing <code>(m &gt;&gt;= f) &gt;&gt;= g</code> is just like doing <code>m &gt;&gt;= (\x -&gt; f x &gt;&gt;= g)</code></li>
</ul></div><div><p>Hmmm, now what's going on here? We have one monadic value, <code>m</code> and two monadic functions <code>f</code> and <code>g</code>. When we're doing <code>(m &gt;&gt;= f) &gt;&gt;= g</code>, we're feeding <code>m</code> to <code>f</code>, which results in a monadic value. Then, we feed that monadic value to <code>g</code>. In the expression <code>m &gt;&gt;= (\x -&gt; f x &gt;&gt;= g)</code>, we take a monadic value and we feed it to a function that feeds the result of <code>f x</code> to <code>g</code>. It's not easy to see how those two are equal, so let's take a look at an example that makes this equality a bit clearer.</p></div><div><p>Remember when we had our tightrope walker Pierre walk a rope while birds landed on his balancing pole? To simulate birds landing on his balancing pole, we made a chain of several functions that might produce failure:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token builtin">return</span> <span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">&gt;&gt;=</span> <span class="token hvariable">landRight</span> <span class="token number">2</span> <span class="token operator">&gt;&gt;=</span> <span class="token hvariable">landLeft</span> <span class="token number">2</span> <span class="token operator">&gt;&gt;=</span> <span class="token hvariable">landRight</span> <span class="token number">2</span>
<span class="token constant">Just</span> <span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">)</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>We started with <code>Just (0,0)</code> and then bound that value to the next monadic function, <code>landRight 2</code>. The result of that was another monadic value which got bound into the next monadic function, and so on. If we were to explicitly parenthesize this, we'd write:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token builtin">return</span> <span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">&gt;&gt;=</span> <span class="token hvariable">landRight</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token operator">&gt;&gt;=</span> <span class="token hvariable">landLeft</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token operator">&gt;&gt;=</span> <span class="token hvariable">landRight</span> <span class="token number">2</span>
<span class="token constant">Just</span> <span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">)</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>But we can also write the routine like this:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token builtin">return</span> <span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">&gt;&gt;=</span> <span class="token punctuation">(</span><span class="token operator">\</span><span class="token hvariable">x</span> <span class="token operator">-&gt;</span>
<span class="token hvariable">landRight</span> <span class="token number">2</span> <span class="token hvariable">x</span> <span class="token operator">&gt;&gt;=</span> <span class="token punctuation">(</span><span class="token operator">\</span><span class="token hvariable">y</span> <span class="token operator">-&gt;</span>
<span class="token hvariable">landLeft</span> <span class="token number">2</span> <span class="token hvariable">y</span> <span class="token operator">&gt;&gt;=</span> <span class="token punctuation">(</span><span class="token operator">\</span><span class="token hvariable">z</span> <span class="token operator">-&gt;</span>
<span class="token hvariable">landRight</span> <span class="token number">2</span> <span class="token hvariable">z</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p><code>return (0,0)</code> is the same as <code>Just (0,0)</code> and when we feed it to the lambda, the <code>x</code> becomes <code>(0,0)</code>. <code>landRight</code> takes a number of birds and a pole (a tuple of numbers) and that's what it gets passed. This results in a <code>Just (0,2)</code> and when we feed this to the next lambda, <code>y</code> is <code>(0,2)</code>. This goes on until the final bird landing produces a <code>Just (2,4)</code>, which is indeed the result of the whole expression.</p></div><div><p>So it doesn't matter how you nest feeding values to monadic functions, what matters is their meaning. Here's another way to look at this law: consider composing two functions, <code>f</code> and <code>g</code>. Composing two functions is implemented like so:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token punctuation">(</span><span class="token punctuation">.</span><span class="token punctuation">)</span> <span class="token operator">::</span> <span class="token punctuation">(</span><span class="token hvariable">b</span> <span class="token operator">-&gt;</span> <span class="token hvariable">c</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token punctuation">(</span><span class="token hvariable">a</span> <span class="token operator">-&gt;</span> <span class="token hvariable">b</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token punctuation">(</span><span class="token hvariable">a</span> <span class="token operator">-&gt;</span> <span class="token hvariable">c</span><span class="token punctuation">)</span>
<span class="token hvariable">f</span> <span class="token operator">.</span> <span class="token hvariable">g</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token operator">\</span><span class="token hvariable">x</span> <span class="token operator">-&gt;</span> <span class="token hvariable">f</span> <span class="token punctuation">(</span><span class="token hvariable">g</span> <span class="token hvariable">x</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>If the type of <code>g</code> is <code>a -&gt; b</code> and the type of <code>f</code> is <code>b -&gt; c</code>, we arrange them into a new function which has a type of <code>a -&gt; c</code>, so that its parameter is passed between those functions. Now what if those two functions were monadic, that is, what if the values they returned were monadic values? If we had a function of type <code>a -&gt; m b</code>, we couldn't just pass its result to a function of type <code>b -&gt; m c</code>, because that function accepts a normal <code>b</code>, not a monadic one. We could however, use <code>&gt;&gt;=</code> to make that happen. So by using <code>&gt;&gt;=</code>, we can compose two monadic functions:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token punctuation">(</span><span class="token operator">&lt;=&lt;</span><span class="token punctuation">)</span> <span class="token operator">::</span> <span class="token punctuation">(</span><span class="token constant">Monad</span> <span class="token hvariable">m</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">(</span><span class="token hvariable">b</span> <span class="token operator">-&gt;</span> <span class="token hvariable">m</span> <span class="token hvariable">c</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token punctuation">(</span><span class="token hvariable">a</span> <span class="token operator">-&gt;</span> <span class="token hvariable">m</span> <span class="token hvariable">b</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token punctuation">(</span><span class="token hvariable">a</span> <span class="token operator">-&gt;</span> <span class="token hvariable">m</span> <span class="token hvariable">c</span><span class="token punctuation">)</span>
<span class="token hvariable">f</span> <span class="token operator">&lt;=&lt;</span> <span class="token hvariable">g</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token operator">\</span><span class="token hvariable">x</span> <span class="token operator">-&gt;</span> <span class="token hvariable">g</span> <span class="token hvariable">x</span> <span class="token operator">&gt;&gt;=</span> <span class="token hvariable">f</span><span class="token punctuation">)</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>So now we can compose two monadic functions:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token keyword">let</span> <span class="token hvariable">f</span> <span class="token hvariable">x</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token hvariable">x</span><span class="token punctuation">,</span><span class="token operator">-</span><span class="token hvariable">x</span><span class="token punctuation">]</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token keyword">let</span> <span class="token hvariable">g</span> <span class="token hvariable">x</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token hvariable">x</span><span class="token operator">*</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token hvariable">x</span><span class="token operator">*</span><span class="token number">2</span><span class="token punctuation">]</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token keyword">let</span> <span class="token hvariable">h</span> <span class="token operator">=</span> <span class="token hvariable">f</span> <span class="token operator">&lt;=&lt;</span> <span class="token hvariable">g</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token hvariable">h</span> <span class="token number">3</span>
<span class="token punctuation">[</span><span class="token number">9</span><span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">9</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">6</span><span class="token punctuation">]</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Cool. So what does that have to do with the associativity law? Well, when we look at the law as a law of compositions, it states that <code>f &lt;=&lt; (g &lt;=&lt; h)</code> should be the same as <code>(f &lt;=&lt; g) &lt;=&lt; h</code>. This is just another way of saying that for monads, the nesting of operations shouldn't matter.</p></div><div><p>If we translate the first two laws to use <code>&lt;=&lt;</code>, then the left identity law states that for every monadic function <code>f</code>, <code>f &lt;=&lt; return</code> is the same as writing just <code>f</code> and the right identity law says that <code>return &lt;=&lt; f</code> is also no different from <code>f</code>.</p></div><div><p>This is very similar to how if <code>f</code> is a normal function, <code>(f . g) . h</code> is the same as <code>f . (g . h)</code>, <code>f . id</code> is always the same as <code>f</code> and <code>id . f</code> is also just <code>f</code>.</p></div><div><p>In this chapter, we took a look at the basics of monads and learned how the <code>Maybe</code> monad and the list monad work. In the next chapter, we'll take a look at a whole bunch of other cool monads and we'll also learn how to make our own.</p></div><div><h1 data-heading="For a Few Monads More" id="For_a_Few_Monads_More">For a Few Monads More</h1></div><div><p><span alt="LYHfGG_106_clint.png" src="LYHfGG_106_clint.png" class="internal-embed media-embed image-embed is-loaded"><img alt="LYHfGG_106_clint.png" src="курсы\learn-you-a-haskell-for-great-good!\картинки\lyhfgg_106_clint.png"></span></p></div><div><p>We've seen how monads can be used to take values with contexts and apply them to functions and how using <code>&gt;&gt;=</code> or <code>do</code> notation allows us to focus on the values themselves while the context gets handled for us.</p></div><div><p>We've met the <code>Maybe</code> monad and seen how it adds a context of possible failure to values. We've learned about the list monad and saw how it lets us easily introduce non-determinism into our programs. We've also learned how to work in the <code>IO</code> monad, even before we knew what a monad was!</p></div><div><p>In this chapter, we're going to learn about a few other monads. We'll see how they can make our programs clearer by letting us treat all sorts of values as monadic ones. Exploring a few monads more will also solidify our intuition for monads.</p></div><div><p>The monads that we'll be exploring are all part of the <code>mtl</code> package. A Haskell package is a collection of modules. The <code>mtl</code> package comes with the Haskell Platform, so you probably already have it. To check if you do, type <code>ghc-pkg list</code> in the command-line. This will show which Haskell packages you have installed and one of them should be <code>mtl</code>, followed by a version number.</p></div><div><h2 data-heading="Writer? I hardly know her!" id="Writer?_I_hardly_know_her!" style="display: flex;"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>Writer? I hardly know her!</h2></div><div><p>We've loaded our gun with the <code>Maybe</code> monad, the list monad and the <code>IO</code> monad. Now let's put the <code>Writer</code> monad in the chamber and see what happens when we fire it!</p></div><div><p>Whereas <code>Maybe</code> is for values with an added context of failure and the list is for non-deterministic values, the <code>Writer</code> monad is for values that have another value attached that acts as a sort of log value. <code>Writer</code> allows us to do computations while making sure that all the log values are combined into one log value that then gets attached to the result.</p></div><div><p>For instance, we might want to equip our values with strings that explain what's going on, probably for debugging purposes. Consider a function that takes a number of bandits in a gang and tells us if that's a big gang or not. That's a very simple function:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">isBigGang</span> <span class="token operator">::</span> <span class="token constant">Int</span> <span class="token operator">-&gt;</span> <span class="token constant">Bool</span>
<span class="token hvariable">isBigGang</span> <span class="token hvariable">x</span> <span class="token operator">=</span> <span class="token hvariable">x</span> <span class="token operator">&gt;</span> <span class="token number">9</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Now, what if instead of just giving us a <code>True</code> or <code>False</code> value, we want it to also return a log string that says what it did? Well, we just make that string and return it along side our <code>Bool</code>:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">isBigGang</span> <span class="token operator">::</span> <span class="token constant">Int</span> <span class="token operator">-&gt;</span> <span class="token punctuation">(</span><span class="token constant">Bool</span><span class="token punctuation">,</span> <span class="token constant">String</span><span class="token punctuation">)</span>
<span class="token hvariable">isBigGang</span> <span class="token hvariable">x</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token hvariable">x</span> <span class="token operator">&gt;</span> <span class="token number">9</span><span class="token punctuation">,</span> <span class="token string">"Compared gang size to 9."</span><span class="token punctuation">)</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>So now instead of just returning a <code>Bool</code>, we return a tuple where the first component of the tuple is the actual value and the second component is the string that accompanies that value. There's some added context to our value now. Let's give this a go:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token hvariable">isBigGang</span> <span class="token number">3</span>
<span class="token punctuation">(</span><span class="token constant">False</span><span class="token punctuation">,</span><span class="token string">"Compared gang size to 9."</span><span class="token punctuation">)</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token hvariable">isBigGang</span> <span class="token number">30</span>
<span class="token punctuation">(</span><span class="token constant">True</span><span class="token punctuation">,</span><span class="token string">"Compared gang size to 9."</span><span class="token punctuation">)</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p><span alt="LYHfGG_107_tuco.png" src="LYHfGG_107_tuco.png" class="internal-embed media-embed image-embed is-loaded"><img alt="LYHfGG_107_tuco.png" src="курсы\learn-you-a-haskell-for-great-good!\картинки\lyhfgg_107_tuco.png"></span></p></div><div><p>So far so good. <code>isBigGang</code> takes a normal value and returns a value with a context. As we've just seen, feeding it a normal value is not a problem. Now what if we already have a value that has a log string attached to it, such as <code>(3, "Smallish gang.")</code>, and we want to feed it to <code>isBigGang</code>? It seems like once again, we're faced with this question: if we have a function that takes a normal value and returns a value with a context, how do we take a value with a context and feed it to the function?</p></div><div><p>When we were exploring the <code>Maybe</code> monad, we made a function <code>applyMaybe</code>, which took a <code>Maybe a</code> value and a function of type <code>a -&gt; Maybe b</code> and fed that <code>Maybe a</code> value into the function, even though the function takes a normal <code>a</code> instead of a <code>Maybe a</code>. It did this by minding the context that comes with <code>Maybe a</code> values, which is that they are values with possible failure. But inside the <code>a -&gt; Maybe b</code> function, we were able to treat that value as just a normal value, because <code>applyMaybe</code> (which later became <code>&gt;&gt;=</code>) took care of checking if it was a <code>Nothing</code> or a <code>Just</code> value.</p></div><div><p>In the same vein, let's make a function that takes a value with an attached log, that is, an <code>(a,String)</code> value and a function of type <code>a -&gt; (b,String)</code> and feeds that value into the function. We'll call it <code>applyLog</code>. But because an <code>(a,String)</code> value doesn't carry with it a context of possible failure, but rather a context of an additional log value, <code>applyLog</code> is going to make sure that the log of the original value isn't lost, but is joined together with the log of the value that results from the function. Here's the implementation of <code>applyLog</code>:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">applyLog</span> <span class="token operator">::</span> <span class="token punctuation">(</span><span class="token hvariable">a</span><span class="token punctuation">,</span><span class="token constant">String</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token punctuation">(</span><span class="token hvariable">a</span> <span class="token operator">-&gt;</span> <span class="token punctuation">(</span><span class="token hvariable">b</span><span class="token punctuation">,</span><span class="token constant">String</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token punctuation">(</span><span class="token hvariable">b</span><span class="token punctuation">,</span><span class="token constant">String</span><span class="token punctuation">)</span>
<span class="token hvariable">applyLog</span> <span class="token punctuation">(</span><span class="token hvariable">x</span><span class="token punctuation">,</span><span class="token builtin">log</span><span class="token punctuation">)</span> <span class="token hvariable">f</span> <span class="token operator">=</span> <span class="token keyword">let</span> <span class="token punctuation">(</span><span class="token hvariable">y</span><span class="token punctuation">,</span><span class="token hvariable">newLog</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token hvariable">f</span> <span class="token hvariable">x</span> <span class="token keyword">in</span> <span class="token punctuation">(</span><span class="token hvariable">y</span><span class="token punctuation">,</span><span class="token builtin">log</span> <span class="token operator">++</span> <span class="token hvariable">newLog</span><span class="token punctuation">)</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>When we have a value with a context and we want to feed it to a function, we usually try to separate the actual value from the context and then try to apply the function to the value and then see that the context is taken care of. In the <code>Maybe</code> monad, we checked if the value was a <code>Just x</code> and if it was, we took that <code>x</code> and applied the function to it. In this case, it's very easy to find the actual value, because we're dealing with a pair where one component is the value and the other a log. So first we just take the value, which is <code>x</code> and we apply the function <code>f</code> to it. We get a pair of <code>(y,newLog)</code>, where <code>y</code> is the new result and <code>newLog</code> the new log. But if we returned that as the result, the old log value wouldn't be included in the result, so we return a pair of <code>(y,log ++ newLog)</code>. We use <code>++</code> to append the new log to the old one.</p></div><div><p>Here's <code>applyLog</code> in action:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token string">"Smallish gang."</span><span class="token punctuation">)</span> <span class="token operator">`applyLog`</span> <span class="token hvariable">isBigGang</span>
<span class="token punctuation">(</span><span class="token constant">False</span><span class="token punctuation">,</span><span class="token string">"Smallish gang.Compared gang size to 9"</span><span class="token punctuation">)</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token punctuation">(</span><span class="token number">30</span><span class="token punctuation">,</span> <span class="token string">"A freaking platoon."</span><span class="token punctuation">)</span> <span class="token operator">`applyLog`</span> <span class="token hvariable">isBigGang</span>
<span class="token punctuation">(</span><span class="token constant">True</span><span class="token punctuation">,</span><span class="token string">"A freaking platoon.Compared gang size to 9"</span><span class="token punctuation">)</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>The results are similar to before, only now the number of people in the gang had its accompanying log and it got included in the result log. Here are a few more examples of using <code>applyLog</code>:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token punctuation">(</span><span class="token string">"Tobin"</span><span class="token punctuation">,</span><span class="token string">"Got outlaw name."</span><span class="token punctuation">)</span> <span class="token operator">`applyLog`</span> <span class="token punctuation">(</span><span class="token operator">\</span><span class="token hvariable">x</span> <span class="token operator">-&gt;</span> <span class="token punctuation">(</span><span class="token builtin">length</span> <span class="token hvariable">x</span><span class="token punctuation">,</span> <span class="token string">"Applied length."</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token string">"Got outlaw name.Applied length."</span><span class="token punctuation">)</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token punctuation">(</span><span class="token string">"Bathcat"</span><span class="token punctuation">,</span><span class="token string">"Got outlaw name."</span><span class="token punctuation">)</span> <span class="token operator">`applyLog`</span> <span class="token punctuation">(</span><span class="token operator">\</span><span class="token hvariable">x</span> <span class="token operator">-&gt;</span> <span class="token punctuation">(</span><span class="token builtin">length</span> <span class="token hvariable">x</span><span class="token punctuation">,</span> <span class="token string">"Applied length"</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token punctuation">(</span><span class="token number">7</span><span class="token punctuation">,</span><span class="token string">"Got outlaw name.Applied length"</span><span class="token punctuation">)</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>See how inside the lambda, <code>x</code> is just a normal string and not a tuple and how <code>applyLog</code> takes care of appending the logs.</p></div><div><h3 data-heading="Monoids to the rescue" id="Monoids_to_the_rescue" style="display: flex;"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>Monoids to the rescue</h3></div><div><blockquote>
<p>Be sure you know what <a data-tooltip-position="top" aria-label="http://learnyouahaskell.com/functors-applicative-functors-and-monoids#monoids" rel="noopener" class="external-link" href="http://learnyouahaskell.com/functors-applicative-functors-and-monoids#monoids" target="_blank">monoids</a> are at this point! Cheers.</p>
</blockquote></div><div><p>Right now, <code>applyLog</code> takes values of type <code>(a,String)</code>, but is there a reason that the log has to be a <code>String</code>? It uses <code>++</code> to append the logs, so wouldn't this work on any kind of list, not just a list of characters? Sure it would. We can go ahead and change its type to this:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">applyLog</span> <span class="token operator">::</span> <span class="token punctuation">(</span><span class="token hvariable">a</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token hvariable">c</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token punctuation">(</span><span class="token hvariable">a</span> <span class="token operator">-&gt;</span> <span class="token punctuation">(</span><span class="token hvariable">b</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token hvariable">c</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token punctuation">(</span><span class="token hvariable">b</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token hvariable">c</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Now, the log is a list. The type of values contained in the list has to be the same for the original list as well as for the list that the function returns, otherwise we wouldn't be able to use <code>++</code> to stick them together.</p></div><div><p>Would this work for bytestrings? There's no reason it shouldn't. However, the type we have now only works for lists. It seems like we'd have to make a separate <code>applyLog</code> for bytestrings. But wait! Both lists and bytestrings are monoids. As such, they are both instances of the <code>Monoid</code> type class, which means that they implement the <code>mappend</code> function. And for both lists and bytestrings, <code>mappend</code> is for appending. Watch:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">]</span> <span class="token operator">`mappend`</span> <span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">]</span>
<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">]</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token constant">B</span><span class="token punctuation">.</span><span class="token builtin">pack</span> <span class="token punctuation">[</span><span class="token number">99</span><span class="token punctuation">,</span><span class="token number">104</span><span class="token punctuation">,</span><span class="token number">105</span><span class="token punctuation">]</span> <span class="token operator">`mappend`</span> <span class="token constant">B</span><span class="token punctuation">.</span><span class="token builtin">pack</span> <span class="token punctuation">[</span><span class="token number">104</span><span class="token punctuation">,</span><span class="token number">117</span><span class="token punctuation">,</span><span class="token number">97</span><span class="token punctuation">,</span><span class="token number">104</span><span class="token punctuation">,</span><span class="token number">117</span><span class="token punctuation">,</span><span class="token number">97</span><span class="token punctuation">]</span>
<span class="token constant">Chunk</span> <span class="token string">"chi"</span> <span class="token punctuation">(</span><span class="token constant">Chunk</span> <span class="token string">"huahua"</span> <span class="token constant">Empty</span><span class="token punctuation">)</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Cool! Now our <code>applyLog</code> can work for any monoid. We have to change the type to reflect this, as well as the implementation, because we have to change <code>++</code> to <code>mappend</code>:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">applyLog</span> <span class="token operator">::</span> <span class="token punctuation">(</span><span class="token constant">Monoid</span> <span class="token hvariable">m</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">(</span><span class="token hvariable">a</span><span class="token punctuation">,</span><span class="token hvariable">m</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token punctuation">(</span><span class="token hvariable">a</span> <span class="token operator">-&gt;</span> <span class="token punctuation">(</span><span class="token hvariable">b</span><span class="token punctuation">,</span><span class="token hvariable">m</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token punctuation">(</span><span class="token hvariable">b</span><span class="token punctuation">,</span><span class="token hvariable">m</span><span class="token punctuation">)</span>
<span class="token hvariable">applyLog</span> <span class="token punctuation">(</span><span class="token hvariable">x</span><span class="token punctuation">,</span><span class="token builtin">log</span><span class="token punctuation">)</span> <span class="token hvariable">f</span> <span class="token operator">=</span> <span class="token keyword">let</span> <span class="token punctuation">(</span><span class="token hvariable">y</span><span class="token punctuation">,</span><span class="token hvariable">newLog</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token hvariable">f</span> <span class="token hvariable">x</span> <span class="token keyword">in</span> <span class="token punctuation">(</span><span class="token hvariable">y</span><span class="token punctuation">,</span><span class="token builtin">log</span> <span class="token operator">`mappend`</span> <span class="token hvariable">newLog</span><span class="token punctuation">)</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Because the accompanying value can now be any monoid value, we no longer have to think of the tuple as a value and a log, but now we can think of it as a value with an accompanying monoid value. For instance, we can have a tuple that has an item name and an item price as the monoid value. We just use the <code>Sum</code> newtype to make sure that the prices get added as we operate with the items. Here's a function that adds drink to some cowboy food:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token import-statement"><span class="token keyword">import</span> Data<span class="token punctuation">.</span>Monoid</span>

<span class="token keyword">type</span> <span class="token constant">Food</span> <span class="token operator">=</span> <span class="token constant">String</span>
<span class="token keyword">type</span> <span class="token constant">Price</span> <span class="token operator">=</span> <span class="token constant">Sum</span> <span class="token constant">Int</span>

<span class="token hvariable">addDrink</span> <span class="token operator">::</span> <span class="token constant">Food</span> <span class="token operator">-&gt;</span> <span class="token punctuation">(</span><span class="token constant">Food</span><span class="token punctuation">,</span><span class="token constant">Price</span><span class="token punctuation">)</span>
<span class="token hvariable">addDrink</span> <span class="token string">"beans"</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token string">"milk"</span><span class="token punctuation">,</span> <span class="token constant">Sum</span> <span class="token number">25</span><span class="token punctuation">)</span>
<span class="token hvariable">addDrink</span> <span class="token string">"jerky"</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token string">"whiskey"</span><span class="token punctuation">,</span> <span class="token constant">Sum</span> <span class="token number">99</span><span class="token punctuation">)</span>
<span class="token hvariable">addDrink</span> <span class="token hvariable">_</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token string">"beer"</span><span class="token punctuation">,</span> <span class="token constant">Sum</span> <span class="token number">30</span><span class="token punctuation">)</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>We use strings to represent foods and an <code>Int</code> in a <code>Sum</code> <code>newtype</code> wrapper to keep track of how many cents something costs. Just a reminder, doing <code>mappend</code> with <code>Sum</code> results in the wrapped values getting added together:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token constant">Sum</span> <span class="token number">3</span> <span class="token operator">`mappend`</span> <span class="token constant">Sum</span> <span class="token number">9</span>
<span class="token constant">Sum</span> <span class="token punctuation">{</span><span class="token hvariable">getSum</span> <span class="token operator">=</span> <span class="token number">12</span><span class="token punctuation">}</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>The <code>addDrink</code> function is pretty simple. If we're eating beans, it returns <code>"milk"</code> along with <code>Sum 25</code>, so 25 cents wrapped in <code>Sum</code>. If we're eating jerky we drink whiskey and if we're eating anything else we drink beer. Just normally applying this function to a food wouldn't be terribly interesting right now, but using <code>applyLog</code> to feed a food that comes with a price itself into this function is interesting:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token punctuation">(</span><span class="token string">"beans"</span><span class="token punctuation">,</span> <span class="token constant">Sum</span> <span class="token number">10</span><span class="token punctuation">)</span> <span class="token operator">`applyLog`</span> <span class="token hvariable">addDrink</span>
<span class="token punctuation">(</span><span class="token string">"milk"</span><span class="token punctuation">,</span><span class="token constant">Sum</span> <span class="token punctuation">{</span><span class="token hvariable">getSum</span> <span class="token operator">=</span> <span class="token number">35</span><span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token punctuation">(</span><span class="token string">"jerky"</span><span class="token punctuation">,</span> <span class="token constant">Sum</span> <span class="token number">25</span><span class="token punctuation">)</span> <span class="token operator">`applyLog`</span> <span class="token hvariable">addDrink</span>
<span class="token punctuation">(</span><span class="token string">"whiskey"</span><span class="token punctuation">,</span><span class="token constant">Sum</span> <span class="token punctuation">{</span><span class="token hvariable">getSum</span> <span class="token operator">=</span> <span class="token number">124</span><span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token punctuation">(</span><span class="token string">"dogmeat"</span><span class="token punctuation">,</span> <span class="token constant">Sum</span> <span class="token number">5</span><span class="token punctuation">)</span> <span class="token operator">`applyLog`</span> <span class="token hvariable">addDrink</span>
<span class="token punctuation">(</span><span class="token string">"beer"</span><span class="token punctuation">,</span><span class="token constant">Sum</span> <span class="token punctuation">{</span><span class="token hvariable">getSum</span> <span class="token operator">=</span> <span class="token number">35</span><span class="token punctuation">}</span><span class="token punctuation">)</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Milk costs <code>25</code> cents, but if we eat it with beans that cost <code>10</code> cents, we'll end up paying <code>35</code> cents. Now it's clear how the attached value doesn't always have to be a log, it can be any monoid value and how two such values are combined into one depends on the monoid. When we were doing logs, they got appended, but now, the numbers are being added up.</p></div><div><p>Because the value that <code>addDrink</code> returns is a tuple of type <code>(Food,Price)</code>, we can feed that result to <code>addDrink</code> again, so that it tells us what we should drink along with our drink and how much that will cost us. Let's give it a shot:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token punctuation">(</span><span class="token string">"dogmeat"</span><span class="token punctuation">,</span> <span class="token constant">Sum</span> <span class="token number">5</span><span class="token punctuation">)</span> <span class="token operator">`applyLog`</span> <span class="token hvariable">addDrink</span> <span class="token operator">`applyLog`</span> <span class="token hvariable">addDrink</span>
<span class="token punctuation">(</span><span class="token string">"beer"</span><span class="token punctuation">,</span><span class="token constant">Sum</span> <span class="token punctuation">{</span><span class="token hvariable">getSum</span> <span class="token operator">=</span> <span class="token number">65</span><span class="token punctuation">}</span><span class="token punctuation">)</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Adding a drink to some dog meat results in a beer and an additional <code>30</code> cents, so <code>("beer", Sum 35)</code>. And if we use <code>applyLog</code> to feed that to <code>addDrink</code>, we get another beer and the result is <code>("beer", Sum 65)</code>.</p></div><div><h3 data-heading="The Writer type" id="The_Writer_type" style="display: flex;"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>The Writer type</h3></div><div><p>Now that we've seen that a value with an attached monoid acts like a monadic value, let's examine the <code>Monad</code> instance for types of such values. The <code>Control.Monad.Writer</code> module exports the <code>Writer w a</code> type along with its <code>Monad</code> instance and some useful functions for dealing with values of this type.</p></div><div><p>First, let's examine the type itself. To attach a monoid to a value, we just need to put them together in a tuple. The <code>Writer w a</code> type is just a <code>newtype</code> wrapper for this. Its definition is very simple:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token keyword">newtype</span> <span class="token constant">Writer</span> <span class="token hvariable">w</span> <span class="token hvariable">a</span> <span class="token operator">=</span> <span class="token constant">Writer</span> <span class="token punctuation">{</span> <span class="token hvariable">runWriter</span> <span class="token operator">::</span> <span class="token punctuation">(</span><span class="token hvariable">a</span><span class="token punctuation">,</span> <span class="token hvariable">w</span><span class="token punctuation">)</span> <span class="token punctuation">}</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>It's wrapped in a <code>newtype</code> so that it can be made an instance of <code>Monad</code> and that its type is separate from a normal tuple. The <code>a</code> type parameter represents the type of the value and the <code>w</code> type parameter the type of the attached monoid value.</p></div><div><p>Its <code>Monad</code> instance is defined like so:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token keyword">instance</span> <span class="token punctuation">(</span><span class="token constant">Monoid</span> <span class="token hvariable">w</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token constant">Monad</span> <span class="token punctuation">(</span><span class="token constant">Writer</span> <span class="token hvariable">w</span><span class="token punctuation">)</span> <span class="token keyword">where</span>
    <span class="token builtin">return</span> <span class="token hvariable">x</span> <span class="token operator">=</span> <span class="token constant">Writer</span> <span class="token punctuation">(</span><span class="token hvariable">x</span><span class="token punctuation">,</span> <span class="token hvariable">mempty</span><span class="token punctuation">)</span>
    <span class="token punctuation">(</span><span class="token constant">Writer</span> <span class="token punctuation">(</span><span class="token hvariable">x</span><span class="token punctuation">,</span><span class="token hvariable">v</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&gt;&gt;=</span> <span class="token hvariable">f</span> <span class="token operator">=</span> <span class="token keyword">let</span> <span class="token punctuation">(</span><span class="token constant">Writer</span> <span class="token punctuation">(</span><span class="token hvariable">y</span><span class="token punctuation">,</span> <span class="token hvariable">v'</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token hvariable">f</span> <span class="token hvariable">x</span> <span class="token keyword">in</span> <span class="token constant">Writer</span> <span class="token punctuation">(</span><span class="token hvariable">y</span><span class="token punctuation">,</span> <span class="token hvariable">v</span> <span class="token operator">`mappend`</span> <span class="token hvariable">v'</span><span class="token punctuation">)</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p><span alt="LYHfGG_108_angeleyes.png" src="LYHfGG_108_angeleyes.png" class="internal-embed media-embed image-embed is-loaded"><img alt="LYHfGG_108_angeleyes.png" src="курсы\learn-you-a-haskell-for-great-good!\картинки\lyhfgg_108_angeleyes.png"></span></p></div><div><p>First off, let's examine <code>&gt;&gt;=</code>. Its implementation is essentially the same as <code>applyLog</code>, only now that our tuple is wrapped in the <code>Writer</code> <code>newtype</code>, we have to unwrap it when pattern matching. We take the value <code>x</code> and apply the function <code>f</code> to it. This gives us a <code>Writer w a</code> value and we use a <code>let</code> expression to pattern match on it. We present <code>y</code> as the new result and use <code>mappend</code> to combine the old monoid value with the new one. We pack that up with the result value in a tuple and then wrap that with the <code>Writer</code> constructor so that our result is a <code>Writer</code> value instead of just an unwrapped tuple.</p></div><div><p>So, what about <code>return</code>? It has to take a value and put it in a default minimal context that still presents that value as the result. So what would such a context be for <code>Writer</code> values? If we want the accompanying monoid value to affect other monoid values as little as possible, it makes sense to use <code>mempty</code>. <code>mempty</code> is used to present identity monoid values, such as <code>""</code> and <code>Sum 0</code> and empty bytestrings. Whenever we use <code>mappend</code> between <code>mempty</code> and some other monoid value, the result is that other monoid value. So if we use <code>return</code> to make a <code>Writer</code> value and then use <code>&gt;&gt;=</code> to feed that value to a function, the resulting monoid value will be only what the function returns. Let's use <code>return</code> on the number <code>3</code> a bunch of times, only we'll pair it with a different monoid every time:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token hvariable">runWriter</span> <span class="token punctuation">(</span><span class="token builtin">return</span> <span class="token number">3</span> <span class="token operator">::</span> <span class="token constant">Writer</span> <span class="token constant">String</span> <span class="token constant">Int</span><span class="token punctuation">)</span>
<span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token string">""</span><span class="token punctuation">)</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token hvariable">runWriter</span> <span class="token punctuation">(</span><span class="token builtin">return</span> <span class="token number">3</span> <span class="token operator">::</span> <span class="token constant">Writer</span> <span class="token punctuation">(</span><span class="token constant">Sum</span> <span class="token constant">Int</span><span class="token punctuation">)</span> <span class="token constant">Int</span><span class="token punctuation">)</span>
<span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token constant">Sum</span> <span class="token punctuation">{</span><span class="token hvariable">getSum</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token hvariable">runWriter</span> <span class="token punctuation">(</span><span class="token builtin">return</span> <span class="token number">3</span> <span class="token operator">::</span> <span class="token constant">Writer</span> <span class="token punctuation">(</span><span class="token constant">Product</span> <span class="token constant">Int</span><span class="token punctuation">)</span> <span class="token constant">Int</span><span class="token punctuation">)</span>
<span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token constant">Product</span> <span class="token punctuation">{</span><span class="token hvariable">getProduct</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">}</span><span class="token punctuation">)</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Because <code>Writer</code> doesn't have a <code>Show</code> instance, we had to use <code>runWriter</code> to convert our <code>Writer</code> values to normal tuples that can be shown. For <code>String</code>, the monoid value is the empty string. With <code>Sum</code>, it's <code>0</code>, because if we add 0 to something, that something stays the same. For <code>Product</code>, the identity is <code>1</code>.</p></div><div><p>The <code>Writer</code> instance doesn't feature an implementation for <code>fail</code>, so if a pattern match fails in <code>do</code> notation, <code>error</code> is called.</p></div><div><h3 data-heading="Using do notation with Writer" id="Using_do_notation_with_Writer" style="display: flex;"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>Using do notation with Writer</h3></div><div><p>Now that we have a <code>Monad</code> instance, we're free to use <code>do</code> notation for <code>Writer</code> values. It's handy for when we have a several <code>Writer</code> values and we want to do stuff with them. Like with other monads, we can treat them as normal values and the context gets taken for us. In this case, all the monoid values that come attached get <code>mappend</code>ed and so are reflected in the final result. Here's a simple example of using <code>do</code> notation with <code>Writer</code> to multiply two numbers:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token import-statement"><span class="token keyword">import</span> Control<span class="token punctuation">.</span>Monad<span class="token punctuation">.</span>Writer</span>

<span class="token hvariable">logNumber</span> <span class="token operator">::</span> <span class="token constant">Int</span> <span class="token operator">-&gt;</span> <span class="token constant">Writer</span> <span class="token punctuation">[</span><span class="token constant">String</span><span class="token punctuation">]</span> <span class="token constant">Int</span>
<span class="token hvariable">logNumber</span> <span class="token hvariable">x</span> <span class="token operator">=</span> <span class="token constant">Writer</span> <span class="token punctuation">(</span><span class="token hvariable">x</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token string">"Got number: "</span> <span class="token operator">++</span> <span class="token builtin">show</span> <span class="token hvariable">x</span><span class="token punctuation">]</span><span class="token punctuation">)</span>

<span class="token hvariable">multWithLog</span> <span class="token operator">::</span> <span class="token constant">Writer</span> <span class="token punctuation">[</span><span class="token constant">String</span><span class="token punctuation">]</span> <span class="token constant">Int</span>
<span class="token hvariable">multWithLog</span> <span class="token operator">=</span> <span class="token keyword">do</span>
    <span class="token hvariable">a</span> <span class="token operator">&lt;-</span> <span class="token hvariable">logNumber</span> <span class="token number">3</span>
    <span class="token hvariable">b</span> <span class="token operator">&lt;-</span> <span class="token hvariable">logNumber</span> <span class="token number">5</span>
    <span class="token builtin">return</span> <span class="token punctuation">(</span><span class="token hvariable">a</span><span class="token operator">*</span><span class="token hvariable">b</span><span class="token punctuation">)</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p><code>logNumber</code> takes a number and makes a <code>Writer</code> value out of it. For the monoid, we use a list of strings and we equip the number with a singleton list that just says that we have that number. <code>multWithLog</code> is a <code>Writer</code> value which multiplies <code>3</code> and <code>5</code> and makes sure that their attached logs get included in the final log. We use <code>return</code> to present <code>a*b</code> as the result. Because <code>return</code> just takes something and puts it in a minimal context, we can be sure that it won't add anything to the log. Here's what we see if we run this:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token hvariable">runWriter</span> <span class="token hvariable">multWithLog</span>
<span class="token punctuation">(</span><span class="token number">15</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token string">"Got number: 3"</span><span class="token punctuation">,</span><span class="token string">"Got number: 5"</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Sometimes we just want some monoid value to be included at some particular point. For this, the <code>tell</code> function is useful. It's part of the <code>MonadWriter</code> type class and in the case of <code>Writer</code> it takes a monoid value, like <code>["This is going on"]</code> and creates a <code>Writer</code> value that presents the dummy value <code>()</code> as its result but has our desired monoid value attached. When we have a monadic value that has <code>()</code> as its result, we don't bind it to a variable. Here's <code>multWithLog</code> but with some extra reporting included:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">multWithLog</span> <span class="token operator">::</span> <span class="token constant">Writer</span> <span class="token punctuation">[</span><span class="token constant">String</span><span class="token punctuation">]</span> <span class="token constant">Int</span>
<span class="token hvariable">multWithLog</span> <span class="token operator">=</span> <span class="token keyword">do</span>
    <span class="token hvariable">a</span> <span class="token operator">&lt;-</span> <span class="token hvariable">logNumber</span> <span class="token number">3</span>
    <span class="token hvariable">b</span> <span class="token operator">&lt;-</span> <span class="token hvariable">logNumber</span> <span class="token number">5</span>
    <span class="token hvariable">tell</span> <span class="token punctuation">[</span><span class="token string">"Gonna multiply these two"</span><span class="token punctuation">]</span>
    <span class="token builtin">return</span> <span class="token punctuation">(</span><span class="token hvariable">a</span><span class="token operator">*</span><span class="token hvariable">b</span><span class="token punctuation">)</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>It's important that <code>return (a*b)</code> is the last line, because the result of the last line in a <code>do</code> expression is the result of the whole <code>do</code> expression. Had we put <code>tell</code> as the last line, <code>()</code> would have been the result of this <code>do</code> expression. We'd lose the result of the multiplication. However, the log would be the same. Here is this in action:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token hvariable">runWriter</span> <span class="token hvariable">multWithLog</span>
<span class="token punctuation">(</span><span class="token number">15</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token string">"Got number: 3"</span><span class="token punctuation">,</span><span class="token string">"Got number: 5"</span><span class="token punctuation">,</span><span class="token string">"Gonna multiply these two"</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><h3 data-heading="Adding logging to programs" id="Adding_logging_to_programs" style="display: flex;"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>Adding logging to programs</h3></div><div><p>Euclid's algorithm is an algorithm that takes two numbers and computes their greatest common divisor. That is, the biggest number that still divides both of them. Haskell already features the <code>gcd</code> function, which does exactly this, but let's implement our own and then equip it with logging capabilities. Here's the normal algorithm:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token builtin">gcd</span>' <span class="token operator">::</span> <span class="token constant">Int</span> <span class="token operator">-&gt;</span> <span class="token constant">Int</span> <span class="token operator">-&gt;</span> <span class="token constant">Int</span>
<span class="token builtin">gcd</span>' <span class="token hvariable">a</span> <span class="token hvariable">b</span> 
    <span class="token operator">|</span> <span class="token hvariable">b</span> <span class="token operator">==</span> <span class="token number">0</span>    <span class="token operator">=</span> <span class="token hvariable">a</span>
    <span class="token operator">|</span> <span class="token builtin">otherwise</span> <span class="token operator">=</span> <span class="token builtin">gcd</span>' <span class="token hvariable">b</span> <span class="token punctuation">(</span><span class="token hvariable">a</span> <span class="token operator">`mod`</span> <span class="token hvariable">b</span><span class="token punctuation">)</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>The algorithm is very simple. First, it checks if the second number is 0. If it is, then the result is the first number. If it isn't, then the result is the greatest common divisor of the second number and the remainder of dividing the first number with the second one. For instance, if we want to know what the greatest common divisor of 8 and 3 is, we just follow the algorithm outlined. Because 3 isn't 0, we have to find the greatest common divisor of 3 and 2 (if we divide 8 by 3, the remainder is 2). Next, we find the greatest common divisor of 3 and 2. 2 still isn't 0, so now we have have 2 and 1. The second number isn't 0, so we run the algorithm again for 1 and 0, as dividing 2 by 1 gives us a remainder of 0. And finally, because the second number is now 0, the final result is 1. Let's see if our code agrees:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token builtin">gcd</span>' <span class="token number">8</span> <span class="token number">3</span>
<span class="token number">1</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>It does. Very good! Now, we want to equip our result with a context, and the context will be a monoid value that acts as a log. Like before, we'll use a list of strings as our monoid. So the type of our new <code>gcd'</code> function should be:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token builtin">gcd</span>' <span class="token operator">::</span> <span class="token constant">Int</span> <span class="token operator">-&gt;</span> <span class="token constant">Int</span> <span class="token operator">-&gt;</span> <span class="token constant">Writer</span> <span class="token punctuation">[</span><span class="token constant">String</span><span class="token punctuation">]</span> <span class="token constant">Int</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>All that's left now is to equip our function with log values. Here's the code:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token import-statement"><span class="token keyword">import</span> Control<span class="token punctuation">.</span>Monad<span class="token punctuation">.</span>Writer</span>

<span class="token builtin">gcd</span>' <span class="token operator">::</span> <span class="token constant">Int</span> <span class="token operator">-&gt;</span> <span class="token constant">Int</span> <span class="token operator">-&gt;</span> <span class="token constant">Writer</span> <span class="token punctuation">[</span><span class="token constant">String</span><span class="token punctuation">]</span> <span class="token constant">Int</span>
<span class="token builtin">gcd</span>' <span class="token hvariable">a</span> <span class="token hvariable">b</span>
    <span class="token operator">|</span> <span class="token hvariable">b</span> <span class="token operator">==</span> <span class="token number">0</span> <span class="token operator">=</span> <span class="token keyword">do</span>
        <span class="token hvariable">tell</span> <span class="token punctuation">[</span><span class="token string">"Finished with "</span> <span class="token operator">++</span> <span class="token builtin">show</span> <span class="token hvariable">a</span><span class="token punctuation">]</span>
        <span class="token builtin">return</span> <span class="token hvariable">a</span>
    <span class="token operator">|</span> <span class="token builtin">otherwise</span> <span class="token operator">=</span> <span class="token keyword">do</span>
        <span class="token hvariable">tell</span> <span class="token punctuation">[</span><span class="token builtin">show</span> <span class="token hvariable">a</span> <span class="token operator">++</span> <span class="token string">" mod "</span> <span class="token operator">++</span> <span class="token builtin">show</span> <span class="token hvariable">b</span> <span class="token operator">++</span> <span class="token string">" = "</span> <span class="token operator">++</span> <span class="token builtin">show</span> <span class="token punctuation">(</span><span class="token hvariable">a</span> <span class="token operator">`mod`</span> <span class="token hvariable">b</span><span class="token punctuation">)</span><span class="token punctuation">]</span>
        <span class="token builtin">gcd</span>' <span class="token hvariable">b</span> <span class="token punctuation">(</span><span class="token hvariable">a</span> <span class="token operator">`mod`</span> <span class="token hvariable">b</span><span class="token punctuation">)</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>This function takes two normal <code>Int</code> values and returns a <code>Writer [String] Int</code>, that is, an <code>Int</code> that has a log context. In the case where <code>b</code> is <code>0</code>, instead of just giving <code>a</code> as the result, we use a <code>do</code> expression to put together a <code>Writer</code> value as a result. First we use <code>tell</code> to report that we're finished and then we use <code>return</code> to present <code>a</code> as the result of the <code>do</code> expression. Instead of this <code>do</code> expression, we could have also written this:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token constant">Writer</span> <span class="token punctuation">(</span><span class="token hvariable">a</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token string">"Finished with "</span> <span class="token operator">++</span> <span class="token builtin">show</span> <span class="token hvariable">a</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>However, I think the <code>do</code> expression is easier to read. Next, we have the case when <code>b</code> isn't <code>0</code>. In this case, we log that we're using <code>mod</code> to figure out the remainder of dividing <code>a</code> and <code>b</code>. Then, the second line of the <code>do</code> expression just recursively calls <code>gcd'</code>. Remember, <code>gcd'</code> now ultimately returns a <code>Writer</code> value, so it's perfectly valid that <code>gcd' b (a `mod` b)</code> is a line in a <code>do</code> expression.</p></div><div><p>While it may be kind of useful to trace the execution of this new <code>gcd'</code> by hand to see how the logs get appended, I think it's more insightful to just look at the big picture and view these as values with a context and from that gain insight as to what the final result will be.</p></div><div><p>Let's try our new <code>gcd'</code> out. Its result is a <code>Writer [String] Int</code> value and if we unwrap that from its <code>newtype</code>, we get a tuple. The first part of the tuple is the result. Let's see if it's okay:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token builtin">fst</span> <span class="token operator">$</span> <span class="token hvariable">runWriter</span> <span class="token punctuation">(</span><span class="token builtin">gcd</span>' <span class="token number">8</span> <span class="token number">3</span><span class="token punctuation">)</span>
<span class="token number">1</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Good! Now what about the log? Because the log is a list of strings, let's use <code>mapM_ putStrLn</code> to print those strings to the screen:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token builtin">mapM_</span> <span class="token builtin">putStrLn</span> <span class="token operator">$</span> <span class="token builtin">snd</span> <span class="token operator">$</span> <span class="token hvariable">runWriter</span> <span class="token punctuation">(</span><span class="token builtin">gcd</span>' <span class="token number">8</span> <span class="token number">3</span><span class="token punctuation">)</span>
<span class="token number">8</span> <span class="token builtin">mod</span> <span class="token number">3</span> <span class="token operator">=</span> <span class="token number">2</span>
<span class="token number">3</span> <span class="token builtin">mod</span> <span class="token number">2</span> <span class="token operator">=</span> <span class="token number">1</span>
<span class="token number">2</span> <span class="token builtin">mod</span> <span class="token number">1</span> <span class="token operator">=</span> <span class="token number">0</span>
<span class="token constant">Finished</span> <span class="token hvariable">with</span> <span class="token number">1</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>I think it's awesome how we were able to change our ordinary algorithm to one that reports what it does as it goes along just by changing normal values to monadic values and letting the implementation of <code>&gt;&gt;=</code> for <code>Writer</code> take care of the logs for us. We can add a logging mechanism to pretty much any function. We just replace normal values with <code>Writer</code> values where we want and change normal function application to <code>&gt;&gt;=</code> (or <code>do</code> expressions if it increases readability).</p></div><div><h3 data-heading="Inefficient list construction" id="Inefficient_list_construction" style="display: flex;"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>Inefficient list construction</h3></div><div><p>When using the <code>Writer</code> monad, you have to be careful which monoid to use, because using lists can sometimes turn out to be very slow. That's because lists use <code>++</code> for <code>mappend</code> and using <code>++</code> to add something to the end of a list is slow if that list is really long.</p></div><div><p>In our <code>gcd'</code> function, the logging is fast because the list appending ends up looking like this:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">a</span> <span class="token operator">++</span> <span class="token punctuation">(</span><span class="token hvariable">b</span> <span class="token operator">++</span> <span class="token punctuation">(</span><span class="token hvariable">c</span> <span class="token operator">++</span> <span class="token punctuation">(</span><span class="token hvariable">d</span> <span class="token operator">++</span> <span class="token punctuation">(</span><span class="token hvariable">e</span> <span class="token operator">++</span> <span class="token hvariable">f</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Lists are a data structure that's constructed from left to right, and this is efficient because we first fully construct the left part of a list and only then add a longer list on the right. But if we're not careful, using the <code>Writer</code> monad can produce list appending that looks like this:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token hvariable">a</span> <span class="token operator">++</span> <span class="token hvariable">b</span><span class="token punctuation">)</span> <span class="token operator">++</span> <span class="token hvariable">c</span><span class="token punctuation">)</span> <span class="token operator">++</span> <span class="token hvariable">d</span><span class="token punctuation">)</span> <span class="token operator">++</span> <span class="token hvariable">e</span><span class="token punctuation">)</span> <span class="token operator">++</span> <span class="token hvariable">f</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>This associates to the left instead of to the right. This is inefficient because every time it wants to add the right part to the left part, it has to construct the left part all the way from the beginning!</p></div><div><p>The following function works like <code>gcd'</code>, only it logs stuff in reverse. First it produces the log for the rest of the procedure and then adds the current step to the end of the log.</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token import-statement"><span class="token keyword">import</span> Control<span class="token punctuation">.</span>Monad<span class="token punctuation">.</span>Writer</span>

<span class="token hvariable">gcdReverse</span> <span class="token operator">::</span> <span class="token constant">Int</span> <span class="token operator">-&gt;</span> <span class="token constant">Int</span> <span class="token operator">-&gt;</span> <span class="token constant">Writer</span> <span class="token punctuation">[</span><span class="token constant">String</span><span class="token punctuation">]</span> <span class="token constant">Int</span>
<span class="token hvariable">gcdReverse</span> <span class="token hvariable">a</span> <span class="token hvariable">b</span>
    <span class="token operator">|</span> <span class="token hvariable">b</span> <span class="token operator">==</span> <span class="token number">0</span> <span class="token operator">=</span> <span class="token keyword">do</span>
        <span class="token hvariable">tell</span> <span class="token punctuation">[</span><span class="token string">"Finished with "</span> <span class="token operator">++</span> <span class="token builtin">show</span> <span class="token hvariable">a</span><span class="token punctuation">]</span>
        <span class="token builtin">return</span> <span class="token hvariable">a</span>
    <span class="token operator">|</span> <span class="token builtin">otherwise</span> <span class="token operator">=</span> <span class="token keyword">do</span>
        <span class="token hvariable">result</span> <span class="token operator">&lt;-</span> <span class="token hvariable">gcdReverse</span> <span class="token hvariable">b</span> <span class="token punctuation">(</span><span class="token hvariable">a</span> <span class="token operator">`mod`</span> <span class="token hvariable">b</span><span class="token punctuation">)</span>
        <span class="token hvariable">tell</span> <span class="token punctuation">[</span><span class="token builtin">show</span> <span class="token hvariable">a</span> <span class="token operator">++</span> <span class="token string">" mod "</span> <span class="token operator">++</span> <span class="token builtin">show</span> <span class="token hvariable">b</span> <span class="token operator">++</span> <span class="token string">" = "</span> <span class="token operator">++</span> <span class="token builtin">show</span> <span class="token punctuation">(</span><span class="token hvariable">a</span> <span class="token operator">`mod`</span> <span class="token hvariable">b</span><span class="token punctuation">)</span><span class="token punctuation">]</span>
        <span class="token builtin">return</span> <span class="token hvariable">result</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>It does the recursion first, and binds its result value to <code>result</code>. Then it adds the current step to the log, but the current step goes at the end of the log that was produced by the recursion. Finally, it presents the result of the recursion as the final result. Here it is in action:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token builtin">mapM_</span> <span class="token builtin">putStrLn</span> <span class="token operator">$</span> <span class="token builtin">snd</span> <span class="token operator">$</span> <span class="token hvariable">runWriter</span> <span class="token punctuation">(</span><span class="token hvariable">gcdReverse</span> <span class="token number">8</span> <span class="token number">3</span><span class="token punctuation">)</span>
<span class="token constant">Finished</span> <span class="token hvariable">with</span> <span class="token number">1</span>
<span class="token number">2</span> <span class="token builtin">mod</span> <span class="token number">1</span> <span class="token operator">=</span> <span class="token number">0</span>
<span class="token number">3</span> <span class="token builtin">mod</span> <span class="token number">2</span> <span class="token operator">=</span> <span class="token number">1</span>
<span class="token number">8</span> <span class="token builtin">mod</span> <span class="token number">3</span> <span class="token operator">=</span> <span class="token number">2</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>It's inefficient because it ends up associating the use of <code>++</code> to the left instead of to the right.</p></div><div><h3 data-heading="Difference lists" id="Difference_lists" style="display: flex;"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>Difference lists</h3></div><div><p><span alt="LYHfGG_109_cactus.png" src="LYHfGG_109_cactus.png" class="internal-embed media-embed image-embed is-loaded"><img alt="LYHfGG_109_cactus.png" src="курсы\learn-you-a-haskell-for-great-good!\картинки\lyhfgg_109_cactus.png"></span></p></div><div><p>Because lists can sometimes be inefficient when repeatedly appended in this manner, it's best to use a data structure that always supports efficient appending. One such data structure is the difference list. A difference list is similar to a list, only instead of being a normal list, it's a function that takes a list and prepends another list to it. The difference list equivalent of a list like <code>[1,2,3]</code> would be the function <code>\xs -&gt; [1,2,3] ++ xs</code>. A normal empty list is <code>[]</code>, whereas an empty difference list is the function <code>\xs -&gt; [] ++ xs</code>.</p></div><div><p>The cool thing about difference lists is that they support efficient appending. When we append two normal lists with <code>++</code>, it has to walk all the way to the end of the list on the left of <code>++</code> and then stick the other one there. But what if we take the difference list approach and represent our lists as functions? Well then, appending two difference lists can be done like so:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">f</span> <span class="token operator">`append`</span> <span class="token hvariable">g</span> <span class="token operator">=</span> <span class="token operator">\</span><span class="token hvariable">xs</span> <span class="token operator">-&gt;</span> <span class="token hvariable">f</span> <span class="token punctuation">(</span><span class="token hvariable">g</span> <span class="token hvariable">xs</span><span class="token punctuation">)</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Remember, <code>f</code> and <code>g</code> are functions that take lists and prepend something to them. So, for instance, if <code>f</code> is the function <code>("dog"++)</code> (just another way of writing <code>\xs -&gt; "dog" ++ xs</code>) and <code>g</code> the function <code>("meat"++)</code>, then <code>f `append` g</code> makes a new function that's equivalent to the following:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token operator">\</span><span class="token hvariable">xs</span> <span class="token operator">-&gt;</span> <span class="token string">"dog"</span> <span class="token operator">++</span> <span class="token punctuation">(</span><span class="token string">"meat"</span> <span class="token operator">++</span> <span class="token hvariable">xs</span><span class="token punctuation">)</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>We've appended two difference lists just by making a new function that first applies one difference list some list and then the other.</p></div><div><p>Let's make a <code>newtype</code> wrapper for difference lists so that we can easily give them monoid instances:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token keyword">newtype</span> <span class="token constant">DiffList</span> <span class="token hvariable">a</span> <span class="token operator">=</span> <span class="token constant">DiffList</span> <span class="token punctuation">{</span> <span class="token hvariable">getDiffList</span> <span class="token operator">::</span> <span class="token punctuation">[</span><span class="token hvariable">a</span><span class="token punctuation">]</span> <span class="token operator">-&gt;</span> <span class="token punctuation">[</span><span class="token hvariable">a</span><span class="token punctuation">]</span> <span class="token punctuation">}</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>The type that we wrap is <code>[a] -&gt; [a]</code> because a difference list is just a function that takes a list and returns another. Converting normal lists to difference lists and vice versa is easy:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">toDiffList</span> <span class="token operator">::</span> <span class="token punctuation">[</span><span class="token hvariable">a</span><span class="token punctuation">]</span> <span class="token operator">-&gt;</span> <span class="token constant">DiffList</span> <span class="token hvariable">a</span>
<span class="token hvariable">toDiffList</span> <span class="token hvariable">xs</span> <span class="token operator">=</span> <span class="token constant">DiffList</span> <span class="token punctuation">(</span><span class="token hvariable">xs</span><span class="token operator">++</span><span class="token punctuation">)</span>

<span class="token hvariable">fromDiffList</span> <span class="token operator">::</span> <span class="token constant">DiffList</span> <span class="token hvariable">a</span> <span class="token operator">-&gt;</span> <span class="token punctuation">[</span><span class="token hvariable">a</span><span class="token punctuation">]</span>
<span class="token hvariable">fromDiffList</span> <span class="token punctuation">(</span><span class="token constant">DiffList</span> <span class="token hvariable">f</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token hvariable">f</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>To make a normal list into a difference list we just do what we did before and make it a function that prepends it to another list. Because a difference list is a function that prepends something to another list, if we just want that something, we apply the function to an empty list!</p></div><div><p>Here's the <code>Monoid</code> instance:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token keyword">instance</span> <span class="token constant">Monoid</span> <span class="token punctuation">(</span><span class="token constant">DiffList</span> <span class="token hvariable">a</span><span class="token punctuation">)</span> <span class="token keyword">where</span>
    <span class="token hvariable">mempty</span> <span class="token operator">=</span> <span class="token constant">DiffList</span> <span class="token punctuation">(</span><span class="token operator">\</span><span class="token hvariable">xs</span> <span class="token operator">-&gt;</span> <span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">++</span> <span class="token hvariable">xs</span><span class="token punctuation">)</span>
    <span class="token punctuation">(</span><span class="token constant">DiffList</span> <span class="token hvariable">f</span><span class="token punctuation">)</span> <span class="token operator">`mappend`</span> <span class="token punctuation">(</span><span class="token constant">DiffList</span> <span class="token hvariable">g</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token constant">DiffList</span> <span class="token punctuation">(</span><span class="token operator">\</span><span class="token hvariable">xs</span> <span class="token operator">-&gt;</span> <span class="token hvariable">f</span> <span class="token punctuation">(</span><span class="token hvariable">g</span> <span class="token hvariable">xs</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Notice how for lists, <code>mempty</code> is just the <code>id</code> function and <code>mappend</code> is actually just function composition. Let's see if this works:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token hvariable">fromDiffList</span> <span class="token punctuation">(</span><span class="token hvariable">toDiffList</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">]</span> <span class="token operator">`mappend`</span> <span class="token hvariable">toDiffList</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">]</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Tip top! Now we can increase the efficiency of our <code>gcdReverse</code> function by making it use difference lists instead of normal lists:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token import-statement"><span class="token keyword">import</span> Control<span class="token punctuation">.</span>Monad<span class="token punctuation">.</span>Writer</span>

<span class="token builtin">gcd</span>' <span class="token operator">::</span> <span class="token constant">Int</span> <span class="token operator">-&gt;</span> <span class="token constant">Int</span> <span class="token operator">-&gt;</span> <span class="token constant">Writer</span> <span class="token punctuation">(</span><span class="token constant">DiffList</span> <span class="token constant">String</span><span class="token punctuation">)</span> <span class="token constant">Int</span>
<span class="token builtin">gcd</span>' <span class="token hvariable">a</span> <span class="token hvariable">b</span>
    <span class="token operator">|</span> <span class="token hvariable">b</span> <span class="token operator">==</span> <span class="token number">0</span> <span class="token operator">=</span> <span class="token keyword">do</span>
        <span class="token hvariable">tell</span> <span class="token punctuation">(</span><span class="token hvariable">toDiffList</span> <span class="token punctuation">[</span><span class="token string">"Finished with "</span> <span class="token operator">++</span> <span class="token builtin">show</span> <span class="token hvariable">a</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
        <span class="token builtin">return</span> <span class="token hvariable">a</span>
    <span class="token operator">|</span> <span class="token builtin">otherwise</span> <span class="token operator">=</span> <span class="token keyword">do</span>
        <span class="token hvariable">result</span> <span class="token operator">&lt;-</span> <span class="token builtin">gcd</span>' <span class="token hvariable">b</span> <span class="token punctuation">(</span><span class="token hvariable">a</span> <span class="token operator">`mod`</span> <span class="token hvariable">b</span><span class="token punctuation">)</span>
        <span class="token hvariable">tell</span> <span class="token punctuation">(</span><span class="token hvariable">toDiffList</span> <span class="token punctuation">[</span><span class="token builtin">show</span> <span class="token hvariable">a</span> <span class="token operator">++</span> <span class="token string">" mod "</span> <span class="token operator">++</span> <span class="token builtin">show</span> <span class="token hvariable">b</span> <span class="token operator">++</span> <span class="token string">" = "</span> <span class="token operator">++</span> <span class="token builtin">show</span> <span class="token punctuation">(</span><span class="token hvariable">a</span> <span class="token operator">`mod`</span> <span class="token hvariable">b</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
        <span class="token builtin">return</span> <span class="token hvariable">result</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>We only had to change the type of the monoid from <code>[String]</code> to <code>DiffList String</code> and then when using <code>tell</code>, convert our normal lists into difference lists with <code>toDiffList</code>. Let's see if the log gets assembled properly:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token builtin">mapM_</span> <span class="token builtin">putStrLn</span> <span class="token operator">.</span> <span class="token hvariable">fromDiffList</span> <span class="token operator">.</span> <span class="token builtin">snd</span> <span class="token operator">.</span> <span class="token hvariable">runWriter</span> <span class="token operator">$</span> <span class="token hvariable">gcdReverse</span> <span class="token number">110</span> <span class="token number">34</span>
<span class="token constant">Finished</span> <span class="token hvariable">with</span> <span class="token number">2</span>
<span class="token number">8</span> <span class="token builtin">mod</span> <span class="token number">2</span> <span class="token operator">=</span> <span class="token number">0</span>
<span class="token number">34</span> <span class="token builtin">mod</span> <span class="token number">8</span> <span class="token operator">=</span> <span class="token number">2</span>
<span class="token number">110</span> <span class="token builtin">mod</span> <span class="token number">34</span> <span class="token operator">=</span> <span class="token number">8</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>We do <code>gcdReverse 110 34</code>, then use <code>runWriter</code> to unwrap it from the <code>newtype</code>, then apply <code>snd</code> to that to just get the log, then apply <code>fromDiffList</code> to convert it to a normal list and then finally print its entries to the screen.</p></div><div><h3 data-heading="Comparing Performance" id="Comparing_Performance" style="display: flex;"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>Comparing Performance</h3></div><div><p>To get a feel for just how much difference lists may improve your performance, consider this function that just counts down from some number to zero, but produces its log in reverse, like <code>gcdReverse</code>, so that the numbers in the log will actually be counted up:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">finalCountDown</span> <span class="token operator">::</span> <span class="token constant">Int</span> <span class="token operator">-&gt;</span> <span class="token constant">Writer</span> <span class="token punctuation">(</span><span class="token constant">DiffList</span> <span class="token constant">String</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token hvariable">finalCountDown</span> <span class="token number">0</span> <span class="token operator">=</span> <span class="token keyword">do</span>
    <span class="token hvariable">tell</span> <span class="token punctuation">(</span><span class="token hvariable">toDiffList</span> <span class="token punctuation">[</span><span class="token string">"0"</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
<span class="token hvariable">finalCountDown</span> <span class="token hvariable">x</span> <span class="token operator">=</span> <span class="token keyword">do</span>
    <span class="token hvariable">finalCountDown</span> <span class="token punctuation">(</span><span class="token hvariable">x</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span>
    <span class="token hvariable">tell</span> <span class="token punctuation">(</span><span class="token hvariable">toDiffList</span> <span class="token punctuation">[</span><span class="token builtin">show</span> <span class="token hvariable">x</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>If we give it <code>0</code>, it just logs it. For any other number, it first counts down its predecessor to <code>0</code> and then appends that number to the log. So if we apply <code>finalCountDown</code> to <code>100</code>, the string <code>"100"</code> will come last in the log.</p></div><div><p>Anyway, if you load this function in GHCi and apply it to a big number, like <code>500000</code>, you'll see that it quickly starts counting from <code>0</code> onwards:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token builtin">mapM_</span> <span class="token builtin">putStrLn</span> <span class="token operator">.</span> <span class="token hvariable">fromDiffList</span> <span class="token operator">.</span> <span class="token builtin">snd</span> <span class="token operator">.</span> <span class="token hvariable">runWriter</span> <span class="token operator">$</span> <span class="token hvariable">finalCountDown</span> <span class="token number">500000</span>
<span class="token number">0</span>
<span class="token number">1</span>
<span class="token number">2</span>
<span class="token operator">...</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>However, if we change it to use normal lists instead of difference lists, like so:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">finalCountDown</span> <span class="token operator">::</span> <span class="token constant">Int</span> <span class="token operator">-&gt;</span> <span class="token constant">Writer</span> <span class="token punctuation">[</span><span class="token constant">String</span><span class="token punctuation">]</span> <span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token hvariable">finalCountDown</span> <span class="token number">0</span> <span class="token operator">=</span> <span class="token keyword">do</span>
    <span class="token hvariable">tell</span> <span class="token punctuation">[</span><span class="token string">"0"</span><span class="token punctuation">]</span>
<span class="token hvariable">finalCountDown</span> <span class="token hvariable">x</span> <span class="token operator">=</span> <span class="token keyword">do</span>
    <span class="token hvariable">finalCountDown</span> <span class="token punctuation">(</span><span class="token hvariable">x</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span>
    <span class="token hvariable">tell</span> <span class="token punctuation">[</span><span class="token builtin">show</span> <span class="token hvariable">x</span><span class="token punctuation">]</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>And then tell GHCi to start counting:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token builtin">mapM_</span> <span class="token builtin">putStrLn</span> <span class="token operator">.</span> <span class="token builtin">snd</span> <span class="token operator">.</span> <span class="token hvariable">runWriter</span> <span class="token operator">$</span> <span class="token hvariable">finalCountDown</span> <span class="token number">500000</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>We'll see that the counting is really slow.</p></div><div><p>Of course, this is not the proper and scientific way to test how fast our programs are, but we were able to see that in this case, using difference lists starts producing results right away whereas normal lists take forever.</p></div><div><p>Oh, by the way, the song Final Countdown by Europe is now stuck in your head. Enjoy!</p></div><div><h2 data-heading="Reader? Ugh, not this joke again." id="Reader?_Ugh,_not_this_joke_again." style="display: flex;"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>Reader? Ugh, not this joke again.</h2></div><div><p><span alt="LYHfGG_110_revolver.png" src="LYHfGG_110_revolver.png" class="internal-embed media-embed image-embed is-loaded"><img alt="LYHfGG_110_revolver.png" src="курсы\learn-you-a-haskell-for-great-good!\картинки\lyhfgg_110_revolver.png"></span></p></div><div><p>In the <a data-tooltip-position="top" aria-label="http://learnyouahaskell.com/functors-applicative-functors-and-monoids" rel="noopener" class="external-link" href="http://learnyouahaskell.com/functors-applicative-functors-and-monoids" target="_blank">chapter about applicatives</a>, we saw that the function type, <code>(-&gt;) r</code> is an instance of <code>Functor</code>. Mapping a function <code>f</code> over a function <code>g</code> will make a function that takes the same thing as <code>g</code>, applies <code>g</code> to it and then applies <code>f</code> to that result. So basically, we're making a new function that's like <code>g</code>, only before returning its result, <code>f</code> gets applied to that result as well. For instance:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token keyword">let</span> <span class="token hvariable">f</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token operator">*</span><span class="token number">5</span><span class="token punctuation">)</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token keyword">let</span> <span class="token hvariable">g</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token operator">+</span><span class="token number">3</span><span class="token punctuation">)</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token punctuation">(</span><span class="token builtin">fmap</span> <span class="token hvariable">f</span> <span class="token hvariable">g</span><span class="token punctuation">)</span> <span class="token number">8</span>
<span class="token number">55</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>We've also seen that functions are applicative functors. They allow us to operate on the eventual results of functions as if we already had their results. Here's an example:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token keyword">let</span> <span class="token hvariable">f</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token operator">+</span><span class="token punctuation">)</span> <span class="token operator">&lt;$&gt;</span> <span class="token punctuation">(</span><span class="token operator">*</span><span class="token number">2</span><span class="token punctuation">)</span> <span class="token operator">&lt;*&gt;</span> <span class="token punctuation">(</span><span class="token operator">+</span><span class="token number">10</span><span class="token punctuation">)</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token hvariable">f</span> <span class="token number">3</span>
<span class="token number">19</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>The expression <code>(+) &lt;$&gt; (*2) &lt;*&gt; (+10)</code> makes a function that takes a number, gives that number to <code>(*2)</code> and <code>(+10)</code> and then adds together the results. For instance, if we apply this function to <code>3</code>, it applies both <code>(*2)</code> and <code>(+10)</code> to <code>3</code>, giving <code>6</code> and <code>13</code>. Then, it calls <code>(+)</code> with <code>6</code> and <code>13</code> and the result is <code>19</code>.</p></div><div><p>Not only is the function type <code>(-&gt;) r</code> a functor and an applicative functor, but it's also a monad. Just like other monadic values that we've met so far, a function can also be considered a value with a context. The context for functions is that that value is not present yet and that we have to apply that function to something in order to get its result value.</p></div><div><p>Because we're already acquainted with how functions work as functors and applicative functors, let's dive right in and see what their <code>Monad</code> instance looks like. It's located in <code>Control.Monad.Instances</code> and it goes a little something like this:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token keyword">instance</span> <span class="token constant">Monad</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token operator">-&gt;</span><span class="token punctuation">)</span> <span class="token hvariable">r</span><span class="token punctuation">)</span> <span class="token keyword">where</span>
    <span class="token builtin">return</span> <span class="token hvariable">x</span> <span class="token operator">=</span> <span class="token operator">\</span><span class="token hvariable">_</span> <span class="token operator">-&gt;</span> <span class="token hvariable">x</span>
    <span class="token hvariable">h</span> <span class="token operator">&gt;&gt;=</span> <span class="token hvariable">f</span> <span class="token operator">=</span> <span class="token operator">\</span><span class="token hvariable">w</span> <span class="token operator">-&gt;</span> <span class="token hvariable">f</span> <span class="token punctuation">(</span><span class="token hvariable">h</span> <span class="token hvariable">w</span><span class="token punctuation">)</span> <span class="token hvariable">w</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>We've already seen how <code>pure</code> is implemented for functions, and <code>return</code> is pretty much the same thing as <code>pure</code>. It takes a value and puts it in a minimal context that always has that value as its result. And the only way to make a function that always has a certain value as its result is to make it completely ignore its parameter.</p></div><div><p>The implementation for <code>&gt;&gt;=</code> seems a bit cryptic, but it's really not all that. When we use <code>&gt;&gt;=</code> to feed a monadic value to a function, the result is always a monadic value. So in this case, when we feed a function to another function, the result is a function as well. That's why the result starts off as a lambda. All of the implementations of <code>&gt;&gt;=</code> so far always somehow isolated the result from the monadic value and then applied the function <code>f</code> to that result. The same thing happens here. To get the result from a function, we have to apply it to something, which is why we do <code>(h w)</code> here to get the result from the function and then we apply <code>f</code> to that. <code>f</code> returns a monadic value, which is a function in our case, so we apply it to <code>w</code> as well.</p></div><div><p>If don't get how <code>&gt;&gt;=</code> works at this point, don't worry, because with examples we'll see how this is a really simple monad. Here's a <code>do</code> expression that utilizes this monad:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token import-statement"><span class="token keyword">import</span> Control<span class="token punctuation">.</span>Monad<span class="token punctuation">.</span>Instances</span>

<span class="token hvariable">addStuff</span> <span class="token operator">::</span> <span class="token constant">Int</span> <span class="token operator">-&gt;</span> <span class="token constant">Int</span>
<span class="token hvariable">addStuff</span> <span class="token operator">=</span> <span class="token keyword">do</span>
    <span class="token hvariable">a</span> <span class="token operator">&lt;-</span> <span class="token punctuation">(</span><span class="token operator">*</span><span class="token number">2</span><span class="token punctuation">)</span>
    <span class="token hvariable">b</span> <span class="token operator">&lt;-</span> <span class="token punctuation">(</span><span class="token operator">+</span><span class="token number">10</span><span class="token punctuation">)</span>
    <span class="token builtin">return</span> <span class="token punctuation">(</span><span class="token hvariable">a</span><span class="token operator">+</span><span class="token hvariable">b</span><span class="token punctuation">)</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>This is the same thing as the applicative expression that we wrote earlier, only now it relies on functions being monads. A <code>do</code> expression always results in a monadic value and this one is no different. The result of this monadic value is a function. What happens here is that it takes a number and then <code>(*2)</code> gets applied to that number and the result becomes <code>a</code>. <code>(+10)</code> is applied to the same number that <code>(*2)</code> got applied to and the result becomes <code>b</code>. <code>return</code>, like in other monads, doesn't have any other effect but to make a monadic value that presents some result. This presents <code>a+b</code> as the result of this function. If we test it out, we get the same result as before:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token hvariable">addStuff</span> <span class="token number">3</span>
<span class="token number">19</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Both <code>(*2)</code> and <code>(+10)</code> get applied to the number <code>3</code> in this case. <code>return (a+b)</code> does as well, but it ignores it and always presents <code>a+b</code> as the result. For this reason, the function monad is also called the reader monad. All the functions read from a common source. To illustrate this even better, we can rewrite <code>addStuff</code> like so:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">addStuff</span> <span class="token operator">::</span> <span class="token constant">Int</span> <span class="token operator">-&gt;</span> <span class="token constant">Int</span>
<span class="token hvariable">addStuff</span> <span class="token hvariable">x</span> <span class="token operator">=</span> <span class="token keyword">let</span>
    <span class="token hvariable">a</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token operator">*</span><span class="token number">2</span><span class="token punctuation">)</span> <span class="token hvariable">x</span>
    <span class="token hvariable">b</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token operator">+</span><span class="token number">10</span><span class="token punctuation">)</span> <span class="token hvariable">x</span>
    <span class="token keyword">in</span> <span class="token hvariable">a</span><span class="token operator">+</span><span class="token hvariable">b</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>We see that the reader monad allows us to treat functions as values with a context. We can act as if we already know what the functions will return. It does this by gluing functions together into one function and then giving that function's parameter to all of the functions that it was glued from. So if we have a lot of functions that are all just missing one parameter and they'd eventually be applied to the same thing, we can use the reader monad to sort of extract their future results and the <code>&gt;&gt;=</code> implementation will make sure that it all works out.</p></div><div><h2 data-heading="Tasteful stateful computations" id="Tasteful_stateful_computations" style="display: flex;"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>Tasteful stateful computations</h2></div><div><p><span alt="LYHfGG_111_texas.png" src="LYHfGG_111_texas.png" class="internal-embed media-embed image-embed is-loaded"><img alt="LYHfGG_111_texas.png" src="курсы\learn-you-a-haskell-for-great-good!\картинки\lyhfgg_111_texas.png"></span></p></div><div><p>Haskell is a pure language and because of that, our programs are made of functions that can't change any global state or variables, they can only do some computations and return them results. This restriction actually makes it easier to think about our programs, as it frees us from worrying what every variable's value is at some point in time. However, some problems are inherently stateful in that they rely on some state that changes over time. While such problems aren't a problem for Haskell, they can be a bit tedious to model sometimes. That's why Haskell features a thing called the state monad, which makes dealing with stateful problems a breeze while still keeping everything nice and pure.</p></div><div><p><a data-tooltip-position="top" aria-label="http://learnyouahaskell.com/input-and-output#randomness" rel="noopener" class="external-link" href="http://learnyouahaskell.com/input-and-output#randomness" target="_blank">When we were dealing with random numbers</a>, we dealt with functions that took a random generator as a parameter and returned a random number and a new random generator. If we wanted to generate several random numbers, we always had to use the random generator that a previous function returned along with its result. When making a function that takes a <code>StdGen</code> and tosses a coin three times based on that generator, we had to do this:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">threeCoins</span> <span class="token operator">::</span> <span class="token constant">StdGen</span> <span class="token operator">-&gt;</span> <span class="token punctuation">(</span><span class="token constant">Bool</span><span class="token punctuation">,</span> <span class="token constant">Bool</span><span class="token punctuation">,</span> <span class="token constant">Bool</span><span class="token punctuation">)</span>
<span class="token hvariable">threeCoins</span> <span class="token hvariable">gen</span> <span class="token operator">=</span> 
    <span class="token keyword">let</span> <span class="token punctuation">(</span><span class="token hvariable">firstCoin</span><span class="token punctuation">,</span> <span class="token hvariable">newGen</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token hvariable">random</span> <span class="token hvariable">gen</span>
        <span class="token punctuation">(</span><span class="token hvariable">secondCoin</span><span class="token punctuation">,</span> <span class="token hvariable">newGen'</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token hvariable">random</span> <span class="token hvariable">newGen</span>
        <span class="token punctuation">(</span><span class="token hvariable">thirdCoin</span><span class="token punctuation">,</span> <span class="token hvariable">newGen''</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token hvariable">random</span> <span class="token hvariable">newGen'</span>
    <span class="token keyword">in</span>  <span class="token punctuation">(</span><span class="token hvariable">firstCoin</span><span class="token punctuation">,</span> <span class="token hvariable">secondCoin</span><span class="token punctuation">,</span> <span class="token hvariable">thirdCoin</span><span class="token punctuation">)</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>It took a generator <code>gen</code> and then <code>random gen</code> returned a <code>Bool</code> value along with a new generator. To throw the second coin, we used the new generator, and so on. In most other languages, we wouldn't have to return a new generator along with a random number. We could just modify the existing one! But since Haskell is pure, we can't do that, so we had to take some state, make a result from it and a new state and then use that new state to generate new results.</p></div><div><p>You'd think that to avoid manually dealing with stateful computations in this way, we'd have to give up the purity of Haskell. Well, we don't have to, since there exist a special little monad called the state monad which handles all this state business for us and without giving up any of the purity that makes Haskell programming so cool.</p></div><div><p>So, to help us understand this concept of stateful computations better, let's go ahead and give them a type. We'll say that a stateful computation is a function that takes some state and returns a value along with some new state. That function would have the following type:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">s</span> <span class="token operator">-&gt;</span> <span class="token punctuation">(</span><span class="token hvariable">a</span><span class="token punctuation">,</span><span class="token hvariable">s</span><span class="token punctuation">)</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p><code>s</code> is the type of the state and <code>a</code> the result of the stateful computations.</p></div><div><blockquote>
<p>Assignment in most other languages could be thought of as a stateful computation. For instance, when we do <code>x = 5</code> in an imperative language, it will usually assign the value <code>5</code> to the variable <code>x</code> and it will also have the value <code>5</code> as an expression. If you look at that functionally, you could look at it as a function that takes a state (that is, all the variables that have been assigned previously) and returns a result (in this case <code>5</code>) and a new state, which would be all the previous variable mappings plus the newly assigned variable.</p>
</blockquote></div><div><p>This stateful computation, a function that takes a state and returns a result and a new state, can be thought of as a value with a context as well. The actual value is the result, whereas the context is that we have to provide some initial state to actually get that result and that apart from getting a result we also get a new state.</p></div><div><h3 data-heading="Stacks and stones" id="Stacks_and_stones" style="display: flex;"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>Stacks and stones</h3></div><div><p>Say we want to model operating a stack. You have a stack of things one on top of another and you can either push stuff on top of that stack or you can take stuff off the top of the stack. When you're putting an item on top of the stack we say that you're pushing it to the stack and when you're taking stuff off the top we say that you're popping it. If you want to something that's at the bottom of the stack, you have to pop everything that's above it.</p></div><div><p>We'll use a list to represent our stack and the head of the list will be the top of the stack. To help us with our task, we'll make two functions: <code>pop</code> and <code>push</code>. <code>pop</code> will take a stack, pop one item and return that item as the result and also return a new stack, without that item. <code>push</code> will take an item and a stack and then push that item onto the stack. It will return <code>()</code> as its result, along with a new stack. Here goes:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token keyword">type</span> <span class="token constant">Stack</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token constant">Int</span><span class="token punctuation">]</span>

<span class="token hvariable">pop</span> <span class="token operator">::</span> <span class="token constant">Stack</span> <span class="token operator">-&gt;</span> <span class="token punctuation">(</span><span class="token constant">Int</span><span class="token punctuation">,</span><span class="token constant">Stack</span><span class="token punctuation">)</span>
<span class="token hvariable">pop</span> <span class="token punctuation">(</span><span class="token hvariable">x</span><span class="token operator">:</span><span class="token hvariable">xs</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token hvariable">x</span><span class="token punctuation">,</span><span class="token hvariable">xs</span><span class="token punctuation">)</span>

<span class="token hvariable">push</span> <span class="token operator">::</span> <span class="token constant">Int</span> <span class="token operator">-&gt;</span> <span class="token constant">Stack</span> <span class="token operator">-&gt;</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token constant">Stack</span><span class="token punctuation">)</span>
<span class="token hvariable">push</span> <span class="token hvariable">a</span> <span class="token hvariable">xs</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token hvariable">a</span><span class="token operator">:</span><span class="token hvariable">xs</span><span class="token punctuation">)</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>We used <code>()</code> as the result when pushing to the stack because pushing an item onto the stack doesn't have any important result value, its main job is to change the stack. Notice how we just apply the first parameter of <code>push</code>, we get a stateful computation. <code>pop</code> is already a stateful computation because of its type.</p></div><div><p>Let's write a small piece of code to simulate a stack using these functions. We'll take a stack, push <code>3</code> to it and then pop two items, just for kicks. Here it is:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">stackManip</span> <span class="token operator">::</span> <span class="token constant">Stack</span> <span class="token operator">-&gt;</span> <span class="token punctuation">(</span><span class="token constant">Int</span><span class="token punctuation">,</span> <span class="token constant">Stack</span><span class="token punctuation">)</span>
<span class="token hvariable">stackManip</span> <span class="token hvariable">stack</span> <span class="token operator">=</span> <span class="token keyword">let</span>
    <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token hvariable">newStack1</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token hvariable">push</span> <span class="token number">3</span> <span class="token hvariable">stack</span>
    <span class="token punctuation">(</span><span class="token hvariable">a</span> <span class="token punctuation">,</span><span class="token hvariable">newStack2</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token hvariable">pop</span> <span class="token hvariable">newStack1</span>
    <span class="token keyword">in</span> <span class="token hvariable">pop</span> <span class="token hvariable">newStack2</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>We take a <code>stack</code> and then we do <code>push 3 stack</code>, which results in a tuple. The first part of the tuple is a <code>()</code> and the second is a new stack and we call it <code>newStack1</code>. Then, we pop a number from <code>newStack1</code>, which results in a number <code>a</code> (which is the <code>3</code>) that we pushed and a new stack which we call <code>newStack2</code>. Then, we pop a number off <code>newStack2</code> and we get a number that's <code>b</code> and a <code>newStack3</code>. We return a tuple with that number and that stack. Let's try it out:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token hvariable">stackManip</span> <span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">8</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">]</span>
<span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token number">8</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Cool, the result is <code>5</code> and the new stack is <code>[8,2,1]</code>. Notice how <code>stackManip</code> is itself a stateful computation. We've taken a bunch of stateful computations and we've sort of glued them together. Hmm, sounds familiar.</p></div><div><p>The above code for <code>stackManip</code> is kind of tedious since we're manually giving the state to every stateful computation and storing it and then giving it to the next one. Wouldn't it be cooler if, instead of giving the stack manually to each function, we could write something like this:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">stackManip</span> <span class="token operator">=</span> <span class="token keyword">do</span>
    <span class="token hvariable">push</span> <span class="token number">3</span>
    <span class="token hvariable">a</span> <span class="token operator">&lt;-</span> <span class="token hvariable">pop</span>
    <span class="token hvariable">pop</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Well, using the state monad will allow us to do exactly this. With it, we will be able to take stateful computations like these and use them without having to manage the state manually.</p></div><div><h3 data-heading="The State monad" id="The_State_monad" style="display: flex;"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>The State monad</h3></div><div><p>The <code>Control.Monad.State</code> module provides a <code>newtype</code> that wraps stateful computations. Here's its definition:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token keyword">newtype</span> <span class="token constant">State</span> <span class="token hvariable">s</span> <span class="token hvariable">a</span> <span class="token operator">=</span> <span class="token constant">State</span> <span class="token punctuation">{</span> <span class="token hvariable">runState</span> <span class="token operator">::</span> <span class="token hvariable">s</span> <span class="token operator">-&gt;</span> <span class="token punctuation">(</span><span class="token hvariable">a</span><span class="token punctuation">,</span><span class="token hvariable">s</span><span class="token punctuation">)</span> <span class="token punctuation">}</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>A <code>State s a</code> is a stateful computation that manipulates a state of type <code>s</code> and has a result of type <code>a</code>.</p></div><div><p>Now that we've seen what stateful computations are about and how they can even be thought of as values with contexts, let's check out their <code>Monad</code> instance:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token keyword">instance</span> <span class="token constant">Monad</span> <span class="token punctuation">(</span><span class="token constant">State</span> <span class="token hvariable">s</span><span class="token punctuation">)</span> <span class="token keyword">where</span>
    <span class="token builtin">return</span> <span class="token hvariable">x</span> <span class="token operator">=</span> <span class="token constant">State</span> <span class="token operator">$</span> <span class="token operator">\</span><span class="token hvariable">s</span> <span class="token operator">-&gt;</span> <span class="token punctuation">(</span><span class="token hvariable">x</span><span class="token punctuation">,</span><span class="token hvariable">s</span><span class="token punctuation">)</span>
    <span class="token punctuation">(</span><span class="token constant">State</span> <span class="token hvariable">h</span><span class="token punctuation">)</span> <span class="token operator">&gt;&gt;=</span> <span class="token hvariable">f</span> <span class="token operator">=</span> <span class="token constant">State</span> <span class="token operator">$</span> <span class="token operator">\</span><span class="token hvariable">s</span> <span class="token operator">-&gt;</span> <span class="token keyword">let</span> <span class="token punctuation">(</span><span class="token hvariable">a</span><span class="token punctuation">,</span> <span class="token hvariable">newState</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token hvariable">h</span> <span class="token hvariable">s</span>
                                        <span class="token punctuation">(</span><span class="token constant">State</span> <span class="token hvariable">g</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token hvariable">f</span> <span class="token hvariable">a</span>
                                    <span class="token keyword">in</span>  <span class="token hvariable">g</span> <span class="token hvariable">newState</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Let's take a gander at <code>return</code> first. Our aim with <code>return</code> is to take a value and make a stateful computation that always has that value as its result. That's why we just make a lambda <code>\s -&gt; (x,s)</code>. We always present <code>x</code> as the result of the stateful computation and the state is kept unchanged, because <code>return</code> has to put a value in a minimal context. So <code>return</code> will make a stateful computation that presents a certain value as the result and keeps the state unchanged.</p></div><div><p><span alt="LYHfGG_112_badge.png" src="LYHfGG_112_badge.png" class="internal-embed media-embed image-embed is-loaded"><img alt="LYHfGG_112_badge.png" src="курсы\learn-you-a-haskell-for-great-good!\картинки\lyhfgg_112_badge.png"></span></p></div><div><p>What about <code>&gt;&gt;=</code>? Well, the result of feeding a stateful computation to a function with <code>&gt;&gt;=</code> has to be a stateful computation, right? So we start off with the <code>State</code> <code>newtype</code> wrapper and then we type out a lambda. This lambda will be our new stateful computation. But what goes on in it? Well, we somehow have to extract the result value from the first stateful computation. Because we're in a stateful computation right now, we can give the stateful computation <code>h</code> our current state <code>s</code>, which results in a pair of result and a new state: <code>(a, newState)</code>. Every time so far when we were implementing <code>&gt;&gt;=</code>, once we had the extracted the result from the monadic value, we applied the function <code>f</code> to it to get the new monadic value. In <code>Writer</code>, after doing that and getting the new monadic value, we still had to make sure that the context was taken care of by <code>mappend</code>ing the old monoid value with the new one. Here, we do <code>f a</code> and we get a new stateful computation <code>g</code>. Now that we have a new stateful computation and a new state (goes by the name of <code>newState</code>) we just apply that stateful computation <code>g</code> to the <code>newState</code>. The result is a tuple of final result and final state!</p></div><div><p>So with <code>&gt;&gt;=</code>, we kind of glue two stateful computations together, only the second one is hidden inside a function that takes the previous one's result. Because <code>pop</code> and <code>push</code> are already stateful computations, it's easy to wrap them into a <code>State</code> wrapper. Watch:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token import-statement"><span class="token keyword">import</span> Control<span class="token punctuation">.</span>Monad<span class="token punctuation">.</span>State</span>

<span class="token hvariable">pop</span> <span class="token operator">::</span> <span class="token constant">State</span> <span class="token constant">Stack</span> <span class="token constant">Int</span>
<span class="token hvariable">pop</span> <span class="token operator">=</span> <span class="token constant">State</span> <span class="token operator">$</span> <span class="token operator">\</span><span class="token punctuation">(</span><span class="token hvariable">x</span><span class="token operator">:</span><span class="token hvariable">xs</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token punctuation">(</span><span class="token hvariable">x</span><span class="token punctuation">,</span><span class="token hvariable">xs</span><span class="token punctuation">)</span>

<span class="token hvariable">push</span> <span class="token operator">::</span> <span class="token constant">Int</span> <span class="token operator">-&gt;</span> <span class="token constant">State</span> <span class="token constant">Stack</span> <span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token hvariable">push</span> <span class="token hvariable">a</span> <span class="token operator">=</span> <span class="token constant">State</span> <span class="token operator">$</span> <span class="token operator">\</span><span class="token hvariable">xs</span> <span class="token operator">-&gt;</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token hvariable">a</span><span class="token operator">:</span><span class="token hvariable">xs</span><span class="token punctuation">)</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p><code>pop</code> is already a stateful computation and <code>push</code> takes an <code>Int</code> and returns a stateful computation. Now we can rewrite our previous example of pushing <code>3</code> onto the stack and then popping two numbers off like this:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token import-statement"><span class="token keyword">import</span> Control<span class="token punctuation">.</span>Monad<span class="token punctuation">.</span>State</span>

<span class="token hvariable">stackManip</span> <span class="token operator">::</span> <span class="token constant">State</span> <span class="token constant">Stack</span> <span class="token constant">Int</span>
<span class="token hvariable">stackManip</span> <span class="token operator">=</span> <span class="token keyword">do</span>
    <span class="token hvariable">push</span> <span class="token number">3</span>
    <span class="token hvariable">a</span> <span class="token operator">&lt;-</span> <span class="token hvariable">pop</span>
    <span class="token hvariable">pop</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>See how we've glued a push and two pops into one stateful computation? When we unwrap it from its <code>newtype</code> wrapper we get a function to which we can provide some initial state:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token hvariable">runState</span> <span class="token hvariable">stackManip</span> <span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">8</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">]</span>
<span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token number">8</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>We didn't have to bind the second <code>pop</code> to <code>a</code> because we didn't use that <code>a</code> at all. So we could have written it like this:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">stackManip</span> <span class="token operator">::</span> <span class="token constant">State</span> <span class="token constant">Stack</span> <span class="token constant">Int</span>
<span class="token hvariable">stackManip</span> <span class="token operator">=</span> <span class="token keyword">do</span>
    <span class="token hvariable">push</span> <span class="token number">3</span>
    <span class="token hvariable">pop</span>
    <span class="token hvariable">pop</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Pretty cool. But what if we want to do this: pop one number off the stack and then if that number is <code>5</code> we just put it back onto the stack and stop but if it isn't <code>5</code>, we push <code>3</code> and <code>8</code> back on? Well, here's the code:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">stackStuff</span> <span class="token operator">::</span> <span class="token constant">State</span> <span class="token constant">Stack</span> <span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token hvariable">stackStuff</span> <span class="token operator">=</span> <span class="token keyword">do</span>
    <span class="token hvariable">a</span> <span class="token operator">&lt;-</span> <span class="token hvariable">pop</span>
    <span class="token keyword">if</span> <span class="token hvariable">a</span> <span class="token operator">==</span> <span class="token number">5</span>
        <span class="token keyword">then</span> <span class="token hvariable">push</span> <span class="token number">5</span>
        <span class="token keyword">else</span> <span class="token keyword">do</span>
            <span class="token hvariable">push</span> <span class="token number">3</span>
            <span class="token hvariable">push</span> <span class="token number">8</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>This is quite straightforward. Let's run it with an initial stack.</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token hvariable">runState</span> <span class="token hvariable">stackStuff</span> <span class="token punctuation">[</span><span class="token number">9</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">]</span>
<span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token number">8</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Remember, <code>do</code> expressions result in monadic values and with the <code>State</code> monad, a single <code>do</code> expression is also a stateful function. Because <code>stackManip</code> and <code>stackStuff</code> are ordinary stateful computations, we can glue them together to produce further stateful computations.</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">moreStack</span> <span class="token operator">::</span> <span class="token constant">State</span> <span class="token constant">Stack</span> <span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token hvariable">moreStack</span> <span class="token operator">=</span> <span class="token keyword">do</span>
    <span class="token hvariable">a</span> <span class="token operator">&lt;-</span> <span class="token hvariable">stackManip</span>
    <span class="token keyword">if</span> <span class="token hvariable">a</span> <span class="token operator">==</span> <span class="token number">100</span>
        <span class="token keyword">then</span> <span class="token hvariable">stackStuff</span>
        <span class="token keyword">else</span> <span class="token builtin">return</span> <span class="token punctuation">(</span><span class="token punctuation">)</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>If the result of <code>stackManip</code> on the current stack is <code>100</code>, we run <code>stackStuff</code>, otherwise we do nothing. <code>return ()</code> just keeps the state as it is and does nothing.</p></div><div><p>The <code>Control.Monad.State</code> module provides a type class that's called <code>MonadState</code> and it features two pretty useful functions, namely <code>get</code> and <code>put</code>. For <code>State</code>, the <code>get</code> function is implemented like this:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">get</span> <span class="token operator">=</span> <span class="token constant">State</span> <span class="token operator">$</span> <span class="token operator">\</span><span class="token hvariable">s</span> <span class="token operator">-&gt;</span> <span class="token punctuation">(</span><span class="token hvariable">s</span><span class="token punctuation">,</span><span class="token hvariable">s</span><span class="token punctuation">)</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>So it just takes the current state and presents it as the result. The <code>put</code> function takes some state and makes a stateful function that replaces the current state with it:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">put</span> <span class="token hvariable">newState</span> <span class="token operator">=</span> <span class="token constant">State</span> <span class="token operator">$</span> <span class="token operator">\</span><span class="token hvariable">s</span> <span class="token operator">-&gt;</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token hvariable">newState</span><span class="token punctuation">)</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>So with these, we can see what the current stack is or we can replace it with a whole other stack. Like so:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">stackyStack</span> <span class="token operator">::</span> <span class="token constant">State</span> <span class="token constant">Stack</span> <span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token hvariable">stackyStack</span> <span class="token operator">=</span> <span class="token keyword">do</span>
    <span class="token hvariable">stackNow</span> <span class="token operator">&lt;-</span> <span class="token hvariable">get</span>
    <span class="token keyword">if</span> <span class="token hvariable">stackNow</span> <span class="token operator">==</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">]</span>
        <span class="token keyword">then</span> <span class="token hvariable">put</span> <span class="token punctuation">[</span><span class="token number">8</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">]</span>
        <span class="token keyword">else</span> <span class="token hvariable">put</span> <span class="token punctuation">[</span><span class="token number">9</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">]</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>It's worth examining what the type of <code>&gt;&gt;=</code> would be if it only worked for <code>State</code> values:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token punctuation">(</span><span class="token operator">&gt;&gt;=</span><span class="token punctuation">)</span> <span class="token operator">::</span> <span class="token constant">State</span> <span class="token hvariable">s</span> <span class="token hvariable">a</span> <span class="token operator">-&gt;</span> <span class="token punctuation">(</span><span class="token hvariable">a</span> <span class="token operator">-&gt;</span> <span class="token constant">State</span> <span class="token hvariable">s</span> <span class="token hvariable">b</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token constant">State</span> <span class="token hvariable">s</span> <span class="token hvariable">b</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>See how the type of the state <code>s</code> stays the same but the type of the result can change from <code>a</code> to <code>b</code>? This means that we can glue together several stateful computations whose results are of different types but the type of the state has to stay the same. Now why is that? Well, for instance, for <code>Maybe</code>, <code>&gt;&gt;=</code> has this type:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token punctuation">(</span><span class="token operator">&gt;&gt;=</span><span class="token punctuation">)</span> <span class="token operator">::</span> <span class="token constant">Maybe</span> <span class="token hvariable">a</span> <span class="token operator">-&gt;</span> <span class="token punctuation">(</span><span class="token hvariable">a</span> <span class="token operator">-&gt;</span> <span class="token constant">Maybe</span> <span class="token hvariable">b</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token constant">Maybe</span> <span class="token hvariable">b</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>It makes sense that the monad itself, <code>Maybe</code>, doesn't change. It wouldn't make sense to use <code>&gt;&gt;=</code> between two different monads. Well, for the state monad, the monad is actually <code>State s</code>, so if that <code>s</code> was different, we'd be using <code>&gt;&gt;=</code> between two different monads.</p></div><div><h3 data-heading="Randomness and the state monad" id="Randomness_and_the_state_monad" style="display: flex;"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>Randomness and the state monad</h3></div><div><p>At the beginning of this section, we saw how generating numbers can sometimes be awkward because every random function takes a generator and returns a random number along with a new generator, which must then be used instead of the old one if we want to generate another random number. The state monad makes dealing with this a lot easier.</p></div><div><p>The <code>random</code> function from <code>System.Random</code> has the following type:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">random</span> <span class="token operator">::</span> <span class="token punctuation">(</span><span class="token constant">RandomGen</span> <span class="token hvariable">g</span><span class="token punctuation">,</span> <span class="token constant">Random</span> <span class="token hvariable">a</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token hvariable">g</span> <span class="token operator">-&gt;</span> <span class="token punctuation">(</span><span class="token hvariable">a</span><span class="token punctuation">,</span> <span class="token hvariable">g</span><span class="token punctuation">)</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Meaning it takes a random generator and produces a random number along with a new generator. We can see that it's a stateful computation, so we can wrap it in the <code>State</code> <code>newtype</code> constructor and then use it as a monadic value so that passing of the state gets handled for us:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token import-statement"><span class="token keyword">import</span> System<span class="token punctuation">.</span>Random</span>
<span class="token import-statement"><span class="token keyword">import</span> Control<span class="token punctuation">.</span>Monad<span class="token punctuation">.</span>State</span>

<span class="token hvariable">randomSt</span> <span class="token operator">::</span> <span class="token punctuation">(</span><span class="token constant">RandomGen</span> <span class="token hvariable">g</span><span class="token punctuation">,</span> <span class="token constant">Random</span> <span class="token hvariable">a</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token constant">State</span> <span class="token hvariable">g</span> <span class="token hvariable">a</span>
<span class="token hvariable">randomSt</span> <span class="token operator">=</span> <span class="token constant">State</span> <span class="token hvariable">random</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>So now if we want to throw three coins (<code>True</code> is tails, <code>False</code> is heads) we just do the following:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token import-statement"><span class="token keyword">import</span> System<span class="token punctuation">.</span>Random</span>
<span class="token import-statement"><span class="token keyword">import</span> Control<span class="token punctuation">.</span>Monad<span class="token punctuation">.</span>State</span>

<span class="token hvariable">threeCoins</span> <span class="token operator">::</span> <span class="token constant">State</span> <span class="token constant">StdGen</span> <span class="token punctuation">(</span><span class="token constant">Bool</span><span class="token punctuation">,</span><span class="token constant">Bool</span><span class="token punctuation">,</span><span class="token constant">Bool</span><span class="token punctuation">)</span>
<span class="token hvariable">threeCoins</span> <span class="token operator">=</span> <span class="token keyword">do</span>
    <span class="token hvariable">a</span> <span class="token operator">&lt;-</span> <span class="token hvariable">randomSt</span>
    <span class="token hvariable">b</span> <span class="token operator">&lt;-</span> <span class="token hvariable">randomSt</span>
    <span class="token hvariable">c</span> <span class="token operator">&lt;-</span> <span class="token hvariable">randomSt</span>
    <span class="token builtin">return</span> <span class="token punctuation">(</span><span class="token hvariable">a</span><span class="token punctuation">,</span><span class="token hvariable">b</span><span class="token punctuation">,</span><span class="token hvariable">c</span><span class="token punctuation">)</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p><code>threeCoins</code> is now a stateful computations and after taking an initial random generator, it passes it to the first <code>randomSt</code>, which produces a number and a new generator, which gets passed to the next one and so on. We use <code>return (a,b,c)</code> to present <code>(a,b,c)</code> as the result without changing the most recent generator. Let's give this a go:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token hvariable">runState</span> <span class="token hvariable">threeCoins</span> <span class="token punctuation">(</span><span class="token hvariable">mkStdGen</span> <span class="token number">33</span><span class="token punctuation">)</span>
<span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token constant">True</span><span class="token punctuation">,</span><span class="token constant">False</span><span class="token punctuation">,</span><span class="token constant">True</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token number">680029187</span> <span class="token number">2103410263</span><span class="token punctuation">)</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Nice. Doing these sort of things that require some state to be kept in between steps just became much less of a hassle!</p></div><div><h2 data-heading="Error error on the wall" id="Error_error_on_the_wall" style="display: flex;"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>Error error on the wall</h2></div><div><p>We know by now that <code>Maybe</code> is used to add a context of possible failure to values. A value can be a <code>Just something</code> or a <code>Nothing</code>. However useful it may be, when we have a <code>Nothing</code>, all we know is that there was some sort of failure, but there's no way to cram some more info in there telling us what kind of failure it was or why it failed.</p></div><div><p>The <code>Either e a</code> type on the other hand, allows us to incorporate a context of possible failure to our values while also being able to attach values to the failure, so that they can describe what went wrong or provide some other useful info regarding the failure. An <code>Either e a</code> value can either be a <code>Right</code> value, signifying the right answer and a success, or it can be a <code>Left</code> value, signifying failure. For instance:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token operator">:</span><span class="token hvariable">t</span> <span class="token constant">Right</span> <span class="token number">4</span>
<span class="token constant">Right</span> <span class="token number">4</span> <span class="token operator">::</span> <span class="token punctuation">(</span><span class="token constant">Num</span> <span class="token hvariable">t</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token constant">Either</span> <span class="token hvariable">a</span> <span class="token hvariable">t</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token operator">:</span><span class="token hvariable">t</span> <span class="token constant">Left</span> <span class="token string">"out of cheese error"</span>
<span class="token constant">Left</span> <span class="token string">"out of cheese error"</span> <span class="token operator">::</span> <span class="token constant">Either</span> <span class="token punctuation">[</span><span class="token constant">Char</span><span class="token punctuation">]</span> <span class="token hvariable">b</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>This is pretty much just an enhanced <code>Maybe</code>, so it makes sense for it to be a monad, because it can also be viewed as a value with an added context of possible failure, only now there's a value attached when there's an error as well.</p></div><div><p>Its <code>Monad</code> instance is similar to that of <code>Maybe</code> and it can be found in <code>Control.Monad.Error</code>:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token keyword">instance</span> <span class="token punctuation">(</span><span class="token constant">Error</span> <span class="token hvariable">e</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token constant">Monad</span> <span class="token punctuation">(</span><span class="token constant">Either</span> <span class="token hvariable">e</span><span class="token punctuation">)</span> <span class="token keyword">where</span>
    <span class="token builtin">return</span> <span class="token hvariable">x</span> <span class="token operator">=</span> <span class="token constant">Right</span> <span class="token hvariable">x</span> 
    <span class="token constant">Right</span> <span class="token hvariable">x</span> <span class="token operator">&gt;&gt;=</span> <span class="token hvariable">f</span> <span class="token operator">=</span> <span class="token hvariable">f</span> <span class="token hvariable">x</span>
    <span class="token constant">Left</span> <span class="token hvariable">err</span> <span class="token operator">&gt;&gt;=</span> <span class="token hvariable">f</span> <span class="token operator">=</span> <span class="token constant">Left</span> <span class="token hvariable">err</span>
    <span class="token builtin">fail</span> <span class="token hvariable">msg</span> <span class="token operator">=</span> <span class="token constant">Left</span> <span class="token punctuation">(</span><span class="token hvariable">strMsg</span> <span class="token hvariable">msg</span><span class="token punctuation">)</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p><code>return</code>, as always, takes a value and puts it in a default minimal context. It wraps our value in the <code>Right</code> constructor because we're using <code>Right</code> to represent a successful computation where a result is present. This is a lot like <code>return</code> for <code>Maybe</code>.</p></div><div><p>The <code>&gt;&gt;=</code> examines two possible cases: a <code>Left</code> and a <code>Right</code>. In the case of a <code>Right</code>, the function <code>f</code> is applied to the value inside it, similar to how in the case of a <code>Just</code>, the function is just applied to its contents. In the case of an error, the <code>Left</code> value is kept, along with its contents, which describe the failure.</p></div><div><p>The <code>Monad</code> instance for <code>Either e</code> makes an additional requirement, and that is that the type of the value contained in a <code>Left</code>, the one that's indexed by the <code>e</code> type parameter, has to be an instance of the <code>Error</code> type class. The <code>Error</code> type class is for types whose values can act like error messages. It defines the <code>strMsg</code> function, which takes an error in the form of a string and returns such a value. A good example of an <code>Error</code> instance is, well, the <code>String</code> type! In the case of <code>String</code>, the <code>strMsg</code> function just returns the string that it got:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token operator">:</span><span class="token hvariable">t</span> <span class="token hvariable">strMsg</span>
<span class="token hvariable">strMsg</span> <span class="token operator">::</span> <span class="token punctuation">(</span><span class="token constant">Error</span> <span class="token hvariable">a</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token constant">String</span> <span class="token operator">-&gt;</span> <span class="token hvariable">a</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token hvariable">strMsg</span> <span class="token string">"boom!"</span> <span class="token operator">::</span> <span class="token constant">String</span>
<span class="token string">"boom!"</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>But since we usually use <code>String</code> to describe the error when using <code>Either</code>, we don't have to worry about this too much. When a pattern match fails in <code>do</code> notation, a <code>Left</code> value is used to signify this failure.</p></div><div><p>Anyway, here are a few examples of usage:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token constant">Left</span> <span class="token string">"boom"</span> <span class="token operator">&gt;&gt;=</span> <span class="token operator">\</span><span class="token hvariable">x</span> <span class="token operator">-&gt;</span> <span class="token builtin">return</span> <span class="token punctuation">(</span><span class="token hvariable">x</span><span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span>
<span class="token constant">Left</span> <span class="token string">"boom"</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token constant">Right</span> <span class="token number">100</span> <span class="token operator">&gt;&gt;=</span> <span class="token operator">\</span><span class="token hvariable">x</span> <span class="token operator">-&gt;</span> <span class="token constant">Left</span> <span class="token string">"no way!"</span>
<span class="token constant">Left</span> <span class="token string">"no way!"</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>When we use <code>&gt;&gt;=</code> to feed a <code>Left</code> value to a function, the function is ignored and an identical <code>Left</code> value is returned. When we feed a <code>Right</code> value to a function, the function gets applied to what's on the inside, but in this case that function produced a <code>Left</code> value anyway!</p></div><div><p>When we try to feed a <code>Right</code> value to a function that also succeeds, we're tripped up by a peculiar type error! Hmmm.</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token constant">Right</span> <span class="token number">3</span> <span class="token operator">&gt;&gt;=</span> <span class="token operator">\</span><span class="token hvariable">x</span> <span class="token operator">-&gt;</span> <span class="token builtin">return</span> <span class="token punctuation">(</span><span class="token hvariable">x</span> <span class="token operator">+</span> <span class="token number">100</span><span class="token punctuation">)</span>

<span class="token operator">&lt;</span><span class="token hvariable">interactive</span><span class="token operator">&gt;:</span><span class="token number">1</span><span class="token operator">:</span><span class="token number">0</span><span class="token operator">:</span>
    <span class="token constant">Ambiguous</span> <span class="token keyword">type</span> <span class="token hvariable">variable</span> `<span class="token hvariable">a'</span> <span class="token keyword">in</span> <span class="token hvariable">the</span> <span class="token hvariable">constraints</span><span class="token operator">:</span>
      `<span class="token constant">Error</span> <span class="token hvariable">a'</span> <span class="token hvariable">arising</span> <span class="token hvariable">from</span> <span class="token hvariable">a</span> <span class="token hvariable">use</span> <span class="token keyword">of</span> `<span class="token hvariable">it'</span> <span class="token hvariable">at</span> <span class="token operator">&lt;</span><span class="token hvariable">interactive</span><span class="token operator">&gt;:</span><span class="token number">1</span><span class="token operator">:</span><span class="token number">0</span><span class="token operator">-</span><span class="token number">33</span>
      `<span class="token constant">Show</span> <span class="token hvariable">a'</span> <span class="token hvariable">arising</span> <span class="token hvariable">from</span> <span class="token hvariable">a</span> <span class="token hvariable">use</span> <span class="token keyword">of</span> `<span class="token builtin">print</span>' <span class="token hvariable">at</span> <span class="token operator">&lt;</span><span class="token hvariable">interactive</span><span class="token operator">&gt;:</span><span class="token number">1</span><span class="token operator">:</span><span class="token number">0</span><span class="token operator">-</span><span class="token number">33</span>
    <span class="token constant">Probable</span> <span class="token hvariable">fix</span><span class="token operator">:</span> <span class="token hvariable">add</span> <span class="token hvariable">a</span> <span class="token keyword">type</span> <span class="token hvariable">signature</span> <span class="token hvariable">that</span> <span class="token hvariable">fixes</span> <span class="token hvariable">these</span> <span class="token keyword">type</span> <span class="token hvariable">variable</span><span class="token punctuation">(</span><span class="token hvariable">s</span><span class="token punctuation">)</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Haskell says that it doesn't know which type to choose for the <code>e</code> part of our <code>Either e a</code> typed value, even though we're just printing the <code>Right</code> part. This is due to the <code>Error e</code> constraint on the <code>Monad</code> instance. So if you get type errors like this one when using <code>Either</code> as a monad, just add an explicit type signature:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token constant">Right</span> <span class="token number">3</span> <span class="token operator">&gt;&gt;=</span> <span class="token operator">\</span><span class="token hvariable">x</span> <span class="token operator">-&gt;</span> <span class="token builtin">return</span> <span class="token punctuation">(</span><span class="token hvariable">x</span> <span class="token operator">+</span> <span class="token number">100</span><span class="token punctuation">)</span> <span class="token operator">::</span> <span class="token constant">Either</span> <span class="token constant">String</span> <span class="token constant">Int</span>
<span class="token constant">Right</span> <span class="token number">103</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Alright, now it works!</p></div><div><p>Other than this little hangup, using this monad is very similar to using <code>Maybe</code> as a monad. In the previous chapter, we used the monadic aspects of <code>Maybe</code> to simulate birds landing on the balancing pole of a tightrope walker. As an exercise, you can rewrite that with the error monad so that when the tightrope walker slips and falls, we remember how many birds were on each side of the pole when he fell.</p></div><div><h2 data-heading="Some useful monadic functions" id="Some_useful_monadic_functions" style="display: flex;"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>Some useful monadic functions</h2></div><div><p>In this section, we're going to explore a few functions that either operate on monadic values or return monadic values as their results (or both!). Such functions are usually referred to as monadic functions. While some of them will be brand new, others will be monadic counterparts of functions that we already know, like <code>filter</code> and <code>foldl</code>. Let's see what they are then!</p></div><div><h3 data-heading="liftM and friends" id="liftM_and_friends" style="display: flex;"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>liftM and friends</h3></div><div><p><span alt="LYHfGG_113_wolf.png" src="LYHfGG_113_wolf.png" class="internal-embed media-embed image-embed is-loaded"><img alt="LYHfGG_113_wolf.png" src="курсы\learn-you-a-haskell-for-great-good!\картинки\lyhfgg_113_wolf.png"></span></p></div><div><p>When we started our journey to the top of Monad Mountain, we first looked at functors, which are for things that can be mapped over. Then, we learned about improved functors called applicative functors, which allowed us to apply normal functions between several applicative values as well as to take a normal value and put it in some default context. Finally, we introduced monads as improved applicative functors, which added the ability for these values with context to somehow be fed into normal functions.</p></div><div><p>So every monad is an applicative functor and every applicative functor is a functor. The <code>Applicative</code> type class has a class constraint such that our type has to be an instance of <code>Functor</code> before we can make it an instance of <code>Applicative</code>. But even though <code>Monad</code> should have the same constraint for <code>Applicative</code>, as every monad is an applicative functor, it doesn't, because the <code>Monad</code> type class was introduced to Haskell way before <code>Applicative</code>.</p></div><div><p>But even though every monad is a functor, we don't have to rely on it having a <code>Functor</code> instance because of the <code>liftM</code> function. <code>liftM</code> takes a function and a monadic value and maps it over the monadic value. So it's pretty much the same thing as <code>fmap</code>! This is <code>liftM</code>'s type:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">liftM</span> <span class="token operator">::</span> <span class="token punctuation">(</span><span class="token constant">Monad</span> <span class="token hvariable">m</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">(</span><span class="token hvariable">a</span> <span class="token operator">-&gt;</span> <span class="token hvariable">b</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token hvariable">m</span> <span class="token hvariable">a</span> <span class="token operator">-&gt;</span> <span class="token hvariable">m</span> <span class="token hvariable">b</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>And this is the type of <code>fmap</code>:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token builtin">fmap</span> <span class="token operator">::</span> <span class="token punctuation">(</span><span class="token constant">Functor</span> <span class="token hvariable">f</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">(</span><span class="token hvariable">a</span> <span class="token operator">-&gt;</span> <span class="token hvariable">b</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token hvariable">f</span> <span class="token hvariable">a</span> <span class="token operator">-&gt;</span> <span class="token hvariable">f</span> <span class="token hvariable">b</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>If the <code>Functor</code> and <code>Monad</code> instances for a type obey the functor and monad laws, these two amount to the same thing (and all the monads that we've met so far obey both). This is kind of like <code>pure</code> and <code>return</code> do the same thing, only one has an <code>Applicative</code> class constraint whereas the other has a <code>Monad</code> one. Let's try <code>liftM</code> out:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token hvariable">liftM</span> <span class="token punctuation">(</span><span class="token operator">*</span><span class="token number">3</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token constant">Just</span> <span class="token number">8</span><span class="token punctuation">)</span>
<span class="token constant">Just</span> <span class="token number">24</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token builtin">fmap</span> <span class="token punctuation">(</span><span class="token operator">*</span><span class="token number">3</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token constant">Just</span> <span class="token number">8</span><span class="token punctuation">)</span>
<span class="token constant">Just</span> <span class="token number">24</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token hvariable">runWriter</span> <span class="token operator">$</span> <span class="token hvariable">liftM</span> <span class="token builtin">not</span> <span class="token operator">$</span> <span class="token constant">Writer</span> <span class="token punctuation">(</span><span class="token constant">True</span><span class="token punctuation">,</span> <span class="token string">"chickpeas"</span><span class="token punctuation">)</span>
<span class="token punctuation">(</span><span class="token constant">False</span><span class="token punctuation">,</span><span class="token string">"chickpeas"</span><span class="token punctuation">)</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token hvariable">runWriter</span> <span class="token operator">$</span> <span class="token builtin">fmap</span> <span class="token builtin">not</span> <span class="token operator">$</span> <span class="token constant">Writer</span> <span class="token punctuation">(</span><span class="token constant">True</span><span class="token punctuation">,</span> <span class="token string">"chickpeas"</span><span class="token punctuation">)</span>
<span class="token punctuation">(</span><span class="token constant">False</span><span class="token punctuation">,</span><span class="token string">"chickpeas"</span><span class="token punctuation">)</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token hvariable">runState</span> <span class="token punctuation">(</span><span class="token hvariable">liftM</span> <span class="token punctuation">(</span><span class="token operator">+</span><span class="token number">100</span><span class="token punctuation">)</span> <span class="token hvariable">pop</span><span class="token punctuation">)</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">]</span>
<span class="token punctuation">(</span><span class="token number">101</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token hvariable">runState</span> <span class="token punctuation">(</span><span class="token builtin">fmap</span> <span class="token punctuation">(</span><span class="token operator">+</span><span class="token number">100</span><span class="token punctuation">)</span> <span class="token hvariable">pop</span><span class="token punctuation">)</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">]</span>
<span class="token punctuation">(</span><span class="token number">101</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>We already know quite well how <code>fmap</code> works with <code>Maybe</code> values. And <code>liftM</code> does the same thing. For <code>Writer</code> values, the function is mapped over the first component of the tuple, which is the result. Doing <code>fmap</code> or <code>liftM</code> over a stateful computation results in another stateful computation, only its eventual result is modified by the supplied function. Had we not mapped <code>(+100)</code> over <code>pop</code> in this case before running it, it would have returned <code>(1,[2,3,4])</code>.</p></div><div><p>This is how <code>liftM</code> is implemented:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">liftM</span> <span class="token operator">::</span> <span class="token punctuation">(</span><span class="token constant">Monad</span> <span class="token hvariable">m</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">(</span><span class="token hvariable">a</span> <span class="token operator">-&gt;</span> <span class="token hvariable">b</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token hvariable">m</span> <span class="token hvariable">a</span> <span class="token operator">-&gt;</span> <span class="token hvariable">m</span> <span class="token hvariable">b</span>
<span class="token hvariable">liftM</span> <span class="token hvariable">f</span> <span class="token hvariable">m</span> <span class="token operator">=</span> <span class="token hvariable">m</span> <span class="token operator">&gt;&gt;=</span> <span class="token punctuation">(</span><span class="token operator">\</span><span class="token hvariable">x</span> <span class="token operator">-&gt;</span> <span class="token builtin">return</span> <span class="token punctuation">(</span><span class="token hvariable">f</span> <span class="token hvariable">x</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Or with <code>do</code> notation:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">liftM</span> <span class="token operator">::</span> <span class="token punctuation">(</span><span class="token constant">Monad</span> <span class="token hvariable">m</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">(</span><span class="token hvariable">a</span> <span class="token operator">-&gt;</span> <span class="token hvariable">b</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token hvariable">m</span> <span class="token hvariable">a</span> <span class="token operator">-&gt;</span> <span class="token hvariable">m</span> <span class="token hvariable">b</span>
<span class="token hvariable">liftM</span> <span class="token hvariable">f</span> <span class="token hvariable">m</span> <span class="token operator">=</span> <span class="token keyword">do</span>
    <span class="token hvariable">x</span> <span class="token operator">&lt;-</span> <span class="token hvariable">m</span>
    <span class="token builtin">return</span> <span class="token punctuation">(</span><span class="token hvariable">f</span> <span class="token hvariable">x</span><span class="token punctuation">)</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>We feed the monadic value <code>m</code> into the function and then we apply the function <code>f</code> to its result before putting it back into a default context. Because of the monad laws, this is guaranteed not to change the context, only the result that the monadic value presents. We see that <code>liftM</code> is implemented without referencing the <code>Functor</code> type class at all. This means that we can implement <code>fmap</code> (or <code>liftM</code>, whatever you want to call it) just by using the goodies that monads offer us. Because of this, we can conclude that monads are stronger than just regular old functors.</p></div><div><p>The <code>Applicative</code> type class allows us to apply functions between values with contexts as if they were normal values. Like this:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token punctuation">(</span><span class="token operator">+</span><span class="token punctuation">)</span> <span class="token operator">&lt;$&gt;</span> <span class="token constant">Just</span> <span class="token number">3</span> <span class="token operator">&lt;*&gt;</span> <span class="token constant">Just</span> <span class="token number">5</span>
<span class="token constant">Just</span> <span class="token number">8</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token punctuation">(</span><span class="token operator">+</span><span class="token punctuation">)</span> <span class="token operator">&lt;$&gt;</span> <span class="token constant">Just</span> <span class="token number">3</span> <span class="token operator">&lt;*&gt;</span> <span class="token constant">Nothing</span>
<span class="token constant">Nothing</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Using this applicative style makes things pretty easy. <code>&lt;$&gt;</code> is just <code>fmap</code> and <code>&lt;*&gt;</code> is a function from the <code>Applicative</code> type class that has the following type:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token punctuation">(</span><span class="token operator">&lt;*&gt;</span><span class="token punctuation">)</span> <span class="token operator">::</span> <span class="token punctuation">(</span><span class="token constant">Applicative</span> <span class="token hvariable">f</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token hvariable">f</span> <span class="token punctuation">(</span><span class="token hvariable">a</span> <span class="token operator">-&gt;</span> <span class="token hvariable">b</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token hvariable">f</span> <span class="token hvariable">a</span> <span class="token operator">-&gt;</span> <span class="token hvariable">f</span> <span class="token hvariable">b</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>So it's kind of like <code>fmap</code>, only the function itself is in a context. We have to somehow extract it from the context and map it over the <code>f a</code> value and then assemble the context back together. Because all functions are curried in Haskell by default, we can use the combination of <code>&lt;$&gt;</code> and <code>&lt;*&gt;</code> to apply functions that take several parameters between applicative values.</p></div><div><p>Anyway, it turns out that just like <code>fmap</code>, <code>&lt;*&gt;</code> can also be implemented by using only what the <code>Monad</code> type class give us. The <code>ap</code> function is basically <code>&lt;*&gt;</code>, only it has a <code>Monad</code> constraint instead of an <code>Applicative</code> one. Here's its definition:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">ap</span> <span class="token operator">::</span> <span class="token punctuation">(</span><span class="token constant">Monad</span> <span class="token hvariable">m</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token hvariable">m</span> <span class="token punctuation">(</span><span class="token hvariable">a</span> <span class="token operator">-&gt;</span> <span class="token hvariable">b</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token hvariable">m</span> <span class="token hvariable">a</span> <span class="token operator">-&gt;</span> <span class="token hvariable">m</span> <span class="token hvariable">b</span>
<span class="token hvariable">ap</span> <span class="token hvariable">mf</span> <span class="token hvariable">m</span> <span class="token operator">=</span> <span class="token keyword">do</span>
    <span class="token hvariable">f</span> <span class="token operator">&lt;-</span> <span class="token hvariable">mf</span>
    <span class="token hvariable">x</span> <span class="token operator">&lt;-</span> <span class="token hvariable">m</span>
    <span class="token builtin">return</span> <span class="token punctuation">(</span><span class="token hvariable">f</span> <span class="token hvariable">x</span><span class="token punctuation">)</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p><code>mf</code> is a monadic value whose result is a function. Because the function is in a context as well as the value, we get the function from the context and call it <code>f</code>, then get the value and call that <code>x</code> and then finally apply the function to the value and present that as a result. Here's a quick demonstration:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token constant">Just</span> <span class="token punctuation">(</span><span class="token operator">+</span><span class="token number">3</span><span class="token punctuation">)</span> <span class="token operator">&lt;*&gt;</span> <span class="token constant">Just</span> <span class="token number">4</span>
<span class="token constant">Just</span> <span class="token number">7</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token constant">Just</span> <span class="token punctuation">(</span><span class="token operator">+</span><span class="token number">3</span><span class="token punctuation">)</span> <span class="token operator">`ap`</span> <span class="token constant">Just</span> <span class="token number">4</span>
<span class="token constant">Just</span> <span class="token number">7</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token punctuation">[</span><span class="token punctuation">(</span><span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token operator">+</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token operator">+</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token operator">&lt;*&gt;</span> <span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">,</span><span class="token number">11</span><span class="token punctuation">]</span>
<span class="token punctuation">[</span><span class="token number">11</span><span class="token punctuation">,</span><span class="token number">12</span><span class="token punctuation">,</span><span class="token number">12</span><span class="token punctuation">,</span><span class="token number">13</span><span class="token punctuation">,</span><span class="token number">13</span><span class="token punctuation">,</span><span class="token number">14</span><span class="token punctuation">]</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token punctuation">[</span><span class="token punctuation">(</span><span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token operator">+</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token operator">+</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token operator">`ap`</span> <span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">,</span><span class="token number">11</span><span class="token punctuation">]</span>
<span class="token punctuation">[</span><span class="token number">11</span><span class="token punctuation">,</span><span class="token number">12</span><span class="token punctuation">,</span><span class="token number">12</span><span class="token punctuation">,</span><span class="token number">13</span><span class="token punctuation">,</span><span class="token number">13</span><span class="token punctuation">,</span><span class="token number">14</span><span class="token punctuation">]</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Now we see that monads are stronger than applicatives as well, because we can use the functions from <code>Monad</code> to implement the ones for <code>Applicative</code>. In fact, many times when a type is found to be a monad, people first write up a <code>Monad</code> instance and then make an <code>Applicative</code> instance by just saying that <code>pure</code> is <code>return</code> and <code>&lt;*&gt;</code> is <code>ap</code>. Similarly, if you already have a <code>Monad</code> instance for something, you can give it a <code>Functor</code> instance just saying that <code>fmap</code> is <code>liftM</code>.</p></div><div><p>The <code>liftA2</code> function is a convenience function for applying a function between two applicative values. It's defined simply like so:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">liftA2</span> <span class="token operator">::</span> <span class="token punctuation">(</span><span class="token constant">Applicative</span> <span class="token hvariable">f</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">(</span><span class="token hvariable">a</span> <span class="token operator">-&gt;</span> <span class="token hvariable">b</span> <span class="token operator">-&gt;</span> <span class="token hvariable">c</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token hvariable">f</span> <span class="token hvariable">a</span> <span class="token operator">-&gt;</span> <span class="token hvariable">f</span> <span class="token hvariable">b</span> <span class="token operator">-&gt;</span> <span class="token hvariable">f</span> <span class="token hvariable">c</span>
<span class="token hvariable">liftA2</span> <span class="token hvariable">f</span> <span class="token hvariable">x</span> <span class="token hvariable">y</span> <span class="token operator">=</span> <span class="token hvariable">f</span> <span class="token operator">&lt;$&gt;</span> <span class="token hvariable">x</span> <span class="token operator">&lt;*&gt;</span> <span class="token hvariable">y</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>The <code>liftM2</code> function does the same thing, only it has a <code>Monad</code> constraint. There also exist <code>liftM3</code> and <code>liftM4</code> and <code>liftM5</code>.</p></div><div><p>We saw how monads are stronger than applicatives and functors and how even though all monads are functors and applicative functors, they don't necessarily have <code>Functor</code> and <code>Applicative</code> instances, so we examined the monadic equivalents of the functions that functors and applicative functors use.</p></div><div><h3 data-heading="The join function" id="The_join_function" style="display: flex;"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>The join function</h3></div><div><p>Here's some food for thought: if the result of one monadic value is another monadic value i.e. if one monadic value is nested inside the other, can you flatten them to just a single normal monadic value? Like, if we have <code>Just (Just 9)</code>, can we make that into <code>Just 9</code>? It turns out that any nested monadic value can be flattened and that this is actually a property unique to monads. For this, the <code>join</code> function exists. Its type is this:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">join</span> <span class="token operator">::</span> <span class="token punctuation">(</span><span class="token constant">Monad</span> <span class="token hvariable">m</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token hvariable">m</span> <span class="token punctuation">(</span><span class="token hvariable">m</span> <span class="token hvariable">a</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token hvariable">m</span> <span class="token hvariable">a</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>So it takes a monadic value within a monadic value and gives us just a monadic value, so it sort of flattens it. Here it is with some <code>Maybe</code> values:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token hvariable">join</span> <span class="token punctuation">(</span><span class="token constant">Just</span> <span class="token punctuation">(</span><span class="token constant">Just</span> <span class="token number">9</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token constant">Just</span> <span class="token number">9</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token hvariable">join</span> <span class="token punctuation">(</span><span class="token constant">Just</span> <span class="token constant">Nothing</span><span class="token punctuation">)</span>
<span class="token constant">Nothing</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token hvariable">join</span> <span class="token constant">Nothing</span>
<span class="token constant">Nothing</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>The first line has a successful computation as a result of a successful computation, so they're both just joined into one big successful computation. The second line features a <code>Nothing</code> as a result of a <code>Just</code> value. Whenever we were dealing with <code>Maybe</code> values before and we wanted to combine several of them into one, be it with <code>&lt;*&gt;</code> or <code>&gt;&gt;=</code>, they all had to be <code>Just</code> values for the result to be a <code>Just</code> value. If there was any failure along the way, the result was a failure and the same thing happens here. In the third line, we try to flatten what is from the onset a failure, so the result is a failure as well.</p></div><div><p>Flattening lists is pretty intuitive:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token hvariable">join</span> <span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">]</span><span class="token punctuation">]</span>
<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">]</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>As you can see, for lists, <code>join</code> is just <code>concat</code>. To flatten a <code>Writer</code> value whose result is a <code>Writer</code> value itself, we have to <code>mappend</code> the monoid value.</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token hvariable">runWriter</span> <span class="token operator">$</span> <span class="token hvariable">join</span> <span class="token punctuation">(</span><span class="token constant">Writer</span> <span class="token punctuation">(</span><span class="token constant">Writer</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token string">"aaa"</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token string">"bbb"</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token string">"bbbaaa"</span><span class="token punctuation">)</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>The outer monoid value <code>"bbb"</code> comes first and then to it <code>"aaa"</code> is appended. Intuitively speaking, when you want to examine what the result of a <code>Writer</code> value is, you have to write its monoid value to the log first and only then can you examine what it has inside.</p></div><div><p>Flattening <code>Either</code> values is very similar to flattening <code>Maybe</code> values:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token hvariable">join</span> <span class="token punctuation">(</span><span class="token constant">Right</span> <span class="token punctuation">(</span><span class="token constant">Right</span> <span class="token number">9</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">::</span> <span class="token constant">Either</span> <span class="token constant">String</span> <span class="token constant">Int</span>
<span class="token constant">Right</span> <span class="token number">9</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token hvariable">join</span> <span class="token punctuation">(</span><span class="token constant">Right</span> <span class="token punctuation">(</span><span class="token constant">Left</span> <span class="token string">"error"</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">::</span> <span class="token constant">Either</span> <span class="token constant">String</span> <span class="token constant">Int</span>
<span class="token constant">Left</span> <span class="token string">"error"</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token hvariable">join</span> <span class="token punctuation">(</span><span class="token constant">Left</span> <span class="token string">"error"</span><span class="token punctuation">)</span> <span class="token operator">::</span> <span class="token constant">Either</span> <span class="token constant">String</span> <span class="token constant">Int</span>
<span class="token constant">Left</span> <span class="token string">"error"</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>If we apply <code>join</code> to a stateful computation whose result is a stateful computation, the result is a stateful computation that first runs the outer stateful computation and then the resulting one. Watch:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token hvariable">runState</span> <span class="token punctuation">(</span><span class="token hvariable">join</span> <span class="token punctuation">(</span><span class="token constant">State</span> <span class="token operator">$</span> <span class="token operator">\</span><span class="token hvariable">s</span> <span class="token operator">-&gt;</span> <span class="token punctuation">(</span><span class="token hvariable">push</span> <span class="token number">10</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token operator">:</span><span class="token number">2</span><span class="token operator">:</span><span class="token hvariable">s</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">]</span>
<span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>The lambda here takes a state and puts <code>2</code> and <code>1</code> onto the stack and presents <code>push 10</code> as its result. So when this whole thing is flattened with <code>join</code> and then run, it first puts <code>2</code> and <code>1</code> onto the stack and then <code>push 10</code> gets carried out, pushing a <code>10</code> on to the top.</p></div><div><p>The implementation for <code>join</code> is as follows:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">join</span> <span class="token operator">::</span> <span class="token punctuation">(</span><span class="token constant">Monad</span> <span class="token hvariable">m</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token hvariable">m</span> <span class="token punctuation">(</span><span class="token hvariable">m</span> <span class="token hvariable">a</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token hvariable">m</span> <span class="token hvariable">a</span>
<span class="token hvariable">join</span> <span class="token hvariable">mm</span> <span class="token operator">=</span> <span class="token keyword">do</span>
    <span class="token hvariable">m</span> <span class="token operator">&lt;-</span> <span class="token hvariable">mm</span>
    <span class="token hvariable">m</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Because the result of <code>mm</code> is a monadic value, we get that result and then just put it on a line of its own because it's a monadic value. The trick here is that when we do <code>m &lt;- mm</code>, the context of the monad in which we are in gets taken care of. That's why, for instance, <code>Maybe</code> values result in <code>Just</code> values only if the outer and inner values are both <code>Just</code> values. Here's what this would look like if the <code>mm</code> value was set in advance to <code>Just (Just 8)</code>:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">joinedMaybes</span> <span class="token operator">::</span> <span class="token constant">Maybe</span> <span class="token constant">Int</span>
<span class="token hvariable">joinedMaybes</span> <span class="token operator">=</span> <span class="token keyword">do</span>
    <span class="token hvariable">m</span> <span class="token operator">&lt;-</span> <span class="token constant">Just</span> <span class="token punctuation">(</span><span class="token constant">Just</span> <span class="token number">8</span><span class="token punctuation">)</span>
    <span class="token hvariable">m</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p><span alt="LYHfGG_114_tipi.png" src="LYHfGG_114_tipi.png" class="internal-embed media-embed image-embed is-loaded"><img alt="LYHfGG_114_tipi.png" src="курсы\learn-you-a-haskell-for-great-good!\картинки\lyhfgg_114_tipi.png"></span></p></div><div><p>Perhaps the most interesting thing about <code>join</code> is that for every monad, feeding a monadic value to a function with <code>&gt;&gt;=</code> is the same thing as just mapping that function over the value and then using <code>join</code> to flatten the resulting nested monadic value! In other words, <code>m &gt;&gt;= f</code> is always the same thing as <code>join (fmap f m)</code>! It makes sense when you think about it. With <code>&gt;&gt;=</code>, we're always thinking about how to feed a monadic value to a function that takes a normal value but returns a monadic value. If we just map that function over the monadic value, we have a monadic value inside a monadic value. For instance, say we have <code>Just 9</code> and the function <code>\x -&gt; Just (x+1)</code>. If we map this function over <code>Just 9</code>, we're left with <code>Just (Just 10)</code>.</p></div><div><p>The fact that <code>m &gt;&gt;= f</code> always equals <code>join (fmap f m)</code> is very useful if we're making our own <code>Monad</code> instance for some type because it's often easier to figure out how we would flatten a nested monadic value than figuring out how to implement <code>&gt;&gt;=</code>.</p></div><div><h3 data-heading="filterM" id="filterM" style="display: flex;"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>filterM</h3></div><div><p>The <code>filter</code> function is pretty much the bread of Haskell programming (<code>map</code> being the butter). It takes a predicate and a list to filter out and then returns a new list where only the elements that satisfy the predicate are kept. Its type is this:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token builtin">filter</span> <span class="token operator">::</span> <span class="token punctuation">(</span><span class="token hvariable">a</span> <span class="token operator">-&gt;</span> <span class="token constant">Bool</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token punctuation">[</span><span class="token hvariable">a</span><span class="token punctuation">]</span> <span class="token operator">-&gt;</span> <span class="token punctuation">[</span><span class="token hvariable">a</span><span class="token punctuation">]</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>The predicate takes an element of the list and returns a <code>Bool</code> value. Now, what if the <code>Bool</code> value that it returned was actually a monadic value? Whoa! That is, what if it came with a context? Could that work? For instance, what if every <code>True</code> or a <code>False</code> value that the predicate produced also had an accompanying monoid value, like <code>["Accepted the number 5"]</code> or <code>["3 is too small"]</code>? That sounds like it could work. If that were the case, we'd expect the resulting list to also come with a log of all the log values that were produced along the way. So if the <code>Bool</code> that the predicate returned came with a context, we'd expect the final resulting list to have some context attached as well, otherwise the context that each <code>Bool</code> came with would be lost.</p></div><div><p>The <code>filterM</code> function from <code>Control.Monad</code> does just what we want! Its type is this:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">filterM</span> <span class="token operator">::</span> <span class="token punctuation">(</span><span class="token constant">Monad</span> <span class="token hvariable">m</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">(</span><span class="token hvariable">a</span> <span class="token operator">-&gt;</span> <span class="token hvariable">m</span> <span class="token constant">Bool</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token punctuation">[</span><span class="token hvariable">a</span><span class="token punctuation">]</span> <span class="token operator">-&gt;</span> <span class="token hvariable">m</span> <span class="token punctuation">[</span><span class="token hvariable">a</span><span class="token punctuation">]</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>The predicate returns a monadic value whose result is a <code>Bool</code>, but because it's a monadic value, its context can be anything from a possible failure to non-determinism and more! To ensure that the context is reflected in the final result, the result is also a monadic value.</p></div><div><p>Let's take a list and only keep those values that are smaller than 4. To start, we'll just use the regular <code>filter</code> function:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token builtin">filter</span> <span class="token punctuation">(</span><span class="token operator">\</span><span class="token hvariable">x</span> <span class="token operator">-&gt;</span> <span class="token hvariable">x</span> <span class="token operator">&lt;</span> <span class="token number">4</span><span class="token punctuation">)</span> <span class="token punctuation">[</span><span class="token number">9</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">10</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">]</span>
<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">]</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>That's pretty easy. Now, let's make a predicate that, aside from presenting a <code>True</code> or <code>False</code> result, also provides a log of what it did. Of course, we'll be using the <code>Writer</code> monad for this:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">keepSmall</span> <span class="token operator">::</span> <span class="token constant">Int</span> <span class="token operator">-&gt;</span> <span class="token constant">Writer</span> <span class="token punctuation">[</span><span class="token constant">String</span><span class="token punctuation">]</span> <span class="token constant">Bool</span>
<span class="token hvariable">keepSmall</span> <span class="token hvariable">x</span>
    <span class="token operator">|</span> <span class="token hvariable">x</span> <span class="token operator">&lt;</span> <span class="token number">4</span> <span class="token operator">=</span> <span class="token keyword">do</span>
        <span class="token hvariable">tell</span> <span class="token punctuation">[</span><span class="token string">"Keeping "</span> <span class="token operator">++</span> <span class="token builtin">show</span> <span class="token hvariable">x</span><span class="token punctuation">]</span>
        <span class="token builtin">return</span> <span class="token constant">True</span>
    <span class="token operator">|</span> <span class="token builtin">otherwise</span> <span class="token operator">=</span> <span class="token keyword">do</span>
        <span class="token hvariable">tell</span> <span class="token punctuation">[</span><span class="token builtin">show</span> <span class="token hvariable">x</span> <span class="token operator">++</span> <span class="token string">" is too large, throwing it away"</span><span class="token punctuation">]</span>
        <span class="token builtin">return</span> <span class="token constant">False</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Instead of just and returning a <code>Bool</code>, this function returns a <code>Writer [String] Bool</code>. It's a monadic predicate. Sounds fancy, doesn't it? If the number is smaller than <code>4</code> we report that we're keeping it and then <code>return True</code>.</p></div><div><p>Now, let's give it to <code>filterM</code> along with a list. Because the predicate returns a <code>Writer</code> value, the resulting list will also be a <code>Writer</code> value.</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token builtin">fst</span> <span class="token operator">$</span> <span class="token hvariable">runWriter</span> <span class="token operator">$</span> <span class="token hvariable">filterM</span> <span class="token hvariable">keepSmall</span> <span class="token punctuation">[</span><span class="token number">9</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">10</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">]</span>
<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">]</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Examining the result of the resulting <code>Writer</code> value, we see that everything is in order. Now, let's print the log and see what we got:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token builtin">mapM_</span> <span class="token builtin">putStrLn</span> <span class="token operator">$</span> <span class="token builtin">snd</span> <span class="token operator">$</span> <span class="token hvariable">runWriter</span> <span class="token operator">$</span> <span class="token hvariable">filterM</span> <span class="token hvariable">keepSmall</span> <span class="token punctuation">[</span><span class="token number">9</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">10</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">]</span>
<span class="token number">9</span> <span class="token hvariable">is</span> <span class="token hvariable">too</span> <span class="token hvariable">large</span><span class="token punctuation">,</span> <span class="token hvariable">throwing</span> <span class="token hvariable">it</span> <span class="token hvariable">away</span>
<span class="token constant">Keeping</span> <span class="token number">1</span>
<span class="token number">5</span> <span class="token hvariable">is</span> <span class="token hvariable">too</span> <span class="token hvariable">large</span><span class="token punctuation">,</span> <span class="token hvariable">throwing</span> <span class="token hvariable">it</span> <span class="token hvariable">away</span>
<span class="token constant">Keeping</span> <span class="token number">2</span>
<span class="token number">10</span> <span class="token hvariable">is</span> <span class="token hvariable">too</span> <span class="token hvariable">large</span><span class="token punctuation">,</span> <span class="token hvariable">throwing</span> <span class="token hvariable">it</span> <span class="token hvariable">away</span>
<span class="token constant">Keeping</span> <span class="token number">3</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Awesome. So just by providing a monadic predicate to <code>filterM</code>, we were able to filter a list while taking advantage of the monadic context that we used.</p></div><div><p>A very cool Haskell trick is using <code>filterM</code> to get the powerset of a list (if we think of them as sets for now). The powerset of some set is a set of all subsets of that set. So if we have a set like <code>[1,2,3]</code>, its powerset would include the following sets:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">]</span>
<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">]</span>
<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">]</span>
<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span>
<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">]</span>
<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span>
<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span>
<span class="token punctuation">[</span><span class="token punctuation">]</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>In other words, getting a powerset is like getting all the combinations of keeping and throwing out elements from a set. <code>[2,3]</code> is like the original set, only we excluded the number <code>1</code>.</p></div><div><p>To make a function that returns a powerset of some list, we're going to rely on non-determinism. We take the list <code>[1,2,3]</code> and then look at the first element, which is <code>1</code> and we ask ourselves: should we keep it or drop it? Well, we'd like to do both actually. So we are going to filter a list and we'll use a predicate that non-deterministically both keeps and drops every element from the list. Here's our <code>powerset</code> function:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">powerset</span> <span class="token operator">::</span> <span class="token punctuation">[</span><span class="token hvariable">a</span><span class="token punctuation">]</span> <span class="token operator">-&gt;</span> <span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token hvariable">a</span><span class="token punctuation">]</span><span class="token punctuation">]</span>
<span class="token hvariable">powerset</span> <span class="token hvariable">xs</span> <span class="token operator">=</span> <span class="token hvariable">filterM</span> <span class="token punctuation">(</span><span class="token operator">\</span><span class="token hvariable">x</span> <span class="token operator">-&gt;</span> <span class="token punctuation">[</span><span class="token constant">True</span><span class="token punctuation">,</span> <span class="token constant">False</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token hvariable">xs</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Wait, that's it? Yup. We choose to drop and keep every element, regardless of what that element is. We have a non-deterministic predicate, so the resulting list will also be a non-deterministic value and will thus be a list of lists. Let's give this a go:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token hvariable">powerset</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">]</span>
<span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">]</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>This takes a bit of thinking to wrap your head around, but if you just consider lists as non-deterministic values that don't know what to be so they just decide to be everything at once, it's a bit easier.</p></div><div><h3 data-heading="foldM" id="foldM" style="display: flex;"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>foldM</h3></div><div><p>The monadic counterpart to <code>foldl</code> is <code>foldM</code>. If you remember your folds from the <a data-tooltip-position="top" aria-label="http://learnyouahaskell.com/folds" rel="noopener" class="external-link" href="http://learnyouahaskell.com/folds" target="_blank">folds section</a>, you know that <code>foldl</code> takes a binary function, a starting accumulator and a list to fold up and then folds it from the left into a single value by using the binary function. <code>foldM</code> does the same thing, except it takes a binary function that produces a monadic value and folds the list up with that. Unsurprisingly, the resulting value is also monadic. The type of <code>foldl</code> is this:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token builtin">foldl</span> <span class="token operator">::</span> <span class="token punctuation">(</span><span class="token hvariable">a</span> <span class="token operator">-&gt;</span> <span class="token hvariable">b</span> <span class="token operator">-&gt;</span> <span class="token hvariable">a</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token hvariable">a</span> <span class="token operator">-&gt;</span> <span class="token punctuation">[</span><span class="token hvariable">b</span><span class="token punctuation">]</span> <span class="token operator">-&gt;</span> <span class="token hvariable">a</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Whereas <code>foldM</code> has the following type:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">foldM</span> <span class="token operator">::</span> <span class="token punctuation">(</span><span class="token constant">Monad</span> <span class="token hvariable">m</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">(</span><span class="token hvariable">a</span> <span class="token operator">-&gt;</span> <span class="token hvariable">b</span> <span class="token operator">-&gt;</span> <span class="token hvariable">m</span> <span class="token hvariable">a</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token hvariable">a</span> <span class="token operator">-&gt;</span> <span class="token punctuation">[</span><span class="token hvariable">b</span><span class="token punctuation">]</span> <span class="token operator">-&gt;</span> <span class="token hvariable">m</span> <span class="token hvariable">a</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>The value that the binary function returns is monadic and so the result of the whole fold is monadic as well. Let's sum a list of numbers with a fold:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token builtin">foldl</span> <span class="token punctuation">(</span><span class="token operator">\</span><span class="token hvariable">acc</span> <span class="token hvariable">x</span> <span class="token operator">-&gt;</span> <span class="token hvariable">acc</span> <span class="token operator">+</span> <span class="token hvariable">x</span><span class="token punctuation">)</span> <span class="token number">0</span> <span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">8</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">]</span>
<span class="token number">14</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>The starting accumulator is <code>0</code> and then <code>2</code> gets added to the accumulator, resulting in a new accumulator that has a value of <code>2</code>. <code>8</code> gets added to this accumulator resulting in an accumulator of <code>10</code> and so on and when we reach the end, the final accumulator is the result.</p></div><div><p>Now what if we wanted to sum a list of numbers but with the added condition that if any number is greater than <code>9</code> in the list, the whole thing fails? It would make sense to use a binary function that checks if the current number is greater than <code>9</code> and if it is, fails, and if it isn't, continues on its merry way. Because of this added possibility of failure, let's make our binary function return a <code>Maybe</code> accumulator instead of a normal one. Here's the binary function:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">binSmalls</span> <span class="token operator">::</span> <span class="token constant">Int</span> <span class="token operator">-&gt;</span> <span class="token constant">Int</span> <span class="token operator">-&gt;</span> <span class="token constant">Maybe</span> <span class="token constant">Int</span>
<span class="token hvariable">binSmalls</span> <span class="token hvariable">acc</span> <span class="token hvariable">x</span>
    <span class="token operator">|</span> <span class="token hvariable">x</span> <span class="token operator">&gt;</span> <span class="token number">9</span>     <span class="token operator">=</span> <span class="token constant">Nothing</span>
    <span class="token operator">|</span> <span class="token builtin">otherwise</span> <span class="token operator">=</span> <span class="token constant">Just</span> <span class="token punctuation">(</span><span class="token hvariable">acc</span> <span class="token operator">+</span> <span class="token hvariable">x</span><span class="token punctuation">)</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Because our binary function is now a monadic function, we can't use it with the normal <code>foldl</code>, but we have to use <code>foldM</code>. Here goes:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token hvariable">foldM</span> <span class="token hvariable">binSmalls</span> <span class="token number">0</span> <span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">8</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">]</span>
<span class="token constant">Just</span> <span class="token number">14</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token hvariable">foldM</span> <span class="token hvariable">binSmalls</span> <span class="token number">0</span> <span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">11</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">]</span>
<span class="token constant">Nothing</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Excellent! Because one number in the list was greater than <code>9</code>, the whole thing resulted in a <code>Nothing</code>. Folding with a binary function that returns a <code>Writer</code> value is cool as well because then you log whatever you want as your fold goes along its way.</p></div><div><h3 data-heading="Making a safe RPN calculator" id="Making_a_safe_RPN_calculator" style="display: flex;"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>Making a safe RPN calculator</h3></div><div><p><span alt="LYHfGG_115_miner.png" src="LYHfGG_115_miner.png" class="internal-embed media-embed image-embed is-loaded"><img alt="LYHfGG_115_miner.png" src="курсы\learn-you-a-haskell-for-great-good!\картинки\lyhfgg_115_miner.png"></span></p></div><div><p>When we were solving the problem of <a data-tooltip-position="top" aria-label="http://learnyouahaskell.com/reverse-polish-notation-calculator" rel="noopener" class="external-link" href="http://learnyouahaskell.com/reverse-polish-notation-calculator" target="_blank">implementing a RPN calculator</a>, we noted that it worked fine as long as the input that it got made sense. But if something went wrong, it caused our whole program to crash. Now that we know how to take some code that we have and make it monadic, let's take our RPN calculator and add error handling to it by taking advantage of the <code>Maybe</code> monad.</p></div><div><p>We implemented our RPN calculator by taking a string like <code>"1 3 + 2 *"</code>, breaking it up into words to get something like <code>["1","3","+","2","*"]</code> and then folding over that list by starting out with an empty stack and then using a binary folding function that adds numbers to the stack or manipulates numbers on the top of the stack to add them together and divide them and such.</p></div><div><p>This was the main body of our function:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token import-statement"><span class="token keyword">import</span> Data<span class="token punctuation">.</span>List</span>

<span class="token hvariable">solveRPN</span> <span class="token operator">::</span> <span class="token constant">String</span> <span class="token operator">-&gt;</span> <span class="token constant">Double</span>
<span class="token hvariable">solveRPN</span> <span class="token operator">=</span> <span class="token builtin">head</span> <span class="token operator">.</span> <span class="token builtin">foldl</span> <span class="token hvariable">foldingFunction</span> <span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">.</span> <span class="token builtin">words</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>We made the expression into a list of strings, folded over it with our folding function and then when we were left with just one item in the stack, we returned that item as the answer. This was the folding function:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">foldingFunction</span> <span class="token operator">::</span> <span class="token punctuation">[</span><span class="token constant">Double</span><span class="token punctuation">]</span> <span class="token operator">-&gt;</span> <span class="token constant">String</span> <span class="token operator">-&gt;</span> <span class="token punctuation">[</span><span class="token constant">Double</span><span class="token punctuation">]</span>
<span class="token hvariable">foldingFunction</span> <span class="token punctuation">(</span><span class="token hvariable">x</span><span class="token operator">:</span><span class="token hvariable">y</span><span class="token operator">:</span><span class="token hvariable">ys</span><span class="token punctuation">)</span> <span class="token string">"*"</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token hvariable">x</span> <span class="token operator">*</span> <span class="token hvariable">y</span><span class="token punctuation">)</span><span class="token operator">:</span><span class="token hvariable">ys</span>
<span class="token hvariable">foldingFunction</span> <span class="token punctuation">(</span><span class="token hvariable">x</span><span class="token operator">:</span><span class="token hvariable">y</span><span class="token operator">:</span><span class="token hvariable">ys</span><span class="token punctuation">)</span> <span class="token string">"+"</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token hvariable">x</span> <span class="token operator">+</span> <span class="token hvariable">y</span><span class="token punctuation">)</span><span class="token operator">:</span><span class="token hvariable">ys</span>
<span class="token hvariable">foldingFunction</span> <span class="token punctuation">(</span><span class="token hvariable">x</span><span class="token operator">:</span><span class="token hvariable">y</span><span class="token operator">:</span><span class="token hvariable">ys</span><span class="token punctuation">)</span> <span class="token string">"-"</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token hvariable">y</span> <span class="token operator">-</span> <span class="token hvariable">x</span><span class="token punctuation">)</span><span class="token operator">:</span><span class="token hvariable">ys</span>
<span class="token hvariable">foldingFunction</span> <span class="token hvariable">xs</span> <span class="token hvariable">numberString</span> <span class="token operator">=</span> <span class="token builtin">read</span> <span class="token hvariable">numberString</span><span class="token operator">:</span><span class="token hvariable">xs</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>The accumulator of the fold was a stack, which we represented with a list of <code>Double</code> values. As the folding function went over the RPN expression, if the current item was an operator, it took two items off the top of the stack, applied the operator between them and then put the result back on the stack. If the current item was a string that represented a number, it converted that string into an actual number and returned a new stack that was like the old one, except with that number pushed to the top.</p></div><div><p>Let's first make our folding function capable of graceful failure. Its type is going to change from what it is now to this:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">foldingFunction</span> <span class="token operator">::</span> <span class="token punctuation">[</span><span class="token constant">Double</span><span class="token punctuation">]</span> <span class="token operator">-&gt;</span> <span class="token constant">String</span> <span class="token operator">-&gt;</span> <span class="token constant">Maybe</span> <span class="token punctuation">[</span><span class="token constant">Double</span><span class="token punctuation">]</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>So it will either return <code>Just</code> a new stack or it will fail with <code>Nothing</code>.</p></div><div><p>The <code>reads</code> function is like <code>read</code>, only it returns a list with a single element in case of a successful read. If it fails to read something, then it returns an empty list. Apart from returning the value that it read, it also returns the part of the string that it didn't consume. We're going to say that it always has to consume the full input to work and make it into a <code>readMaybe</code> function for convenience. Here it is:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">readMaybe</span> <span class="token operator">::</span> <span class="token punctuation">(</span><span class="token constant">Read</span> <span class="token hvariable">a</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token constant">String</span> <span class="token operator">-&gt;</span> <span class="token constant">Maybe</span> <span class="token hvariable">a</span>
<span class="token hvariable">readMaybe</span> <span class="token hvariable">st</span> <span class="token operator">=</span> <span class="token keyword">case</span> <span class="token builtin">reads</span> <span class="token hvariable">st</span> <span class="token keyword">of</span> <span class="token punctuation">[</span><span class="token punctuation">(</span><span class="token hvariable">x</span><span class="token punctuation">,</span><span class="token string">""</span><span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token operator">-&gt;</span> <span class="token constant">Just</span> <span class="token hvariable">x</span>
                                <span class="token hvariable">_</span> <span class="token operator">-&gt;</span> <span class="token constant">Nothing</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Testing it out:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token hvariable">readMaybe</span> <span class="token string">"1"</span> <span class="token operator">::</span> <span class="token constant">Maybe</span> <span class="token constant">Int</span>
<span class="token constant">Just</span> <span class="token number">1</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token hvariable">readMaybe</span> <span class="token string">"GO TO HELL"</span> <span class="token operator">::</span> <span class="token constant">Maybe</span> <span class="token constant">Int</span>
<span class="token constant">Nothing</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Okay, it seems to work. So, let's make our folding function into a monadic function that can fail:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">foldingFunction</span> <span class="token operator">::</span> <span class="token punctuation">[</span><span class="token constant">Double</span><span class="token punctuation">]</span> <span class="token operator">-&gt;</span> <span class="token constant">String</span> <span class="token operator">-&gt;</span> <span class="token constant">Maybe</span> <span class="token punctuation">[</span><span class="token constant">Double</span><span class="token punctuation">]</span>
<span class="token hvariable">foldingFunction</span> <span class="token punctuation">(</span><span class="token hvariable">x</span><span class="token operator">:</span><span class="token hvariable">y</span><span class="token operator">:</span><span class="token hvariable">ys</span><span class="token punctuation">)</span> <span class="token string">"*"</span> <span class="token operator">=</span> <span class="token builtin">return</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token hvariable">x</span> <span class="token operator">*</span> <span class="token hvariable">y</span><span class="token punctuation">)</span><span class="token operator">:</span><span class="token hvariable">ys</span><span class="token punctuation">)</span>
<span class="token hvariable">foldingFunction</span> <span class="token punctuation">(</span><span class="token hvariable">x</span><span class="token operator">:</span><span class="token hvariable">y</span><span class="token operator">:</span><span class="token hvariable">ys</span><span class="token punctuation">)</span> <span class="token string">"+"</span> <span class="token operator">=</span> <span class="token builtin">return</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token hvariable">x</span> <span class="token operator">+</span> <span class="token hvariable">y</span><span class="token punctuation">)</span><span class="token operator">:</span><span class="token hvariable">ys</span><span class="token punctuation">)</span>
<span class="token hvariable">foldingFunction</span> <span class="token punctuation">(</span><span class="token hvariable">x</span><span class="token operator">:</span><span class="token hvariable">y</span><span class="token operator">:</span><span class="token hvariable">ys</span><span class="token punctuation">)</span> <span class="token string">"-"</span> <span class="token operator">=</span> <span class="token builtin">return</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token hvariable">y</span> <span class="token operator">-</span> <span class="token hvariable">x</span><span class="token punctuation">)</span><span class="token operator">:</span><span class="token hvariable">ys</span><span class="token punctuation">)</span>
<span class="token hvariable">foldingFunction</span> <span class="token hvariable">xs</span> <span class="token hvariable">numberString</span> <span class="token operator">=</span> <span class="token hvariable">liftM</span> <span class="token punctuation">(</span><span class="token operator">:</span><span class="token hvariable">xs</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token hvariable">readMaybe</span> <span class="token hvariable">numberString</span><span class="token punctuation">)</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>The first three cases are like the old ones, except the new stack gets wrapped in a <code>Just</code> (we used <code>return</code> here to do this, but we could have written <code>Just</code> just as well). In the last case, we do <code>readMaybe numberString</code> and then we map <code>(:xs)</code> over it. So if the stack <code>xs</code> is <code>[1.0,2.0]</code> and <code>readMaybe numberString</code> results in a <code>Just 3.0</code>, the result is <code>Just [3.0,1.0,2.0]</code>. If <code>readMaybe numberString</code> results in a <code>Nothing</code> then the result is <code>Nothing</code>. Let's try out the folding function by itself:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token hvariable">foldingFunction</span> <span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">]</span> <span class="token string">"*"</span>
<span class="token constant">Just</span> <span class="token punctuation">[</span><span class="token number">6.0</span><span class="token punctuation">]</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token hvariable">foldingFunction</span> <span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">]</span> <span class="token string">"-"</span>
<span class="token constant">Just</span> <span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1.0</span><span class="token punctuation">]</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token hvariable">foldingFunction</span> <span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token string">"*"</span>
<span class="token constant">Nothing</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token hvariable">foldingFunction</span> <span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token string">"1"</span>
<span class="token constant">Just</span> <span class="token punctuation">[</span><span class="token number">1.0</span><span class="token punctuation">]</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token hvariable">foldingFunction</span> <span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token string">"1 wawawawa"</span>
<span class="token constant">Nothing</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>It looks like it's working! And now it's time for the new and improved <code>solveRPN</code>. Here it is ladies and gents!</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token import-statement"><span class="token keyword">import</span> Data<span class="token punctuation">.</span>List</span>

<span class="token hvariable">solveRPN</span> <span class="token operator">::</span> <span class="token constant">String</span> <span class="token operator">-&gt;</span> <span class="token constant">Maybe</span> <span class="token constant">Double</span>
<span class="token hvariable">solveRPN</span> <span class="token hvariable">st</span> <span class="token operator">=</span> <span class="token keyword">do</span>
    <span class="token punctuation">[</span><span class="token hvariable">result</span><span class="token punctuation">]</span> <span class="token operator">&lt;-</span> <span class="token hvariable">foldM</span> <span class="token hvariable">foldingFunction</span> <span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token punctuation">(</span><span class="token builtin">words</span> <span class="token hvariable">st</span><span class="token punctuation">)</span>
    <span class="token builtin">return</span> <span class="token hvariable">result</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Just like before, we take the string and make it into a list of words. Then, we do a fold, starting with the empty stack, only instead of doing a normal <code>foldl</code>, we do a <code>foldM</code>. The result of that <code>foldM</code> should be a <code>Maybe</code> value that contains a list (that's our final stack) and that list should have only one value. We use a <code>do</code> expression to get that value and we call it <code>result</code>. In case the <code>foldM</code> returns a <code>Nothing</code>, the whole thing will be a <code>Nothing</code>, because that's how <code>Maybe</code> works. Also notice that we pattern match in the <code>do</code> expression, so if the list has more than one value or none at all, the pattern match fails and a <code>Nothing</code> is produced. In the last line we just do <code>return result</code> to present the result of the RPN calculation as the result of the final <code>Maybe</code> value.</p></div><div><p>Let's give it a shot:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token hvariable">solveRPN</span> <span class="token string">"1 2 * 4 +"</span>
<span class="token constant">Just</span> <span class="token number">6.0</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token hvariable">solveRPN</span> <span class="token string">"1 2 * 4 + 5 *"</span>
<span class="token constant">Just</span> <span class="token number">30.0</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token hvariable">solveRPN</span> <span class="token string">"1 2 * 4"</span>
<span class="token constant">Nothing</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token hvariable">solveRPN</span> <span class="token string">"1 8 wharglbllargh"</span>
<span class="token constant">Nothing</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>The first failure happens because the final stack isn't a list with one element in it and so the pattern matching in the <code>do</code> expression fails. The second failure happens because <code>readMaybe</code> returns a <code>Nothing</code>.</p></div><div><h3 data-heading="Composing monadic functions" id="Composing_monadic_functions" style="display: flex;"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>Composing monadic functions</h3></div><div><p>When we were learning about the monad laws, we said that the <code>&lt;=&lt;</code> function is just like composition, only instead of working for normal functions like <code>a -&gt; b</code>, it works for monadic functions like <code>a -&gt; m b</code>. For instance:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token keyword">let</span> <span class="token hvariable">f</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">.</span> <span class="token punctuation">(</span><span class="token operator">*</span><span class="token number">100</span><span class="token punctuation">)</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token hvariable">f</span> <span class="token number">4</span>
<span class="token number">401</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token keyword">let</span> <span class="token hvariable">g</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token operator">\</span><span class="token hvariable">x</span> <span class="token operator">-&gt;</span> <span class="token builtin">return</span> <span class="token punctuation">(</span><span class="token hvariable">x</span><span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&lt;=&lt;</span> <span class="token punctuation">(</span><span class="token operator">\</span><span class="token hvariable">x</span> <span class="token operator">-&gt;</span> <span class="token builtin">return</span> <span class="token punctuation">(</span><span class="token hvariable">x</span><span class="token operator">*</span><span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token constant">Just</span> <span class="token number">4</span> <span class="token operator">&gt;&gt;=</span> <span class="token hvariable">g</span>
<span class="token constant">Just</span> <span class="token number">401</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>In this example we first composed two normal functions, applied the resulting function to <code>4</code> and then we composed two monadic functions and fed <code>Just 4</code> to the resulting function with <code>&gt;&gt;=</code>.</p></div><div><p>If we have a bunch of functions in a list, we can compose them one all into one big function by just using <code>id</code> as the starting accumulator and the <code>.</code> function as the binary function. Here's an example:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token keyword">let</span> <span class="token hvariable">f</span> <span class="token operator">=</span> <span class="token builtin">foldr</span> <span class="token punctuation">(</span><span class="token punctuation">.</span><span class="token punctuation">)</span> <span class="token builtin">id</span> <span class="token punctuation">[</span><span class="token punctuation">(</span><span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">]</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token hvariable">f</span> <span class="token number">1</span>
<span class="token number">201</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>The function <code>f</code> takes a number and then adds <code>1</code> to it, multiplies the result by <code>100</code> and then adds <code>1</code> to that. Anyway, we can compose monadic functions in the same way, only instead normal composition we use <code>&lt;=&lt;</code> and instead of <code>id</code> we use <code>return</code>. We don't have to use a <code>foldM</code> over a <code>foldr</code> or anything because the <code>&lt;=&lt;</code> function makes sure that composition happens in a monadic fashion.</p></div><div><p>When we were getting to know the list monad in the <a data-tooltip-position="top" aria-label="http://learnyouahaskell.com/a-fistful-of-monads#the-list-monad" rel="noopener" class="external-link" href="http://learnyouahaskell.com/a-fistful-of-monads#the-list-monad" target="_blank">previous chapter</a>, we used it to figure out if a knight can go from one position on a chessboard to another in exactly three moves. We had a function called <code>moveKnight</code> which took the knight's position on the board and returned all the possible moves that he can make next. Then, to generate all the possible positions that he can have after taking three moves, we made the following function:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">in3</span> <span class="token hvariable">start</span> <span class="token operator">=</span> <span class="token builtin">return</span> <span class="token hvariable">start</span> <span class="token operator">&gt;&gt;=</span> <span class="token hvariable">moveKnight</span> <span class="token operator">&gt;&gt;=</span> <span class="token hvariable">moveKnight</span> <span class="token operator">&gt;&gt;=</span> <span class="token hvariable">moveKnight</span> 
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>And to check if he can go from <code>start</code> to <code>end</code> in three moves, we did the following:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">canReachIn3</span> <span class="token operator">::</span> <span class="token constant">KnightPos</span> <span class="token operator">-&gt;</span> <span class="token constant">KnightPos</span> <span class="token operator">-&gt;</span> <span class="token constant">Bool</span>
<span class="token hvariable">canReachIn3</span> <span class="token hvariable">start</span> <span class="token hvariable">end</span> <span class="token operator">=</span> <span class="token hvariable">end</span> <span class="token operator">`elem`</span> <span class="token hvariable">in3</span> <span class="token hvariable">start</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Using monadic function composition, we can make a function like <code>in3</code>, only instead of generating all the positions that the knight can have after making three moves, we can do it for an arbitrary number of moves. If you look at <code>in3</code>, we see that we used <code>moveKnight</code> three times and each time we used <code>&gt;&gt;=</code> to feed it all the possible previous positions. So now, let's make it more general. Here's how to do it:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token import-statement"><span class="token keyword">import</span> Data<span class="token punctuation">.</span>List</span>

<span class="token hvariable">inMany</span> <span class="token operator">::</span> <span class="token constant">Int</span> <span class="token operator">-&gt;</span> <span class="token constant">KnightPos</span> <span class="token operator">-&gt;</span> <span class="token punctuation">[</span><span class="token constant">KnightPos</span><span class="token punctuation">]</span>
<span class="token hvariable">inMany</span> <span class="token hvariable">x</span> <span class="token hvariable">start</span> <span class="token operator">=</span> <span class="token builtin">return</span> <span class="token hvariable">start</span> <span class="token operator">&gt;&gt;=</span> <span class="token builtin">foldr</span> <span class="token punctuation">(</span><span class="token operator">&lt;=&lt;</span><span class="token punctuation">)</span> <span class="token builtin">return</span> <span class="token punctuation">(</span><span class="token builtin">replicate</span> <span class="token hvariable">x</span> <span class="token hvariable">moveKnight</span><span class="token punctuation">)</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>First we use <code>replicate</code> to make a list that contains <code>x</code> copies of the function <code>moveKnight</code>. Then, we monadically compose all those functions into one, which gives us a function that takes a starting position and non-deterministically moves the knight <code>x</code> times. Then, we just make the starting position into a singleton list with <code>return</code> and feed it to the function.</p></div><div><p>Now, we can change our <code>canReachIn3</code> function to be more general as well:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">canReachIn</span> <span class="token operator">::</span> <span class="token constant">Int</span> <span class="token operator">-&gt;</span> <span class="token constant">KnightPos</span> <span class="token operator">-&gt;</span> <span class="token constant">KnightPos</span> <span class="token operator">-&gt;</span> <span class="token constant">Bool</span>
<span class="token hvariable">canReachIn</span> <span class="token hvariable">x</span> <span class="token hvariable">start</span> <span class="token hvariable">end</span> <span class="token operator">=</span> <span class="token hvariable">end</span> <span class="token operator">`elem`</span> <span class="token hvariable">inMany</span> <span class="token hvariable">x</span> <span class="token hvariable">start</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><h2 data-heading="Making monads" id="Making_monads" style="display: flex;"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>Making monads</h2></div><div><p><span alt="LYHfGG_116_spearhead.png" src="LYHfGG_116_spearhead.png" class="internal-embed media-embed image-embed is-loaded"><img alt="LYHfGG_116_spearhead.png" src="курсы\learn-you-a-haskell-for-great-good!\картинки\lyhfgg_116_spearhead.png"></span></p></div><div><p>In this section, we're going to look at an example of how a type gets made, identified as a monad and then given the appropriate <code>Monad</code> instance. We don't usually set out to make a monad with the sole purpose of making a monad. Instead, we usually make a type that whose purpose is to model an aspect of some problem and then later on if we see that the type represents a value with a context and can act like a monad, we give it a <code>Monad</code> instance.</p></div><div><p>As we've seen, lists are used to represent non-deterministic values. A list like <code>[3,5,9]</code> can be viewed as a single non-deterministic value that just can't decide what it's going to be. When we feed a list into a function with <code>&gt;&gt;=</code>, it just makes all the possible choices of taking an element from the list and applying the function to it and then presents those results in a list as well.</p></div><div><p>If we look at the list <code>[3,5,9]</code> as the numbers <code>3</code>, <code>5</code> and <code>9</code> occurring at once, we might notice that there's no info regarding the probability that each of those numbers occurs. What if we wanted to model a non-deterministic value like <code>[3,5,9]</code>, but we wanted to express that <code>3</code> has a 50% chance of happening and <code>5</code> and <code>9</code> both have a 25% chance of happening? Let's try and make this happen!</p></div><div><p>Let's say that every item in the list comes with another value, a probability of it happening. It might make sense to present this like this then:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token punctuation">[</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">0.5</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">0.25</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token number">9</span><span class="token punctuation">,</span><span class="token number">0.25</span><span class="token punctuation">)</span><span class="token punctuation">]</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>In mathematics, probabilities aren't usually expressed in percentages, but rather in real numbers between a 0 and 1. A 0 means that there's no chance in hell for something to happen and a 1 means that it's happening for sure. Floating point numbers can get real messy real fast because they tend to lose precision, so Haskell offers us a data type for rational numbers that doesn't lose precision. That type is called <code>Rational</code> and it lives in <code>Data.Ratio</code>. To make a <code>Rational</code>, we write it as if it were a fraction. The numerator and the denominator are separated by a <code>%</code>. Here are a few examples:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token number">1</span><span class="token operator">%</span><span class="token number">4</span>
<span class="token number">1</span> <span class="token operator">%</span> <span class="token number">4</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token number">1</span><span class="token operator">%</span><span class="token number">2</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token operator">%</span><span class="token number">2</span>
<span class="token number">1</span> <span class="token operator">%</span> <span class="token number">1</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token number">1</span><span class="token operator">%</span><span class="token number">3</span> <span class="token operator">+</span> <span class="token number">5</span><span class="token operator">%</span><span class="token number">4</span>
<span class="token number">19</span> <span class="token operator">%</span> <span class="token number">12</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>The first line is just one quarter. In the second line we add two halves to get a whole and in the third line we add one third with five quarters and get nineteen twelfths. So let'use throw out our floating points and use <code>Rational</code> for our probabilities:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token punctuation">[</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token operator">%</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token operator">%</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token number">9</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token operator">%</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">]</span>
<span class="token punctuation">[</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">1</span> <span class="token operator">%</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">1</span> <span class="token operator">%</span> <span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token number">9</span><span class="token punctuation">,</span><span class="token number">1</span> <span class="token operator">%</span> <span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">]</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Okay, so <code>3</code> has a one out of two chance of happening while <code>5</code> and <code>9</code> will happen one time out of four. Pretty neat.</p></div><div><p>We took lists and we added some extra context to them, so this represents values withs contexts too. Before we go any further, let's wrap this into a <code>newtype</code> because something tells me we'll be making some instances.</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token import-statement"><span class="token keyword">import</span> Data<span class="token punctuation">.</span>Ratio</span>

<span class="token keyword">newtype</span> <span class="token constant">Prob</span> <span class="token hvariable">a</span> <span class="token operator">=</span> <span class="token constant">Prob</span> <span class="token punctuation">{</span> <span class="token hvariable">getProb</span> <span class="token operator">::</span> <span class="token punctuation">[</span><span class="token punctuation">(</span><span class="token hvariable">a</span><span class="token punctuation">,</span><span class="token constant">Rational</span><span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token punctuation">}</span> <span class="token keyword">deriving</span> <span class="token constant">Show</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Alright. Is this a functor? Well, the list is a functor, so this should probably be a functor as well, because we just added some stuff to the list. When we map a function over a list, we apply it to each element. Here, we'll apply it to each element as well, only we'll leave the probabilities as they are. Let's make an instance:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token keyword">instance</span> <span class="token constant">Functor</span> <span class="token constant">Prob</span> <span class="token keyword">where</span>
    <span class="token builtin">fmap</span> <span class="token hvariable">f</span> <span class="token punctuation">(</span><span class="token constant">Prob</span> <span class="token hvariable">xs</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token constant">Prob</span> <span class="token operator">$</span> <span class="token builtin">map</span> <span class="token punctuation">(</span><span class="token operator">\</span><span class="token punctuation">(</span><span class="token hvariable">x</span><span class="token punctuation">,</span><span class="token hvariable">p</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token punctuation">(</span><span class="token hvariable">f</span> <span class="token hvariable">x</span><span class="token punctuation">,</span><span class="token hvariable">p</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token hvariable">xs</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>We unwrap it from the <code>newtype</code> with pattern matching, apply the function <code>f</code> to the values while keeping the probabilities as they are and then wrap it back up. Let's see if it works:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token builtin">fmap</span> <span class="token builtin">negate</span> <span class="token punctuation">(</span><span class="token constant">Prob</span> <span class="token punctuation">[</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token operator">%</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token operator">%</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token number">9</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token operator">%</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
<span class="token constant">Prob</span> <span class="token punctuation">{</span><span class="token hvariable">getProb</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">1</span> <span class="token operator">%</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">1</span> <span class="token operator">%</span> <span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">9</span><span class="token punctuation">,</span><span class="token number">1</span> <span class="token operator">%</span> <span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">}</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Another thing to note is that the probabilities should always add up to <code>1</code>. If those are all the things that can happen, it doesn't make sense for the sum of their probabilities to be anything other than <code>1</code>. A coin that lands tails 75% of the time and heads 50% of the time seems like it could only work in some other strange universe.</p></div><div><p>Now the big question, is this a monad? Given how the list is a monad, this looks like it should be a monad as well. First, let's think about <code>return</code>. How does it work for lists? It takes a value and puts it in a singleton list. What about here? Well, since it's supposed to be a default minimal context, it should also make a singleton list. What about the probability? Well, <code>return x</code> is supposed to make a monadic value that always presents <code>x</code> as its result, so it doesn't make sense for the probability to be <code>0</code>. If it always has to present it as its result, the probability should be <code>1</code>!</p></div><div><p>What about <code>&gt;&gt;=</code>? Seems kind of tricky, so let's make use of the fact that <code>m &gt;&gt;= f</code> always equals <code>join (fmap f m)</code> for monads and think about how we would flatten a probability list of probability lists. As an example, let's consider this list where there's a 25% chance that exactly one of <code>'a'</code> or <code>'b'</code> will happen. Both <code>'a'</code> and <code>'b'</code> are equally likely to occur. Also, there's a 75% chance that exactly one of <code>'c'</code> or <code>'d'</code> will happen. <code>'c'</code> and <code>'d'</code> are also equally likely to happen. Here's a picture of a probability list that models this scenario:</p></div><div><p><span alt="LYHfGG_117_prob.png" src="LYHfGG_117_prob.png" class="internal-embed media-embed image-embed is-loaded"><img alt="LYHfGG_117_prob.png" src="курсы\learn-you-a-haskell-for-great-good!\картинки\lyhfgg_117_prob.png"></span></p></div><div><p>What are the chances for each of these letters to occur? If we were to draw this as just four boxes, each with a probability, what would those probabilities be? To find out, all we have to do is multiply each probability with all of probabilities that it contains. <code>'a'</code> would occur one time out of eight, as would <code>'b'</code>, because if we multiply one half by one quarter we get one eighth. <code>'c'</code> would happen three times out of eight because three quarters multiplied by one half is three eighths. <code>'d'</code> would also happen three times out of eight. If we sum all the probabilities, they still add up to one.</p></div><div><p>Here's this situation expressed as a probability list:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">thisSituation</span> <span class="token operator">::</span> <span class="token constant">Prob</span> <span class="token punctuation">(</span><span class="token constant">Prob</span> <span class="token constant">Char</span><span class="token punctuation">)</span>
<span class="token hvariable">thisSituation</span> <span class="token operator">=</span> <span class="token constant">Prob</span>
    <span class="token punctuation">[</span><span class="token punctuation">(</span> <span class="token constant">Prob</span> <span class="token punctuation">[</span><span class="token punctuation">(</span><span class="token char string">'a'</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token operator">%</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token char string">'b'</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token operator">%</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token punctuation">,</span> <span class="token number">1</span><span class="token operator">%</span><span class="token number">4</span> <span class="token punctuation">)</span>
    <span class="token punctuation">,</span><span class="token punctuation">(</span> <span class="token constant">Prob</span> <span class="token punctuation">[</span><span class="token punctuation">(</span><span class="token char string">'c'</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token operator">%</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token char string">'d'</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token operator">%</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token punctuation">,</span> <span class="token number">3</span><span class="token operator">%</span><span class="token number">4</span><span class="token punctuation">)</span>
    <span class="token punctuation">]</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Notice that its type is <code>Prob (Prob Char)</code>. So now that we've figure out how to flatten a nested probability list, all we have to do is write the code for this and then we can write <code>&gt;&gt;=</code> simply as <code>join (fmap f m)</code> and we have ourselves a monad! So here's <code>flatten</code>, which we'll use because the name <code>join</code> is already taken:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">flatten</span> <span class="token operator">::</span> <span class="token constant">Prob</span> <span class="token punctuation">(</span><span class="token constant">Prob</span> <span class="token hvariable">a</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token constant">Prob</span> <span class="token hvariable">a</span>
<span class="token hvariable">flatten</span> <span class="token punctuation">(</span><span class="token constant">Prob</span> <span class="token hvariable">xs</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token constant">Prob</span> <span class="token operator">$</span> <span class="token builtin">concat</span> <span class="token operator">$</span> <span class="token builtin">map</span> <span class="token hvariable">multAll</span> <span class="token hvariable">xs</span>
    <span class="token keyword">where</span> <span class="token hvariable">multAll</span> <span class="token punctuation">(</span><span class="token constant">Prob</span> <span class="token hvariable">innerxs</span><span class="token punctuation">,</span><span class="token hvariable">p</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token builtin">map</span> <span class="token punctuation">(</span><span class="token operator">\</span><span class="token punctuation">(</span><span class="token hvariable">x</span><span class="token punctuation">,</span><span class="token hvariable">r</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token punctuation">(</span><span class="token hvariable">x</span><span class="token punctuation">,</span><span class="token hvariable">p</span><span class="token operator">*</span><span class="token hvariable">r</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token hvariable">innerxs</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>The function <code>multAll</code> takes a tuple of probability list and a probability <code>p</code> that comes with it and then multiplies every inner probability with <code>p</code>, returning a list of pairs of items and probabilities. We map <code>multAll</code> over each pair in our nested probability list and then we just flatten the resulting nested list.</p></div><div><p>Now we have all that we need, we can write a <code>Monad</code> instance!</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token keyword">instance</span> <span class="token constant">Monad</span> <span class="token constant">Prob</span> <span class="token keyword">where</span>
    <span class="token builtin">return</span> <span class="token hvariable">x</span> <span class="token operator">=</span> <span class="token constant">Prob</span> <span class="token punctuation">[</span><span class="token punctuation">(</span><span class="token hvariable">x</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token operator">%</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">]</span>
    <span class="token hvariable">m</span> <span class="token operator">&gt;&gt;=</span> <span class="token hvariable">f</span> <span class="token operator">=</span> <span class="token hvariable">flatten</span> <span class="token punctuation">(</span><span class="token builtin">fmap</span> <span class="token hvariable">f</span> <span class="token hvariable">m</span><span class="token punctuation">)</span>
    <span class="token builtin">fail</span> <span class="token hvariable">_</span> <span class="token operator">=</span> <span class="token constant">Prob</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p><span alt="LYHfGG_118_ride.png" src="LYHfGG_118_ride.png" class="internal-embed media-embed image-embed is-loaded"><img alt="LYHfGG_118_ride.png" src="курсы\learn-you-a-haskell-for-great-good!\картинки\lyhfgg_118_ride.png"></span></p></div><div><p>Because we already did all the hard work, the instance is very simple. We also defined the <code>fail</code> function, which is the same as it is for lists, so if there's a pattern match failure in a <code>do</code> expression, a failure occurs within the context of a probability list.</p></div><div><p>It's also important to check if the monad laws hold for the monad that we just made. The first one says that <code>return x &gt;&gt;= f</code> should be equal to <code>f x</code>. A rigorous proof would be rather tedious, but we can see that if we put a value in a default context with <code>return</code> and then <code>fmap</code> a function over that and flatten the resulting probability list, every probability that results from the function would be multiplied by the <code>1%1</code> probability that we made with <code>return</code>, so it wouldn't affect the context. The reasoning for <code>m &gt;&gt;= return</code> being equal to just <code>m</code> is similar. The third law states that <code>f &lt;=&lt; (g &lt;=&lt; h)</code> should be the same as <code>(f &lt;=&lt; g) &lt;=&lt; h</code>. This one holds as well, because it holds for the list monad which forms the basis of the probability monad and because multiplication is associative. <code>1%2 * (1%3 * 1%5)</code> is equal to <code>(1%2 * 1%3) * 1%5</code>.</p></div><div><p>Now that we have a monad, what can we do with it? Well, it can help us do calculations with probabilities. We can treat probabilistic events as values with contexts and the probability monad will make sure that those probabilities get reflected in the probabilities of the final result.</p></div><div><p>Say we have two normal coins and one loaded coin that gets tails an astounding nine times out of ten and heads only one time out of ten. If we throw all the coins at once, what are the odds of all of them landing tails? First, let's make probability values for a normal coin flip and for a loaded one:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token keyword">data</span> <span class="token constant">Coin</span> <span class="token operator">=</span> <span class="token constant">Heads</span> <span class="token operator">|</span> <span class="token constant">Tails</span> <span class="token keyword">deriving</span> <span class="token punctuation">(</span><span class="token constant">Show</span><span class="token punctuation">,</span> <span class="token constant">Eq</span><span class="token punctuation">)</span>

<span class="token hvariable">coin</span> <span class="token operator">::</span> <span class="token constant">Prob</span> <span class="token constant">Coin</span>
<span class="token hvariable">coin</span> <span class="token operator">=</span> <span class="token constant">Prob</span> <span class="token punctuation">[</span><span class="token punctuation">(</span><span class="token constant">Heads</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token operator">%</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token constant">Tails</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token operator">%</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">]</span>

<span class="token hvariable">loadedCoin</span> <span class="token operator">::</span> <span class="token constant">Prob</span> <span class="token constant">Coin</span>
<span class="token hvariable">loadedCoin</span> <span class="token operator">=</span> <span class="token constant">Prob</span> <span class="token punctuation">[</span><span class="token punctuation">(</span><span class="token constant">Heads</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token operator">%</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token constant">Tails</span><span class="token punctuation">,</span><span class="token number">9</span><span class="token operator">%</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">]</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>And finally, the coin throwing action:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token import-statement"><span class="token keyword">import</span> Data<span class="token punctuation">.</span>List</span> <span class="token punctuation">(</span><span class="token builtin">all</span><span class="token punctuation">)</span>

<span class="token hvariable">flipThree</span> <span class="token operator">::</span> <span class="token constant">Prob</span> <span class="token constant">Bool</span>
<span class="token hvariable">flipThree</span> <span class="token operator">=</span> <span class="token keyword">do</span>
    <span class="token hvariable">a</span> <span class="token operator">&lt;-</span> <span class="token hvariable">coin</span>
    <span class="token hvariable">b</span> <span class="token operator">&lt;-</span> <span class="token hvariable">coin</span>
    <span class="token hvariable">c</span> <span class="token operator">&lt;-</span> <span class="token hvariable">loadedCoin</span>
    <span class="token builtin">return</span> <span class="token punctuation">(</span><span class="token builtin">all</span> <span class="token punctuation">(</span><span class="token operator">==</span><span class="token constant">Tails</span><span class="token punctuation">)</span> <span class="token punctuation">[</span><span class="token hvariable">a</span><span class="token punctuation">,</span><span class="token hvariable">b</span><span class="token punctuation">,</span><span class="token hvariable">c</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Giving it a go, we see that the odds of all three landing tails are not that good, despite cheating with our loaded coin:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token hvariable">getProb</span> <span class="token hvariable">flipThree</span>
<span class="token punctuation">[</span><span class="token punctuation">(</span><span class="token constant">False</span><span class="token punctuation">,</span><span class="token number">1</span> <span class="token operator">%</span> <span class="token number">40</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token constant">False</span><span class="token punctuation">,</span><span class="token number">9</span> <span class="token operator">%</span> <span class="token number">40</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token constant">False</span><span class="token punctuation">,</span><span class="token number">1</span> <span class="token operator">%</span> <span class="token number">40</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token constant">False</span><span class="token punctuation">,</span><span class="token number">9</span> <span class="token operator">%</span> <span class="token number">40</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
 <span class="token punctuation">(</span><span class="token constant">False</span><span class="token punctuation">,</span><span class="token number">1</span> <span class="token operator">%</span> <span class="token number">40</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token constant">False</span><span class="token punctuation">,</span><span class="token number">9</span> <span class="token operator">%</span> <span class="token number">40</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token constant">False</span><span class="token punctuation">,</span><span class="token number">1</span> <span class="token operator">%</span> <span class="token number">40</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token constant">True</span><span class="token punctuation">,</span><span class="token number">9</span> <span class="token operator">%</span> <span class="token number">40</span><span class="token punctuation">)</span><span class="token punctuation">]</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>All three of them will land tails nine times out of forty, which is less than 25%. We see that our monad doesn't know how to join all of the <code>False</code> outcomes where all coins don't land tails into one outcome. That's not a big problem, since writing a function to put all the same outcomes into one outcome is pretty easy and is left as an exercise to the reader (you!)</p></div><div><p>In this section, we went from having a question (what if lists also carried information about probability?) to making a type, recognizing a monad and finally making an instance and doing something with it. I think that's quite fetching! By now, we should have a pretty good grasp on monads and what they're about.</p></div><div><h1 data-heading="Zippers" id="Zippers">Zippers</h1></div><div><p><span alt="LYHfGG_119_60sdude.png" src="LYHfGG_119_60sdude.png" class="internal-embed media-embed image-embed is-loaded"><img alt="LYHfGG_119_60sdude.png" src="курсы\learn-you-a-haskell-for-great-good!\картинки\lyhfgg_119_60sdude.png"></span></p></div><div><p>While Haskell's purity comes with a whole bunch of benefits, it makes us tackle some problems differently than we would in impure languages. Because of referential transparency, one value is as good as another in Haskell if it represents the same thing.</p></div><div><p>So if we have a tree full of fives (high-fives, maybe?) and we want to change one of them into a six, we have to have some way of knowing exactly which five in our tree we want to change. We have to know where it is in our tree. In impure languages, we could just note where in our memory the five is located and change that. But in Haskell, one five is as good as another, so we can't discriminate based on where in our memory they are. We also can't really <em>change</em> anything; when we say that we change a tree, we actually mean that we take a tree and return a new one that's similar to the original tree, but slightly different.</p></div><div><p>One thing we can do is to remember a path from the root of the tree to the element that we want to change. We could say, take this tree, go left, go right and then left again and change the element that's there. While this works, it can be inefficient. If we want to later change an element that's near the element that we previously changed, we have to walk all the way from the root of the tree to our element again!</p></div><div><p>In this chapter, we'll see how we can take some data structure and focus on a part of it in a way that makes changing its elements easy and walking around it efficient. Nice!</p></div><div><h2 data-heading="Taking a walk" id="Taking_a_walk" style="display: flex;"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>Taking a walk</h2></div><div><p>Like we've learned in biology class, there are many different kinds of trees, so let's pick a seed that we will use to plant ours. Here it is:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token keyword">data</span> <span class="token constant">Tree</span> <span class="token hvariable">a</span> <span class="token operator">=</span> <span class="token constant">Empty</span> <span class="token operator">|</span> <span class="token constant">Node</span> <span class="token hvariable">a</span> <span class="token punctuation">(</span><span class="token constant">Tree</span> <span class="token hvariable">a</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token constant">Tree</span> <span class="token hvariable">a</span><span class="token punctuation">)</span> <span class="token keyword">deriving</span> <span class="token punctuation">(</span><span class="token constant">Show</span><span class="token punctuation">)</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>So our tree is either empty or it's a node that has an element and two sub-trees. Here's a fine example of such a tree, which I give to you, the reader, for free!</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">freeTree</span> <span class="token operator">::</span> <span class="token constant">Tree</span> <span class="token constant">Char</span>
<span class="token hvariable">freeTree</span> <span class="token operator">=</span> 
    <span class="token constant">Node</span> <span class="token char string">'P'</span>
        <span class="token punctuation">(</span><span class="token constant">Node</span> <span class="token char string">'O'</span>
            <span class="token punctuation">(</span><span class="token constant">Node</span> <span class="token char string">'L'</span>
                <span class="token punctuation">(</span><span class="token constant">Node</span> <span class="token char string">'N'</span> <span class="token constant">Empty</span> <span class="token constant">Empty</span><span class="token punctuation">)</span>
                <span class="token punctuation">(</span><span class="token constant">Node</span> <span class="token char string">'T'</span> <span class="token constant">Empty</span> <span class="token constant">Empty</span><span class="token punctuation">)</span>
            <span class="token punctuation">)</span>
            <span class="token punctuation">(</span><span class="token constant">Node</span> <span class="token char string">'Y'</span>
                <span class="token punctuation">(</span><span class="token constant">Node</span> <span class="token char string">'S'</span> <span class="token constant">Empty</span> <span class="token constant">Empty</span><span class="token punctuation">)</span>
                <span class="token punctuation">(</span><span class="token constant">Node</span> <span class="token char string">'A'</span> <span class="token constant">Empty</span> <span class="token constant">Empty</span><span class="token punctuation">)</span>
            <span class="token punctuation">)</span>
        <span class="token punctuation">)</span>
        <span class="token punctuation">(</span><span class="token constant">Node</span> <span class="token char string">'L'</span>
            <span class="token punctuation">(</span><span class="token constant">Node</span> <span class="token char string">'W'</span>
                <span class="token punctuation">(</span><span class="token constant">Node</span> <span class="token char string">'C'</span> <span class="token constant">Empty</span> <span class="token constant">Empty</span><span class="token punctuation">)</span>
                <span class="token punctuation">(</span><span class="token constant">Node</span> <span class="token char string">'R'</span> <span class="token constant">Empty</span> <span class="token constant">Empty</span><span class="token punctuation">)</span>
            <span class="token punctuation">)</span>
            <span class="token punctuation">(</span><span class="token constant">Node</span> <span class="token char string">'A'</span>
                <span class="token punctuation">(</span><span class="token constant">Node</span> <span class="token char string">'A'</span> <span class="token constant">Empty</span> <span class="token constant">Empty</span><span class="token punctuation">)</span>
                <span class="token punctuation">(</span><span class="token constant">Node</span> <span class="token char string">'C'</span> <span class="token constant">Empty</span> <span class="token constant">Empty</span><span class="token punctuation">)</span>
            <span class="token punctuation">)</span>
        <span class="token punctuation">)</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>And here's this tree represented graphically:</p></div><div><p><span alt="LYHfGG_120_pollywantsa.png" src="LYHfGG_120_pollywantsa.png" class="internal-embed media-embed image-embed is-loaded"><img alt="LYHfGG_120_pollywantsa.png" src="курсы\learn-you-a-haskell-for-great-good!\картинки\lyhfgg_120_pollywantsa.png"></span></p></div><div><p>Notice that <code>W</code> in the tree there? Say we want to change it into a <code>P</code>. How would we go about doing that? Well, one way would be to pattern match on our tree until we find the element that's located by first going right and then left and changing said element. Here's the code for this:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">changeToP</span> <span class="token operator">::</span> <span class="token constant">Tree</span> <span class="token constant">Char</span> <span class="token operator">-&gt;</span> <span class="token constant">Tree</span> <span class="token constant">Char</span>
<span class="token hvariable">changeToP</span> <span class="token punctuation">(</span><span class="token constant">Node</span> <span class="token hvariable">x</span> <span class="token hvariable">l</span> <span class="token punctuation">(</span><span class="token constant">Node</span> <span class="token hvariable">y</span> <span class="token punctuation">(</span><span class="token constant">Node</span> <span class="token hvariable">_</span> <span class="token hvariable">m</span> <span class="token hvariable">n</span><span class="token punctuation">)</span> <span class="token hvariable">r</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token constant">Node</span> <span class="token hvariable">x</span> <span class="token hvariable">l</span> <span class="token punctuation">(</span><span class="token constant">Node</span> <span class="token hvariable">y</span> <span class="token punctuation">(</span><span class="token constant">Node</span> <span class="token char string">'P'</span> <span class="token hvariable">m</span> <span class="token hvariable">n</span><span class="token punctuation">)</span> <span class="token hvariable">r</span><span class="token punctuation">)</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Yuck! Not only is this rather ugly, it's also kind of confusing. What happens here? Well, we pattern match on our tree and name its root element <code>x</code> (that's becomes the <code>'P'</code> in the root) and its left sub-tree <code>l</code>. Instead of giving a name to its right sub-tree, we further pattern match on it. We continue this pattern matching until we reach the sub-tree whose root is our <code>'W'</code>. Once we've done this, we rebuild the tree, only the sub-tree that contained the <code>'W'</code> at its root now has a <code>'P'</code>.</p></div><div><p>Is there a better way of doing this? How about we make our function take a tree along with a list of directions. The directions will be either <code>L</code> or <code>R</code>, representing left and right respectively, and we'll change the element that we arrive at if we follow the supplied directions. Here it is:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token keyword">data</span> <span class="token constant">Direction</span> <span class="token operator">=</span> <span class="token constant">L</span> <span class="token operator">|</span> <span class="token constant">R</span> <span class="token keyword">deriving</span> <span class="token punctuation">(</span><span class="token constant">Show</span><span class="token punctuation">)</span>
<span class="token keyword">type</span> <span class="token constant">Directions</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token constant">Direction</span><span class="token punctuation">]</span>

<span class="token hvariable">changeToP</span> <span class="token operator">::</span> <span class="token constant">Directions</span><span class="token operator">-&gt;</span> <span class="token constant">Tree</span> <span class="token constant">Char</span> <span class="token operator">-&gt;</span> <span class="token constant">Tree</span> <span class="token constant">Char</span>
<span class="token hvariable">changeToP</span> <span class="token punctuation">(</span><span class="token constant">L</span><span class="token operator">:</span><span class="token hvariable">ds</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token constant">Node</span> <span class="token hvariable">x</span> <span class="token hvariable">l</span> <span class="token hvariable">r</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token constant">Node</span> <span class="token hvariable">x</span> <span class="token punctuation">(</span><span class="token hvariable">changeToP</span> <span class="token hvariable">ds</span> <span class="token hvariable">l</span><span class="token punctuation">)</span> <span class="token hvariable">r</span>
<span class="token hvariable">changeToP</span> <span class="token punctuation">(</span><span class="token constant">R</span><span class="token operator">:</span><span class="token hvariable">ds</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token constant">Node</span> <span class="token hvariable">x</span> <span class="token hvariable">l</span> <span class="token hvariable">r</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token constant">Node</span> <span class="token hvariable">x</span> <span class="token hvariable">l</span> <span class="token punctuation">(</span><span class="token hvariable">changeToP</span> <span class="token hvariable">ds</span> <span class="token hvariable">r</span><span class="token punctuation">)</span>
<span class="token hvariable">changeToP</span> <span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token punctuation">(</span><span class="token constant">Node</span> <span class="token hvariable">_</span> <span class="token hvariable">l</span> <span class="token hvariable">r</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token constant">Node</span> <span class="token char string">'P'</span> <span class="token hvariable">l</span> <span class="token hvariable">r</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>If the first element in the our list of directions is <code>L</code>, we construct a new tree that's like the old tree, only its left sub-tree has an element changed to <code>'P'</code>. When we recursively call <code>changeToP</code>, we give it only the tail of the list of directions, because we already took a left. We do the same thing in the case of an <code>R</code>. If the list of directions is empty, that means that we're at our destination, so we return a tree that's like the one supplied, only it has <code>'P'</code> as its root element.</p></div><div><p>To avoid printing out the whole tree, let's make a function that takes a list of directions and tells us what the element at the destination is:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">elemAt</span> <span class="token operator">::</span> <span class="token constant">Directions</span> <span class="token operator">-&gt;</span> <span class="token constant">Tree</span> <span class="token hvariable">a</span> <span class="token operator">-&gt;</span> <span class="token hvariable">a</span>
<span class="token hvariable">elemAt</span> <span class="token punctuation">(</span><span class="token constant">L</span><span class="token operator">:</span><span class="token hvariable">ds</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token constant">Node</span> <span class="token hvariable">_</span> <span class="token hvariable">l</span> <span class="token hvariable">_</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token hvariable">elemAt</span> <span class="token hvariable">ds</span> <span class="token hvariable">l</span>
<span class="token hvariable">elemAt</span> <span class="token punctuation">(</span><span class="token constant">R</span><span class="token operator">:</span><span class="token hvariable">ds</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token constant">Node</span> <span class="token hvariable">_</span> <span class="token hvariable">_</span> <span class="token hvariable">r</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token hvariable">elemAt</span> <span class="token hvariable">ds</span> <span class="token hvariable">r</span>
<span class="token hvariable">elemAt</span> <span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token punctuation">(</span><span class="token constant">Node</span> <span class="token hvariable">x</span> <span class="token hvariable">_</span> <span class="token hvariable">_</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token hvariable">x</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>This function is actually quite similar to <code>changeToP</code>, only instead of remembering stuff along the way and reconstructing the tree, it ignores everything except its destination. Here we change the <code>'W'</code> to a <code>'P'</code> and see if the change in our new tree sticks:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token keyword">let</span> <span class="token hvariable">newTree</span> <span class="token operator">=</span> <span class="token hvariable">changeToP</span> <span class="token punctuation">[</span><span class="token constant">R</span><span class="token punctuation">,</span><span class="token constant">L</span><span class="token punctuation">]</span> <span class="token hvariable">freeTree</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token hvariable">elemAt</span> <span class="token punctuation">[</span><span class="token constant">R</span><span class="token punctuation">,</span><span class="token constant">L</span><span class="token punctuation">]</span> <span class="token hvariable">newTree</span>
<span class="token char string">'P'</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Nice, this seems to work. In these functions, the list of directions acts as a sort of <em>focus</em>, because it pinpoints one exact sub-tree from our tree. A direction list of <code>[R]</code> focuses on the sub-tree that's right of the root, for example. An empty direction list focuses on the main tree itself.</p></div><div><p>While this technique may seem cool, it can be rather inefficient, especially if we want to repeatedly change elements. Say we have a really huge tree and a long direction list that points to some element all the way at the bottom of the tree. We use the direction list to take a walk along the tree and change an element at the bottom. If we want to change another element that's close to the element that we've just changed, we have to start from the root of the tree and walk all the way to the bottom again! What a drag.</p></div><div><p>In the next section, we'll find a better way of focusing on a sub-tree, one that allows us to efficiently switch focus to sub-trees that are nearby.</p></div><div><h2 data-heading="A trail of breadcrumbs" id="A_trail_of_breadcrumbs" style="display: flex;"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>A trail of breadcrumbs</h2></div><div><p><span alt="LYHfGG_121_bread.png" src="LYHfGG_121_bread.png" class="internal-embed media-embed image-embed is-loaded"><img alt="LYHfGG_121_bread.png" src="курсы\learn-you-a-haskell-for-great-good!\картинки\lyhfgg_121_bread.png"></span></p></div><div><p>Okay, so for focusing on a sub-tree, we want something better than just a list of directions that we always follow from the root of our tree. Would it help if we start at the root of the tree and move either left or right one step at a time and sort of leave breadcrumbs? That is, when we go left, we remember that we went left and when we go right, we remember that we went right. Sure, we can try that.</p></div><div><p>To represent our breadcrumbs, we'll also use a list of <code>Direction</code> (which is either <code>L</code> or <code>R</code>), only instead of calling it <code>Directions</code>, we'll call it <code>Breadcrumbs</code> , because our directions will now be reversed since we're leaving them as we go down our tree:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token keyword">type</span> <span class="token constant">Breadcrumbs</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token constant">Direction</span><span class="token punctuation">]</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Here's a function that takes a tree and some breadcrumbs and moves to the left sub-tree while adding <code>L</code> to the head of the list that represents our breadcrumbs:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">goLeft</span> <span class="token operator">::</span> <span class="token punctuation">(</span><span class="token constant">Tree</span> <span class="token hvariable">a</span><span class="token punctuation">,</span> <span class="token constant">Breadcrumbs</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token punctuation">(</span><span class="token constant">Tree</span> <span class="token hvariable">a</span><span class="token punctuation">,</span> <span class="token constant">Breadcrumbs</span><span class="token punctuation">)</span>
<span class="token hvariable">goLeft</span> <span class="token punctuation">(</span><span class="token constant">Node</span> <span class="token hvariable">_</span> <span class="token hvariable">l</span> <span class="token hvariable">_</span><span class="token punctuation">,</span> <span class="token hvariable">bs</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token hvariable">l</span><span class="token punctuation">,</span> <span class="token constant">L</span><span class="token operator">:</span><span class="token hvariable">bs</span><span class="token punctuation">)</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>We ignore the element at the root and the right sub-tree and just return the left sub-tree along with the old breadcrumbs with <code>L</code> as the head. Here's a function to go right:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">goRight</span> <span class="token operator">::</span> <span class="token punctuation">(</span><span class="token constant">Tree</span> <span class="token hvariable">a</span><span class="token punctuation">,</span> <span class="token constant">Breadcrumbs</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token punctuation">(</span><span class="token constant">Tree</span> <span class="token hvariable">a</span><span class="token punctuation">,</span> <span class="token constant">Breadcrumbs</span><span class="token punctuation">)</span>
<span class="token hvariable">goRight</span> <span class="token punctuation">(</span><span class="token constant">Node</span> <span class="token hvariable">_</span> <span class="token hvariable">_</span> <span class="token hvariable">r</span><span class="token punctuation">,</span> <span class="token hvariable">bs</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token hvariable">r</span><span class="token punctuation">,</span> <span class="token constant">R</span><span class="token operator">:</span><span class="token hvariable">bs</span><span class="token punctuation">)</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>It works the same way. Let's use these functions to take our <code>freeTree</code> and go right and then left:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token hvariable">goLeft</span> <span class="token punctuation">(</span><span class="token hvariable">goRight</span> <span class="token punctuation">(</span><span class="token hvariable">freeTree</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token punctuation">(</span><span class="token constant">Node</span> <span class="token char string">'W'</span> <span class="token punctuation">(</span><span class="token constant">Node</span> <span class="token char string">'C'</span> <span class="token constant">Empty</span> <span class="token constant">Empty</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token constant">Node</span> <span class="token char string">'R'</span> <span class="token constant">Empty</span> <span class="token constant">Empty</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token constant">L</span><span class="token punctuation">,</span><span class="token constant">R</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p><span alt="LYHfGG_122_almostzipper.png" src="LYHfGG_122_almostzipper.png" class="internal-embed media-embed image-embed is-loaded"><img alt="LYHfGG_122_almostzipper.png" src="курсы\learn-you-a-haskell-for-great-good!\картинки\lyhfgg_122_almostzipper.png"></span></p></div><div><p>Okay, so now we have a tree that has <code>'W'</code> in its root and <code>'C'</code> in the root of its left sub-tree and <code>'R'</code> in the root of its right sub-tree. The breadcrumbs are <code>[L,R]</code>, because we first went right and then left.</p></div><div><p>To make walking along our tree clearer, we can use the <code>-:</code> function that we defined like so:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">x</span> <span class="token operator">-:</span> <span class="token hvariable">f</span> <span class="token operator">=</span> <span class="token hvariable">f</span> <span class="token hvariable">x</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Which allows us to apply functions to values by first writing the value, then writing a <code>-:</code> and then the function. So instead of <code>goRight (freeTree, [])</code>, we can write <code>(freeTree, []) -: goRight</code>. Using this, we can rewrite the above so that it's more apparent that we're first going right and then left:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token punctuation">(</span><span class="token hvariable">freeTree</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-:</span> <span class="token hvariable">goRight</span> <span class="token operator">-:</span> <span class="token hvariable">goLeft</span>
<span class="token punctuation">(</span><span class="token constant">Node</span> <span class="token char string">'W'</span> <span class="token punctuation">(</span><span class="token constant">Node</span> <span class="token char string">'C'</span> <span class="token constant">Empty</span> <span class="token constant">Empty</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token constant">Node</span> <span class="token char string">'R'</span> <span class="token constant">Empty</span> <span class="token constant">Empty</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token constant">L</span><span class="token punctuation">,</span><span class="token constant">R</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><h3 data-heading="Going back up" id="Going_back_up" style="display: flex;"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>Going back up</h3></div><div><p>What if we now want to go back up in our tree? From our breadcrumbs we know that the current tree is the left sub-tree of its parent and that it is the right sub-tree of its parent, but that's it. They don't tell us enough about the parent of the current sub-tree for us to be able to go up in the tree. It would seem that apart from the direction that we took, a single breadcrumb should also contain all other data that we need to go back up. In this case, that's the element in the parent tree along with its right sub-tree.</p></div><div><p>In general, a single breadcrumb should contain all the data needed to reconstruct the parent node. So it should have the information from all the paths that we didn't take and it should also know the direction that we did take, but it must not contain the sub-tree that we're currently focusing on. That's because we already have that sub-tree in the first component of the tuple, so if we also had it in the breadcrumbs, we'd have duplicate information.</p></div><div><p>Let's modify our breadcrumbs so that they also contain information about everything that we previously ignored when moving left and right. Instead of <code>Direction</code>, we'll make a new data type:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token keyword">data</span> <span class="token constant">Crumb</span> <span class="token hvariable">a</span> <span class="token operator">=</span> <span class="token constant">LeftCrumb</span> <span class="token hvariable">a</span> <span class="token punctuation">(</span><span class="token constant">Tree</span> <span class="token hvariable">a</span><span class="token punctuation">)</span> <span class="token operator">|</span> <span class="token constant">RightCrumb</span> <span class="token hvariable">a</span> <span class="token punctuation">(</span><span class="token constant">Tree</span> <span class="token hvariable">a</span><span class="token punctuation">)</span> <span class="token keyword">deriving</span> <span class="token punctuation">(</span><span class="token constant">Show</span><span class="token punctuation">)</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Now, instead of just <code>L</code>, we have a <code>LeftCrumb</code> that also contains the element in the node that we moved from and the right tree that we didn't visit. Instead of <code>R</code>, we have <code>RightCrumb</code>, which contains the element in the node that we moved from and the left tree that we didn't visit.</p></div><div><p>These breadcrumbs now contain all the data needed to recreate the tree that we walked through. So instead of just being normal bread crumbs, they're now more like floppy disks that we leave as we go along, because they contain a lot more information than just the direction that we took.</p></div><div><p>In essence, every breadcrumb is now like a tree node with a hole in it. When we move deeper into a tree, the breadcrumb carries all the information that the node that we moved away from carried <em>except</em> the sub-tree that we chose to focus on. It also has to note where the hole is. In the case of a <code>LeftCrumb</code>, we know that we moved left, so the sub-tree that's missing is the left one.</p></div><div><p>Let's also change our <code>Breadcrumbs</code> type synonym to reflect this:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token keyword">type</span> <span class="token constant">Breadcrumbs</span> <span class="token hvariable">a</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token constant">Crumb</span> <span class="token hvariable">a</span><span class="token punctuation">]</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Next up, we have to modify the <code>goLeft</code> and <code>goRight</code> functions to store information about the paths that we didn't take in our breadcrumbs, instead of ignoring that information like they did before. Here's <code>goLeft</code>:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">goLeft</span> <span class="token operator">::</span> <span class="token punctuation">(</span><span class="token constant">Tree</span> <span class="token hvariable">a</span><span class="token punctuation">,</span> <span class="token constant">Breadcrumbs</span> <span class="token hvariable">a</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token punctuation">(</span><span class="token constant">Tree</span> <span class="token hvariable">a</span><span class="token punctuation">,</span> <span class="token constant">Breadcrumbs</span> <span class="token hvariable">a</span><span class="token punctuation">)</span>
<span class="token hvariable">goLeft</span> <span class="token punctuation">(</span><span class="token constant">Node</span> <span class="token hvariable">x</span> <span class="token hvariable">l</span> <span class="token hvariable">r</span><span class="token punctuation">,</span> <span class="token hvariable">bs</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token hvariable">l</span><span class="token punctuation">,</span> <span class="token constant">LeftCrumb</span> <span class="token hvariable">x</span> <span class="token hvariable">r</span><span class="token operator">:</span><span class="token hvariable">bs</span><span class="token punctuation">)</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>You can see that it's very similar to our previous <code>goLeft</code>, only instead of just adding a <code>L</code> to the head of our list of breadcrumbs, we add a <code>LeftCrumb</code> to signify that we went left and we equip our <code>LeftCrumb</code> with the element in the node that we moved from (that's the <code>x</code>) and the right sub-tree that we chose not to visit.</p></div><div><p>Note that this function assumes that the current tree that's under focus isn't <code>Empty</code>. An empty tree doesn't have any sub-trees, so if we try to go left from an empty tree, an error will occur because the pattern match on <code>Node</code> won't succeed and there's no pattern that takes care of <code>Empty</code>.</p></div><div><p><code>goRight</code> is similar:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">goRight</span> <span class="token operator">::</span> <span class="token punctuation">(</span><span class="token constant">Tree</span> <span class="token hvariable">a</span><span class="token punctuation">,</span> <span class="token constant">Breadcrumbs</span> <span class="token hvariable">a</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token punctuation">(</span><span class="token constant">Tree</span> <span class="token hvariable">a</span><span class="token punctuation">,</span> <span class="token constant">Breadcrumbs</span> <span class="token hvariable">a</span><span class="token punctuation">)</span>
<span class="token hvariable">goRight</span> <span class="token punctuation">(</span><span class="token constant">Node</span> <span class="token hvariable">x</span> <span class="token hvariable">l</span> <span class="token hvariable">r</span><span class="token punctuation">,</span> <span class="token hvariable">bs</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token hvariable">r</span><span class="token punctuation">,</span> <span class="token constant">RightCrumb</span> <span class="token hvariable">x</span> <span class="token hvariable">l</span><span class="token operator">:</span><span class="token hvariable">bs</span><span class="token punctuation">)</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>We were previously able to go left and right. What we've gotten now is the ability to actualy go back up by remembering stuff about the parent nodes and the paths that we didn't visit. Here's the <code>goUp</code> function:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">goUp</span> <span class="token operator">::</span> <span class="token punctuation">(</span><span class="token constant">Tree</span> <span class="token hvariable">a</span><span class="token punctuation">,</span> <span class="token constant">Breadcrumbs</span> <span class="token hvariable">a</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token punctuation">(</span><span class="token constant">Tree</span> <span class="token hvariable">a</span><span class="token punctuation">,</span> <span class="token constant">Breadcrumbs</span> <span class="token hvariable">a</span><span class="token punctuation">)</span>
<span class="token hvariable">goUp</span> <span class="token punctuation">(</span><span class="token hvariable">t</span><span class="token punctuation">,</span> <span class="token constant">LeftCrumb</span> <span class="token hvariable">x</span> <span class="token hvariable">r</span><span class="token operator">:</span><span class="token hvariable">bs</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token constant">Node</span> <span class="token hvariable">x</span> <span class="token hvariable">t</span> <span class="token hvariable">r</span><span class="token punctuation">,</span> <span class="token hvariable">bs</span><span class="token punctuation">)</span>
<span class="token hvariable">goUp</span> <span class="token punctuation">(</span><span class="token hvariable">t</span><span class="token punctuation">,</span> <span class="token constant">RightCrumb</span> <span class="token hvariable">x</span> <span class="token hvariable">l</span><span class="token operator">:</span><span class="token hvariable">bs</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token constant">Node</span> <span class="token hvariable">x</span> <span class="token hvariable">l</span> <span class="token hvariable">t</span><span class="token punctuation">,</span> <span class="token hvariable">bs</span><span class="token punctuation">)</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p><span alt="LYHfGG_123_asstronaut.png" src="LYHfGG_123_asstronaut.png" class="internal-embed media-embed image-embed is-loaded"><img alt="LYHfGG_123_asstronaut.png" src="курсы\learn-you-a-haskell-for-great-good!\картинки\lyhfgg_123_asstronaut.png"></span></p></div><div><p>We're focusing on the tree <code>t</code> and we check what the latest <code>Crumb</code> is. If it's a <code>LeftCrumb</code>, then we construct a new tree where our tree <code>t</code> is the left sub-tree and we use the information about the right sub-tree that we didn't visit and the element to fill out the rest of the <code>Node</code>. Because we moved back so to speak and picked up the last breadcrumb to recreate with it the parent tree, the new list of breadcrumbs doesn't contain it.</p></div><div><p>Note that this function causes an error if we're already at the top of a tree and we want to move up. Later on, we'll use the <code>Maybe</code> monad to represent possible failure when moving focus.</p></div><div><p>With a pair of <code>Tree a</code> and <code>Breadcrumbs a</code>, we have all the information to rebuild the whole tree and we also have a focus on a sub-tree. This scheme also enables us to easily move up, left and right. Such a pair that contains a focused part of a data structure and its surroundings is called a zipper, because moving our focus up and down the data structure resembles the operation of a zipper on a regular pair of pants. So it's cool to make a type synonym as such:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token keyword">type</span> <span class="token constant">Zipper</span> <span class="token hvariable">a</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token constant">Tree</span> <span class="token hvariable">a</span><span class="token punctuation">,</span> <span class="token constant">Breadcrumbs</span> <span class="token hvariable">a</span><span class="token punctuation">)</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>I'd prefer naming the type synonym <code>Focus</code> because that makes it clearer that we're focusing on a part of a data structure, but the term zipper is more widely used to describe such a setup, so we'll stick with <code>Zipper</code>.</p></div><div><h3 data-heading="Manipulating trees under focus" id="Manipulating_trees_under_focus" style="display: flex;"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>Manipulating trees under focus</h3></div><div><p>Now that we can move up and down, let's make a function that modifies the element in the root of the sub-tree that the zipper is focusing on:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">modify</span> <span class="token operator">::</span> <span class="token punctuation">(</span><span class="token hvariable">a</span> <span class="token operator">-&gt;</span> <span class="token hvariable">a</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token constant">Zipper</span> <span class="token hvariable">a</span> <span class="token operator">-&gt;</span> <span class="token constant">Zipper</span> <span class="token hvariable">a</span>
<span class="token hvariable">modify</span> <span class="token hvariable">f</span> <span class="token punctuation">(</span><span class="token constant">Node</span> <span class="token hvariable">x</span> <span class="token hvariable">l</span> <span class="token hvariable">r</span><span class="token punctuation">,</span> <span class="token hvariable">bs</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token constant">Node</span> <span class="token punctuation">(</span><span class="token hvariable">f</span> <span class="token hvariable">x</span><span class="token punctuation">)</span> <span class="token hvariable">l</span> <span class="token hvariable">r</span><span class="token punctuation">,</span> <span class="token hvariable">bs</span><span class="token punctuation">)</span>
<span class="token hvariable">modify</span> <span class="token hvariable">f</span> <span class="token punctuation">(</span><span class="token constant">Empty</span><span class="token punctuation">,</span> <span class="token hvariable">bs</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token constant">Empty</span><span class="token punctuation">,</span> <span class="token hvariable">bs</span><span class="token punctuation">)</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>If we're focusing on a node, we modify its root element with the function <code>f</code>. If we're focusing on an empty tree, we leave it as it is. Now we can start off with a tree, move to anywhere we want and modify an element, all while keeping focus on that element so that we can easily move further up or down. An example:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token keyword">let</span> <span class="token hvariable">newFocus</span> <span class="token operator">=</span> <span class="token hvariable">modify</span> <span class="token punctuation">(</span><span class="token operator">\</span><span class="token hvariable">_</span> <span class="token operator">-&gt;</span> <span class="token char string">'P'</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token hvariable">goRight</span> <span class="token punctuation">(</span><span class="token hvariable">goLeft</span> <span class="token punctuation">(</span><span class="token hvariable">freeTree</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>We go left, then right and then modify the root element by replacing it with a <code>'P'</code>. This reads even better if we use <code>-:</code>:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token keyword">let</span> <span class="token hvariable">newFocus</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token hvariable">freeTree</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-:</span> <span class="token hvariable">goLeft</span> <span class="token operator">-:</span> <span class="token hvariable">goRight</span> <span class="token operator">-:</span> <span class="token hvariable">modify</span> <span class="token punctuation">(</span><span class="token operator">\</span><span class="token hvariable">_</span> <span class="token operator">-&gt;</span> <span class="token char string">'P'</span><span class="token punctuation">)</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>We can then move up if we want and replace an element with a mysterious <code>'X'</code>:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token keyword">let</span> <span class="token hvariable">newFocus2</span> <span class="token operator">=</span> <span class="token hvariable">modify</span> <span class="token punctuation">(</span><span class="token operator">\</span><span class="token hvariable">_</span> <span class="token operator">-&gt;</span> <span class="token char string">'X'</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token hvariable">goUp</span> <span class="token hvariable">newFocus</span><span class="token punctuation">)</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Or if we wrote it with <code>-:</code>:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token keyword">let</span> <span class="token hvariable">newFocus2</span> <span class="token operator">=</span> <span class="token hvariable">newFocus</span> <span class="token operator">-:</span> <span class="token hvariable">goUp</span> <span class="token operator">-:</span> <span class="token hvariable">modify</span> <span class="token punctuation">(</span><span class="token operator">\</span><span class="token hvariable">_</span> <span class="token operator">-&gt;</span> <span class="token char string">'X'</span><span class="token punctuation">)</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Moving up is easy because the breadcrumbs that we leave form the part of the data structure that we're not focusing on, but it's inverted, sort of like turning a sock inside out. That's why when we want to move up, we don't have to start from the root and make our way down, but we just take the top of our inverted tree, thereby uninverting a part of it and adding it to our focus.</p></div><div><p>Each node has two sub-trees, even if those sub-trees are empty trees. So if we're focusing on an empty sub-tree, one thing we can do is to replace it with a non-empty subtree, thus attaching a tree to a leaf node. The code for this is simple:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">attach</span> <span class="token operator">::</span> <span class="token constant">Tree</span> <span class="token hvariable">a</span> <span class="token operator">-&gt;</span> <span class="token constant">Zipper</span> <span class="token hvariable">a</span> <span class="token operator">-&gt;</span> <span class="token constant">Zipper</span> <span class="token hvariable">a</span>
<span class="token hvariable">attach</span> <span class="token hvariable">t</span> <span class="token punctuation">(</span><span class="token hvariable">_</span><span class="token punctuation">,</span> <span class="token hvariable">bs</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token hvariable">t</span><span class="token punctuation">,</span> <span class="token hvariable">bs</span><span class="token punctuation">)</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>We take a tree and a zipper and return a new zipper that has its focus replaced with the supplied tree. Not only can we extend trees this way by replacing empty sub-trees with new trees, we can also replace whole existing sub-trees. Let's attach a tree to the far left of our <code>freeTree</code>:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token keyword">let</span> <span class="token hvariable">farLeft</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token hvariable">freeTree</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-:</span> <span class="token hvariable">goLeft</span> <span class="token operator">-:</span> <span class="token hvariable">goLeft</span> <span class="token operator">-:</span> <span class="token hvariable">goLeft</span> <span class="token operator">-:</span> <span class="token hvariable">goLeft</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token keyword">let</span> <span class="token hvariable">newFocus</span> <span class="token operator">=</span> <span class="token hvariable">farLeft</span> <span class="token operator">-:</span> <span class="token hvariable">attach</span> <span class="token punctuation">(</span><span class="token constant">Node</span> <span class="token char string">'Z'</span> <span class="token constant">Empty</span> <span class="token constant">Empty</span><span class="token punctuation">)</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p><code>newFocus</code> is now focused on the tree that we just attached and the rest of the tree lies inverted in the breadcrumbs. If we were to use <code>goUp</code> to walk all the way to the top of the tree, it would be the same tree as <code>freeTree</code> but with an additional <code>'Z'</code> on its far left.</p></div><div><h3 data-heading="I'm going straight to the top, oh yeah, up where the air is fresh and clean!" id="I'm_going_straight_to_the_top,_oh_yeah,_up_where_the_air_is_fresh_and_clean!" style="display: flex;"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>I'm going straight to the top, oh yeah, up where the air is fresh and clean!</h3></div><div><p>Making a function that walks all the way to the top of the tree, regardless of what we're focusing on, is really easy. Here it is:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">topMost</span> <span class="token operator">::</span> <span class="token constant">Zipper</span> <span class="token hvariable">a</span> <span class="token operator">-&gt;</span> <span class="token constant">Zipper</span> <span class="token hvariable">a</span>
<span class="token hvariable">topMost</span> <span class="token punctuation">(</span><span class="token hvariable">t</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token hvariable">t</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
<span class="token hvariable">topMost</span> <span class="token hvariable">z</span> <span class="token operator">=</span> <span class="token hvariable">topMost</span> <span class="token punctuation">(</span><span class="token hvariable">goUp</span> <span class="token hvariable">z</span><span class="token punctuation">)</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>If our trail of beefed up breadcrumbs is empty, this means that we're already at the root of our tree, so we just return the current focus. Otherwise, we go up to get the focus of the parent node and then recursively apply <code>topMost</code> to that. So now we can walk around our tree, going left and right and up, applying <code>modify</code> and <code>attach</code> as we go along and then when we're done with our modifications, we use <code>topMost</code> to focus on the root of our tree and see the changes that we've done in proper perspective.</p></div><div><h2 data-heading="Focusing on lists" id="Focusing_on_lists" style="display: flex;"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>Focusing on lists</h2></div><div><p>Zippers can be used with pretty much any data structure, so it's no surprise that they can be used to focus on sub-lists of lists. After all, lists are pretty much like trees, only where a node in a tree has an element (or not) and several sub-trees, a node in a list has an element and only a single sub-list. When we <a data-tooltip-position="top" aria-label="http://learnyouahaskell.com/making-our-own-types-and-typeclasses#recursive-data-structures" rel="noopener" class="external-link" href="http://learnyouahaskell.com/making-our-own-types-and-typeclasses#recursive-data-structures" target="_blank">implemented our own lists</a>, we defined our data type like so:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token keyword">data</span> <span class="token constant">List</span> <span class="token hvariable">a</span> <span class="token operator">=</span> <span class="token constant">Empty</span> <span class="token operator">|</span> <span class="token constant">Cons</span> <span class="token hvariable">a</span> <span class="token punctuation">(</span><span class="token constant">List</span> <span class="token hvariable">a</span><span class="token punctuation">)</span> <span class="token keyword">deriving</span> <span class="token punctuation">(</span><span class="token constant">Show</span><span class="token punctuation">,</span> <span class="token constant">Read</span><span class="token punctuation">,</span> <span class="token constant">Eq</span><span class="token punctuation">,</span> <span class="token constant">Ord</span><span class="token punctuation">)</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p><span alt="LYHfGG_124_picard.png" src="LYHfGG_124_picard.png" class="internal-embed media-embed image-embed is-loaded"><img alt="LYHfGG_124_picard.png" src="курсы\learn-you-a-haskell-for-great-good!\картинки\lyhfgg_124_picard.png"></span></p></div><div><p>Contrast this with our definition of our binary tree and it's easy to see how lists can be viewed as trees where each node has only one sub-tree.</p></div><div><p>A list like <code>[1,2,3]</code> can be written as <code>1:2:3:[]</code>. It consists of the head of the list, which is <code>1</code> and then the list's tail, which is <code>2:3:[]</code>. In turn, <code>2:3:[]</code> also has a head, which is <code>2</code> and a tail, which is <code>3:[]</code>. With <code>3:[]</code>, the <code>3</code> is the head and the tail is the empty list <code>[]</code>.</p></div><div><p>Let's make a zipper for lists. To change the focus on sub-lists of a list, we move either forward or back (whereas with trees we moved either up or left or right). The focused part will be a sub-tree and along with that we'll leave breadcrumbs as we move forward. Now what would a single breadcrumb for a list consist of? When we were dealing with binary trees, we said that a breadcrumb has to hold the element in the root of the parent node along with all the sub-trees that we didn't choose. It also had to remember if we went left or right. So, it had to have all the information that a node has except for the sub-tree that we chose to focus on.</p></div><div><p>Lists are simpler than trees, so we don't have to remember if we went left or right, because there's only one way to go deeper into a list. Because there's only one sub-tree to each node, we don't have to remember the paths that we didn't take either. It seems that all we have to remember is the previous element. If we have a list like <code>[3,4,5]</code> and we know that the previous element was <code>2</code>, we can go back by just putting that element at the head of our list, getting <code>[2,3,4,5]</code>.</p></div><div><p>Because a single breadcrumb here is just the element, we don't really have to put it inside a data type, like we did when we made the <code>Crumb</code> data type for tree zippers:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token keyword">type</span> <span class="token constant">ListZipper</span> <span class="token hvariable">a</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token hvariable">a</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token hvariable">a</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>The first list represents the list that we're focusing on and the second list is the list of breadcrumbs. Let's make functions that go forward and back into lists:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">goForward</span> <span class="token operator">::</span> <span class="token constant">ListZipper</span> <span class="token hvariable">a</span> <span class="token operator">-&gt;</span> <span class="token constant">ListZipper</span> <span class="token hvariable">a</span>
<span class="token hvariable">goForward</span> <span class="token punctuation">(</span><span class="token hvariable">x</span><span class="token operator">:</span><span class="token hvariable">xs</span><span class="token punctuation">,</span> <span class="token hvariable">bs</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token hvariable">xs</span><span class="token punctuation">,</span> <span class="token hvariable">x</span><span class="token operator">:</span><span class="token hvariable">bs</span><span class="token punctuation">)</span>

<span class="token hvariable">goBack</span> <span class="token operator">::</span> <span class="token constant">ListZipper</span> <span class="token hvariable">a</span> <span class="token operator">-&gt;</span> <span class="token constant">ListZipper</span> <span class="token hvariable">a</span>
<span class="token hvariable">goBack</span> <span class="token punctuation">(</span><span class="token hvariable">xs</span><span class="token punctuation">,</span> <span class="token hvariable">b</span><span class="token operator">:</span><span class="token hvariable">bs</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token hvariable">b</span><span class="token operator">:</span><span class="token hvariable">xs</span><span class="token punctuation">,</span> <span class="token hvariable">bs</span><span class="token punctuation">)</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>When we're going forward, we focus on the tail of the current list and leave the head element as a breadcrumb. When we're moving backwards, we take the latest breadcrumb and put it at the beginning of the list.</p></div><div><p>Here are these two functions in action:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token keyword">let</span> <span class="token hvariable">xs</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">]</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token hvariable">goForward</span> <span class="token punctuation">(</span><span class="token hvariable">xs</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token hvariable">goForward</span> <span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token hvariable">goForward</span> <span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token hvariable">goBack</span> <span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>We see that the breadcrumbs in the case of lists are nothing more but a reversed part of our list. The element that we move away from always goes into the head of the breadcrumbs, so it's easy to move back by just taking that element from the head of the breadcrumbs and making it the head of our focus.</p></div><div><p>This also makes it easier to see why we call this a zipper, because this really looks like the slider of a zipper moving up and down.</p></div><div><p>If you were making a text editor, you could use a list of strings to represent the lines of text that are currently opened and you could then use a zipper so that you know which line the cursor is currently focused on. By using a zipper, it would also make it easier to insert new lines anywhere in the text or delete existing ones.</p></div><div><h2 data-heading="A very simple file system" id="A_very_simple_file_system" style="display: flex;"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>A very simple file system</h2></div><div><p>Now that we know how zippers work, let's use trees to represent a very simple file system and then make a zipper for that file system, which will allow us to move between folders, just like we usually do when jumping around our file system.</p></div><div><p>If we take a simplistic view of the average hierarchical file system, we see that it's mostly made up of files and folders. Files are units of data and come with a name, whereas folders are used to organize those files and can contain files or other folders. So let's say that an item in a file system is either a file, which comes with a name and some data, or a folder, which has a name and then a bunch of items that are either files or folders themselves. Here's a data type for this and some type synonyms so we know what's what:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token keyword">type</span> <span class="token constant">Name</span> <span class="token operator">=</span> <span class="token constant">String</span>
<span class="token keyword">type</span> <span class="token constant">Data</span> <span class="token operator">=</span> <span class="token constant">String</span>
<span class="token keyword">data</span> <span class="token constant">FSItem</span> <span class="token operator">=</span> <span class="token constant">File</span> <span class="token constant">Name</span> <span class="token constant">Data</span> <span class="token operator">|</span> <span class="token constant">Folder</span> <span class="token constant">Name</span> <span class="token punctuation">[</span><span class="token constant">FSItem</span><span class="token punctuation">]</span> <span class="token keyword">deriving</span> <span class="token punctuation">(</span><span class="token constant">Show</span><span class="token punctuation">)</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>A file comes with two strings, which represent its name and the data it holds. A folder comes with a string that is its name and a list of items. If that list is empty, then we have an empty folder.</p></div><div><p>Here's a folder with some files and sub-folders:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">myDisk</span> <span class="token operator">::</span> <span class="token constant">FSItem</span>
<span class="token hvariable">myDisk</span> <span class="token operator">=</span>
    <span class="token constant">Folder</span> <span class="token string">"root"</span> 
        <span class="token punctuation">[</span> <span class="token constant">File</span> <span class="token string">"goat_yelling_like_man.wmv"</span> <span class="token string">"baaaaaa"</span>
        <span class="token punctuation">,</span> <span class="token constant">File</span> <span class="token string">"pope_time.avi"</span> <span class="token string">"god bless"</span>
        <span class="token punctuation">,</span> <span class="token constant">Folder</span> <span class="token string">"pics"</span>
            <span class="token punctuation">[</span> <span class="token constant">File</span> <span class="token string">"ape_throwing_up.jpg"</span> <span class="token string">"bleargh"</span>
            <span class="token punctuation">,</span> <span class="token constant">File</span> <span class="token string">"watermelon_smash.gif"</span> <span class="token string">"smash!!"</span>
            <span class="token punctuation">,</span> <span class="token constant">File</span> <span class="token string">"skull_man(scary).bmp"</span> <span class="token string">"Yikes!"</span>
            <span class="token punctuation">]</span>
        <span class="token punctuation">,</span> <span class="token constant">File</span> <span class="token string">"dijon_poupon.doc"</span> <span class="token string">"best mustard"</span>
        <span class="token punctuation">,</span> <span class="token constant">Folder</span> <span class="token string">"programs"</span>
            <span class="token punctuation">[</span> <span class="token constant">File</span> <span class="token string">"fartwizard.exe"</span> <span class="token string">"10gotofart"</span>
            <span class="token punctuation">,</span> <span class="token constant">File</span> <span class="token string">"owl_bandit.dmg"</span> <span class="token string">"mov eax, h00t"</span>
            <span class="token punctuation">,</span> <span class="token constant">File</span> <span class="token string">"not_a_virus.exe"</span> <span class="token string">"really not a virus"</span>
            <span class="token punctuation">,</span> <span class="token constant">Folder</span> <span class="token string">"source code"</span>
                <span class="token punctuation">[</span> <span class="token constant">File</span> <span class="token string">"best_hs_prog.hs"</span> <span class="token string">"main = print (fix error)"</span>
                <span class="token punctuation">,</span> <span class="token constant">File</span> <span class="token string">"random.hs"</span> <span class="token string">"main = print 4"</span>
                <span class="token punctuation">]</span>
            <span class="token punctuation">]</span>
        <span class="token punctuation">]</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>That's actually what my disk contains right now.</p></div><div><h3 data-heading="A zipper for our file system" id="A_zipper_for_our_file_system" style="display: flex;"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>A zipper for our file system</h3></div><div><p><span alt="LYHfGG_125_spongedisk.png" src="LYHfGG_125_spongedisk.png" class="internal-embed media-embed image-embed is-loaded"><img alt="LYHfGG_125_spongedisk.png" src="курсы\learn-you-a-haskell-for-great-good!\картинки\lyhfgg_125_spongedisk.png"></span></p></div><div><p>Now that we have a file system, all we need is a zipper so we can zip and zoom around it and add, modify and remove files as well as folders. Like with binary trees and lists, we're going to be leaving breadcrumbs that contain info about all the stuff that we chose not to visit. Like we said, a single breadcrumb should be kind of like a node, only it should contain everything except the sub-tree that we're currently focusing on. It should also note where the hole is so that once we move back up, we can plug our previous focus into the hole.</p></div><div><p>In this case, a breadcrumb should be like a folder, only it should be missing the folder that we currently chose. Why not like a file, you ask? Well, because once we're focusing on a file, we can't move deeper into the file system, so it doesn't make sense to leave a breadcrumb that says that we came from a file. A file is sort of like an empty tree.</p></div><div><p>If we're focusing on the folder <code>"root"</code> and we then focus on the file <code>"dijon_poupon.doc"</code>, what should the breadcrumb that we leave look like? Well, it should contain the name of its parent folder along with the items that come before the file that we're focusing on and the items that come after it. So all we need is a <code>Name</code> and two lists of items. By keeping separate lists for the items that come before the item that we're focusing and for the items that come after it, we know exactly where to place it once we move back up. So this way, we know where the hole is.</p></div><div><p>Here's our breadcrumb type for the file system:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token keyword">data</span> <span class="token constant">FSCrumb</span> <span class="token operator">=</span> <span class="token constant">FSCrumb</span> <span class="token constant">Name</span> <span class="token punctuation">[</span><span class="token constant">FSItem</span><span class="token punctuation">]</span> <span class="token punctuation">[</span><span class="token constant">FSItem</span><span class="token punctuation">]</span> <span class="token keyword">deriving</span> <span class="token punctuation">(</span><span class="token constant">Show</span><span class="token punctuation">)</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>And here's a type synonym for our zipper:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token keyword">type</span> <span class="token constant">FSZipper</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token constant">FSItem</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token constant">FSCrumb</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Going back up in the hierarchy is very simple. We just take the latest breadcrumb and assemble a new focus from the current focus and breadcrumb. Like so:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">fsUp</span> <span class="token operator">::</span> <span class="token constant">FSZipper</span> <span class="token operator">-&gt;</span> <span class="token constant">FSZipper</span>
<span class="token hvariable">fsUp</span> <span class="token punctuation">(</span><span class="token hvariable">item</span><span class="token punctuation">,</span> <span class="token constant">FSCrumb</span> <span class="token hvariable">name</span> <span class="token hvariable">ls</span> <span class="token hvariable">rs</span><span class="token operator">:</span><span class="token hvariable">bs</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token constant">Folder</span> <span class="token hvariable">name</span> <span class="token punctuation">(</span><span class="token hvariable">ls</span> <span class="token operator">++</span> <span class="token punctuation">[</span><span class="token hvariable">item</span><span class="token punctuation">]</span> <span class="token operator">++</span> <span class="token hvariable">rs</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token hvariable">bs</span><span class="token punctuation">)</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Because our breadcrumb knew what the parent folder's name was, as well as the items that came before our focused item in the folder (that's <code>ls</code>) and the ones that came after (that's <code>rs</code>), moving up was easy.</p></div><div><p>How about going deeper into the file system? If we're in the <code>"root"</code> and we want to focus on <code>"dijon_poupon.doc"</code>, the breadcrumb that we leave is going to include the name <code>"root"</code> along with the items that precede <code>"dijon_poupon.doc"</code> and the ones that come after it.</p></div><div><p>Here's a function that, given a name, focuses on a file of folder that's located in the current focused folder:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token import-statement"><span class="token keyword">import</span> Data<span class="token punctuation">.</span>List</span> <span class="token punctuation">(</span><span class="token builtin">break</span><span class="token punctuation">)</span>

<span class="token hvariable">fsTo</span> <span class="token operator">::</span> <span class="token constant">Name</span> <span class="token operator">-&gt;</span> <span class="token constant">FSZipper</span> <span class="token operator">-&gt;</span> <span class="token constant">FSZipper</span>
<span class="token hvariable">fsTo</span> <span class="token hvariable">name</span> <span class="token punctuation">(</span><span class="token constant">Folder</span> <span class="token hvariable">folderName</span> <span class="token hvariable">items</span><span class="token punctuation">,</span> <span class="token hvariable">bs</span><span class="token punctuation">)</span> <span class="token operator">=</span> 
    <span class="token keyword">let</span> <span class="token punctuation">(</span><span class="token hvariable">ls</span><span class="token punctuation">,</span> <span class="token hvariable">item</span><span class="token operator">:</span><span class="token hvariable">rs</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token builtin">break</span> <span class="token punctuation">(</span><span class="token hvariable">nameIs</span> <span class="token hvariable">name</span><span class="token punctuation">)</span> <span class="token hvariable">items</span>
    <span class="token keyword">in</span>  <span class="token punctuation">(</span><span class="token hvariable">item</span><span class="token punctuation">,</span> <span class="token constant">FSCrumb</span> <span class="token hvariable">folderName</span> <span class="token hvariable">ls</span> <span class="token hvariable">rs</span><span class="token operator">:</span><span class="token hvariable">bs</span><span class="token punctuation">)</span>

<span class="token hvariable">nameIs</span> <span class="token operator">::</span> <span class="token constant">Name</span> <span class="token operator">-&gt;</span> <span class="token constant">FSItem</span> <span class="token operator">-&gt;</span> <span class="token constant">Bool</span>
<span class="token hvariable">nameIs</span> <span class="token hvariable">name</span> <span class="token punctuation">(</span><span class="token constant">Folder</span> <span class="token hvariable">folderName</span> <span class="token hvariable">_</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token hvariable">name</span> <span class="token operator">==</span> <span class="token hvariable">folderName</span>
<span class="token hvariable">nameIs</span> <span class="token hvariable">name</span> <span class="token punctuation">(</span><span class="token constant">File</span> <span class="token hvariable">fileName</span> <span class="token hvariable">_</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token hvariable">name</span> <span class="token operator">==</span> <span class="token hvariable">fileName</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p><code>fsTo</code> takes a <code>Name</code> and a <code>FSZipper</code> and returns a new <code>FSZipper</code> that focuses on the file with the given name. That file has to be in the current focused folder. This function doesn't search all over the place, it just looks at the current folder.</p></div><div><p><span alt="LYHfGG_126_cool.png" src="LYHfGG_126_cool.png" class="internal-embed media-embed image-embed is-loaded"><img alt="LYHfGG_126_cool.png" src="курсы\learn-you-a-haskell-for-great-good!\картинки\lyhfgg_126_cool.png"></span></p></div><div><p>First we use <code>break</code> to break the list of items in a folder into those that precede the file that we're searching for and those that come after it. If you remember, <code>break</code> takes a predicate and a list and returns a pair of lists. The first list in the pair holds items for which the predicate returns <code>False</code>. Then, once the predicate returns <code>True</code> for an item, it places that item and the rest of the list in the second item of the pair. We made an auxilliary function called <code>nameIs</code> that takes a name and a file system item and returns <code>True</code> if the names match.</p></div><div><p>So now, <code>ls</code> is a list that contains the items that precede the item that we're searching for, <code>item</code> is that very item and <code>rs</code> is the list of items that come after it in its folder. Now that we have this, we just present the item that we got from <code>break</code> as the focus and build a breadcrumb that has all the data it needs.</p></div><div><p>Note that if the name we're looking for isn't in the folder, the pattern <code>item:rs</code> will try to match on an empty list and we'll get an error. Also, if our current focus isn't a folder at all but a file, we get an error as well and the program crashes.</p></div><div><p>Now we can move up and down our file system. Let's start at the root and walk to the file <code>"skull_man(scary).bmp"</code>:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token keyword">let</span> <span class="token hvariable">newFocus</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token hvariable">myDisk</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-:</span> <span class="token hvariable">fsTo</span> <span class="token string">"pics"</span> <span class="token operator">-:</span> <span class="token hvariable">fsTo</span> <span class="token string">"skull_man(scary).bmp"</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p><code>newFocus</code> is now a zipper that's focused on the <code>"skull_man(scary).bmp"</code> file. Let's get the first component of the zipper (the focus itself) and see if that's really true:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token builtin">fst</span> <span class="token hvariable">newFocus</span>
<span class="token constant">File</span> <span class="token string">"skull_man(scary).bmp"</span> <span class="token string">"Yikes!"</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Let's move up and then focus on its neighboring file <code>"watermelon_smash.gif"</code>:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token keyword">let</span> <span class="token hvariable">newFocus2</span> <span class="token operator">=</span> <span class="token hvariable">newFocus</span> <span class="token operator">-:</span> <span class="token hvariable">fsUp</span> <span class="token operator">-:</span> <span class="token hvariable">fsTo</span> <span class="token string">"watermelon_smash.gif"</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token builtin">fst</span> <span class="token hvariable">newFocus2</span>
<span class="token constant">File</span> <span class="token string">"watermelon_smash.gif"</span> <span class="token string">"smash!!"</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><h3 data-heading="Manipulating our file system" id="Manipulating_our_file_system" style="display: flex;"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>Manipulating our file system</h3></div><div><p>Now that we know how to navigate our file system, manipulating it is easy. Here's a function that renames the currently focused file or folder:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">fsRename</span> <span class="token operator">::</span> <span class="token constant">Name</span> <span class="token operator">-&gt;</span> <span class="token constant">FSZipper</span> <span class="token operator">-&gt;</span> <span class="token constant">FSZipper</span>
<span class="token hvariable">fsRename</span> <span class="token hvariable">newName</span> <span class="token punctuation">(</span><span class="token constant">Folder</span> <span class="token hvariable">name</span> <span class="token hvariable">items</span><span class="token punctuation">,</span> <span class="token hvariable">bs</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token constant">Folder</span> <span class="token hvariable">newName</span> <span class="token hvariable">items</span><span class="token punctuation">,</span> <span class="token hvariable">bs</span><span class="token punctuation">)</span>
<span class="token hvariable">fsRename</span> <span class="token hvariable">newName</span> <span class="token punctuation">(</span><span class="token constant">File</span> <span class="token hvariable">name</span> <span class="token hvariable">dat</span><span class="token punctuation">,</span> <span class="token hvariable">bs</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token constant">File</span> <span class="token hvariable">newName</span> <span class="token hvariable">dat</span><span class="token punctuation">,</span> <span class="token hvariable">bs</span><span class="token punctuation">)</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Now we can rename our <code>"pics"</code> folder to <code>"cspi"</code>:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token keyword">let</span> <span class="token hvariable">newFocus</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token hvariable">myDisk</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-:</span> <span class="token hvariable">fsTo</span> <span class="token string">"pics"</span> <span class="token operator">-:</span> <span class="token hvariable">fsRename</span> <span class="token string">"cspi"</span> <span class="token operator">-:</span> <span class="token hvariable">fsUp</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>We descended to the <code>"pics"</code> folder, renamed it and then moved back up.</p></div><div><p>How about a function that makes a new item in the current folder? Behold:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">fsNewFile</span> <span class="token operator">::</span> <span class="token constant">FSItem</span> <span class="token operator">-&gt;</span> <span class="token constant">FSZipper</span> <span class="token operator">-&gt;</span> <span class="token constant">FSZipper</span>
<span class="token hvariable">fsNewFile</span> <span class="token hvariable">item</span> <span class="token punctuation">(</span><span class="token constant">Folder</span> <span class="token hvariable">folderName</span> <span class="token hvariable">items</span><span class="token punctuation">,</span> <span class="token hvariable">bs</span><span class="token punctuation">)</span> <span class="token operator">=</span> 
    <span class="token punctuation">(</span><span class="token constant">Folder</span> <span class="token hvariable">folderName</span> <span class="token punctuation">(</span><span class="token hvariable">item</span><span class="token operator">:</span><span class="token hvariable">items</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token hvariable">bs</span><span class="token punctuation">)</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Easy as pie. Note that this would crash if we tried to add an item but weren't focusing on a folder, but were focusing on a file instead.</p></div><div><p>Let's add a file to our <code>"pics"</code> folder and then move back up to the root:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token keyword">let</span> <span class="token hvariable">newFocus</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token hvariable">myDisk</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-:</span> <span class="token hvariable">fsTo</span> <span class="token string">"pics"</span> <span class="token operator">-:</span> <span class="token hvariable">fsNewFile</span> <span class="token punctuation">(</span><span class="token constant">File</span> <span class="token string">"heh.jpg"</span> <span class="token string">"lol"</span><span class="token punctuation">)</span> <span class="token operator">-:</span> <span class="token hvariable">fsUp</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>What's really cool about all this is that when we modify our file system, it doesn't actually modify it in place but it returns a whole new file system. That way, we have access to our old file system (in this case, <code>myDisk</code>) as well as the new one (the first component of <code>newFocus</code>). So by using zippers, we get versioning for free, meaning that we can always refer to older versions of data structures even after we've changed them, so to speak. This isn't unique to zippers, but is a property of Haskell because its data structures are immutable. With zippers however, we get the ability to easily and efficiently walk around our data structures, so the persistence of Haskell's data structures really begins to shine.</p></div><div><h2 data-heading="Watch your step" id="Watch_your_step" style="display: flex;"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>Watch your step</h2></div><div><p>So far, while walking through our data structures, whether they were binary trees, lists or file systems, we didn't really care if we took a step too far and fell off. For instance, our <code>goLeft</code> function takes a zipper of a binary tree and moves the focus to its left sub-tree:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">goLeft</span> <span class="token operator">::</span> <span class="token constant">Zipper</span> <span class="token hvariable">a</span> <span class="token operator">-&gt;</span> <span class="token constant">Zipper</span> <span class="token hvariable">a</span>
<span class="token hvariable">goLeft</span> <span class="token punctuation">(</span><span class="token constant">Node</span> <span class="token hvariable">x</span> <span class="token hvariable">l</span> <span class="token hvariable">r</span><span class="token punctuation">,</span> <span class="token hvariable">bs</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token hvariable">l</span><span class="token punctuation">,</span> <span class="token constant">LeftCrumb</span> <span class="token hvariable">x</span> <span class="token hvariable">r</span><span class="token operator">:</span><span class="token hvariable">bs</span><span class="token punctuation">)</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p><span alt="LYHfGG_127_bigtree.png" src="LYHfGG_127_bigtree.png" class="internal-embed media-embed image-embed is-loaded"><img alt="LYHfGG_127_bigtree.png" src="курсы\learn-you-a-haskell-for-great-good!\картинки\lyhfgg_127_bigtree.png"></span></p></div><div><p>But what if the tree we're stepping off from is an empty tree? That is, what if it's not a <code>Node</code>, but an <code>Empty</code>? In this case, we'd get a runtime error because the pattern match would fail and we have made no pattern to handle an empty tree, which doesn't have any sub-trees at all. So far, we just assumed that we'd never try to focus on the left sub-tree of an empty tree as its left sub-tree doesn't exist at all. But going to the left sub-tree of an empty tree doesn't make much sense, and so far we've just conveniently ignored this.</p></div><div><p>Or what if we were already at the root of some tree and didn't have any breadcrumbs but still tried to move up? The same thing would happen. It seems that when using zippers, any step could be our last (cue ominous music). In other words, any move can result in a success, but it can also result in a failure. Does that remind you of something? Of course, monads! More specifically, the <code>Maybe</code> monad which adds a context of possible failure to normal values.</p></div><div><p>So let's use the <code>Maybe</code> monad to add a context of possible failure to our movements. We're going to take the functions that work on our binary tree zipper and we're going to make them into monadic functions. First, let's take care of possible failure in <code>goLeft</code> and <code>goRight</code>. So far, the failure of functions that could fail was always reflected in their result, and this time is no different. So here are <code>goLeft</code> and <code>goRight</code> with an added possibility of failure:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">goLeft</span> <span class="token operator">::</span> <span class="token constant">Zipper</span> <span class="token hvariable">a</span> <span class="token operator">-&gt;</span> <span class="token constant">Maybe</span> <span class="token punctuation">(</span><span class="token constant">Zipper</span> <span class="token hvariable">a</span><span class="token punctuation">)</span>
<span class="token hvariable">goLeft</span> <span class="token punctuation">(</span><span class="token constant">Node</span> <span class="token hvariable">x</span> <span class="token hvariable">l</span> <span class="token hvariable">r</span><span class="token punctuation">,</span> <span class="token hvariable">bs</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token constant">Just</span> <span class="token punctuation">(</span><span class="token hvariable">l</span><span class="token punctuation">,</span> <span class="token constant">LeftCrumb</span> <span class="token hvariable">x</span> <span class="token hvariable">r</span><span class="token operator">:</span><span class="token hvariable">bs</span><span class="token punctuation">)</span>
<span class="token hvariable">goLeft</span> <span class="token punctuation">(</span><span class="token constant">Empty</span><span class="token punctuation">,</span> <span class="token hvariable">_</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token constant">Nothing</span>

<span class="token hvariable">goRight</span> <span class="token operator">::</span> <span class="token constant">Zipper</span> <span class="token hvariable">a</span> <span class="token operator">-&gt;</span> <span class="token constant">Maybe</span> <span class="token punctuation">(</span><span class="token constant">Zipper</span> <span class="token hvariable">a</span><span class="token punctuation">)</span>
<span class="token hvariable">goRight</span> <span class="token punctuation">(</span><span class="token constant">Node</span> <span class="token hvariable">x</span> <span class="token hvariable">l</span> <span class="token hvariable">r</span><span class="token punctuation">,</span> <span class="token hvariable">bs</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token constant">Just</span> <span class="token punctuation">(</span><span class="token hvariable">r</span><span class="token punctuation">,</span> <span class="token constant">RightCrumb</span> <span class="token hvariable">x</span> <span class="token hvariable">l</span><span class="token operator">:</span><span class="token hvariable">bs</span><span class="token punctuation">)</span>
<span class="token hvariable">goRight</span> <span class="token punctuation">(</span><span class="token constant">Empty</span><span class="token punctuation">,</span> <span class="token hvariable">_</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token constant">Nothing</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Cool, now if we try to take a step to the left of an empty tree, we get a <code>Nothing</code>!</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token hvariable">goLeft</span> <span class="token punctuation">(</span><span class="token constant">Empty</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
<span class="token constant">Nothing</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token hvariable">goLeft</span> <span class="token punctuation">(</span><span class="token constant">Node</span> <span class="token char string">'A'</span> <span class="token constant">Empty</span> <span class="token constant">Empty</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
<span class="token constant">Just</span> <span class="token punctuation">(</span><span class="token constant">Empty</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token constant">LeftCrumb</span> <span class="token char string">'A'</span> <span class="token constant">Empty</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Looks good! How about going up? The problem before happened if we tried to go up but we didn't have any more breadcrumbs, which meant that we were already in the root of the tree. This is the <code>goUp</code> function that throws an error if we don't keep within the bounds of our tree:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">goUp</span> <span class="token operator">::</span> <span class="token constant">Zipper</span> <span class="token hvariable">a</span> <span class="token operator">-&gt;</span> <span class="token constant">Zipper</span> <span class="token hvariable">a</span>
<span class="token hvariable">goUp</span> <span class="token punctuation">(</span><span class="token hvariable">t</span><span class="token punctuation">,</span> <span class="token constant">LeftCrumb</span> <span class="token hvariable">x</span> <span class="token hvariable">r</span><span class="token operator">:</span><span class="token hvariable">bs</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token constant">Node</span> <span class="token hvariable">x</span> <span class="token hvariable">t</span> <span class="token hvariable">r</span><span class="token punctuation">,</span> <span class="token hvariable">bs</span><span class="token punctuation">)</span>
<span class="token hvariable">goUp</span> <span class="token punctuation">(</span><span class="token hvariable">t</span><span class="token punctuation">,</span> <span class="token constant">RightCrumb</span> <span class="token hvariable">x</span> <span class="token hvariable">l</span><span class="token operator">:</span><span class="token hvariable">bs</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token constant">Node</span> <span class="token hvariable">x</span> <span class="token hvariable">l</span> <span class="token hvariable">t</span><span class="token punctuation">,</span> <span class="token hvariable">bs</span><span class="token punctuation">)</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Now let's modify it to fail gracefully:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">goUp</span> <span class="token operator">::</span> <span class="token constant">Zipper</span> <span class="token hvariable">a</span> <span class="token operator">-&gt;</span> <span class="token constant">Maybe</span> <span class="token punctuation">(</span><span class="token constant">Zipper</span> <span class="token hvariable">a</span><span class="token punctuation">)</span>
<span class="token hvariable">goUp</span> <span class="token punctuation">(</span><span class="token hvariable">t</span><span class="token punctuation">,</span> <span class="token constant">LeftCrumb</span> <span class="token hvariable">x</span> <span class="token hvariable">r</span><span class="token operator">:</span><span class="token hvariable">bs</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token constant">Just</span> <span class="token punctuation">(</span><span class="token constant">Node</span> <span class="token hvariable">x</span> <span class="token hvariable">t</span> <span class="token hvariable">r</span><span class="token punctuation">,</span> <span class="token hvariable">bs</span><span class="token punctuation">)</span>
<span class="token hvariable">goUp</span> <span class="token punctuation">(</span><span class="token hvariable">t</span><span class="token punctuation">,</span> <span class="token constant">RightCrumb</span> <span class="token hvariable">x</span> <span class="token hvariable">l</span><span class="token operator">:</span><span class="token hvariable">bs</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token constant">Just</span> <span class="token punctuation">(</span><span class="token constant">Node</span> <span class="token hvariable">x</span> <span class="token hvariable">l</span> <span class="token hvariable">t</span><span class="token punctuation">,</span> <span class="token hvariable">bs</span><span class="token punctuation">)</span>
<span class="token hvariable">goUp</span> <span class="token punctuation">(</span><span class="token hvariable">_</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token constant">Nothing</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>If we have breadcrumbs, everything is okay and we return a successful new focus, but if we don't, then we return a failure.</p></div><div><p>Before, these functions took zippers and returned zippers, which meant that we could chain them like this to walk around:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">gchi</span><span class="token operator">&gt;</span> <span class="token keyword">let</span> <span class="token hvariable">newFocus</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token hvariable">freeTree</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-:</span> <span class="token hvariable">goLeft</span> <span class="token operator">-:</span> <span class="token hvariable">goRight</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>But now, instead of returning <code>Zipper a</code>, they return <code>Maybe (Zipper a)</code>, so chaining functions like this won't work. We had a similar problem when we were <a data-tooltip-position="top" aria-label="http://learnyouahaskell.com/a-fistful-of-monads#walk-the-line" rel="noopener" class="external-link" href="http://learnyouahaskell.com/a-fistful-of-monads#walk-the-line" target="_blank">dealing with our tightrope walker</a> in the chapter about monads. He also walked one step at a time and each of his steps could result in failure because a bunch of birds could land on one side of his balancing pole and make him fall.</p></div><div><p>Now, the joke's on us because we're the ones doing the walking, and we're traversing a labyrinth of our own devising. Luckily, we can learn from the tightrope walker and just do what he did, which is to exchange normal function application for using <code>&gt;&gt;=</code>, which takes a value with a context (in our case, the <code>Maybe (Zipper a)</code>, which has a context of possible failure) and feeds it into a function while making sure that the context is taken care of. So just like our tightrope walker, we're going to trade in all our <code>-:</code> operators for <code>&gt;&gt;=</code>. Alright, we can chain our functions again! Watch:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token keyword">let</span> <span class="token hvariable">coolTree</span> <span class="token operator">=</span> <span class="token constant">Node</span> <span class="token number">1</span> <span class="token constant">Empty</span> <span class="token punctuation">(</span><span class="token constant">Node</span> <span class="token number">3</span> <span class="token constant">Empty</span> <span class="token constant">Empty</span><span class="token punctuation">)</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token builtin">return</span> <span class="token punctuation">(</span><span class="token hvariable">coolTree</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">&gt;&gt;=</span> <span class="token hvariable">goRight</span>
<span class="token constant">Just</span> <span class="token punctuation">(</span><span class="token constant">Node</span> <span class="token number">3</span> <span class="token constant">Empty</span> <span class="token constant">Empty</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token constant">RightCrumb</span> <span class="token number">1</span> <span class="token constant">Empty</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token builtin">return</span> <span class="token punctuation">(</span><span class="token hvariable">coolTree</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">&gt;&gt;=</span> <span class="token hvariable">goRight</span> <span class="token operator">&gt;&gt;=</span> <span class="token hvariable">goRight</span>
<span class="token constant">Just</span> <span class="token punctuation">(</span><span class="token constant">Empty</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token constant">RightCrumb</span> <span class="token number">3</span> <span class="token constant">Empty</span><span class="token punctuation">,</span><span class="token constant">RightCrumb</span> <span class="token number">1</span> <span class="token constant">Empty</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token builtin">return</span> <span class="token punctuation">(</span><span class="token hvariable">coolTree</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">&gt;&gt;=</span> <span class="token hvariable">goRight</span> <span class="token operator">&gt;&gt;=</span> <span class="token hvariable">goRight</span> <span class="token operator">&gt;&gt;=</span> <span class="token hvariable">goRight</span>
<span class="token constant">Nothing</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>We used <code>return</code> to put a zipper in a <code>Just</code> and then used <code>&gt;&gt;=</code> to feed that to our <code>goRight</code> function. First, we made a tree that has on its left an empty sub-tree and on its right a node that has two empty sub-trees. When we try to go right once, the result is a success, because the operation makes sense. Going right twice is okay too; we end up with the focus on an empty sub-tree. But going right three times wouldn't make sense, because we can't go to the right of an empty sub-tree, which is why the result is a <code>Nothing</code>.</p></div><div><p>Now we've equipped our trees with a safety-net that will catch us should we fall off. Wow, I nailed this metaphor.</p></div><div><p>Our file system also has a lot of cases where an operation could fail, such as trying to focus on a file or folder that doesn't exist. As an exercise, you can equip our file system with functions that fail gracefully by using the <code>Maybe</code> monad.</p></div><div class="mod-footer"></div></div></div></div><div class="sidebar-right sidebar"><div class="sidebar-content"><span class="sidebar-section-header">Interactive Graph</span><div class="graph-view-placeholder">
		<div class="graph-view-container">
			<div class="graph-icon graph-expand" role="button" aria-label="Expand" data-tooltip-position="top"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon lucide-arrow-up-right"><line x1="7" y1="17" x2="17" y2="7"></line><polyline points="7 7 17 7 17 17"></polyline></svg></div>
			<canvas id="graph-canvas" width="512px" height="512px"></canvas>
		</div>
		</div><div class="tree-container outline-tree" data-depth="0"><div class="tree-header"><span class="sidebar-section-header">Table Of Contents</span><button class="clickable-icon collapse-tree-button"><iconify-icon icon="ph:arrows-in-line-horizontal-bold" width="18px" height="18px" rotate="90deg" color="currentColor"></iconify-icon></button></div><div class="tree-scroll-area"><div class="tree-item mod-tree-heading" data-depth="1"><div class="tree-item-contents"><a class="tree-item-link" href="#Introduction"><span class="tree-item-title">Introduction</span></a></div><div class="tree-item-children"><div class="tree-item mod-tree-heading" data-depth="2"><div class="tree-item-contents"><a class="tree-item-link" href="#About_this_tutorial"><span class="tree-item-title">About this tutorial</span></a></div><div class="tree-item-children"></div></div><div class="tree-item mod-tree-heading" data-depth="2"><div class="tree-item-contents"><a class="tree-item-link" href="#So_what's_Haskell?"><span class="tree-item-title">So what's Haskell?</span></a></div><div class="tree-item-children"></div></div><div class="tree-item mod-tree-heading" data-depth="2"><div class="tree-item-contents"><a class="tree-item-link" href="#What_you_need_to_dive_in"><span class="tree-item-title">What you need to dive in</span></a></div><div class="tree-item-children"></div></div></div></div><div class="tree-item mod-tree-heading" data-depth="1"><div class="tree-item-contents"><a class="tree-item-link" href="#Starting_Out"><span class="tree-item-title">Starting Out</span></a></div><div class="tree-item-children"><div class="tree-item mod-tree-heading" data-depth="2"><div class="tree-item-contents"><a class="tree-item-link" href="#Ready,_set,_go!"><span class="tree-item-title">Ready, set, go!</span></a></div><div class="tree-item-children"></div></div><div class="tree-item mod-tree-heading" data-depth="2"><div class="tree-item-contents"><a class="tree-item-link" href="#Baby's_first_functions"><span class="tree-item-title">Baby's first functions</span></a></div><div class="tree-item-children"></div></div><div class="tree-item mod-tree-heading" data-depth="2"><div class="tree-item-contents"><a class="tree-item-link" href="#An_intro_to_lists"><span class="tree-item-title">An intro to lists</span></a></div><div class="tree-item-children"></div></div><div class="tree-item mod-tree-heading" data-depth="2"><div class="tree-item-contents"><a class="tree-item-link" href="#Texas_ranges"><span class="tree-item-title">Texas ranges</span></a></div><div class="tree-item-children"></div></div><div class="tree-item mod-tree-heading" data-depth="2"><div class="tree-item-contents"><a class="tree-item-link" href="#I'm_a_list_comprehension"><span class="tree-item-title">I'm a list comprehension</span></a></div><div class="tree-item-children"></div></div><div class="tree-item mod-tree-heading" data-depth="2"><div class="tree-item-contents"><a class="tree-item-link" href="#Tuples"><span class="tree-item-title">Tuples</span></a></div><div class="tree-item-children"></div></div></div></div><div class="tree-item mod-tree-heading" data-depth="1"><div class="tree-item-contents"><a class="tree-item-link" href="#Types_and_Typeclasses"><span class="tree-item-title">Types and Typeclasses</span></a></div><div class="tree-item-children"><div class="tree-item mod-tree-heading" data-depth="2"><div class="tree-item-contents"><a class="tree-item-link" href="#Believe_the_type"><span class="tree-item-title">Believe the type</span></a></div><div class="tree-item-children"></div></div><div class="tree-item mod-tree-heading" data-depth="2"><div class="tree-item-contents"><a class="tree-item-link" href="#Type_variables"><span class="tree-item-title">Type variables</span></a></div><div class="tree-item-children"></div></div><div class="tree-item mod-tree-heading" data-depth="2"><div class="tree-item-contents"><a class="tree-item-link" href="#Typeclasses_101"><span class="tree-item-title">Typeclasses 101</span></a></div><div class="tree-item-children"></div></div></div></div><div class="tree-item mod-tree-heading" data-depth="1"><div class="tree-item-contents"><a class="tree-item-link" href="#Syntax_in_Functions"><span class="tree-item-title">Syntax in Functions</span></a></div><div class="tree-item-children"><div class="tree-item mod-tree-heading" data-depth="2"><div class="tree-item-contents"><a class="tree-item-link" href="#Pattern_matching"><span class="tree-item-title">Pattern matching</span></a></div><div class="tree-item-children"></div></div><div class="tree-item mod-tree-heading" data-depth="2"><div class="tree-item-contents"><a class="tree-item-link" href="#Guards,_guards!"><span class="tree-item-title">Guards, guards!</span></a></div><div class="tree-item-children"></div></div><div class="tree-item mod-tree-heading" data-depth="2"><div class="tree-item-contents"><a class="tree-item-link" href="#Where!?"><span class="tree-item-title">Where!?</span></a></div><div class="tree-item-children"></div></div><div class="tree-item mod-tree-heading" data-depth="2"><div class="tree-item-contents"><a class="tree-item-link" href="#Let_it_be"><span class="tree-item-title">Let it be</span></a></div><div class="tree-item-children"></div></div><div class="tree-item mod-tree-heading" data-depth="2"><div class="tree-item-contents"><a class="tree-item-link" href="#Case_expressions"><span class="tree-item-title">Case expressions</span></a></div><div class="tree-item-children"></div></div></div></div><div class="tree-item mod-tree-heading" data-depth="1"><div class="tree-item-contents"><a class="tree-item-link" href="#Recursion"><span class="tree-item-title">Recursion</span></a></div><div class="tree-item-children"><div class="tree-item mod-tree-heading" data-depth="2"><div class="tree-item-contents"><a class="tree-item-link" href="#Hello_recursion!"><span class="tree-item-title">Hello recursion!</span></a></div><div class="tree-item-children"></div></div><div class="tree-item mod-tree-heading" data-depth="2"><div class="tree-item-contents"><a class="tree-item-link" href="#Maximum_awesome"><span class="tree-item-title">Maximum awesome</span></a></div><div class="tree-item-children"></div></div><div class="tree-item mod-tree-heading" data-depth="2"><div class="tree-item-contents"><a class="tree-item-link" href="#A_few_more_recursive_functions"><span class="tree-item-title">A few more recursive functions</span></a></div><div class="tree-item-children"></div></div><div class="tree-item mod-tree-heading" data-depth="2"><div class="tree-item-contents"><a class="tree-item-link" href="#Quick,_sort!"><span class="tree-item-title">Quick, sort!</span></a></div><div class="tree-item-children"></div></div><div class="tree-item mod-tree-heading" data-depth="2"><div class="tree-item-contents"><a class="tree-item-link" href="#Thinking_recursively"><span class="tree-item-title">Thinking recursively</span></a></div><div class="tree-item-children"></div></div></div></div><div class="tree-item mod-tree-heading" data-depth="1"><div class="tree-item-contents"><a class="tree-item-link" href="#Higher_order_functions"><span class="tree-item-title">Higher order functions</span></a></div><div class="tree-item-children"><div class="tree-item mod-tree-heading" data-depth="2"><div class="tree-item-contents"><a class="tree-item-link" href="#Curried_functions"><span class="tree-item-title">Curried functions</span></a></div><div class="tree-item-children"></div></div><div class="tree-item mod-tree-heading" data-depth="2"><div class="tree-item-contents"><a class="tree-item-link" href="#Some_higher-orderism_is_in_order"><span class="tree-item-title">Some higher-orderism is in order</span></a></div><div class="tree-item-children"></div></div><div class="tree-item mod-tree-heading" data-depth="2"><div class="tree-item-contents"><a class="tree-item-link" href="#Maps_and_filters"><span class="tree-item-title">Maps and filters</span></a></div><div class="tree-item-children"></div></div><div class="tree-item mod-tree-heading" data-depth="2"><div class="tree-item-contents"><a class="tree-item-link" href="#Lambdas"><span class="tree-item-title">Lambdas</span></a></div><div class="tree-item-children"></div></div><div class="tree-item mod-tree-heading" data-depth="2"><div class="tree-item-contents"><a class="tree-item-link" href="#Only_folds_and_horses"><span class="tree-item-title">Only folds and horses</span></a></div><div class="tree-item-children"></div></div><div class="tree-item mod-tree-heading" data-depth="2"><div class="tree-item-contents"><a class="tree-item-link" href="#Function_application_with_$"><span class="tree-item-title">Function application with $</span></a></div><div class="tree-item-children"></div></div><div class="tree-item mod-tree-heading" data-depth="2"><div class="tree-item-contents"><a class="tree-item-link" href="#Function_composition"><span class="tree-item-title">Function composition</span></a></div><div class="tree-item-children"></div></div></div></div><div class="tree-item mod-tree-heading" data-depth="1"><div class="tree-item-contents"><a class="tree-item-link" href="#Modules"><span class="tree-item-title">Modules</span></a></div><div class="tree-item-children"><div class="tree-item mod-tree-heading" data-depth="2"><div class="tree-item-contents"><a class="tree-item-link" href="#Loading_modules"><span class="tree-item-title">Loading modules</span></a></div><div class="tree-item-children"></div></div><div class="tree-item mod-tree-heading" data-depth="2"><div class="tree-item-contents"><a class="tree-item-link" href="#Data.List"><span class="tree-item-title">Data.List</span></a></div><div class="tree-item-children"></div></div><div class="tree-item mod-tree-heading" data-depth="2"><div class="tree-item-contents"><a class="tree-item-link" href="#Data.Char"><span class="tree-item-title">Data.Char</span></a></div><div class="tree-item-children"></div></div><div class="tree-item mod-tree-heading" data-depth="2"><div class="tree-item-contents"><a class="tree-item-link" href="#Data.Map"><span class="tree-item-title">Data.Map</span></a></div><div class="tree-item-children"></div></div><div class="tree-item mod-tree-heading" data-depth="2"><div class="tree-item-contents"><a class="tree-item-link" href="#Data.Set"><span class="tree-item-title">Data.Set</span></a></div><div class="tree-item-children"></div></div><div class="tree-item mod-tree-heading" data-depth="2"><div class="tree-item-contents"><a class="tree-item-link" href="#Making_our_own_modules"><span class="tree-item-title">Making our own modules</span></a></div><div class="tree-item-children"></div></div></div></div><div class="tree-item mod-tree-heading" data-depth="1"><div class="tree-item-contents"><a class="tree-item-link" href="#Making_Our_Own_Types_and_Typeclasses"><span class="tree-item-title">Making Our Own Types and Typeclasses</span></a></div><div class="tree-item-children"><div class="tree-item mod-tree-heading" data-depth="2"><div class="tree-item-contents"><a class="tree-item-link" href="#Algebraic_data_types_intro"><span class="tree-item-title">Algebraic data types intro</span></a></div><div class="tree-item-children"></div></div><div class="tree-item mod-tree-heading" data-depth="2"><div class="tree-item-contents"><a class="tree-item-link" href="#Record_syntax"><span class="tree-item-title">Record syntax</span></a></div><div class="tree-item-children"></div></div><div class="tree-item mod-tree-heading" data-depth="2"><div class="tree-item-contents"><a class="tree-item-link" href="#Type_parameters"><span class="tree-item-title">Type parameters</span></a></div><div class="tree-item-children"></div></div><div class="tree-item mod-tree-heading" data-depth="2"><div class="tree-item-contents"><a class="tree-item-link" href="#Derived_instances"><span class="tree-item-title">Derived instances</span></a></div><div class="tree-item-children"></div></div><div class="tree-item mod-tree-heading" data-depth="2"><div class="tree-item-contents"><a class="tree-item-link" href="#Type_synonyms"><span class="tree-item-title">Type synonyms</span></a></div><div class="tree-item-children"></div></div><div class="tree-item mod-tree-heading" data-depth="2"><div class="tree-item-contents"><a class="tree-item-link" href="#Recursive_data_structures"><span class="tree-item-title">Recursive data structures</span></a></div><div class="tree-item-children"></div></div><div class="tree-item mod-tree-heading" data-depth="2"><div class="tree-item-contents"><a class="tree-item-link" href="#Typeclasses_102"><span class="tree-item-title">Typeclasses 102</span></a></div><div class="tree-item-children"></div></div><div class="tree-item mod-tree-heading" data-depth="2"><div class="tree-item-contents"><a class="tree-item-link" href="#A_yes-no_typeclass"><span class="tree-item-title">A yes-no typeclass</span></a></div><div class="tree-item-children"></div></div><div class="tree-item mod-tree-heading" data-depth="2"><div class="tree-item-contents"><a class="tree-item-link" href="#The_Functor_typeclass"><span class="tree-item-title">The Functor typeclass</span></a></div><div class="tree-item-children"></div></div><div class="tree-item mod-tree-heading" data-depth="2"><div class="tree-item-contents"><a class="tree-item-link" href="#Kinds_and_some_type-foo"><span class="tree-item-title">Kinds and some type-foo</span></a></div><div class="tree-item-children"></div></div></div></div><div class="tree-item mod-tree-heading" data-depth="1"><div class="tree-item-contents"><a class="tree-item-link" href="#Input_and_Output"><span class="tree-item-title">Input and Output</span></a></div><div class="tree-item-children"><div class="tree-item mod-tree-heading" data-depth="2"><div class="tree-item-contents"><a class="tree-item-link" href="#Hello,_world!"><span class="tree-item-title">Hello, world!</span></a></div><div class="tree-item-children"></div></div><div class="tree-item mod-tree-heading" data-depth="2"><div class="tree-item-contents"><a class="tree-item-link" href="#Files_and_streams"><span class="tree-item-title">Files and streams</span></a></div><div class="tree-item-children"></div></div><div class="tree-item mod-tree-heading" data-depth="2"><div class="tree-item-contents"><a class="tree-item-link" href="#Command_line_arguments"><span class="tree-item-title">Command line arguments</span></a></div><div class="tree-item-children"></div></div><div class="tree-item mod-tree-heading" data-depth="2"><div class="tree-item-contents"><a class="tree-item-link" href="#Randomness"><span class="tree-item-title">Randomness</span></a></div><div class="tree-item-children"></div></div><div class="tree-item mod-tree-heading" data-depth="2"><div class="tree-item-contents"><a class="tree-item-link" href="#Bytestrings"><span class="tree-item-title">Bytestrings</span></a></div><div class="tree-item-children"></div></div><div class="tree-item mod-tree-heading" data-depth="2"><div class="tree-item-contents"><a class="tree-item-link" href="#Exceptions"><span class="tree-item-title">Exceptions</span></a></div><div class="tree-item-children"></div></div></div></div><div class="tree-item mod-tree-heading" data-depth="1"><div class="tree-item-contents"><a class="tree-item-link" href="#Functionally_Solving_Problems"><span class="tree-item-title">Functionally Solving Problems</span></a></div><div class="tree-item-children"><div class="tree-item mod-tree-heading" data-depth="2"><div class="tree-item-contents"><a class="tree-item-link" href="#Reverse_Polish_notation_calculator"><span class="tree-item-title">Reverse Polish notation calculator</span></a></div><div class="tree-item-children"></div></div><div class="tree-item mod-tree-heading" data-depth="2"><div class="tree-item-contents"><a class="tree-item-link" href="#Heathrow_to_London"><span class="tree-item-title">Heathrow to London</span></a></div><div class="tree-item-children"></div></div></div></div><div class="tree-item mod-tree-heading" data-depth="1"><div class="tree-item-contents"><a class="tree-item-link" href="#Functors,_Applicative_Functors_and_Monoids"><span class="tree-item-title">Functors, Applicative Functors and Monoids</span></a></div><div class="tree-item-children"><div class="tree-item mod-tree-heading" data-depth="2"><div class="tree-item-contents"><a class="tree-item-link" href="#Functors_redux"><span class="tree-item-title">Functors redux</span></a></div><div class="tree-item-children"></div></div><div class="tree-item mod-tree-heading" data-depth="2"><div class="tree-item-contents"><a class="tree-item-link" href="#Applicative_functors"><span class="tree-item-title">Applicative functors</span></a></div><div class="tree-item-children"></div></div><div class="tree-item mod-tree-heading mod-collapsible" data-depth="2"><div class="tree-item-contents"><div class="tree-item-icon collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div><a class="tree-item-link" href="#The_newtype_keyword"><span class="tree-item-title">The newtype keyword</span></a></div><div class="tree-item-children"><div class="tree-item mod-tree-heading" data-depth="3"><div class="tree-item-contents"><a class="tree-item-link" href="#Using_newtype_to_make_type_class_instances"><span class="tree-item-title">Using newtype to make type class instances</span></a></div><div class="tree-item-children"></div></div><div class="tree-item mod-tree-heading" data-depth="3"><div class="tree-item-contents"><a class="tree-item-link" href="#On_newtype_laziness"><span class="tree-item-title">On newtype laziness</span></a></div><div class="tree-item-children"></div></div><div class="tree-item mod-tree-heading" data-depth="3"><div class="tree-item-contents"><a class="tree-item-link" href="#type_vs._newtype_vs._data"><span class="tree-item-title">type vs. newtype vs. data</span></a></div><div class="tree-item-children"></div></div></div></div><div class="tree-item mod-tree-heading mod-collapsible" data-depth="2"><div class="tree-item-contents"><div class="tree-item-icon collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div><a class="tree-item-link" href="#Monoids"><span class="tree-item-title">Monoids</span></a></div><div class="tree-item-children"><div class="tree-item mod-tree-heading" data-depth="3"><div class="tree-item-contents"><a class="tree-item-link" href="#Lists_are_monoids"><span class="tree-item-title">Lists are monoids</span></a></div><div class="tree-item-children"></div></div><div class="tree-item mod-tree-heading" data-depth="3"><div class="tree-item-contents"><a class="tree-item-link" href="#Product_and_Sum"><span class="tree-item-title">Product and Sum</span></a></div><div class="tree-item-children"></div></div><div class="tree-item mod-tree-heading" data-depth="3"><div class="tree-item-contents"><a class="tree-item-link" href="#Any_and_All"><span class="tree-item-title">Any and All</span></a></div><div class="tree-item-children"></div></div><div class="tree-item mod-tree-heading" data-depth="3"><div class="tree-item-contents"><a class="tree-item-link" href="#The_Ordering_monoid"><span class="tree-item-title">The Ordering monoid</span></a></div><div class="tree-item-children"></div></div><div class="tree-item mod-tree-heading" data-depth="3"><div class="tree-item-contents"><a class="tree-item-link" href="#Maybe_the_monoid"><span class="tree-item-title">Maybe the monoid</span></a></div><div class="tree-item-children"></div></div><div class="tree-item mod-tree-heading" data-depth="3"><div class="tree-item-contents"><a class="tree-item-link" href="#Using_monoids_to_fold_data_structures"><span class="tree-item-title">Using monoids to fold data structures</span></a></div><div class="tree-item-children"></div></div></div></div></div></div><div class="tree-item mod-tree-heading" data-depth="1"><div class="tree-item-contents"><a class="tree-item-link" href="#A_Fistful_of_Monads"><span class="tree-item-title">A Fistful of Monads</span></a></div><div class="tree-item-children"><div class="tree-item mod-tree-heading" data-depth="2"><div class="tree-item-contents"><a class="tree-item-link" href="#Getting_our_feet_wet_with_Maybe"><span class="tree-item-title">Getting our feet wet with Maybe</span></a></div><div class="tree-item-children"></div></div><div class="tree-item mod-tree-heading" data-depth="2"><div class="tree-item-contents"><a class="tree-item-link" href="#The_Monad_type_class"><span class="tree-item-title">The Monad type class</span></a></div><div class="tree-item-children"></div></div><div class="tree-item mod-tree-heading" data-depth="2"><div class="tree-item-contents"><a class="tree-item-link" href="#Walk_the_line"><span class="tree-item-title">Walk the line</span></a></div><div class="tree-item-children"></div></div><div class="tree-item mod-tree-heading" data-depth="2"><div class="tree-item-contents"><a class="tree-item-link" href="#do_notation"><span class="tree-item-title">do notation</span></a></div><div class="tree-item-children"></div></div><div class="tree-item mod-tree-heading mod-collapsible" data-depth="2"><div class="tree-item-contents"><div class="tree-item-icon collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div><a class="tree-item-link" href="#The_list_monad"><span class="tree-item-title">The list monad</span></a></div><div class="tree-item-children"><div class="tree-item mod-tree-heading" data-depth="3"><div class="tree-item-contents"><a class="tree-item-link" href="#A_knight's_quest"><span class="tree-item-title">A knight's quest</span></a></div><div class="tree-item-children"></div></div></div></div><div class="tree-item mod-tree-heading mod-collapsible" data-depth="2"><div class="tree-item-contents"><div class="tree-item-icon collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div><a class="tree-item-link" href="#Monad_laws"><span class="tree-item-title">Monad laws</span></a></div><div class="tree-item-children"><div class="tree-item mod-tree-heading" data-depth="3"><div class="tree-item-contents"><a class="tree-item-link" href="#Left_identity"><span class="tree-item-title">Left identity</span></a></div><div class="tree-item-children"></div></div><div class="tree-item mod-tree-heading" data-depth="3"><div class="tree-item-contents"><a class="tree-item-link" href="#Right_identity"><span class="tree-item-title">Right identity</span></a></div><div class="tree-item-children"></div></div><div class="tree-item mod-tree-heading" data-depth="3"><div class="tree-item-contents"><a class="tree-item-link" href="#Associativity"><span class="tree-item-title">Associativity</span></a></div><div class="tree-item-children"></div></div></div></div></div></div><div class="tree-item mod-tree-heading" data-depth="1"><div class="tree-item-contents"><a class="tree-item-link" href="#For_a_Few_Monads_More"><span class="tree-item-title">For a Few Monads More</span></a></div><div class="tree-item-children"><div class="tree-item mod-tree-heading mod-collapsible" data-depth="2"><div class="tree-item-contents"><div class="tree-item-icon collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div><a class="tree-item-link" href="#Writer?_I_hardly_know_her!"><span class="tree-item-title">Writer? I hardly know her!</span></a></div><div class="tree-item-children"><div class="tree-item mod-tree-heading" data-depth="3"><div class="tree-item-contents"><a class="tree-item-link" href="#Monoids_to_the_rescue"><span class="tree-item-title">Monoids to the rescue</span></a></div><div class="tree-item-children"></div></div><div class="tree-item mod-tree-heading" data-depth="3"><div class="tree-item-contents"><a class="tree-item-link" href="#The_Writer_type"><span class="tree-item-title">The Writer type</span></a></div><div class="tree-item-children"></div></div><div class="tree-item mod-tree-heading" data-depth="3"><div class="tree-item-contents"><a class="tree-item-link" href="#Using_do_notation_with_Writer"><span class="tree-item-title">Using do notation with Writer</span></a></div><div class="tree-item-children"></div></div><div class="tree-item mod-tree-heading" data-depth="3"><div class="tree-item-contents"><a class="tree-item-link" href="#Adding_logging_to_programs"><span class="tree-item-title">Adding logging to programs</span></a></div><div class="tree-item-children"></div></div><div class="tree-item mod-tree-heading" data-depth="3"><div class="tree-item-contents"><a class="tree-item-link" href="#Inefficient_list_construction"><span class="tree-item-title">Inefficient list construction</span></a></div><div class="tree-item-children"></div></div><div class="tree-item mod-tree-heading" data-depth="3"><div class="tree-item-contents"><a class="tree-item-link" href="#Difference_lists"><span class="tree-item-title">Difference lists</span></a></div><div class="tree-item-children"></div></div><div class="tree-item mod-tree-heading" data-depth="3"><div class="tree-item-contents"><a class="tree-item-link" href="#Comparing_Performance"><span class="tree-item-title">Comparing Performance</span></a></div><div class="tree-item-children"></div></div></div></div><div class="tree-item mod-tree-heading" data-depth="2"><div class="tree-item-contents"><a class="tree-item-link" href="#Reader?_Ugh,_not_this_joke_again."><span class="tree-item-title">Reader? Ugh, not this joke again.</span></a></div><div class="tree-item-children"></div></div><div class="tree-item mod-tree-heading mod-collapsible" data-depth="2"><div class="tree-item-contents"><div class="tree-item-icon collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div><a class="tree-item-link" href="#Tasteful_stateful_computations"><span class="tree-item-title">Tasteful stateful computations</span></a></div><div class="tree-item-children"><div class="tree-item mod-tree-heading" data-depth="3"><div class="tree-item-contents"><a class="tree-item-link" href="#Stacks_and_stones"><span class="tree-item-title">Stacks and stones</span></a></div><div class="tree-item-children"></div></div><div class="tree-item mod-tree-heading" data-depth="3"><div class="tree-item-contents"><a class="tree-item-link" href="#The_State_monad"><span class="tree-item-title">The State monad</span></a></div><div class="tree-item-children"></div></div><div class="tree-item mod-tree-heading" data-depth="3"><div class="tree-item-contents"><a class="tree-item-link" href="#Randomness_and_the_state_monad"><span class="tree-item-title">Randomness and the state monad</span></a></div><div class="tree-item-children"></div></div></div></div><div class="tree-item mod-tree-heading" data-depth="2"><div class="tree-item-contents"><a class="tree-item-link" href="#Error_error_on_the_wall"><span class="tree-item-title">Error error on the wall</span></a></div><div class="tree-item-children"></div></div><div class="tree-item mod-tree-heading mod-collapsible" data-depth="2"><div class="tree-item-contents"><div class="tree-item-icon collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div><a class="tree-item-link" href="#Some_useful_monadic_functions"><span class="tree-item-title">Some useful monadic functions</span></a></div><div class="tree-item-children"><div class="tree-item mod-tree-heading" data-depth="3"><div class="tree-item-contents"><a class="tree-item-link" href="#liftM_and_friends"><span class="tree-item-title">liftM and friends</span></a></div><div class="tree-item-children"></div></div><div class="tree-item mod-tree-heading" data-depth="3"><div class="tree-item-contents"><a class="tree-item-link" href="#The_join_function"><span class="tree-item-title">The join function</span></a></div><div class="tree-item-children"></div></div><div class="tree-item mod-tree-heading" data-depth="3"><div class="tree-item-contents"><a class="tree-item-link" href="#filterM"><span class="tree-item-title">filterM</span></a></div><div class="tree-item-children"></div></div><div class="tree-item mod-tree-heading" data-depth="3"><div class="tree-item-contents"><a class="tree-item-link" href="#foldM"><span class="tree-item-title">foldM</span></a></div><div class="tree-item-children"></div></div><div class="tree-item mod-tree-heading" data-depth="3"><div class="tree-item-contents"><a class="tree-item-link" href="#Making_a_safe_RPN_calculator"><span class="tree-item-title">Making a safe RPN calculator</span></a></div><div class="tree-item-children"></div></div><div class="tree-item mod-tree-heading" data-depth="3"><div class="tree-item-contents"><a class="tree-item-link" href="#Composing_monadic_functions"><span class="tree-item-title">Composing monadic functions</span></a></div><div class="tree-item-children"></div></div></div></div><div class="tree-item mod-tree-heading" data-depth="2"><div class="tree-item-contents"><a class="tree-item-link" href="#Making_monads"><span class="tree-item-title">Making monads</span></a></div><div class="tree-item-children"></div></div></div></div><div class="tree-item mod-tree-heading" data-depth="1"><div class="tree-item-contents"><a class="tree-item-link" href="#Zippers"><span class="tree-item-title">Zippers</span></a></div><div class="tree-item-children"><div class="tree-item mod-tree-heading" data-depth="2"><div class="tree-item-contents"><a class="tree-item-link" href="#Taking_a_walk"><span class="tree-item-title">Taking a walk</span></a></div><div class="tree-item-children"></div></div><div class="tree-item mod-tree-heading mod-collapsible" data-depth="2"><div class="tree-item-contents"><div class="tree-item-icon collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div><a class="tree-item-link" href="#A_trail_of_breadcrumbs"><span class="tree-item-title">A trail of breadcrumbs</span></a></div><div class="tree-item-children"><div class="tree-item mod-tree-heading" data-depth="3"><div class="tree-item-contents"><a class="tree-item-link" href="#Going_back_up"><span class="tree-item-title">Going back up</span></a></div><div class="tree-item-children"></div></div><div class="tree-item mod-tree-heading" data-depth="3"><div class="tree-item-contents"><a class="tree-item-link" href="#Manipulating_trees_under_focus"><span class="tree-item-title">Manipulating trees under focus</span></a></div><div class="tree-item-children"></div></div><div class="tree-item mod-tree-heading" data-depth="3"><div class="tree-item-contents"><a class="tree-item-link" href="#I'm_going_straight_to_the_top,_oh_yeah,_up_where_the_air_is_fresh_and_clean!"><span class="tree-item-title">I'm going straight to the top, oh yeah, up where the air is fresh and clean!</span></a></div><div class="tree-item-children"></div></div></div></div><div class="tree-item mod-tree-heading" data-depth="2"><div class="tree-item-contents"><a class="tree-item-link" href="#Focusing_on_lists"><span class="tree-item-title">Focusing on lists</span></a></div><div class="tree-item-children"></div></div><div class="tree-item mod-tree-heading mod-collapsible" data-depth="2"><div class="tree-item-contents"><div class="tree-item-icon collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div><a class="tree-item-link" href="#A_very_simple_file_system"><span class="tree-item-title">A very simple file system</span></a></div><div class="tree-item-children"><div class="tree-item mod-tree-heading" data-depth="3"><div class="tree-item-contents"><a class="tree-item-link" href="#A_zipper_for_our_file_system"><span class="tree-item-title">A zipper for our file system</span></a></div><div class="tree-item-children"></div></div><div class="tree-item mod-tree-heading" data-depth="3"><div class="tree-item-contents"><a class="tree-item-link" href="#Manipulating_our_file_system"><span class="tree-item-title">Manipulating our file system</span></a></div><div class="tree-item-children"></div></div></div></div><div class="tree-item mod-tree-heading" data-depth="2"><div class="tree-item-contents"><a class="tree-item-link" href="#Watch_your_step"><span class="tree-item-title">Watch your step</span></a></div><div class="tree-item-children"></div></div></div></div></div></div></div></div></div></body></html>