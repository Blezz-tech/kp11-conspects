<!DOCTYPE html>
<html><head>
			
		<title>О Haskell по-человечески (Оригинал)</title>
		<base href="../../">
		<meta id="root-path" root-path="../../">

		<link rel="icon" sizes="96x96" href="https://publish-01.obsidian.md/access/f786db9fac45774fa4f0d8112e232d67/favicon-96x96.png">
		<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes, minimum-scale=1.0, maximum-scale=5.0">
		<meta charset="UTF-8">
		<script src="https://code.iconify.design/iconify-icon/1.0.3/iconify-icon.min.js"></script>

			<link rel="stylesheet" href="lib/styles/obsidian-styles.css">
			<link rel="stylesheet" href="lib/styles/theme.css">
			<link rel="stylesheet" href="lib/styles/plugin-styles.css">
			<link rel="stylesheet" href="lib/styles/snippets.css">
			<style>  </style>

			
			<!-- Graph View Data -->
			<script>
			let nodes=
{"nodeCount":11,"linkCount":10,"radii":[6,5.353316326530613,4.7602040816326525,3.975765306122449,3.975765306122449,3.975765306122449,3.975765306122449,3.975765306122449,3.975765306122449,3.975765306122449,3.975765306122449],"labels":["Отчеты","README","README","Полезные ресурсы","О Haskell по-человечески (Итого)","О Haskell по-человечески (Оригинал)","Learn You a Haskell for Great Good! ru","Learn You a Haskell for Great Good! en","py Конвертация txt в xlsx","py код оптимизации mdx","nodejs - зло"],"paths":["отчеты.html","курсы/learn-you-a-haskell-for-great-good!/readme.html","readme.html","полезные-ресурсы.html","мои-решения/о-haskell-по-человечески/о-haskell-по-человечески-(итого).html","курсы/о-haskell-по-человечески/о-haskell-по-человечески-(оригинал).html","курсы/learn-you-a-haskell-for-great-good!/learn-you-a-haskell-for-great-good!-ru.html","курсы/learn-you-a-haskell-for-great-good!/learn-you-a-haskell-for-great-good!-en.html","для-отчета/py-конвертация-txt-в-xlsx.html","для-отчета/py-код-оптимизации-mdx.html","для-отчета/nodejs-зло.html"],"linkSources":[2,2,1,1,0,0,0,0,0,0],"linkTargets":[3,0,7,6,5,4,1,10,9,8]};
			let attractionForce = 1;
			let linkLength = 10;
			let repulsionForce = 150;
			let centralForce = 3;
			let edgePruning = 100;
			</script>
			
<script type="module" src="lib/scripts/graph_view.js"></script>

<script src="lib/scripts/graph_wasm.js"></script>

<script src="lib/scripts/tinycolor.js"></script>

<script src="https://cdnjs.cloudflare.com/ajax/libs/pixi.js/7.2.4/pixi.min.js" integrity="sha512-Ch/O6kL8BqUwAfCF7Ie5SX1Hin+BJgYH4pNjRqXdTEqMsis1TUYg+j6nnI9uduPjGaj7DN4UKCZgpvoExt6dkw==" crossorigin="anonymous" referrerpolicy="no-referrer"></script>

<script src="lib/scripts/webpage.js"></script>

			</head><body class="theme-dark mod-windows is-frameless is-maximized is-hidden-frameless obsidian-app show-inline-title show-view-header" style="--zoom-factor:1; --font-text-size:16px; --line-width:100%; --line-width-adaptive:100%; --file-line-width:100%; --content-width:500em; --sidebar-width:25em; --collapse-arrow-size:0.4em; --tree-horizontal-spacing:1em; --tree-vertical-spacing:0.5em; --sidebar-margin:12px;"><div class="webpage-container"><div class="sidebar-left sidebar"><div class="sidebar-content"><div><label class="theme-toggle-container" for="theme_toggle"><input class="theme-toggle-input" type="checkbox" id="theme_toggle"><div class="toggle-background"></div></label></div><div class="tree-container file-tree mod-nav-indicator" data-depth="0"><div class="tree-header"><span class="sidebar-section-header">learn-haskell-valut</span><button class="clickable-icon collapse-tree-button is-collapsed"><iconify-icon icon="ph:arrows-in-line-horizontal-bold" width="18px" height="18px" rotate="90deg" color="currentColor"></iconify-icon></button></div><div class="tree-scroll-area"><div class="tree-item mod-tree-folder mod-collapsible is-collapsed" data-depth="1"><div class="tree-item-contents"><div class="tree-item-icon collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div><a class="tree-item-link" href="для-отчета"><span class="tree-item-title">Для отчета</span></a></div><div class="tree-item-children"><div class="tree-item mod-tree-file" data-depth="2"><div class="tree-item-contents"><a class="tree-item-link" href="для-отчета/nodejs-зло.html"><span class="tree-item-title">nodejs - зло</span></a></div><div class="tree-item-children"></div></div><div class="tree-item mod-tree-file" data-depth="2"><div class="tree-item-contents"><a class="tree-item-link" href="для-отчета/py-код-оптимизации-mdx.html"><span class="tree-item-title">py код оптимизации mdx</span></a></div><div class="tree-item-children"></div></div><div class="tree-item mod-tree-file" data-depth="2"><div class="tree-item-contents"><a class="tree-item-link" href="для-отчета/py-конвертация-txt-в-xlsx.html"><span class="tree-item-title">py Конвертация txt в xlsx</span></a></div><div class="tree-item-children"></div></div></div></div><div class="tree-item mod-tree-folder mod-collapsible is-collapsed" data-depth="1"><div class="tree-item-contents"><div class="tree-item-icon collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div><a class="tree-item-link" href="курсы"><span class="tree-item-title">Курсы</span></a></div><div class="tree-item-children"><div class="tree-item mod-tree-folder mod-collapsible is-collapsed" data-depth="2"><div class="tree-item-contents"><div class="tree-item-icon collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div><a class="tree-item-link" href="курсы/о-haskell-по-человечески"><span class="tree-item-title">О Haskell по-человечески</span></a></div><div class="tree-item-children"><div class="tree-item mod-tree-file" data-depth="3"><div class="tree-item-contents"><a class="tree-item-link" href="курсы/о-haskell-по-человечески/о-haskell-по-человечески-(оригинал).html"><span class="tree-item-title">О Haskell по-человечески (Оригинал)</span></a></div><div class="tree-item-children"></div></div></div></div><div class="tree-item mod-tree-folder mod-collapsible is-collapsed" data-depth="2"><div class="tree-item-contents"><div class="tree-item-icon collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div><a class="tree-item-link" href="курсы/learn-you-a-haskell-for-great-good!"><span class="tree-item-title">Learn You a Haskell for Great Good!</span></a></div><div class="tree-item-children"><div class="tree-item mod-tree-file" data-depth="3"><div class="tree-item-contents"><a class="tree-item-link" href="курсы/learn-you-a-haskell-for-great-good!/learn-you-a-haskell-for-great-good!-en.html"><span class="tree-item-title">Learn You a Haskell for Great Good! en</span></a></div><div class="tree-item-children"></div></div><div class="tree-item mod-tree-file" data-depth="3"><div class="tree-item-contents"><a class="tree-item-link" href="курсы/learn-you-a-haskell-for-great-good!/learn-you-a-haskell-for-great-good!-ru.html"><span class="tree-item-title">Learn You a Haskell for Great Good! ru</span></a></div><div class="tree-item-children"></div></div><div class="tree-item mod-tree-file" data-depth="3"><div class="tree-item-contents"><a class="tree-item-link" href="курсы/learn-you-a-haskell-for-great-good!/readme.html"><span class="tree-item-title">README</span></a></div><div class="tree-item-children"></div></div></div></div></div></div><div class="tree-item mod-tree-folder mod-collapsible is-collapsed" data-depth="1"><div class="tree-item-contents"><div class="tree-item-icon collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div><a class="tree-item-link" href="мои-решения"><span class="tree-item-title">Мои решения</span></a></div><div class="tree-item-children"><div class="tree-item mod-tree-folder mod-collapsible is-collapsed" data-depth="2"><div class="tree-item-contents"><div class="tree-item-icon collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div><a class="tree-item-link" href="мои-решения/о-haskell-по-человечески"><span class="tree-item-title">О Haskell по-человечески</span></a></div><div class="tree-item-children"><div class="tree-item mod-tree-file" data-depth="3"><div class="tree-item-contents"><a class="tree-item-link" href="мои-решения/о-haskell-по-человечески/о-haskell-по-человечески-(итого).html"><span class="tree-item-title">О Haskell по-человечески (Итого)</span></a></div><div class="tree-item-children"></div></div></div></div></div></div><div class="tree-item mod-tree-file" data-depth="1"><div class="tree-item-contents"><a class="tree-item-link" href="отчеты.html"><span class="tree-item-title">Отчеты</span></a></div><div class="tree-item-children"></div></div><div class="tree-item mod-tree-file" data-depth="1"><div class="tree-item-contents"><a class="tree-item-link" href="полезные-ресурсы.html"><span class="tree-item-title">Полезные ресурсы</span></a></div><div class="tree-item-children"></div></div><div class="tree-item mod-tree-file" data-depth="1"><div class="tree-item-contents"><a class="tree-item-link" href="readme.html"><span class="tree-item-title">README</span></a></div><div class="tree-item-children"></div></div></div></div></div></div><div class="document-container"><div class="markdown-preview-view markdown-rendered node-insert-event allow-fold-headings show-indentation-guide allow-fold-lists show-frontmatter" style="tab-size: 4;"><style id="MJX-CHTML-styles"></style><div class="markdown-preview-sizer markdown-preview-section" style="padding-bottom: ; padding-top: var(--file-margins); padding-right: var(--file-margins); padding-left: var(--file-margins); width: 100%; position: absolute;"><div class="markdown-preview-pusher" style="width: 1px; height: 0.1px; margin-bottom: 0px;"></div><div class="mod-header"><div class="inline-title" contenteditable="true" spellcheck="true" autocapitalize="on" tabindex="-1" enterkeyhint="done">О Haskell по-человечески (Оригинал)</div></div><div><p><a data-tooltip-position="top" aria-label="https://www.ohaskell.guide/" rel="noopener" class="external-link" href="https://www.ohaskell.guide/" target="_blank">Ссылка на оригинальную книгу</a></p></div><div><h1 data-heading="Приветствую!" id="Приветствую!">Приветствую!</h1></div><div><p>Перед вами — книга о Haskell, удивительном и прекрасном языке программирования.</p></div><div><h2 data-heading="Почему эта книга появилась" id="Почему_эта_книга_появилась" style="display: flex;"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>Почему эта книга появилась</h2></div><div><p>Потому что меня откровенно достало. Почти все известные мне книги о Haskell начинаются с примера реализации быстрой сортировки и — куда ж без неё! — последовательности Фибоначчи. Эта книга не такая: минимум академизма, максимум практичности.</p></div><div><h2 data-heading="Цель" id="Цель" style="display: flex;"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>Цель</h2></div><div><p>Функциональное программирование — своеобразное гетто посреди мегаполиса нашей индустрии. Доля функциональных языков пока ещё очень мала, и многие разработчики побаиваются знакомства с этими языками, и с Haskell в особенности. Моя цель — разрушить этот страх. Вероятно, вы слышали, что Haskell — это что-то архисложное, сугубо научное и непригодное для реальной жизни? Читайте дальше, и вскоре вы убедитесь в обратном.</p></div><div><h2 data-heading="О себе" id="О_себе" style="display: flex;"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>О себе</h2></div><div><p>Обыкновенный программист-самоучка. Разрабатываю с 2006 года. В 2012 году впервые услышал про Haskell, ужаснулся и поспешил о нём забыть. В 2013 вспомнил опять, в 2014 увлёкся всерьёз, а в 2015, после 8 лет жизни с C++, окончательно перешёл в Haskell-мир. Также я положил начало&nbsp;<a data-tooltip-position="top" aria-label="http://ruhaskell.org/" rel="noopener" class="external-link" href="http://ruhaskell.org/" target="_blank">русскоязычному сообществу Haskell-разработчиков</a>. И да, я действительно использую этот язык в своей каждодневной работе.</p></div><div><h2 data-heading="О вас" id="О_вас" style="display: flex;"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>О вас</h2></div><div><p>Знаете, что такое компилятор? Не боитесь командной строки? Слышали слово «функция»? Если да — смело продолжайте читать, никаких дополнительных навыков от вас не ожидается. И какой-либо математической подготовки — тоже.</p></div><div><h2 data-heading="Обещание" id="Обещание" style="display: flex;"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>Обещание</h2></div><div><p>Возможно, вы по уши влюбитесь в Haskell. Возможно, он вызовет у вас отвращение. Обещаю одно — скучно не будет. Начнём.</p></div><div><h1 data-heading="Первые вопросы" id="Первые_вопросы">Первые вопросы</h1></div><div><p>Мне задавали их множество раз. Отвечаю.</p></div><div><h2 data-heading="«Что такое этот ваш Haskell?»" id="«Что_такое_этот_ваш_Haskell?»" style="display: flex;"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>«Что такое этот ваш Haskell?»</h2></div><div><p>Haskell — чисто функциональный язык программирования общего назначения, может быть использован для решения самого широкого круга задач. Компилируемый, но может вести себя и как скриптовый. Кроссплатформенный. Ленивый, со строгой статической типизацией. И он не похож на другие языки. Совсем.</p></div><div><h2 data-heading="«Это что, какой-то новый язык?»" id="«Это_что,_какой-то_новый_язык?»" style="display: flex;"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>«Это что, какой-то новый язык?»</h2></div><div><p>Вовсе нет. История Haskell началась ещё в 1987 году. Этот язык был рождён в математических кругах, когда группа людей решила создать лучший функциональный язык программирования. В 1990 году вышла первая версия языка, названного в честь известного американского математика&nbsp;<a data-tooltip-position="top" aria-label="https://en.wikipedia.org/wiki/Haskell_Curry" rel="noopener" class="external-link" href="https://en.wikipedia.org/wiki/Haskell_Curry" target="_blank">Хаскелла Карри</a>. В 1998 году язык был стандартизован, а начиная с 2000-х началось его медленное вхождение в мир практического программирования. За эти годы язык совершенствовался, и вот в 2010 мир увидел его обновлённый стандарт. Так что мы имеем дело с языком, который старше Java.</p></div><div><h2 data-heading="«И кто его сделал?»" id="«И_кто_его_сделал?»" style="display: flex;"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>«И кто его сделал?»</h2></div><div><p>Haskell создавался многими людьми. Наиболее известная реализация языка нашла своё воплощение в компиляторе GHC (The Glasgow Haskell Compiler), родившегося в 1989 году в Университете Глазго. У компилятора было несколько главных разработчиков, из которых наиболее известны двое,&nbsp;<a data-tooltip-position="top" aria-label="http://research.microsoft.com/en-us/people/simonpj/" rel="noopener" class="external-link" href="http://research.microsoft.com/en-us/people/simonpj/" target="_blank">Simon Peyton Jones</a>&nbsp;и&nbsp;<a data-tooltip-position="top" aria-label="http://community.haskell.org/~simonmar/" rel="noopener" class="external-link" href="http://community.haskell.org/~simonmar/" target="_blank">Simon Marlow</a>. Впоследствии весомый вклад в разработку GHC внесли ещё несколько сотен человек. Исходный код компилятора GHC&nbsp;<a data-tooltip-position="top" aria-label="https://ghc.haskell.org/trac/ghc" rel="noopener" class="external-link" href="https://ghc.haskell.org/trac/ghc" target="_blank">открыт</a>. Кстати, сам компилятор на 82% написан на Haskell.</p></div><div><p>Для любопытных: исчерпывающее повествование об истории Haskell и GHC читайте&nbsp;<a data-tooltip-position="top" aria-label="http://haskell.cs.yale.edu/wp-content/uploads/2011/02/history.pdf" rel="noopener" class="external-link" href="http://haskell.cs.yale.edu/wp-content/uploads/2011/02/history.pdf" target="_blank">здесь</a>.</p></div><div><h2 data-heading="«А библиотеки для Haskell имеются?»" id="«А_библиотеки_для_Haskell_имеются?»" style="display: flex;"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>«А библиотеки для Haskell имеются?»</h2></div><div><p>О да! Их даже не сотни — их тысячи. В процессе чтения вы познакомитесь со многими из них.</p></div><div><h2 data-heading="«И что, его уже можно в production?»" id="«И_что,_его_уже_можно_в_production?»" style="display: flex;"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>«И что, его уже можно в production?»</h2></div><div><p>Он уже в production. С момента выхода первого стандарта язык улучшался, развивалась его экосистема, появлялись новые библиотеки, выходили в свет книги. Haskell полностью готов к серьёзному коммерческому использованию, о чём свидетельствуют истории успешного внедрения Haskell в бизнесе, в том числе&nbsp;<a data-tooltip-position="top" aria-label="https://dshevchenko.biz/hs-research/Haskell-in-the-Large.pdf" rel="noopener" class="external-link" href="https://dshevchenko.biz/hs-research/Haskell-in-the-Large.pdf" target="_blank">крупном</a>.</p></div><div><h2 data-heading="«А порог вхождения в Haskell высокий?»" id="«А_порог_вхождения_в_Haskell_высокий?»" style="display: flex;"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>«А порог вхождения в Haskell высокий?»</h2></div><div><p>И да и нет. Освоение Haskell сложно в первую очередь из-за его непохожести на остальные языки, поэтому людям, имеющим опыт работы с другими языками, мозги поломать придётся. Именно поломать, а не просто пошевелить ими: Haskell заставляет иначе взглянуть даже на привычные вещи. С другой стороны, Haskell проще многих известных языков. Не верьте мне на слово, вскоре вы и сами в этом убедитесь. И знайте: многие люди, узнав вкус Haskell, категорически не желают возвращаться к другим языкам. Я вас предупредил.</p></div><div><h2 data-heading="«А я слышал ещё про какие-то монады…»" id="«А_я_слышал_ещё_про_какие-то_монады…»" style="display: flex;"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>«А я слышал ещё про какие-то монады…»</h2></div><div><p>Да, есть такое дело. Некоторые вещи из мира Haskell не имеют прямых аналогов в других языках программирования, и это вводит новичков в ступор. Но не беспокойтесь: я сам прошёл через этот ступор и хорошо вас понимаю. Помните: новое лишь кажется страшным.</p></div><div><h2 data-heading="«А если сравнить его с C++/Python/Scala…»" id="«А_если_сравнить_его_с_C++/Python/Scala…»" style="display: flex;"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>«А если сравнить его с C++/Python/Scala…»</h2></div><div><p>Сравнение Haskell с другими языками выходит за рамки этой книги. Несколько раз вы встретите здесь кусочки кода на других языках, но я привожу их исключительно для того, чтобы подчеркнуть различие с Haskell, а вовсе не для сравнения в контексте «лучше/хуже». И вообще, я буду изо всех сил стараться не восхвалять Haskell без меры, я хочу лишь рассказать вам правду о нём. Мой вывод об этом языке я уже сделал, а свой вывод о нём вы должны сделать сами.</p></div><div><h1 data-heading="Об этой книге" id="Об_этой_книге">Об этой книге</h1></div><div><p>В последние годы заметно возросло число книг, посвящённых Haskell, и это радует. Каждая из них преследует свою цель, поэтому трудно сказать, какая из них лучше. Цель этой книги двоякая.</p></div><div><p>Во-первых, я научу вас главному в Haskell. Основам, без освоения которых двигаться дальше никак не получится.</p></div><div><p>Во-вторых, я разрушу страх. Уже много лет вокруг Haskell витает дух страха, и я сполна ощутил его на себе. В действительности Haskell совсем не страшный, в нём нет чёрной магии, и чтобы программировать на нём, вам не нужна учёная степень. Более того, вы удивитесь, насколько просто в Haskell делать многие вещи, но эта простота откроется вам лишь после того, как вы близко познакомитесь с Тремя Китами Haskell, а также с госпожой Черепахой, поддерживающей оных. Имена этих Китов и Черепахи вы узнаете уже в следующей главе.</p></div><div><p>Эта книга не возведёт вас на вершины Haskell, но она откроет вам путь к этим вершинам.</p></div><div><h2 data-heading="Чего здесь нет" id="Чего_здесь_нет" style="display: flex;"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>Чего здесь нет</h2></div><div><p>Трёх вещей вы не найдёте на страницах этой книги:</p></div><div><ol>
<li data-line="0">Исчерпывающего справочника по Haskell. Дублировать&nbsp;<a data-tooltip-position="top" aria-label="https://www.haskell.org/onlinereport/haskell2010/" rel="noopener" class="external-link" href="https://www.haskell.org/onlinereport/haskell2010/" target="_blank">официальное описание стандарта Haskell 2010</a>&nbsp;я не стану.</li>
<li data-line="1">Набора готовых рецептов. За рецептами пожалуйте на&nbsp;<a data-tooltip-position="top" aria-label="http://stackoverflow.com/questions/tagged/haskell" rel="noopener" class="external-link" href="http://stackoverflow.com/questions/tagged/haskell" target="_blank">Stack Overflow</a>.</li>
<li data-line="2">Введения в математическую теорию. Несмотря на то, что Haskell корнями своими уходит в математику, в этой книге нет погружения в теорию категорий и в иные теории. Извините, если разочаровал.</li>
</ol></div><div><h2 data-heading="О первом и втором издании" id="О_первом_и_втором_издании" style="display: flex;"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>О первом и втором издании</h2></div><div><p>На обложке вы видели метку «издание 2.0». Перед вами второе издание, полностью переработанное и переосмысленное. Вот две причины, побудившие меня переписать книгу.</p></div><div><p>Первая — мои ошибки. Я убеждён, что обучать языку программирования могут лишь те, кто использует этот язык в своей каждодневной работе. На момент написания первой версии я ещё не работал с Haskell, а потому многого не знал и не понимал. В результате часть информации из первого издания была откровенно бедна, а несколько глав вообще вводили читателя в заблуждение.</p></div><div><p>Вторая причина — изменившаяся цель книги. Я намеренно сузил круг рассматриваемых здесь тем. Теперь книга всецело посвящена основам языка, поэтому не ищите здесь рассмотрения специфических тем. Я не очень-то верю в идею book-all-in-one, книга для новичков должна быть книгой для новичков. Вы не встретите здесь ни примеров реализации 3D-движка, ни рассказа о работе с PostgreSQL, ни повествования о проектировании игры для Android. Всё это можно делать с Haskell, но подобным темам посвящены другие публикации, которые несомненно будут вам по плечу после прочтения моей книги.</p></div><div><h2 data-heading="Читайте последовательно" id="Читайте_последовательно" style="display: flex;"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>Читайте последовательно</h2></div><div><p>И это важно. В процессе чтения вы заметите, что я периодически поднимаю вопросы и как бы оставляю их без ответа. Это делается вполне осознанно: ответы обязательно будут даны, но в последующих главах, там, где это будет наиболее уместно. Поэтому перепрыгивание с главы на главу может вас запутать.</p></div><div><p>Впрочем, в веб-версии книги есть «Предметный указатель», который поможет вам быстро найти нужное место, что особенно полезно при повторном прочтении книги.</p></div><div><h2 data-heading="Для любопытных" id="Для_любопытных" style="display: flex;"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>Для любопытных</h2></div><div><p>В конце большинства глав вы найдёте небольшой раздел, который так и называется — «Для любопытных». Читать его необязательно, но любознательным непременно понравится. В этом разделе я привожу некоторые технические подробности, исторические сведения и просто интересные факты.</p></div><div><p>И учтите, пожалуйста: содержимое раздела «Для любопытных» иногда чуток ломает последовательность изложения материала, это сделано осознанно. Помня о многих вопросах читателей к главам из предыдущего издания, я вынес ответы на некоторые из этих вопросов в данный раздел, и поэтому оный, скажем, в 12 главе может ссылаться на материал, изложенный лишь в 16 главе. Если сомневаетесь — не читайте.</p></div><div><h2 data-heading="О пояснениях" id="О_пояснениях" style="display: flex;"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>О пояснениях</h2></div><div><p>Во многих примерах исходного кода вы увидите пояснения вот такого вида:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token keyword">type</span>  <span class="token constant">String</span>  <span class="token operator">=</span>      <span class="token punctuation">[</span><span class="token constant">Char</span><span class="token punctuation">]</span>

тип   этот    равен  тому
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Такие пояснение следует читать слева направо и сверху вниз, и вы сразу поймёте что к чему. Каждая часть пояснения расположена строго под тем кусочком кода, к которому она относится.</p></div><div><p>Вот ещё один пример:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token keyword">let</span> <span class="token punctuation">(</span><span class="token hvariable">host</span><span class="token punctuation">,</span> <span class="token hvariable">alias</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token string">"173.194.71.106"</span><span class="token punctuation">,</span> <span class="token string">"www.google.com"</span><span class="token punctuation">)</span>

                     данное значение
     это
     хост
                                       а вот это
                                       значение
           это
           имя
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Здесь я говорю вам: «Данное значение — это хост, а вот это значение — это имя». В ряде случаев я использую также различного вида подчёркивание:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token punctuation">(</span><span class="token hvariable">host</span><span class="token punctuation">,</span> <span class="token hvariable">alias</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token string">"173.194.71.106"</span><span class="token punctuation">,</span> <span class="token string">"www.google.com"</span><span class="token punctuation">)</span>

 <span class="token hvariable">____</span>            <span class="token hvariable">________________</span>

       <span class="token operator">=====</span>                       <span class="token operator">================</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Здесь я провожу параллель: «Значение&nbsp;<code>host</code>&nbsp;ассоциировано со строкой&nbsp;<code>173.194.71.106</code>, а значение&nbsp;<code>alias</code>&nbsp;— со строкой&nbsp;<code>www.google.com</code>».</p></div><div><h2 data-heading="Благодарность" id="Благодарность" style="display: flex;"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>Благодарность</h2></div><div><p>Эта книга — плод не только моих усилий. Многие члены нашего сообщества помогли мне советами, замечаниями и исправлениями. Большое спасибо вам, друзья!</p></div><div><p>А ещё я благодарю всех тех, кто создал Haskell, и всех тех, кто неустанно совершенствует его. Вашими усилиями наша профессия становится ещё более прекрасной!</p></div><div><h2 data-heading="Слово к читавшим первое издание" id="Слово_к_читавшим_первое_издание" style="display: flex;"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>Слово к читавшим первое издание</h2></div><div><p>Если вы не читали его — можете переходить к следующей главе.</p></div><div><p>Как уже было сказано, цель книги поменялась. Я убеждён, что новичку следует дать фундамент, освоив который, он сможет уже самостоятельно изучать то, что нужно именно ему. Я больше не хочу давать читателям рыбу, я хочу дать им удочку. Поэтому здесь нет повествований обо всех имеющихся монадных трансформерах, или обо всех контейнерах, или о Кметтовских линзах, или о трубах Гонсалеса.</p></div><div><p>Я сделаю упор на теорию, но уже глубже. Так, в прошлом издании я часто использовал неточную терминологию, откровенно ступил с определением монады, прогнал какую-то пургу с ФВП, ни словом не обмолвился о функторных и иных законах, почти не рассказал о паттерн-матчинге и использовал мало примеров реального кода. В этом издании я постараюсь исправить все эти ошибки.</p></div><div><p>И я по-прежнему открыт для вашей критики.</p></div><div><h1 data-heading="Приготовимся" id="Приготовимся">Приготовимся</h1></div><div><p>Мы не можем начать изучение языка без испытательного полигона. Установим Haskell.</p></div><div><p>Сделать это можно несколькими способами, мы выберем самый удобный. Называется он&nbsp;<a data-tooltip-position="top" aria-label="http://haskellstack.org/" rel="noopener" class="external-link" href="http://haskellstack.org/" target="_blank">The Haskell Tool Stack</a>. Эта маленькая утилита — всё, что вам понадобится для работы с Haskell.</p></div><div><p>Haskell — кроссплатформенный язык, работающий и в Linux, и в macOS OS X, и даже в Windows. Однако в 2008 году я навсегда покинул мир Windows, поэтому все последующие примеры взаимодействия с командной строкой подразумевают Unix-way. Впрочем, если вы всё-таки используете Windows, будьте уверены — всё описанное ниже заработает и у вас.</p></div><div><p>Вся конфигурация и примеры кода опробованы мною на Ubuntu 16.04.1.</p></div><div><h2 data-heading="Устанавливаем" id="Устанавливаем" style="display: flex;"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>Устанавливаем</h2></div><div><p>Идём&nbsp;<a data-tooltip-position="top" aria-label="https://docs.haskellstack.org/en/stable/install_and_upgrade/" rel="noopener" class="external-link" href="https://docs.haskellstack.org/en/stable/install_and_upgrade/" target="_blank">сюда</a>&nbsp;и забираем нужную нам версию. Общий Unix-вариант установки предельно прост:</p></div><div><pre class="language-bash" tabindex="0"><code class="language-bash is-loaded">$ <span class="token function">curl</span> -sSL https://get.haskellstack.org/ <span class="token operator">|</span> <span class="token function">sh</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Готово. После установки нам будет доступна команда&nbsp;<code>stack</code>, и она — наше всё.</p></div><div><p>На момент написания книги я использовал&nbsp;<code>stack</code>&nbsp;версии 1.4.0. Если у вас более старая версия — непременно обновитесь. Если же более новая — у вас что-нибудь может работать не совсем так, как описано ниже, поскольку&nbsp;<code>stack</code>&nbsp;всё ещё активно развивается.</p></div><div><p>Главное (но не единственное), что умеет делать&nbsp;<code>stack</code>, это:</p></div><div><ol>
<li data-line="0">Разворачивать инфраструктуру.</li>
<li data-line="1">Собирать проекты.</li>
<li data-line="2">Устанавливать библиотеки.</li>
</ol></div><div><p>Haskell-инфраструктура — экосистема, краеугольным камнем которой является ранее упомянутый компилятор GHC. Haskell является компилируемым языком: приложение представляет собой обыкновенный исполняемый (англ. executable) файл.</p></div><div><p>Haskell-проект — среда для создания приложений и библиотек.</p></div><div><p>Haskell-библиотеки — кем-то написанные решения, спасающие нас от изобретения велосипедов.</p></div><div><h2 data-heading="Разворачиваем инфраструктуру" id="Разворачиваем_инфраструктуру" style="display: flex;"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>Разворачиваем инфраструктуру</h2></div><div><p>Делаем:</p></div><div><pre class="language-bash" tabindex="0"><code class="language-bash is-loaded">$ stack setup
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>В результате на ваш компьютер будет установлена инфраструктура последней стабильной версии. Жить всё это хозяйство будет в только что созданном каталоге&nbsp;<code>~/.stack/</code>. Именно поэтому устанавливать инфраструктуру для последующих Haskell-проектов вам уже не придётся: единожды развернули, используем всегда. Пока вам не нужно знать об устройстве этой инфраструктуры, воспринимайте её как данность: теперь на вашем компьютере живёт Haskell.</p></div><div><h2 data-heading="Hi World" id="Hi_World" style="display: flex;"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>Hi World</h2></div><div><p>Создадим наш первый Haskell-проект:</p></div><div><pre class="language-bash" tabindex="0"><code class="language-bash is-loaded">$ stack new real
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Здесь&nbsp;<code>real</code>&nbsp;— название проекта. В результате будет создан каталог&nbsp;<code>real</code>, внутри которого мы увидим это:</p></div><div><pre class="language-bash" tabindex="0"><code class="language-bash is-loaded"><span class="token builtin class-name">.</span>
├── app
│   └── Main.hs <span class="token operator">&lt;</span>- Главный модуль программы
├── LICENSE
├── README.md
├── real.cabal  <span class="token operator">&lt;</span>- Сборочный конфиг проекта
├── Setup.hs
├── src
│   └── Lib.hs  <span class="token operator">&lt;</span>- Ещё один модуль
├── stack.yaml  <span class="token operator">&lt;</span>- Конфиг Stack
└── <span class="token builtin class-name">test</span>
    └── Spec.hs <span class="token operator">&lt;</span>- Тесты, они нам пока не нужны
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Теперь переходим в каталог&nbsp;<code>real</code>&nbsp;и собираем проект командой:</p></div><div><pre class="language-bash" tabindex="0"><code class="language-bash is-loaded">$ stack build
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Запомните эту команду, мы будем использовать её постоянно. В результате сборки появится файл&nbsp;<code>real-exe</code>. Располагается он внутри скрытого каталога&nbsp;<code>.stack-work</code>&nbsp;в корне проекта. Чтобы сразу его запустить, не копаясь во внутренностях этого скрытого каталога, используем команду:</p></div><div><pre class="language-bash" tabindex="0"><code class="language-bash is-loaded">$ stack <span class="token builtin class-name">exec</span> real-exe
someFunc
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Команда&nbsp;<code>stack exec</code>&nbsp;запускает программу (в данном случае&nbsp;<code>real-exe</code>) внутри&nbsp;<code>stack</code>-окружения. В одной из последующих глав я подробнее расскажу об этом окружении. Впрочем, мы можем запустить нашу программу и напрямую, без&nbsp;<code>stack</code>. Исполняемый файл&nbsp;<code>real-exe</code>&nbsp;находится внутри скрытого каталога&nbsp;<code>.stack-work</code>&nbsp;в корне проекта. Например, на моём компьютере путь к исполняемому файлу такой:</p></div><div><pre class="language-bash" tabindex="0"><code class="language-bash is-loaded">.stack-work/dist/x86_64-linux/Cabal-1.24.2.0/build/real-exe/real-exe
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Но можно и упростить себе жизнь, выполнив команду:</p></div><div><pre class="language-bash" tabindex="0"><code class="language-bash is-loaded">$ stack <span class="token function">install</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>В результате исполняемый файл будет скопирован в каталог&nbsp;<code>~/.local/bin</code>&nbsp;(подразумевается, что такой каталог у вас уже имеется). Кстати, полезно добавить&nbsp;<code>~/.local/bin</code>&nbsp;в&nbsp;<code>PATH</code>, что позволит вам тут же запускать программу:</p></div><div><pre class="language-bash" tabindex="0"><code class="language-bash is-loaded">$ real-exe
someFunc
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Вот мы и создали Haskell-проект и запустили нашу первую программу, выведшую строку&nbsp;<code>someFunc</code>. Но как же это работает? Пришла пора познакомиться с фундаментальной единицей проекта — модулем.</p></div><div><h2 data-heading="Модули: знакомство" id="Модули:_знакомство" style="display: flex;"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>Модули: знакомство</h2></div><div><p>Haskell-проект состоит из модулей. Модулем называется файл, содержащий исходный Haskell-код. Один файл — один модуль. Расширение&nbsp;<code>.hs</code>&nbsp;— стандартное расширения для модулей. В Haskell нет понятия «заголовочный файл»: каждый из модулей рассматривается как самостоятельная единица проекта, содержащая в себе разные полезные вещи. А чтобы воспользоваться этими вещами, необходимо один модуль импортировать в другой.</p></div><div><p>Откроем модуль&nbsp;<code>src/Lib.hs</code>:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token keyword">module</span> <span class="token constant">Lib</span>      <span class="token comment">-- Имя модуля</span>
    <span class="token punctuation">(</span> <span class="token hvariable">someFunc</span>  <span class="token comment">-- Интерфейс модуля</span>
    <span class="token punctuation">)</span> <span class="token keyword">where</span>

<span class="token comment">-- Всё содержимое модуля - эта функция.</span>
<span class="token hvariable">someFunc</span> <span class="token operator">::</span> <span class="token constant">IO</span> <span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token hvariable">someFunc</span> <span class="token operator">=</span> <span class="token builtin">putStrLn</span> <span class="token string">"someFunc"</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>В первой строке объявлено, что имя этого модуля —&nbsp;<code>Lib</code>. Далее в круглых скобках указан интерфейс данного модуля, то есть та его часть, которая видна всему миру. В данном случае это единственная функция&nbsp;<code>someFunc</code>, объявление и определение которой идёт далее, вслед за ключевым словом&nbsp;<code>where</code>. Пока вам не нужно знать о синтаксисе объявления и определений функции, в следующих главах мы разберём его тщательнейшим образом.</p></div><div><p>Теперь откроем модуль&nbsp;<code>app/Main.hs</code>:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token keyword">module</span> <span class="token constant">Main</span> <span class="token keyword">where</span>

<span class="token import-statement"><span class="token keyword">import</span> Lib</span>      <span class="token comment">-- Импортируем модуль Lib...</span>

<span class="token hvariable">main</span> <span class="token operator">::</span> <span class="token constant">IO</span> <span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token hvariable">main</span> <span class="token operator">=</span> <span class="token hvariable">someFunc</span> <span class="token comment">-- Используем его содержимое...</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Это модуль&nbsp;<code>Main</code>, главный модуль нашего приложения, ведь именно здесь определена функция&nbsp;<code>main</code>. С помощью директивы&nbsp;<code>import</code>&nbsp;мы включаем сюда модуль&nbsp;<code>Lib</code>&nbsp;и можем работать с содержимым этого модуля.</p></div><div><p>Запомните модуль&nbsp;<code>Main</code>, с ним мы будем работать чаще всего. Все примеры исходного кода, которые вы увидите на страницах этой книги, живут именно в модуле&nbsp;<code>Main</code>, если не оговорено иное.</p></div><div><p>Все модули в наших проектах можно разделить на две части: те, которые мы берём из библиотек и те, которые мы создали сами. Библиотеки — это уже кем-то написанные решения, в последующих главах мы познакомимся со многими из них. Среди библиотек следует выделить одну, так называемую стандартную библиотеку. Модули из стандартной библиотеки мы начнём использовать уже в ближайших главах. А одна из глав будет полностью посвящена рассказу о библиотеках: из неё мы подробно узнаем, откуда берутся библиотеки и как их можно использовать.</p></div><div><h2 data-heading="Для любопытных" id="Для_любопытных" style="display: flex;"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>Для любопытных</h2></div><div><p>До появления&nbsp;<code>stack</code>&nbsp;основным способом установки Haskell была так называемая&nbsp;<a data-tooltip-position="top" aria-label="https://www.haskell.org/platform/" rel="noopener" class="external-link" href="https://www.haskell.org/platform/" target="_blank">Haskell Platform</a>. Однако именно&nbsp;<code>stack</code>, несмотря на свою молодость (вышел в свет летом 2015 года), является предпочтительным путём в мир Haskell, особенно для новичков. Его настолько полюбили, что последние версии Haskell Platform включают в себя&nbsp;<code>stack</code>&nbsp;по умолчанию!</p></div><div><p>Как вы заметили, имена файлов с исходным кодом начинаются с большой буквы:&nbsp;<code>app/Main.hs</code>&nbsp;и&nbsp;<code>src/Lib.hs</code>. Строго говоря, это необязательно, можно и с маленькой буквы, однако для гармонии с именем модуля лучше придерживаться общепринятой практики и называть файл модуля по имени самого модуля:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">app</span><span class="token operator">/</span><span class="token hvariable">Main<span class="token punctuation">.</span>hs</span> <span class="token operator">-&gt;</span> <span class="token keyword">module</span> <span class="token constant">Main</span> <span class="token operator">...</span>
<span class="token hvariable">src</span><span class="token operator">/</span><span class="token hvariable">Lib<span class="token punctuation">.</span>hs</span>  <span class="token operator">-&gt;</span> <span class="token keyword">module</span> <span class="token constant">Lib</span> <span class="token operator">...</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>И ещё. При создании проекта мы могли бы использовать схему&nbsp;<code>simple</code>&nbsp;вместо предлагаемой по умолчанию. Для этого проект нужно было создать командой:</p></div><div><pre class="language-bash" tabindex="0"><code class="language-bash is-loaded">$ stack new real simple
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>где&nbsp;<code>simple</code>&nbsp;— имя схемы проекта. Дело в том, что команда&nbsp;<code>stack new</code>&nbsp;может создавать заготовки проектов для разных нужд. Простейшая из заготовок называется&nbsp;<code>simple</code>. В этом случае в проекте отсутствует модуль&nbsp;<code>src/Lib.hs</code>, а есть лишь&nbsp;<code>src/Main.hs</code>:</p></div><div><pre class="language-bash" tabindex="0"><code class="language-bash is-loaded"><span class="token builtin class-name">.</span>
├── LICENSE
├── Setup.hs
├── real.cabal
├── src
│   └── Main.hs <span class="token operator">&lt;</span>- Единственный модуль
└── stack.yaml
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Да, мы могли бы воспользоваться данной схемой, однако в этом случае мы не увидели бы механизма импорта одного модуля в другой. Я рад, что вы познакомились с импортом уже сейчас, ведь в последующих главах мы будем постоянно использовать различные модули из многих библиотек.</p></div><div><h1 data-heading="Киты и Черепаха" id="Киты_и_Черепаха">Киты и Черепаха</h1></div><div><p>Итак, проект создали, теперь мы готовы начать наше путешествие.</p></div><div><p>Haskell стоит на Трёх Китах, имена которым:&nbsp;<strong>Функция</strong>,&nbsp;<strong>Тип</strong>&nbsp;и&nbsp;<strong>Класс типов</strong>. Они же, в свою очередь, покоятся на огромной Черепахе, имя которой —&nbsp;<strong>Выражение</strong>.</p></div><div><h2 data-heading="Черепаха" id="Черепаха" style="display: flex;"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>Черепаха</h2></div><div><p>Haskell-программа представляет собой совокупность выражений (англ. expression). Взгляните:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token number">1</span> <span class="token operator">+</span> <span class="token number">2</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Это — основной кирпич Haskell-программы, будь то Hello World или часть инфраструктуры международного банка. Конечно, помимо сложения единицы с двойкой существуют и другие выражения, но суть у них у всех одна:</p></div><div><blockquote>
<p>Выражение — это то, что может дать нам некий полезный результат.</p>
</blockquote></div><div><p>Полезный результат мы получаем в результате вычисления (англ. evaluation) выражения. Все выражения можно вычислить, однако одни выражения в результате вычисления уменьшаются (англ. reduce), а другие — нет. Первые иногда называют редуцируемыми выражениями, а вторые — нередуцируемые. Так, выражение:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token number">1</span> <span class="token operator">+</span> <span class="token number">2</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>относится к редуцируемым, потому что оно в результате вычисления уменьшится и даст нам другое выражение:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token number">3</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Это выражение уже нельзя уменьшить, оно нередуцируемое и мы теперь лишь можем использовать его как есть.</p></div><div><p>Таким образом, выражения, составляющие программу, вычисляются/редуцируются до тех пор, пока не останется некое окончательное, корневое выражение. А запуск Haskell-программы на выполнение (англ. execution) — это запуск всей этой цепочки вычислений, причём с корнем этой цепочки мы уже познакомились ранее. Помните функцию&nbsp;<code>main</code>, определённую в модуле&nbsp;<code>app/Main.hs</code>? Вот эта функция и является главной точкой нашей программы, её Альфой и Омегой.</p></div><div><h2 data-heading="Первый Кит" id="Первый_Кит" style="display: flex;"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>Первый Кит</h2></div><div><p>Вернёмся к выражению&nbsp;<code>1 + 2</code>. Полезный результат мы получим лишь после того, как вычислим это выражение, то есть осуществим сложение. И как же можно «осуществить сложение» в рамках Haskell-программы? С помощью функции. Именно функция делает выражение вычислимым, именно она оживляет нашу программу, потому я и назвал Функцию Первым Китом Haskell. Но дабы избежать недоразумений, определимся с понятиями.</p></div><div><p>Что такое функция в математике? Вспомним школьный курс:</p></div><div><blockquote>
<p>Функция — это закон, описывающий зависимость одного значения от другого.</p>
</blockquote></div><div><p>Рассмотрим функцию возведения целого числа в квадрат:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">square</span> <span class="token hvariable">v</span> <span class="token operator">=</span> <span class="token hvariable">v</span> <span class="token operator">*</span> <span class="token hvariable">v</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Функция&nbsp;<code>square</code>&nbsp;определяет простую зависимость: числу&nbsp;<code>2</code>&nbsp;соответствует число&nbsp;<code>4</code>, числу&nbsp;<code>3</code>&nbsp;—&nbsp;<code>9</code>, и так далее. Схематично это можно записать так:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token number">2</span> <span class="token operator">-&gt;</span> <span class="token number">4</span>
<span class="token number">3</span> <span class="token operator">-&gt;</span> <span class="token number">9</span>
<span class="token number">4</span> <span class="token operator">-&gt;</span> <span class="token number">16</span>
<span class="token number">5</span> <span class="token operator">-&gt;</span> <span class="token number">25</span>
<span class="token operator">...</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Входное значение функции называют аргументом. А так как функция определяет однозначную зависимость выходного значения от аргумента, её, функцию, называют ещё&nbsp;<em>отображением</em>: она отображает/проецирует входное значение на выходное. Получается как бы труба: кинули в неё&nbsp;<code>2</code>&nbsp;— с другой стороны вылетело&nbsp;<code>4</code>, кинули&nbsp;<code>5</code>&nbsp;— вылетело&nbsp;<code>25</code>.</p></div><div><p>Чтобы заставить функцию сделать полезную работу, её необходимо применить (англ. apply) к аргументу. Пример:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">square</span> <span class="token number">2</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Мы применили функцию&nbsp;<code>square</code>&nbsp;к аргументу&nbsp;<code>2</code>. Синтаксис предельно прост: имя функции и через пробел аргумент. Если аргументов более одного — просто дописываем их так же, через пробел. Например, функция&nbsp;<code>sum</code>, вычисляющая сумму двух своих целочисленных аргументов, применяется так:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token builtin">sum</span> <span class="token number">10</span> <span class="token number">20</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Так вот выражение&nbsp;<code>1 + 2</code>&nbsp;есть ни что иное, как применение функции! И чтобы яснее это увидеть, перепишем выражение:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token punctuation">(</span><span class="token operator">+</span><span class="token punctuation">)</span> <span class="token number">1</span> <span class="token number">2</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Это применение функции&nbsp;<code>(+)</code>&nbsp;к двум аргументам,&nbsp;<code>1</code>&nbsp;и&nbsp;<code>2</code>. Не удивляйтесь, что имя функции заключено в скобки, вскоре я расскажу об этом подробнее. А пока запомните главное:</p></div><div><blockquote>
<p>Вычислить выражение — это значит применить какие-то функции (одну или более) к каким-то аргументам (одному или более).</p>
</blockquote></div><div><p>И ещё. Возможно, вы слышали о так называемом «вызове» функции. В Haskell функции не вызывают. Понятие «вызов» функции пришло к нам из почтенного языка C. Там функции действительно вызывают (англ. call), потому что в C, в отличие от Haskell, понятие «функция» не имеет никакого отношения к математике. Там это подпрограмма, то есть обособленный кусочек программы, доступный по некоторому адресу в памяти. Если у вас есть опыт разработки на C-подобных языках — забудьте о подпрограмме. В Haskell функция — это функция в математическом смысле слова, поэтому её не вызывают, а применяют к чему-то.</p></div><div><h2 data-heading="Второй Кит" id="Второй_Кит" style="display: flex;"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>Второй Кит</h2></div><div><p>Итак, любое редуцируемое выражение суть применение функции к некоторому аргументу (тоже являющемуся выражением):</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">square</span>   <span class="token number">2</span>
функция  аргумент
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Аргумент представляет собой некоторое значение, его ещё называют «данное» (англ. data). Данные в Haskell — это сущности, обладающие двумя главными характеристиками: типом и конкретным значением/содержимым.</p></div><div><p>Тип — это Второй Кит в Haskell. Тип отражает конкретное содержимое данных, а потому все данные в программе обязательно имеют некий тип. Когда мы видим данное типа&nbsp;<code>Double</code>, мы точно знаем, что перед нами число с плавающей точкой, а когда видим данные типа&nbsp;<code>String</code>&nbsp;— можем ручаться, что перед нами строки.</p></div><div><p>Отношение к типам в Haskell очень серьёзное, и работа с типами характеризуется тремя важными чертами:</p></div><div><ol>
<li data-line="0">статическая проверка,</li>
<li data-line="1">сила,</li>
<li data-line="2">выведение.</li>
</ol></div><div><p>Три эти свойства системы типов Haskell — наши добрые друзья, ведь они делают нашу программистскую жизнь счастливее. Познакомимся с ними.</p></div><div><h3 data-heading="Статическая проверка" id="Статическая_проверка" style="display: flex;"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>Статическая проверка</h3></div><div><p>Статическая проверка типов (англ. static type checking) — это проверка типов всех данных в программе, осуществляемая на этапе компиляции. Haskell-компилятор упрям: когда ему что-либо не нравится в типах, он громко ругается. Поэтому если функция работает с целыми числами, применить её к строкам никак не получится. Так что если компиляция нашей программы завершилась успешно, мы точно знаем, что с типами у нас всё в порядке. Преимущества статической проверки невозможно переоценить, ведь она гарантирует отсутствие в наших программах целого ряда ошибок. Мы уже не сможем спутать числа со строками или вычесть метры из рублей.</p></div><div><p>Конечно, у этой медали есть и обратная сторона — время, затрачиваемое на компиляцию. Вам придётся свыкнуться с этой мыслью: внесли изменения в проект — будьте добры скомпилировать. Однако утешением вам пусть послужит тот факт, что преимущества статической проверки куда ценнее времени, потраченного на компиляцию.</p></div><div><h3 data-heading="Сила" id="Сила" style="display: flex;"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>Сила</h3></div><div><p>Сильная (англ. strong) система типов — это бескомпромиссный контроль соответствия ожидаемого действительному. Сила делает работу с типами ещё более аккуратной. Вот вам пример из мира C:</p></div><div><pre class="language-c" tabindex="0"><code class="language-c is-loaded"><span class="token keyword">double</span> <span class="token function">coeff</span><span class="token punctuation">(</span><span class="token keyword">double</span> base<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> base <span class="token operator">*</span> <span class="token number">4.9856</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">int</span> value <span class="token operator">=</span> <span class="token function">coeff</span><span class="token punctuation">(</span><span class="token number">122.04</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Это канонический пример проблемы, обусловленной слабой (англ. weak) системой типов. Функция&nbsp;<code>coeff</code>&nbsp;возвращает значение типа&nbsp;<code>double</code>, однако вызывающая сторона ожидает почему-то целое число. Ну вот ошиблись мы, криво скопировали. В этом случае произойдёт жульничество, называемое скрытым приведением типов (англ. implicit type casting): число с плавающей точкой, возвращённое функцией&nbsp;<code>coeff</code>, будет грубо сломано путём приведения его к типу&nbsp;<code>int</code>, в результате чего дробная часть будет отброшена и мы получим не&nbsp;<code>608.4426</code>, а&nbsp;<code>608</code>. Подобная ошибка, кстати, приводила к серьёзным последствиям, таким как уничтожение космических аппаратов. Нет, это вовсе не означает, что слабая типизация ужасна сама по себе, просто есть иной путь.</p></div><div><p>Благодаря сильной типизации в Haskell подобный код не имеет ни малейших шансов пройти компиляцию. Мы всегда получаем то, что ожидаем, и если должно быть число с плавающей точкой — расшибись, но предоставь именно его. Компилятор скрупулёзно отслеживает соответствие ожидаемого типа фактическому, поэтому когда компиляция завершается успешно, мы абсолютно уверены в гармонии между типами всех наших данных.</p></div><div><h3 data-heading="Выведение" id="Выведение" style="display: flex;"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>Выведение</h3></div><div><p>Выведение (англ. inference) типов — это способность определить тип данных автоматически, по конкретному выражению. В том же языке C тип данных следует указывать явно:</p></div><div><pre class="language-c" tabindex="0"><code class="language-c is-loaded"><span class="token keyword">double</span> value <span class="token operator">=</span> <span class="token number">122.04</span><span class="token punctuation">;</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>однако в Haskell мы напишем просто:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">value</span> <span class="token operator">=</span> <span class="token number">122.04</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>В этом случае компилятор автоматически выведет тип&nbsp;<code>value</code>&nbsp;как&nbsp;<code>Double</code>.</p></div><div><p>Выведение типов делает наш код лаконичнее и проще в сопровождении. Впрочем, мы можем указать тип значения и явно, а иногда даже должны это сделать. В последующих главах я объясню, почему.</p></div><div><p>Да, кстати, вот простейшие стандартные типы, они нам понадобятся:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token number">123</span>         <span class="token constant">Int</span>
<span class="token number">23.5798</span>     <span class="token constant">Double</span>
<span class="token char string">'a'</span>         <span class="token constant">Char</span>
<span class="token string">"Hello!"</span>    <span class="token constant">String</span>
<span class="token constant">True</span>        <span class="token constant">Bool</span><span class="token punctuation">,</span> истина
<span class="token constant">False</span>       <span class="token constant">Bool</span><span class="token punctuation">,</span> ложь
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>С типами&nbsp;<code>Int</code>&nbsp;и&nbsp;<code>Double</code>&nbsp;вы уже знакомы. Тип&nbsp;<code>Char</code>&nbsp;— это Unicode-символ. Тип&nbsp;<code>String</code>&nbsp;— строка, состоящая из Unicode-символов. Тип&nbsp;<code>Bool</code>&nbsp;— логический тип, соответствующий истине или лжи. В последующих главах мы встретимся ещё с несколькими стандартными типами, но пока хватит и этих. И заметьте: имя типа в Haskell всегда начинается с большой буквы.</p></div><div><h2 data-heading="Третий Кит" id="Третий_Кит" style="display: flex;"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>Третий Кит</h2></div><div><p>А вот о Третьем Ките, о&nbsp;<strong>Классе типов</strong>, я пока умолчу, потому что знакомиться с ним следует лишь после того, как мы поближе подружимся с первыми двумя.</p></div><div><p>Уверен, после прочтения этой главы у вас появилось множество вопросов. Ответы будут, но позже. Более того, следующая глава несомненно удивит вас.</p></div><div><h2 data-heading="Для любопытных" id="Для_любопытных" style="display: flex;"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>Для любопытных</h2></div><div><p>Если вы работали с объектно-ориентированными языками, такими как C++, вас удивит тот факт, что в Haskell между понятиями «тип» и «класс» проведено чёткое различие. А поскольку типам и классам типов в Haskell отведена колоссально важная роль, добрый вам совет: когда в будущих главах мы познакомимся с ними поближе, не пытайтесь проводить аналогии из других языков. Например, некоторые усматривают родство между классами типов в Haskell и интерфейсами в Java. Не делайте этого, во избежание путаницы.</p></div><div><h1 data-heading="Неизменность и чистота" id="Неизменность_и_чистота">Неизменность и чистота</h1></div><div><p>В предыдущей главе мы познакомились с функциями и выражениями, увидев близкую связь этих понятий. В этой главе мы познакомимся с функциями поближе, а также узнаем, что такое «чисто функциональный» язык и почему в нём нет места оператору присваивания.</p></div><div><h2 data-heading="Объявляем и определяем" id="Объявляем_и_определяем" style="display: flex;"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>Объявляем и определяем</h2></div><div><p>Применение функции нам уже знакомо, осталось узнать про объявление и определение, без них использовать функцию не получится. Помните функцию&nbsp;<code>square</code>, возводящую свой единственный аргумент в квадрат? Вот как выглядит её объявление и определение:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">square</span> <span class="token operator">::</span> <span class="token constant">Int</span> <span class="token operator">-&gt;</span> <span class="token constant">Int</span>
<span class="token hvariable">square</span> <span class="token hvariable">v</span> <span class="token operator">=</span> <span class="token hvariable">v</span> <span class="token operator">*</span> <span class="token hvariable">v</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Первая строка содержит объявление, вторая — определение. Объявление (англ. declaration) — это весть всему миру о том, что такая функция существует, вот её имя и вот типы, с которыми она работает. Определение (англ. definition) — это весть о том, что конкретно делает данная функция.</p></div><div><p>Рассмотрим объявление:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">square</span> <span class="token operator">::</span> <span class="token constant">Int</span> <span class="token operator">-&gt;</span> <span class="token constant">Int</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Оно разделено двойным двоеточием на две части: слева указано имя функции, справа — типы, с которыми эта функция работает, а именно типы аргументов и тип вычисленного, итогового значения. Как вы узнали из предыдущей главы, все данные в Haskell-программе имеют конкретный тип, а поскольку функция работает с данными, её объявление содержит типы этих данных. Типы разделены стрелками. Схематично это выглядит так:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">square</span> <span class="token operator">::</span> <span class="token constant">Int</span>      <span class="token operator">-&gt;</span> <span class="token constant">Int</span>

имя       тип         тип
функции   аргумента   вычисленного
                      значения
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Такое объявление сообщает нам о том, что функция&nbsp;<code>square</code>&nbsp;принимает единственный аргумент типа&nbsp;<code>Int</code>&nbsp;и возвращает значение того же типа&nbsp;<code>Int</code>. Если же аргументов более одного, объявление просто вытягивается. Например, объявление функции&nbsp;<code>prod</code>, возвращающей произведение двух целочисленных аргументов, могло бы выглядеть так:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">prod</span>    <span class="token operator">::</span> <span class="token constant">Int</span>      <span class="token operator">-&gt;</span> <span class="token constant">Int</span>      <span class="token operator">-&gt;</span> <span class="token constant">Int</span>

имя        тип         тип         тип
функции    первого     второго     вычисленного
           аргумента   аргумента   значения
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Идею вы поняли: ищем крайнюю правую стрелку, и всё что левее от неё — то типы аргументов, а всё что правее — то тип вычисленного значения.</p></div><div><p>Мы не можем работать с функцией, которая ничего не вычисляет. То есть аналога C-функции&nbsp;<code>void f(int i)</code>&nbsp;в Haskell быть не может, так как это противоречит математической природе. Однако мы можем работать с функцией, которая ничего не принимает, то есть с аналогом C-функции&nbsp;<code>int f(void)</code>. С такими функциями мы познакомимся в следующих главах.</p></div><div><p>Теперь рассмотрим определение функции&nbsp;<code>square</code>:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">square</span> <span class="token hvariable">v</span> <span class="token operator">=</span> <span class="token hvariable">v</span> <span class="token operator">*</span> <span class="token hvariable">v</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Схема определения такова:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">square</span>   <span class="token hvariable">v</span>          <span class="token operator">=</span>    <span class="token hvariable">v</span> <span class="token operator">*</span> <span class="token hvariable">v</span>

имя      имя        это  выражение
функции  аргумента
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>А функция&nbsp;<code>prod</code>&nbsp;определена так:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">prod</span>     <span class="token hvariable">x</span>          <span class="token hvariable">y</span>         <span class="token operator">=</span>    <span class="token hvariable">x</span> <span class="token operator">*</span> <span class="token hvariable">y</span>

имя      имя        имя       это  выражение
функции  первого    второго
         аргумента  аргумента
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Определение тоже разделено на две части: слева от знака равенства — имя функции и имена аргументов (имена, а не типы), разделённые пробелами, а справа — выражение, составляющее суть функции, её содержимое. Иногда эти части называют «головой» и «телом»:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">square</span>   <span class="token hvariable">v</span>      <span class="token operator">=</span>  <span class="token hvariable">v</span> <span class="token operator">*</span> <span class="token hvariable">v</span>

голова функции     тело функции
<span class="token punctuation">(</span>англ<span class="token punctuation">.</span> <span class="token builtin">head</span><span class="token punctuation">)</span>       <span class="token punctuation">(</span>англ<span class="token punctuation">.</span> <span class="token hvariable">body</span><span class="token punctuation">)</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Обратите внимание, речь здесь идёт именно о знаке равенства, а никак не об операторе присваивания. Мы ничего не присваиваем, мы лишь декларируем равенство левой и правой частей. Когда мы пишем:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">prod</span> <span class="token hvariable">x</span> <span class="token hvariable">y</span> <span class="token operator">=</span> <span class="token hvariable">x</span> <span class="token operator">*</span> <span class="token hvariable">y</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>мы объявляем следующее: «Отныне выражение&nbsp;<code>prod x y</code>&nbsp;равно выражению&nbsp;<code>x * y</code>». Мы можем безопасно заменить выражение&nbsp;<code>prod 2 5</code>&nbsp;выражением&nbsp;<code>2 * 5</code>, а выражение&nbsp;<code>prod 120 500</code>&nbsp;— выражением&nbsp;<code>120 * 500</code>, и при этом работа программы гарантированно останется неизменной.</p></div><div><p>Но откуда у меня такая уверенность? А вот откуда.</p></div><div><h2 data-heading="Чисто функциональный" id="Чисто_функциональный" style="display: flex;"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>Чисто функциональный</h2></div><div><p>Haskell — чисто функциональный (англ. purely functional) язык. Чисто функциональным он называется потому, что центральное место в нём уделено чистой функции (англ. pure function). А чистой называется такая функция, которая предельно честна с нами: её выходное значение всецело определяется её аргументами и более ничем. Это и есть функция в математическом смысле. Вспомним функцию&nbsp;<code>prod</code>: когда на входе числа&nbsp;<code>10</code>&nbsp;и&nbsp;<code>20</code>&nbsp;— на выходе всегда будет&nbsp;<code>200</code>, и ничто не способно помешать этому. Функция&nbsp;<code>prod</code>&nbsp;является чистой, а потому характеризуется отсутствием побочных эффектов (англ. side effects): она не способна сделать ничего, кроме как вернуть произведение двух своих аргументов. Именно поэтому чистая функция предельно надёжна, ведь она не может преподнести нам никаких сюрпризов.</p></div><div><p>Скажу больше: чистые функции не видят окружающий мир. Вообще. Они не могут вывести текст на консоль, их нельзя заставить обработать HTTP-запрос, они не умеют дружить с базой данных и прочесть файл они также неспособны. Они суть вещь в себе.</p></div><div><p>А чтобы удивить вас ещё больше, открою ещё один секрет Haskell.</p></div><div><h2 data-heading="«Присваивание? Не, не слышал…»" id="«Присваивание?_Не,_не_слышал…»" style="display: flex;"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>«Присваивание? Не, не слышал…»</h2></div><div><p>В мире Haskell нет места оператору присваивания. Впрочем, этот факт удивителен лишь на первый взгляд. Задумаемся: если каждая функция в конечном итоге представляет собою выражение, вычисляемое посредством применения каких-то других функций к каким-то другим аргументам, тогда нам просто не нужно ничего ничему присваивать.</p></div><div><p>Вспомним, что присваивание (англ. assignment) пришло к нам из императивных языков. Императивное программирование (англ. imperative programming) — это направление в разработке, объединяющее несколько парадигм программирования, одной из которых является знаменитая объектно-ориентированная парадигма. В рамках этого направления программа воспринимается как набор инструкций, выполнение которых неразрывно связано с изменением состояния (англ. state) этой программы. Вот почему в императивных языках обязательно присутствует понятие «переменная» (англ. variable). А раз есть переменные — должен быть и оператор присваивания. Когда мы пишем:</p></div><div><pre class="language-c" tabindex="0"><code class="language-c is-loaded">coeff <span class="token operator">=</span> <span class="token number">0.569</span><span class="token punctuation">;</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>мы тем самым приказываем: «Возьми значение&nbsp;<code>0.569</code>&nbsp;и перезапиши им то значение, которое уже содержалось в переменной&nbsp;<code>coeff</code>&nbsp;до этого». И перезаписывать это значение мы можем множество раз, а следовательно, мы вынуждены внимательно отслеживать текущее состояние переменной&nbsp;<code>coeff</code>, равно как и состояния всех остальных переменных в нашем коде.</p></div><div><p>Однако существует принципиально иной подход к разработке, а именно декларативное программирование (англ. declarative programming). Данное направление также включает в себя несколько парадигм, одной из которых является функциональная парадигма, нашедшая своё воплощение в Haskell. При этом подходе программа воспринимается уже не как набор инструкций, а как набор выражений. А поскольку выражения вычисляются путём применения функций к аргументам (то есть, по сути, к другим выражениям), там нет места ни переменным, ни оператору присваивания. Все данные в Haskell-программе, будучи созданными единожды, уже не могут быть изменены. Поэтому нам не нужен не только оператор присваивания, но и ключевое слово&nbsp;<code>const</code>. И когда в Haskell-коде мы пишем:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">coeff</span> <span class="token operator">=</span> <span class="token number">0.569</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>мы просто объявляем: «Отныне значение&nbsp;<code>coeff</code>&nbsp;равно&nbsp;<code>0.569</code>, и так оно будет всегда». Вот почему в Haskell-коде символ&nbsp;<code>=</code>&nbsp;— это знак равенства в математическом смысле, и с присваиванием он не имеет ничего общего.</p></div><div><p>Уверен, вы удивлены. Как же можно написать реальную программу на языке, в котором нельзя изменять данные? Какой прок от этих чистых функций, если они не способны ни файл прочесть, ни запрос по сети отправить? Оказывается, прок есть, и на Haskell можно написать очень даже реальную программу. За примером далеко ходить не буду: сама эта книга построена с помощью программы, написанной на Haskell, о чём я подробнее расскажу в следующих главах.</p></div><div><p>А теперь, дабы не мучить вас вопросами без ответов, мы начнём ближе знакомиться с Китами Haskell, и детали большой головоломки постепенно сложатся в красивую картину.</p></div><div><h2 data-heading="Для любопытных" id="Для_любопытных" style="display: flex;"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>Для любопытных</h2></div><div><p>В процессе работы Haskell-программы в памяти создаётся великое множество различных данных, ведь мы постоянно строим новые данные на основе уже имеющихся. За их своевременное уничтожение отвечает сборщик мусора (англ. garbage collector, GC), встраиваемый в программы компилятором GHC.</p></div><div><h1 data-heading="Выбираем и возвращаемся" id="Выбираем_и_возвращаемся">Выбираем и возвращаемся</h1></div><div><p>В этой главе мы встретимся с условными конструкциями, выглянем в терминал, а также узнаем, почему из Haskell-функций не возвращаются (впрочем, последнее — не более чем игра слов).</p></div><div><h2 data-heading="Выглянем во внешний мир" id="Выглянем_во_внешний_мир" style="display: flex;"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>Выглянем во внешний мир</h2></div><div><p>Мы начинаем писать настоящий код. А для этого нам понадобится окно во внешний мир. Откроем модуль&nbsp;<code>app/Main.hs</code>, найдём функцию&nbsp;<code>main</code>&nbsp;и напишем в ней следующее:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">main</span> <span class="token operator">::</span> <span class="token constant">IO</span> <span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token hvariable">main</span> <span class="token operator">=</span> <span class="token builtin">putStrLn</span> <span class="token string">"Hi, real world!"</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Стандартная функция&nbsp;<code>putStrLn</code>&nbsp;выводит строку на консоль. А если говорить строже, функция&nbsp;<code>putStrLn</code>&nbsp;применяется к значению типа&nbsp;<code>String</code>&nbsp;и делает так, чтобы мы увидели это значение в нашем терминале.</p></div><div><p>Да, я уже слышу вопрос внимательного читателя. Как же так, спросите вы, разве мы не говорили о чистых функциях в прошлой главе, неспособных взаимодействовать с внешним миром? Придётся признаться: функция&nbsp;<code>putStrLn</code>&nbsp;относится к особым функциям, которые могут-таки вылезти во внешний мир. Но об этом в следующих главах. Это прелюбопытнейшая тема, поверьте мне!</p></div><div><p>И ещё нам следует познакомиться с Haskell-комментариями, они нам понадобятся:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token comment">{-
    Я - сложный многострочный
     комментарий, содержащий
  нечто
        очень важное!
-}</span>
<span class="token hvariable">main</span> <span class="token operator">::</span> <span class="token constant">IO</span> <span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token hvariable">main</span> <span class="token operator">=</span>
  <span class="token comment">-- А я - скромный однострочный комментарий.</span>
  <span class="token builtin">putStrLn</span> <span class="token string">"Hi, real world!"</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Символы&nbsp;<code>{-</code>&nbsp;и&nbsp;<code>-}</code>&nbsp;скрывают многострочный комментарий, а символ&nbsp;<code>--</code>&nbsp;начинает комментарий однострочный.</p></div><div><p>На всякий случай напоминаю команду сборки, запускаемую из корня проекта:</p></div><div><pre class="language-bash" tabindex="0"><code class="language-bash is-loaded">$ stack build
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>После сборки запускаем:</p></div><div><pre class="language-bash" tabindex="0"><code class="language-bash is-loaded">$ stack <span class="token builtin class-name">exec</span> real-exe
Hi, real world<span class="token operator">!</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><h2 data-heading="Выбор и выход" id="Выбор_и_выход" style="display: flex;"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>Выбор и выход</h2></div><div><p>Выбирать внутри функции приходится очень часто. Существует несколько способов задания условной конструкции. Вот базовый вариант:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token keyword">if</span> <span class="token constant">CONDITION</span> <span class="token keyword">then</span> <span class="token constant">EXPR1</span> <span class="token keyword">else</span> <span class="token constant">EXPR2</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>где&nbsp;<code>CONDITION</code>&nbsp;— логическое выражение, дающее ложь или истину,&nbsp;<code>EXPR1</code>&nbsp;— выражение, используемое в случае&nbsp;<code>True</code>,&nbsp;<code>EXPR2</code>&nbsp;— выражение, используемое в случае&nbsp;<code>False</code>. Пример:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">checkLocalhost</span> <span class="token operator">::</span> <span class="token constant">String</span> <span class="token operator">-&gt;</span> <span class="token constant">String</span>
<span class="token hvariable">checkLocalhost</span> <span class="token hvariable">ip</span> <span class="token operator">=</span>
  <span class="token comment">-- True или False?</span>
  <span class="token keyword">if</span> <span class="token hvariable">ip</span> <span class="token operator">==</span> <span class="token string">"127.0.0.1"</span> <span class="token operator">||</span> <span class="token hvariable">ip</span> <span class="token operator">==</span> <span class="token string">"0.0.0.0"</span>
    <span class="token comment">-- Если True - идёт туда...</span>
    <span class="token keyword">then</span> <span class="token string">"It's a localhost!"</span>
    <span class="token comment">-- А если False - сюда...</span>
    <span class="token keyword">else</span> <span class="token string">"No, it's not a localhost."</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Функция&nbsp;<code>checkLocalhost</code>&nbsp;применяется к единственному аргументу типа&nbsp;<code>String</code>&nbsp;и возвращает другое значение типа&nbsp;<code>String</code>. В качестве аргумента выступает строка, содержащая IP-адрес, а функция проверяет, не лежит ли в ней localhost. Оператор&nbsp;<code>||</code>&nbsp;— стандартый оператор логического «ИЛИ», а оператор&nbsp;<code>==</code>&nbsp;— стандартный оператор проверки на равенство. Итак, если строка&nbsp;<code>ip</code>&nbsp;равна&nbsp;<code>127.0.0.1</code>&nbsp;или&nbsp;<code>0.0.0.0</code>, значит в ней localhost, и мы возвращаем первое выражение, то есть строку&nbsp;<code>It's a localhost!</code>, в противном случае возвращаем второе выражение, строку&nbsp;<code>No, it's not a localhost.</code>.</p></div><div><p>А кстати, что значит «возвращаем»? Ведь, как мы узнали, функции в Haskell не вызывают (англ. call), а значит, из них и не возвращаются (англ. return). И это действительно так. Если напишем:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">main</span> <span class="token operator">::</span> <span class="token constant">IO</span> <span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token hvariable">main</span> <span class="token operator">=</span> <span class="token builtin">putStrLn</span> <span class="token punctuation">(</span><span class="token hvariable">checkLocalhost</span> <span class="token string">"127.0.0.1"</span><span class="token punctuation">)</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>при запуске увидим это:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token constant">It'</span><span class="token hvariable">s</span> <span class="token hvariable">a</span> <span class="token hvariable">localhost</span><span class="token operator">!</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>а если так:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">main</span> <span class="token operator">::</span> <span class="token constant">IO</span> <span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token hvariable">main</span> <span class="token operator">=</span> <span class="token builtin">putStrLn</span> <span class="token punctuation">(</span><span class="token hvariable">checkLocalhost</span> <span class="token string">"173.194.22.100"</span><span class="token punctuation">)</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>тогда увидим это:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token constant">No</span><span class="token punctuation">,</span> <span class="token hvariable">it's</span> <span class="token builtin">not</span> <span class="token hvariable">a</span> <span class="token hvariable">localhost</span><span class="token punctuation">.</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Круглые скобки включают выражение типа&nbsp;<code>String</code>&nbsp;по схеме:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">main</span> <span class="token operator">::</span> <span class="token constant">IO</span> <span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token hvariable">main</span> <span class="token operator">=</span> <span class="token builtin">putStrLn</span> <span class="token punctuation">(</span><span class="token hvariable">checkLocalhost</span> <span class="token string">"173.194.22.100"</span><span class="token punctuation">)</span>

                 └─── выражение типа <span class="token constant">String</span> ───┘
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>То есть функция&nbsp;<code>putStrLn</code>&nbsp;видит не применение функции&nbsp;<code>checkLocalhost</code>&nbsp;к строке, а просто выражение типа&nbsp;<code>String</code>. Если бы мы опустили скобки и написали так:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">main</span> <span class="token operator">::</span> <span class="token constant">IO</span> <span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token hvariable">main</span> <span class="token operator">=</span> <span class="token builtin">putStrLn</span> <span class="token hvariable">checkLocalhost</span> <span class="token string">"173.194.22.100"</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>произошла бы ошибка компиляции, и это вполне ожидаемо: функция&nbsp;<code>putStrLn</code>&nbsp;применяется к одному аргументу, а тут их получается два:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">main</span> <span class="token operator">=</span> <span class="token builtin">putStrLn</span>     <span class="token hvariable">checkLocalhost</span>  <span class="token string">"173.194.22.100"</span>

       функция      к этому
       применяется  аргументу<span class="token operator">...</span>
                                    и к этому<span class="token operator">??</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Не знаю как вы, а я не очень люблю круглые скобки, при всём уважении к Lisp-программистам. К счастью, в Haskell существует способ уменьшить число скобок. Об этом способе — в одной из последующих глав.</p></div><div><p>Так что же с возвращением из функции? Вспомним о равенстве в определении:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">checkLocalhost</span> <span class="token hvariable">ip</span> <span class="token operator">=</span>
  <span class="token keyword">if</span> <span class="token hvariable">ip</span> <span class="token operator">==</span> <span class="token string">"127.0.0.1"</span> <span class="token operator">||</span> <span class="token hvariable">ip</span> <span class="token operator">==</span> <span class="token string">"0.0.0.0"</span>
    <span class="token keyword">then</span> <span class="token string">"It's a localhost!"</span>
    <span class="token keyword">else</span> <span class="token string">"No, it's not a localhost."</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>То, что слева от знака равенства, равно тому, что справа. А раз так, эти два кода эквивалентны:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">main</span> <span class="token operator">::</span> <span class="token constant">IO</span> <span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token hvariable">main</span> <span class="token operator">=</span> <span class="token builtin">putStrLn</span> <span class="token punctuation">(</span><span class="token hvariable">checkLocalhost</span> <span class="token string">"173.194.22.100"</span><span class="token punctuation">)</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">main</span> <span class="token operator">::</span> <span class="token constant">IO</span> <span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token hvariable">main</span> <span class="token operator">=</span>
  <span class="token builtin">putStrLn</span> <span class="token punctuation">(</span><span class="token keyword">if</span> <span class="token string">"173.194.22.100"</span> <span class="token operator">==</span> <span class="token string">"127.0.0.1"</span> <span class="token operator">||</span>
               <span class="token string">"173.194.22.100"</span> <span class="token operator">==</span> <span class="token string">"0.0.0.0"</span>
              <span class="token keyword">then</span> <span class="token string">"It's a localhost!"</span>
              <span class="token keyword">else</span> <span class="token string">"No, it's not a localhost."</span><span class="token punctuation">)</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Мы просто заменили применение функции&nbsp;<code>checkLocalhost</code>&nbsp;её внутренним выражением, подставив вместо аргумента&nbsp;<code>ip</code>&nbsp;конкретную строку&nbsp;<code>173.194.22.100</code>. В итоге, в зависимости от истинности или ложности проверок на равенство, эта условная конструкция будет также заменена одним из двух выражений. В этом и заключается идея: возвращаемое функцией значение — это её последнее, итоговое выражение. То есть если выражение:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token string">"173.194.22.100"</span> <span class="token operator">==</span> <span class="token string">"127.0.0.1"</span> <span class="token operator">||</span>
<span class="token string">"173.194.22.100"</span> <span class="token operator">==</span> <span class="token string">"0.0.0.0"</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>даст нам результат&nbsp;<code>True</code>, то мы переходим к выражению из логической ветви&nbsp;<code>then</code>. Если же оно даст нам&nbsp;<code>False</code>&nbsp;— мы переходим к выражению из логической ветви&nbsp;<code>else</code>. Это даёт нам право утверждать, что условная конструкция вида:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token keyword">if</span> <span class="token constant">True</span>
  <span class="token keyword">then</span> <span class="token string">"It's a localhost!"</span>
  <span class="token keyword">else</span> <span class="token string">"No, it's not a localhost."</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>может быть заменена на первое нередуцируемое выражение, строку&nbsp;<code>It's a localhost!</code>, а условную конструкцию вида:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token keyword">if</span> <span class="token constant">False</span>
  <span class="token keyword">then</span> <span class="token string">"It's a localhost!"</span>
  <span class="token keyword">else</span> <span class="token string">"No, it's not a localhost."</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>можно спокойно заменить вторым нередуцируемым выражением, строкой&nbsp;<code>No, it's not a localhost.</code>. Поэтому код:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">main</span> <span class="token operator">::</span> <span class="token constant">IO</span> <span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token hvariable">main</span> <span class="token operator">=</span> <span class="token builtin">putStrLn</span> <span class="token punctuation">(</span><span class="token hvariable">checkLocalhost</span> <span class="token string">"0.0.0.0"</span><span class="token punctuation">)</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>эквивалентен коду:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">main</span> <span class="token operator">::</span> <span class="token constant">IO</span> <span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token hvariable">main</span> <span class="token operator">=</span> <span class="token builtin">putStrLn</span> <span class="token string">"It's a localhost!"</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Аналогично, код:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">main</span> <span class="token operator">::</span> <span class="token constant">IO</span> <span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token hvariable">main</span> <span class="token operator">=</span> <span class="token builtin">putStrLn</span> <span class="token punctuation">(</span><span class="token hvariable">checkLocalhost</span> <span class="token string">"173.194.22.100"</span><span class="token punctuation">)</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>есть ни что иное, как:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">main</span> <span class="token operator">::</span> <span class="token constant">IO</span> <span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token hvariable">main</span> <span class="token operator">=</span> <span class="token builtin">putStrLn</span> <span class="token string">"No, it's not a localhost."</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Каким бы сложным ни было логическое ветвление внутри функции&nbsp;<code>checkLocalhost</code>, в конечном итоге оно вернёт/вычислит какое-то одно итоговое выражение. Именно поэтому из функции в Haskell нельзя выйти в произвольном месте, как это принято в императивных языках, ведь она не является набором инструкций, она — выражение, состоящее из других выражений. Вот почему функции в Haskell так просто компоновать друг с другом, и позже мы встретим множество таких примеров.</p></div><div><h2 data-heading="Для любопытных" id="Для_любопытных" style="display: flex;"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>Для любопытных</h2></div><div><p>Внимательный читатель несомненно заметил необычное объявление главной функции нашего проекта, функции&nbsp;<code>main</code>:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">main</span> <span class="token operator">::</span> <span class="token constant">IO</span> <span class="token punctuation">(</span><span class="token punctuation">)</span>   <span class="token comment">-- Объявление?</span>
<span class="token hvariable">main</span> <span class="token operator">=</span> <span class="token builtin">putStrLn</span> <span class="token operator">...</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Если&nbsp;<code>IO</code>&nbsp;— это тип, то что такое&nbsp;<code>()</code>? И почему указан лишь один тип? Что такое&nbsp;<code>IO ()</code>: аргумент функции&nbsp;<code>main</code>, или же то, что она вычисляет? Сожалею, но пока я вынужден сохранить это в секрете. Когда мы поближе познакомимся со Вторым Китом Haskell, я непременно расскажу про этот странный&nbsp;<code>IO ()</code>.</p></div><div><h1 data-heading="Выбор и образцы" id="Выбор_и_образцы">Выбор и образцы</h1></div><div><p>Эта глава откроет нам другие способы выбора, а также познакомит нас с образцами. Уверяю, вы влюбитесь в них!</p></div><div><h2 data-heading="Не только из двух" id="Не_только_из_двух" style="display: flex;"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>Не только из двух</h2></div><div><p>Часто мы хотим выбирать не только из двух возможных вариантов. Вот как это можно сделать:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">analyzeGold</span> <span class="token operator">::</span> <span class="token constant">Int</span> <span class="token operator">-&gt;</span> <span class="token constant">String</span>
<span class="token hvariable">analyzeGold</span> <span class="token hvariable">standard</span> <span class="token operator">=</span>
  <span class="token keyword">if</span> <span class="token hvariable">standard</span> <span class="token operator">==</span> <span class="token number">999</span>
    <span class="token keyword">then</span> <span class="token string">"Wow! 999 standard!"</span>
    <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token hvariable">standard</span> <span class="token operator">==</span> <span class="token number">750</span>
           <span class="token keyword">then</span> <span class="token string">"Great! 750 standard."</span>
           <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token hvariable">standard</span> <span class="token operator">==</span> <span class="token number">585</span>
                  <span class="token keyword">then</span> <span class="token string">"Not bad! 585 standard."</span>
                  <span class="token keyword">else</span> <span class="token string">"I don't know such a standard..."</span>

<span class="token hvariable">main</span> <span class="token operator">::</span> <span class="token constant">IO</span> <span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token hvariable">main</span> <span class="token operator">=</span> <span class="token builtin">putStrLn</span> <span class="token punctuation">(</span><span class="token hvariable">analyzeGold</span> <span class="token number">999</span><span class="token punctuation">)</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Уверен, вы уже стираете плевок с экрана. Вложенная&nbsp;<code>if-then-else</code>&nbsp;конструкция не может понравиться никому, ведь она крайне неудобна в обращении. А уж если бы анализируемых проб золота было штук пять или семь, эта лестница стала бы поистине ужасной. К счастью, в Haskell можно написать по-другому:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">analyzeGold</span> <span class="token operator">::</span> <span class="token constant">Int</span> <span class="token operator">-&gt;</span> <span class="token constant">String</span>
<span class="token hvariable">analyzeGold</span> <span class="token hvariable">standard</span> <span class="token operator">=</span>
  <span class="token keyword">if</span> <span class="token operator">|</span> <span class="token hvariable">standard</span> <span class="token operator">==</span> <span class="token number">999</span> <span class="token operator">-&gt;</span> <span class="token string">"Wow! 999 standard!"</span>
     <span class="token operator">|</span> <span class="token hvariable">standard</span> <span class="token operator">==</span> <span class="token number">750</span> <span class="token operator">-&gt;</span> <span class="token string">"Great! 750 standard."</span>
     <span class="token operator">|</span> <span class="token hvariable">standard</span> <span class="token operator">==</span> <span class="token number">585</span> <span class="token operator">-&gt;</span> <span class="token string">"Not bad! 585 standard."</span>
     <span class="token operator">|</span> <span class="token builtin">otherwise</span> <span class="token operator">-&gt;</span> <span class="token string">"I don't know such a standard..."</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Не правда ли, так красивее? Это — множественный&nbsp;<code>if</code>. Работает он по схеме:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token keyword">if</span> <span class="token operator">|</span> <span class="token constant">COND1</span> <span class="token operator">-&gt;</span> <span class="token constant">EXPR1</span>
   <span class="token operator">|</span> <span class="token constant">COND2</span> <span class="token operator">-&gt;</span> <span class="token constant">EXPR2</span>
   <span class="token operator">|</span> <span class="token operator">...</span>
   <span class="token operator">|</span> <span class="token constant">CONDn</span> <span class="token operator">-&gt;</span> <span class="token constant">EXPRn</span>
   <span class="token operator">|</span> <span class="token builtin">otherwise</span> <span class="token operator">-&gt;</span> <span class="token constant">COMMON_EXPR</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>где&nbsp;<code>COND1..n</code>&nbsp;— выражения, дающие ложь или истину, а&nbsp;<code>EXPR1..n</code>&nbsp;— соответствующие им результирующие выражения. Особая функция&nbsp;<code>otherwise</code>&nbsp;соответствует общему случаю, когда ни одно из логических выражений не дало&nbsp;<code>True</code>, и в этой ситуации результатом условной конструкции послужит выражение&nbsp;<code>COMMON_EXPR</code>.</p></div><div><p>Не пренебрегайте&nbsp;<code>otherwise</code>! Если вы его не укажете и при этом примените функцию&nbsp;<code>analyzeGold</code>&nbsp;к значению, отличному от проверяемых:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">analyzeGold</span> <span class="token operator">::</span> <span class="token constant">Int</span> <span class="token operator">-&gt;</span> <span class="token constant">String</span>
<span class="token hvariable">analyzeGold</span> <span class="token hvariable">standard</span> <span class="token operator">=</span>
  <span class="token keyword">if</span> <span class="token operator">|</span> <span class="token hvariable">standard</span> <span class="token operator">==</span> <span class="token number">999</span> <span class="token operator">-&gt;</span> <span class="token string">"Wow! 999 standard!"</span>
     <span class="token operator">|</span> <span class="token hvariable">standard</span> <span class="token operator">==</span> <span class="token number">750</span> <span class="token operator">-&gt;</span> <span class="token string">"Great! 750 standard."</span>
     <span class="token operator">|</span> <span class="token hvariable">standard</span> <span class="token operator">==</span> <span class="token number">585</span> <span class="token operator">-&gt;</span> <span class="token string">"Not bad! 585 standard."</span>

<span class="token hvariable">main</span> <span class="token operator">::</span> <span class="token constant">IO</span> <span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token hvariable">main</span> <span class="token operator">=</span> <span class="token builtin">putStrLn</span> <span class="token punctuation">(</span><span class="token hvariable">analyzeGold</span> <span class="token number">583</span><span class="token punctuation">)</span>  <span class="token comment">-- Ой...</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>компиляция завершится успешно, однако в момент запуска программы вас ожидает неприятный сюрприз в виде ошибки:</p></div><div><pre class="language-bash" tabindex="0"><code class="language-bash is-loaded">Non-exhaustive guards <span class="token keyword">in</span> multi-way <span class="token keyword">if</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Проверка получилась неполной, вот и получите ошибку.</p></div><div><p>Кстати, видите слово&nbsp;<code>guards</code>&nbsp;в сообщении об ошибке? Вертикальные черты перед логическими выражениями — это и есть охранники (англ. guard), неусыпно охраняющие наши условия. Потешное название выбрали. Чтобы читать их было легче, воспринимайте их как аналог слова «ИЛИ».</p></div><div><p>А сейчас стоп. Вы ведь попробовали скомпилировать этот код, не так ли? А почему вы не ругаетесь? Ведь такой код не скомпилируется, так как не хватает одной маленькой, но важной детали. Вот как должен выглядеть модуль&nbsp;<code>Main</code>:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token comment">{-# LANGUAGE MultiWayIf #-}</span>  <span class="token comment">-- Что это??</span>

<span class="token keyword">module</span> <span class="token constant">Main</span> <span class="token keyword">where</span>

<span class="token hvariable">analyzeGold</span> <span class="token operator">::</span> <span class="token constant">Int</span> <span class="token operator">-&gt;</span> <span class="token constant">String</span>
<span class="token hvariable">analyzeGold</span> <span class="token hvariable">standard</span> <span class="token operator">=</span>
  <span class="token keyword">if</span> <span class="token operator">|</span> <span class="token hvariable">standard</span> <span class="token operator">==</span> <span class="token number">999</span> <span class="token operator">-&gt;</span> <span class="token string">"Wow! 999 standard!"</span>
     <span class="token operator">|</span> <span class="token hvariable">standard</span> <span class="token operator">==</span> <span class="token number">750</span> <span class="token operator">-&gt;</span> <span class="token string">"Great! 750 standard."</span>
     <span class="token operator">|</span> <span class="token hvariable">standard</span> <span class="token operator">==</span> <span class="token number">585</span> <span class="token operator">-&gt;</span> <span class="token string">"Not bad! 585 standard."</span>
     <span class="token operator">|</span> <span class="token builtin">otherwise</span> <span class="token operator">-&gt;</span> <span class="token string">"I don't know such a standard..."</span>

<span class="token hvariable">main</span> <span class="token operator">::</span> <span class="token constant">IO</span> <span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token hvariable">main</span> <span class="token operator">=</span> <span class="token builtin">putStrLn</span> <span class="token punctuation">(</span><span class="token hvariable">analyzeGold</span> <span class="token number">999</span><span class="token punctuation">)</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Вот теперь всё в порядке. Но что это за странный комментарий в первой строке модуля? Вроде бы оформлен как многострочный комментарий, но выглядит необычно. Перед нами — указание расширения языка Haskell.</p></div><div><p>Стандарт&nbsp;<a data-tooltip-position="top" aria-label="https://www.haskell.org/onlinereport/haskell2010/" rel="noopener" class="external-link" href="https://www.haskell.org/onlinereport/haskell2010/" target="_blank">Haskell 2010</a>&nbsp;— это официальный стержень языка. Однако компилятор GHC, давно уж ставший компилятором по умолчанию при разработке на Haskell, обладает рядом особых возможностей. По умолчанию многие из этих возможностей выключены, а прагма&nbsp;<code>LANGUAGE</code>&nbsp;как раз для того и предназначена, чтобы их включать/активизировать. В данном случае мы включили расширение&nbsp;<code>MultiWayIf</code>. Именно это расширение позволяет нам использовать множественный&nbsp;<code>if</code>. Такого рода расширений существует очень много, и мы будем часто их использовать.</p></div><div><p>Помните: расширение, включённое с помощью прагмы&nbsp;<code>LANGUAGE</code>, действует лишь в рамках текущего модуля. И если я прописал его только в модуле&nbsp;<code>app/Main.hs</code>, то на модуль&nbsp;<code>src/Lib.hs</code>&nbsp;механизм&nbsp;<code>MultiWayIf</code>&nbsp;не распространяется.</p></div><div><h2 data-heading="Без Если" id="Без_Если" style="display: flex;"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>Без Если</h2></div><div><p>Множественный&nbsp;<code>if</code>&nbsp;весьма удобен, но есть способ более красивый. Взгляните:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">analyzeGold</span> <span class="token operator">::</span> <span class="token constant">Int</span> <span class="token operator">-&gt;</span> <span class="token constant">String</span>
<span class="token hvariable">analyzeGold</span> <span class="token hvariable">standard</span>
  <span class="token operator">|</span> <span class="token hvariable">standard</span> <span class="token operator">==</span> <span class="token number">999</span> <span class="token operator">=</span> <span class="token string">"Wow! 999 standard!"</span>
  <span class="token operator">|</span> <span class="token hvariable">standard</span> <span class="token operator">==</span> <span class="token number">750</span> <span class="token operator">=</span> <span class="token string">"Great! 750 standard."</span>
  <span class="token operator">|</span> <span class="token hvariable">standard</span> <span class="token operator">==</span> <span class="token number">585</span> <span class="token operator">=</span> <span class="token string">"Not bad! 585 standard."</span>
  <span class="token operator">|</span> <span class="token builtin">otherwise</span> <span class="token operator">=</span> <span class="token string">"I don't know such a standard..."</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Ключевое слово&nbsp;<code>if</code>&nbsp;исчезло. Схема здесь такая:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">function</span> <span class="token hvariable">arg</span>  <span class="token comment">-- Нет знака равенства?</span>
  <span class="token operator">|</span> <span class="token constant">COND1</span> <span class="token operator">=</span> <span class="token constant">EXPR1</span>
  <span class="token operator">|</span> <span class="token constant">COND2</span> <span class="token operator">=</span> <span class="token constant">EXPR2</span>
  <span class="token operator">|</span> <span class="token operator">...</span>
  <span class="token operator">|</span> <span class="token constant">CONDn</span> <span class="token operator">=</span> <span class="token constant">EXPRn</span>
  <span class="token operator">|</span> <span class="token builtin">otherwise</span> <span class="token operator">=</span> <span class="token constant">COMMON_EXPR</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Устройство почти такое же, но, помимо исчезновения ключевого слова&nbsp;<code>if</code>, мы теперь используем знаки равенства вместо стрелок. Именно поэтому исчез знакомый нам знак равенства после имени аргумента&nbsp;<code>arg</code>. В действительности он, конечно, никуда не исчез, он лишь перешёл в выражения. А чтобы это легче прочесть, напишем выражения в строчку:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">function</span> <span class="token hvariable">arg</span>  <span class="token operator">|</span>    <span class="token constant">COND1</span>     <span class="token operator">=</span>      <span class="token constant">EXPR1</span>     <span class="token operator">|</span>    <span class="token operator">...</span>

эта           или            равна
функция
                                    этому
                                    выражению

                   в случае
                   истинности
                   этого
                   выражения
                                              или  и т<span class="token punctuation">.</span>д<span class="token punctuation">.</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>То есть перед нами уже не одно определение функции, а цепочка определений, потому нам и не нужно ключевое слово&nbsp;<code>if</code>. Но и эту цепочку определений можно упростить.</p></div><div><h2 data-heading="Сравнение с образцом" id="Сравнение_с_образцом" style="display: flex;"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>Сравнение с образцом</h2></div><div><p>Убрав слово&nbsp;<code>if</code>, мы и с нашими виртуальными «ИЛИ» можем расстаться. В этом случае останется лишь это:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">analyzeGold</span> <span class="token operator">::</span> <span class="token constant">Int</span> <span class="token operator">-&gt;</span> <span class="token constant">String</span>  <span class="token comment">-- Одно объявление.</span>
<span class="token comment">-- И множество определений...</span>
<span class="token hvariable">analyzeGold</span> <span class="token number">999</span> <span class="token operator">=</span> <span class="token string">"Wow! 999 standard!"</span>
<span class="token hvariable">analyzeGold</span> <span class="token number">750</span> <span class="token operator">=</span> <span class="token string">"Great! 750 standard."</span>
<span class="token hvariable">analyzeGold</span> <span class="token number">585</span> <span class="token operator">=</span> <span class="token string">"Not bad! 585 standard."</span>
<span class="token hvariable">analyzeGold</span> <span class="token hvariable">_</span>   <span class="token operator">=</span> <span class="token string">"I don't know such a standard..."</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Мы просто перечислили определения функции&nbsp;<code>analyzeGold</code>&nbsp;одно за другим. На первый взгляд, возможность множества определений одной и той же функции удивляет, но если вспомнить, что применение функции суть выражение, тогда ничего удивительного. Вот как это читается:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded">      <span class="token hvariable">analyzeGold</span>  <span class="token number">999</span>          <span class="token operator">=</span>      <span class="token string">"Wow! 999 standard!"</span>

если  эта функция  применяется  тогда  этому выражению
                   к этому      она
                   аргументу    равна

      <span class="token hvariable">analyzeGold</span>  <span class="token number">750</span>          <span class="token operator">=</span>      <span class="token string">"Wow! 999 standard!"</span>

если  эта функция  применяется  тогда  другому выражению
                   к другому    она
                   аргументу    равна
<span class="token operator">...</span>
       <span class="token hvariable">analyzeGold</span> <span class="token hvariable">_</span> <span class="token operator">=</span>      <span class="token string">"I don't know such a standard..."</span>

иначе  эта функция   равна  общему выражению
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Когда функция&nbsp;<code>analyzeGold</code>&nbsp;применяется к конкретному аргументу, этот аргумент последовательно сравнивается с образцом (англ. pattern matching). Образца здесь три:&nbsp;<code>999</code>,&nbsp;<code>750</code>&nbsp;и&nbsp;<code>585</code>. И если раньше мы сравнивали аргумент с этими числовыми значениями явно, посредством функции&nbsp;<code>==</code>, теперь это происходит скрыто. Идея сравнения с образцом очень проста: что-то (в данном случае реальный аргумент) сопоставляется с образцом (или образцами) на предмет «подходит/не подходит». Если подходит — то есть сравнение с образцом даёт результат&nbsp;<code>True</code>&nbsp;— готово, используем соответствующее выражение. Если же не подходит — переходим к следующему образцу.</p></div><div><p>Сравнение с образцом, называемое ещё «сопоставлением с образцом» используется в Haskell чрезвычайно широко. В русскоязычной литературе перевод словосочетания «pattern matching» не особо закрепился, вместо этого так и говорят «паттерн матчинг». Я поступлю так же.</p></div><div><p>Но что это за символ подчёркивания такой, в последнем варианте определения? Вот этот:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">analyzeGold</span> <span class="token hvariable">_</span> <span class="token operator">=</span> <span class="token string">"I don't know such a standard..."</span>
            <span class="token operator">^</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>С формальной точки зрения, это — универсальный образец, сравнение с которым всегда истинно (ещё говорят, что с ним матчится (англ. match) всё что угодно). А с неформальной — это символ, который можно прочесть как «мне всё равно». Мы как бы говорим: «В данном случае нас не интересует конкретное содержимое аргумента, нам всё равно, мы просто возвращаем строку&nbsp;<code>I don't know such a standard...</code>».</p></div><div><p>Важно отметить, что сравнение аргумента с образцами происходит последовательно, сверху вниз. Поэтому если мы напишем так:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">analyzeGold</span> <span class="token operator">::</span> <span class="token constant">Int</span> <span class="token operator">-&gt;</span> <span class="token constant">String</span>
<span class="token hvariable">analyzeGold</span> <span class="token hvariable">_</span>   <span class="token operator">=</span> <span class="token string">"I don't know such a standard..."</span>
<span class="token hvariable">analyzeGold</span> <span class="token number">999</span> <span class="token operator">=</span> <span class="token string">"Wow! 999 standard!"</span>
<span class="token hvariable">analyzeGold</span> <span class="token number">750</span> <span class="token operator">=</span> <span class="token string">"Great! 750 standard."</span>
<span class="token hvariable">analyzeGold</span> <span class="token number">585</span> <span class="token operator">=</span> <span class="token string">"Not bad! 585 standard."</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>наша функция будет всегда возвращать первое выражение, строку&nbsp;<code>I don't know such a standard...</code>, и это вполне ожидаемо: первая же проверка гарантированно даст нам&nbsp;<code>True</code>, ведь с образцом&nbsp;<code>_</code>&nbsp;совпадает всё что угодно. Таким образом, общий образец следует располагать в самом конце, чтобы мы попали на него лишь после того, как не сработали все остальные образцы.</p></div><div><h2 data-heading="case" id="case" style="display: flex;"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>case</h2></div><div><p>Существует ещё один вид паттерн матчинга, с помощью конструкции&nbsp;<code>case-of</code>:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">analyzeGold</span> <span class="token hvariable">standard</span> <span class="token operator">=</span>
  <span class="token keyword">case</span> <span class="token hvariable">standard</span> <span class="token keyword">of</span>
    <span class="token number">999</span> <span class="token operator">-&gt;</span> <span class="token string">"Wow! 999 standard!"</span>
    <span class="token number">750</span> <span class="token operator">-&gt;</span> <span class="token string">"Great! 750 standard."</span>
    <span class="token number">585</span> <span class="token operator">-&gt;</span> <span class="token string">"Not bad! 585 standard."</span>
    <span class="token hvariable">_</span>   <span class="token operator">-&gt;</span> <span class="token string">"I don't know such a standard..."</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Запомните конструкцию&nbsp;<code>case-of</code>, мы встретимся с нею не раз. Работает она по модели:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token keyword">case</span> <span class="token constant">EXPRESSION</span> <span class="token keyword">of</span>
  <span class="token constant">PATTERN1</span> <span class="token operator">-&gt;</span> <span class="token constant">EXPR1</span>
  <span class="token constant">PATTERN2</span> <span class="token operator">-&gt;</span> <span class="token constant">EXPR2</span>
  <span class="token operator">...</span>
  <span class="token constant">PATTERNn</span> <span class="token operator">-&gt;</span> <span class="token constant">EXPRn</span>
  <span class="token hvariable">_</span>        <span class="token operator">-&gt;</span> <span class="token constant">COMMON_EXPR</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>где&nbsp;<code>EXPRESSION</code>&nbsp;— анализируемое выражение, последовательно сравниваемое с образцами&nbsp;<code>PATTERN1..n</code>. Если ни одно не сработало — как обычно, упираемся в универсальный образец&nbsp;<code>_</code>&nbsp;и выдаём&nbsp;<code>COMMON_EXPR</code>.</p></div><div><p>В последующих главах мы встретимся и с другими видами паттерн матчинга, ведь он используется не только для выбора.</p></div><div><h1 data-heading="Пусть будет там, Где…" id="Пусть_будет_там,_Где…">Пусть будет там, Где…</h1></div><div><p>В этой главе мы узнаем, как сделать наши функции более удобными и читабельными.</p></div><div><h2 data-heading="Пусть" id="Пусть" style="display: flex;"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>Пусть</h2></div><div><p>В нижеследующих примерах мы вновь будем использовать расширение GHC&nbsp;<code>MultiWayIf</code>, не забудьте включить его. Рассмотрим следующую функцию:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">calculateTime</span> <span class="token operator">::</span> <span class="token constant">Int</span> <span class="token operator">-&gt;</span> <span class="token constant">Int</span>
<span class="token hvariable">calculateTime</span> <span class="token hvariable">timeInS</span> <span class="token operator">=</span>
  <span class="token keyword">if</span> <span class="token operator">|</span> <span class="token hvariable">timeInS</span> <span class="token operator">&lt;</span>  <span class="token number">40</span> <span class="token operator">-&gt;</span> <span class="token hvariable">timeInS</span> <span class="token operator">+</span> <span class="token number">120</span>
     <span class="token operator">|</span> <span class="token hvariable">timeInS</span> <span class="token operator">&gt;=</span> <span class="token number">40</span> <span class="token operator">-&gt;</span> <span class="token hvariable">timeInS</span> <span class="token operator">+</span> <span class="token number">8</span> <span class="token operator">+</span> <span class="token number">120</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Мы считаем время некоторого события, и если исходное время меньше&nbsp;<code>40</code>&nbsp;секунд — результирующее время увеличено на&nbsp;<code>120</code>&nbsp;секунд, в противном случае — ещё на&nbsp;<code>8</code>&nbsp;секунд сверх того. Перед нами классический пример «магических чисел» (англ. magic numbers), когда смысл конкретных значений скрыт за семью печатями. Что за&nbsp;<code>40</code>, и что за&nbsp;<code>8</code>? Во избежание этой проблемы можно ввести временные выражения, и тогда код станет совсем другим:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">calculateTime</span> <span class="token operator">::</span> <span class="token constant">Int</span> <span class="token operator">-&gt;</span> <span class="token constant">Int</span>
<span class="token hvariable">calculateTime</span> <span class="token hvariable">timeInS</span> <span class="token operator">=</span>
  <span class="token keyword">let</span> <span class="token hvariable">threshold</span>  <span class="token operator">=</span> <span class="token number">40</span>
      <span class="token hvariable">correction</span> <span class="token operator">=</span> <span class="token number">120</span>
      <span class="token hvariable">delta</span>      <span class="token operator">=</span> <span class="token number">8</span>
  <span class="token keyword">in</span>
  <span class="token keyword">if</span> <span class="token operator">|</span> <span class="token hvariable">timeInS</span> <span class="token operator">&lt;</span>  <span class="token hvariable">threshold</span> <span class="token operator">-&gt;</span> <span class="token hvariable">timeInS</span> <span class="token operator">+</span> <span class="token hvariable">correction</span>
     <span class="token operator">|</span> <span class="token hvariable">timeInS</span> <span class="token operator">&gt;=</span> <span class="token hvariable">threshold</span> <span class="token operator">-&gt;</span> <span class="token hvariable">timeInS</span> <span class="token operator">+</span> <span class="token hvariable">delta</span> <span class="token operator">+</span> <span class="token hvariable">correction</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Вот, совсем другое дело! Мы избавились от «магических чисел», введя поясняющие выражения&nbsp;<code>threshold</code>,&nbsp;<code>correction</code>&nbsp;и&nbsp;<code>delta</code>. Конструкция&nbsp;<code>let-in</code>&nbsp;вводит поясняющие выражения по схеме:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token keyword">let</span> <span class="token constant">DECLARATIONS</span> <span class="token keyword">in</span> <span class="token constant">EXPRESSION</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>где&nbsp;<code>DECLARATIONS</code>&nbsp;— выражения, декларируемые нами, а&nbsp;<code>EXPRESSION</code>&nbsp;— выражение, в котором используется выражения из&nbsp;<code>DECLARATION</code>. Когда мы написали:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token keyword">let</span> <span class="token hvariable">threshold</span> <span class="token operator">=</span> <span class="token number">40</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>мы объявили: «Отныне выражение&nbsp;<code>threshold</code>&nbsp;равно выражению&nbsp;<code>40</code>». Выглядит как присваивание, но мы-то уже знаем, что в Haskell его нет. Теперь выражение&nbsp;<code>threshold</code>&nbsp;может заменить собою число&nbsp;<code>40</code>&nbsp;внутри выражения, следующего за словом&nbsp;<code>in</code>:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded">  <span class="token keyword">let</span> <span class="token hvariable">threshold</span> <span class="token operator">=</span> <span class="token number">40</span>
      <span class="token operator">...</span>
  <span class="token keyword">in</span> <span class="token keyword">if</span> <span class="token operator">|</span> <span class="token hvariable">timeInS</span> <span class="token operator">&lt;</span>  <span class="token hvariable">threshold</span> <span class="token operator">-&gt;</span> <span class="token operator">...</span>
        <span class="token operator">|</span> <span class="token hvariable">timeInS</span> <span class="token operator">&gt;=</span> <span class="token hvariable">threshold</span> <span class="token operator">-&gt;</span> <span class="token operator">...</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Эта конструкция легко читается:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token keyword">let</span>    <span class="token hvariable">threshold</span>  <span class="token operator">=</span>      <span class="token number">40</span>       <span class="token operator">...</span> <span class="token keyword">in</span> <span class="token operator">...</span>

пусть  это        будет  этому        в  том
       выражение  равно  выражению       выражении
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>С помощью ключевого слова&nbsp;<code>let</code>&nbsp;можно ввести сколько угодно пояснительных/промежуточных выражений, что делает наш код понятнее, а во многих случаях ещё и короче.</p></div><div><p>И кстати, мы ведь можем упростить условную конструкцию, воспользовавшись&nbsp;<code>otherwise</code>:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">calculateTime</span> <span class="token operator">::</span> <span class="token constant">Int</span> <span class="token operator">-&gt;</span> <span class="token constant">Int</span>
<span class="token hvariable">calculateTime</span> <span class="token hvariable">timeInS</span> <span class="token operator">=</span>
  <span class="token keyword">let</span> <span class="token hvariable">threshold</span>  <span class="token operator">=</span> <span class="token number">40</span>
      <span class="token hvariable">correction</span> <span class="token operator">=</span> <span class="token number">120</span>
      <span class="token hvariable">delta</span>      <span class="token operator">=</span> <span class="token number">8</span>
  <span class="token keyword">in</span>
  <span class="token keyword">if</span> <span class="token operator">|</span> <span class="token hvariable">timeInS</span> <span class="token operator">&lt;</span> <span class="token hvariable">threshold</span> <span class="token operator">-&gt;</span> <span class="token hvariable">timeInS</span> <span class="token operator">+</span> <span class="token hvariable">correction</span>
     <span class="token operator">|</span> <span class="token builtin">otherwise</span> <span class="token operator">-&gt;</span> <span class="token hvariable">timeInS</span> <span class="token operator">+</span> <span class="token hvariable">delta</span> <span class="token operator">+</span> <span class="token hvariable">correction</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Важно помнить, что введённое конструкцией&nbsp;<code>let-in</code>&nbsp;выражение существует лишь в рамках выражения, следующего за словом&nbsp;<code>in</code>. Изменим функцию:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">calculateTime</span> <span class="token operator">::</span> <span class="token constant">Int</span> <span class="token operator">-&gt;</span> <span class="token constant">Int</span>
<span class="token hvariable">calculateTime</span> <span class="token hvariable">timeInS</span> <span class="token operator">=</span>
  <span class="token keyword">let</span> <span class="token hvariable">threshold</span>  <span class="token operator">=</span> <span class="token number">40</span>
      <span class="token hvariable">correction</span> <span class="token operator">=</span> <span class="token number">120</span>
  <span class="token keyword">in</span>
  <span class="token keyword">if</span> <span class="token operator">|</span> <span class="token hvariable">timeInS</span> <span class="token operator">&lt;</span> <span class="token hvariable">threshold</span> <span class="token operator">-&gt;</span> <span class="token hvariable">timeInS</span> <span class="token operator">+</span> <span class="token hvariable">correction</span>
     <span class="token operator">|</span> <span class="token builtin">otherwise</span> <span class="token operator">-&gt;</span>
        <span class="token keyword">let</span> <span class="token hvariable">delta</span>     <span class="token operator">=</span> <span class="token number">8</span> <span class="token keyword">in</span> <span class="token hvariable">timeInS</span>
                             <span class="token operator">+</span> <span class="token hvariable">delta</span>
                             <span class="token operator">+</span> <span class="token hvariable">correction</span>

            это              существует лишь в
            выражение        рамках этого выражения
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Мы сократили область видимости промежуточного выражения&nbsp;<code>delta</code>, сделав его видимым лишь в выражении&nbsp;<code>timeInS + delta + correction</code>.</p></div><div><p>При желании&nbsp;<code>let</code>-выражения можно записывать и в строчку:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded">  <span class="token operator">...</span>
  <span class="token keyword">let</span> <span class="token hvariable">threshold</span> <span class="token operator">=</span> <span class="token number">40</span><span class="token punctuation">;</span> <span class="token hvariable">correction</span> <span class="token operator">=</span> <span class="token number">120</span>
  <span class="token keyword">in</span>
  <span class="token keyword">if</span> <span class="token operator">|</span> <span class="token hvariable">timeInS</span> <span class="token operator">&lt;</span> <span class="token hvariable">threshold</span> <span class="token operator">-&gt;</span> <span class="token hvariable">timeInS</span> <span class="token operator">+</span> <span class="token hvariable">correction</span>
     <span class="token operator">|</span> <span class="token builtin">otherwise</span> <span class="token operator">-&gt;</span>
        <span class="token keyword">let</span> <span class="token hvariable">delta</span> <span class="token operator">=</span> <span class="token number">8</span> <span class="token keyword">in</span> <span class="token hvariable">timeInS</span> <span class="token operator">+</span> <span class="token hvariable">delta</span> <span class="token operator">+</span> <span class="token hvariable">correction</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>В этом случае мы перечисляем их через точку с запятой. Лично мне такой стиль не нравится, но выбирать вам.</p></div><div><h2 data-heading="Где" id="Где" style="display: flex;"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>Где</h2></div><div><p>Существует иной способ введения промежуточных выражений, взгляните:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">calculateTime</span> <span class="token operator">::</span> <span class="token constant">Int</span> <span class="token operator">-&gt;</span> <span class="token constant">Int</span>
<span class="token hvariable">calculateTime</span> <span class="token hvariable">timeInS</span> <span class="token operator">=</span>
  <span class="token keyword">if</span> <span class="token operator">|</span> <span class="token hvariable">timeInS</span> <span class="token operator">&lt;</span> <span class="token hvariable">threshold</span> <span class="token operator">-&gt;</span> <span class="token hvariable">timeInS</span> <span class="token operator">+</span> <span class="token hvariable">correction</span>
     <span class="token operator">|</span> <span class="token builtin">otherwise</span> <span class="token operator">-&gt;</span> <span class="token hvariable">timeInS</span> <span class="token operator">+</span>
                    <span class="token hvariable">delta</span> <span class="token operator">+</span>
                    <span class="token hvariable">correction</span>
  <span class="token keyword">where</span>
    <span class="token hvariable">threshold</span>  <span class="token operator">=</span> <span class="token number">40</span>
    <span class="token hvariable">correction</span> <span class="token operator">=</span> <span class="token number">120</span>
    <span class="token hvariable">delta</span>      <span class="token operator">=</span> <span class="token number">8</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Ключевое слово&nbsp;<code>where</code>&nbsp;делает примерно то же, что и&nbsp;<code>let</code>, но промежуточные выражения задаются в конце функции. Такая конструкция читается подобно научной формуле:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded">  <span class="token constant">S</span> <span class="token operator">=</span> <span class="token constant">V</span> <span class="token operator">*</span> <span class="token hvariable">t</span><span class="token punctuation">,</span>      <span class="token comment">-- Выражение</span>
где
  <span class="token comment">-- Всё то, что</span>
  <span class="token comment">-- используется</span>
  <span class="token comment">-- в выражении.</span>
  <span class="token constant">S</span> <span class="token operator">=</span> расстояние<span class="token punctuation">,</span>
  <span class="token constant">V</span> <span class="token operator">=</span> скорость<span class="token punctuation">,</span>
  <span class="token hvariable">t</span> <span class="token operator">=</span> время<span class="token punctuation">.</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>В отличие от&nbsp;<code>let</code>, которое может быть использовано для введения супер-локального выражения (как в последнем примере с&nbsp;<code>delta</code>), все&nbsp;<code>where</code>-выражения доступны в любой части выражения, предшествующего ключевому слову&nbsp;<code>where</code>.</p></div><div><h2 data-heading="Вместе" id="Вместе" style="display: flex;"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>Вместе</h2></div><div><p>Мы можем использовать&nbsp;<code>let-in</code>&nbsp;и&nbsp;<code>where</code>&nbsp;совместно, в рамках одной функции:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">calculateTime</span> <span class="token operator">::</span> <span class="token constant">Int</span> <span class="token operator">-&gt;</span> <span class="token constant">Int</span>
<span class="token hvariable">calculateTime</span> <span class="token hvariable">timeInS</span> <span class="token operator">=</span>
  <span class="token keyword">let</span> <span class="token hvariable">threshold</span> <span class="token operator">=</span> <span class="token number">40</span> <span class="token keyword">in</span>
  <span class="token keyword">if</span> <span class="token operator">|</span> <span class="token hvariable">timeInS</span> <span class="token operator">&lt;</span> <span class="token hvariable">threshold</span> <span class="token operator">-&gt;</span> <span class="token hvariable">timeInS</span> <span class="token operator">+</span> <span class="token hvariable">correction</span>
     <span class="token operator">|</span> <span class="token builtin">otherwise</span> <span class="token operator">-&gt;</span> <span class="token hvariable">timeInS</span> <span class="token operator">+</span> <span class="token hvariable">delta</span> <span class="token operator">+</span> <span class="token hvariable">correction</span>
  <span class="token keyword">where</span>
    <span class="token hvariable">correction</span> <span class="token operator">=</span> <span class="token number">120</span>
    <span class="token hvariable">delta</span>      <span class="token operator">=</span> <span class="token number">8</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Часть промежуточных значений задана вверху, а часть — внизу. Общая рекомендация: не смешивайте&nbsp;<code>let-in</code>&nbsp;и&nbsp;<code>where</code>&nbsp;без особой надобности, такой код читается тяжело, избыточно.</p></div><div><p>Отмечу, что в качестве промежуточных могут выступать и более сложные выражения. Например:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">calculateTime</span> <span class="token operator">::</span> <span class="token constant">Int</span> <span class="token operator">-&gt;</span> <span class="token constant">Int</span>
<span class="token hvariable">calculateTime</span> <span class="token hvariable">timeInS</span> <span class="token operator">=</span>
  <span class="token keyword">let</span> <span class="token hvariable">threshold</span> <span class="token operator">=</span> <span class="token number">40</span> <span class="token keyword">in</span>
  <span class="token keyword">if</span> <span class="token operator">|</span> <span class="token hvariable">timeInS</span> <span class="token operator">&lt;</span> <span class="token hvariable">threshold</span> <span class="token operator">-&gt;</span> <span class="token hvariable">timeInS</span> <span class="token operator">+</span> <span class="token hvariable">correction</span>
     <span class="token operator">|</span> <span class="token builtin">otherwise</span> <span class="token operator">-&gt;</span> <span class="token hvariable">timeInS</span> <span class="token operator">+</span> <span class="token hvariable">delta</span> <span class="token operator">+</span> <span class="token hvariable">correction</span>
  <span class="token keyword">where</span>
    <span class="token comment">-- Это промежуточное выражение зависит от аргумента...</span>
    <span class="token hvariable">correction</span> <span class="token operator">=</span> <span class="token hvariable">timeInS</span> <span class="token operator">*</span> <span class="token number">2</span>
    <span class="token comment">-- А это - от другого выражения...</span>
    <span class="token hvariable">delta</span>      <span class="token operator">=</span> <span class="token hvariable">correction</span> <span class="token operator">-</span> <span class="token number">4</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Выражение&nbsp;<code>correction</code>&nbsp;равно&nbsp;<code>timeInS * 2</code>, то есть теперь оно зависит от значения аргумента функции. А выражение&nbsp;<code>delta</code>&nbsp;зависит в свою очередь от&nbsp;<code>correction</code>. Причём мы можем менять порядок задания выражений:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded">  <span class="token operator">...</span>
  <span class="token keyword">let</span> <span class="token hvariable">threshold</span> <span class="token operator">=</span> <span class="token number">40</span>
  <span class="token keyword">in</span>
  <span class="token keyword">if</span> <span class="token operator">|</span> <span class="token hvariable">timeInS</span> <span class="token operator">&lt;</span> <span class="token hvariable">threshold</span> <span class="token operator">-&gt;</span> <span class="token hvariable">timeInS</span> <span class="token operator">+</span> <span class="token hvariable">correction</span>
     <span class="token operator">|</span> <span class="token builtin">otherwise</span> <span class="token operator">-&gt;</span> <span class="token hvariable">timeInS</span> <span class="token operator">+</span> <span class="token hvariable">delta</span> <span class="token operator">+</span> <span class="token hvariable">correction</span>
  <span class="token keyword">where</span>
    <span class="token hvariable">delta</span>      <span class="token operator">=</span> <span class="token hvariable">correction</span> <span class="token operator">-</span> <span class="token number">4</span>
    <span class="token hvariable">correction</span> <span class="token operator">=</span> <span class="token hvariable">timeInS</span> <span class="token operator">*</span> <span class="token number">2</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Выражение&nbsp;<code>delta</code>&nbsp;теперь задано первым по счёту, но это не имеет никакого значения. Ведь мы всего лишь объявляем равенства, и результат этих объявлений не влияет на конечный результат вычислений. Конечно, порядок объявления равенств не важен и для&nbsp;<code>let</code>-выражений:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">calculateTime</span> <span class="token operator">::</span> <span class="token constant">Int</span> <span class="token operator">-&gt;</span> <span class="token constant">Int</span>
<span class="token hvariable">calculateTime</span> <span class="token hvariable">timeInS</span> <span class="token operator">=</span>
  <span class="token keyword">let</span> <span class="token hvariable">delta</span>     <span class="token operator">=</span> <span class="token hvariable">correction</span> <span class="token operator">-</span> <span class="token number">4</span>
      <span class="token hvariable">threshold</span> <span class="token operator">=</span> <span class="token number">40</span>
  <span class="token keyword">in</span>
  <span class="token keyword">if</span> <span class="token operator">|</span> <span class="token hvariable">timeInS</span> <span class="token operator">&lt;</span> <span class="token hvariable">threshold</span> <span class="token operator">-&gt;</span> <span class="token hvariable">timeInS</span> <span class="token operator">+</span> <span class="token hvariable">correction</span>
     <span class="token operator">|</span> <span class="token builtin">otherwise</span> <span class="token operator">-&gt;</span> <span class="token hvariable">timeInS</span> <span class="token operator">+</span> <span class="token hvariable">delta</span> <span class="token operator">+</span> <span class="token hvariable">correction</span>
  <span class="token keyword">where</span>
    <span class="token hvariable">correction</span> <span class="token operator">=</span> <span class="token hvariable">timeInS</span> <span class="token operator">*</span> <span class="token number">2</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Мало того, что мы задали&nbsp;<code>let</code>-выражения в другом порядке, так мы ещё и использовали в одном из них выражение&nbsp;<code>correction</code>! То есть в&nbsp;<code>let</code>-выражении использовалось&nbsp;<code>where</code>-выражение. А вот проделать обратное, увы, не получится:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">calculateTime</span> <span class="token operator">::</span> <span class="token constant">Int</span> <span class="token operator">-&gt;</span> <span class="token constant">Int</span>
<span class="token hvariable">calculateTime</span> <span class="token hvariable">timeInS</span> <span class="token operator">=</span>
  <span class="token keyword">let</span> <span class="token hvariable">delta</span>     <span class="token operator">=</span> <span class="token hvariable">correction</span> <span class="token operator">-</span> <span class="token number">4</span>
      <span class="token hvariable">threshold</span> <span class="token operator">=</span> <span class="token number">40</span>
  <span class="token keyword">in</span>
  <span class="token keyword">if</span> <span class="token operator">|</span> <span class="token hvariable">timeInS</span> <span class="token operator">&lt;</span> <span class="token hvariable">threshold</span> <span class="token operator">-&gt;</span> <span class="token hvariable">timeInS</span> <span class="token operator">+</span> <span class="token hvariable">correction</span>
     <span class="token operator">|</span> <span class="token builtin">otherwise</span> <span class="token operator">-&gt;</span> <span class="token hvariable">timeInS</span> <span class="token operator">+</span> <span class="token hvariable">delta</span> <span class="token operator">+</span> <span class="token hvariable">correction</span>
  <span class="token keyword">where</span>
    <span class="token hvariable">correction</span> <span class="token operator">=</span> <span class="token hvariable">timeInS</span> <span class="token operator">*</span> <span class="token number">2</span> <span class="token operator">*</span> <span class="token hvariable">threshold</span> <span class="token comment">-- Из let??</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>При попытке скомпилировать такой код мы получим ошибку:</p></div><div><pre class="language-bash" tabindex="0"><code class="language-bash is-loaded">Not <span class="token keyword">in</span> scope: ‘threshold’
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Таково ограничение: использовать&nbsp;<code>let</code>-выражения внутри&nbsp;<code>where</code>-выражений невозможно, ведь последние уже не входят в выражение, следующее за словом&nbsp;<code>in</code>.</p></div><div><p>Ну что ж, пора двигаться дальше, ведь внутренности наших функций не ограничены условными конструкциями.</p></div><div><h1 data-heading="Мир операторов" id="Мир_операторов">Мир операторов</h1></div><div><p>Оператор (англ. operator) — частный случай функции. В предыдущих главах мы уже познакомились с ними, осталось объяснить подробнее.</p></div><div><p>Вспомним наше самое первое выражение:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token number">1</span> <span class="token operator">+</span> <span class="token number">2</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Функция&nbsp;<code>+</code>&nbsp;записана в инфиксной (англ. infix) форме, то есть между своими аргументами. Такая запись выглядит естественнее, нежели обычная:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token punctuation">(</span><span class="token operator">+</span><span class="token punctuation">)</span> <span class="token number">1</span> <span class="token number">2</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Видите круглые скобки? Они говорят о том, что данная функция предназначена для инфиксной записи. Автор этой функции изначально рассчитывал на инфиксную форму использования&nbsp;<code>1 + 2</code>, а не на обычную&nbsp;<code>(+) 1 2</code>, именно поэтому имя функции в определении заключено в круглые скобки:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token punctuation">(</span><span class="token operator">+</span><span class="token punctuation">)</span> <span class="token operator">::</span> <span class="token operator">...</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Функции, предназначенные для инфиксной формы применения, называют операторами.</p></div><div><p>Если же имя функции не заключено в круглые скобки, подразумевается, что мы рассчитываем на обычную форму её применения. Однако и в этом случае можно применять её инфиксно, но имя должно заключаться в обратные одинарные кавычки (англ. backtick).</p></div><div><p>Определим функцию&nbsp;<code>isEqualTo</code>, являющуюся аналогом оператора проверки на равенство для двух целочисленных значений:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">isEqualTo</span> <span class="token operator">::</span> <span class="token constant">Int</span> <span class="token operator">-&gt;</span> <span class="token constant">Int</span> <span class="token operator">-&gt;</span> <span class="token constant">Bool</span>
<span class="token hvariable">isEqualTo</span> <span class="token hvariable">x</span> <span class="token hvariable">y</span> <span class="token operator">=</span> <span class="token hvariable">x</span> <span class="token operator">==</span> <span class="token hvariable">y</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>При обычной форме её применение выглядело бы так:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded">  <span class="token operator">...</span>
  <span class="token keyword">if</span> <span class="token hvariable">isEqualTo</span> <span class="token hvariable">code1</span> <span class="token hvariable">code2</span> <span class="token keyword">then</span> <span class="token operator">...</span> <span class="token keyword">else</span> <span class="token operator">...</span>
  <span class="token keyword">where</span> <span class="token hvariable">code1</span> <span class="token operator">=</span> <span class="token number">123</span>
        <span class="token hvariable">code2</span> <span class="token operator">=</span> <span class="token number">124</span>
  <span class="token operator">...</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Но давайте перепишем в инфиксной форме:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded">  <span class="token operator">...</span>
  <span class="token keyword">if</span> <span class="token hvariable">code1</span> <span class="token operator">`isEqualTo`</span> <span class="token hvariable">code2</span> <span class="token keyword">then</span> <span class="token operator">...</span> <span class="token keyword">else</span> <span class="token operator">...</span>
  <span class="token keyword">where</span> <span class="token hvariable">code1</span> <span class="token operator">=</span> <span class="token number">123</span>
        <span class="token hvariable">code2</span> <span class="token operator">=</span> <span class="token number">124</span>
  <span class="token operator">...</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Гораздо лучше, ведь теперь код читается как обычный английский текст:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded">  <span class="token operator">...</span>
  <span class="token keyword">if</span> <span class="token hvariable">code1</span> <span class="token operator">`isEqualTo`</span> <span class="token hvariable">code2</span> <span class="token operator">...</span>
  <span class="token keyword">if</span> <span class="token hvariable">code1</span> <span class="token hvariable">is</span> <span class="token hvariable">equal</span> <span class="token hvariable">to</span> <span class="token hvariable">code2</span> <span class="token operator">...</span>
  <span class="token operator">...</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Строго говоря, название «оператор» весьма условно, мы можем его и не использовать. Говорить о функции сложения столь же корректно, как и об операторе сложения.</p></div><div><h2 data-heading="Зачем это нужно?" id="Зачем_это_нужно?" style="display: flex;"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>Зачем это нужно?</h2></div><div><p>Почти все ASCII-символы (а также их всевозможные комбинации) можно использовать в качестве операторов в Haskell. Это даёт нам широкие возможности для реализации различных EDSL (англ. Embedded Domain Specific Language), своего рода «языков в языке». Вот пример:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token builtin">div</span> <span class="token operator">!</span> <span class="token hvariable">class_</span> <span class="token string">"nav-wrapper"</span> <span class="token operator">$</span>
  <span class="token hvariable">a</span> <span class="token operator">!</span> <span class="token hvariable">class_</span> <span class="token string">"brand-logo sans"</span> <span class="token operator">!</span> <span class="token hvariable">href</span> <span class="token string">"/"</span> <span class="token operator">$</span>
    <span class="token string">"#ohaskell"</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Любой, кто знаком с веб-разработкой, мгновенно узнает в этом коде HTML. Это&nbsp;<a data-tooltip-position="top" aria-label="https://github.com/denisshevchenko/ohaskell.guide/blob/master/src/CreateHtmlTemplates.hs#L56" rel="noopener" class="external-link" href="https://github.com/denisshevchenko/ohaskell.guide/blob/master/src/CreateHtmlTemplates.hs#L56" target="_blank">кусочек кода</a>, строящего HTML-шаблон для веб-варианта данной книги. То что вы видите — это совершенно легальный Haskell-код, в процессе работы которого генерируется реальный HTML: тег&nbsp;<code>&lt;div&gt;</code>&nbsp;с классом&nbsp;<code>nav-wrapper</code>, внутри которого лежит&nbsp;<code>&lt;a&gt;</code>-ссылка с двумя классами, корневым адресом и внутренним текстом&nbsp;<code>#ohaskell</code>.</p></div><div><p>Идентификаторы&nbsp;<code>div</code>,&nbsp;<code>class_</code>&nbsp;и&nbsp;<code>href</code>&nbsp;— это имена функций, а символы&nbsp;<code>!</code>&nbsp;и&nbsp;<code>$</code>&nbsp;— это операторы, записанные в инфиксной форме. Самое главное, что для понимания этого кода нам абсолютно необязательно знать, где определены все эти функции/операторы и как они работают. Это важная мысль, которую я неоднократно буду повторять в последующих главах:</p></div><div><blockquote>
<p>Чтобы использовать функции, нам вовсе необязательно знать их внутренности.</p>
</blockquote></div><div><p>А про EDSL запомните, мы с ними ещё встретимся.</p></div><div><h1 data-heading="Список" id="Список">Список</h1></div><div><p>Помните, в одной из предыдущих глав я говорил, что познакомлю вас ещё с несколькими стандартными типами данных в Haskell? Пришло время узнать о списках.</p></div><div><p>Список (англ. list) — это стандартный тип, характеризующий уже не просто данные, но структуру данных (англ. data structure). Эта структура представляет собой набор данных одного типа, и едва ли хоть одна реальная Haskell-программа может обойтись без списков.</p></div><div><p>Структуры, содержащие данные одного типа, называют ещё гомогенными (в переводе с греческого: «одного рода»).</p></div><div><p>Вот список из трёх целых чисел:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Квадратные скобки и значения, разделённые запятыми. Вот так выглядит список из двух значений типа&nbsp;<code>Double</code>:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token punctuation">[</span><span class="token number">1.3</span><span class="token punctuation">,</span> <span class="token number">45.7899</span><span class="token punctuation">]</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>а вот и список из одного-единственного символа:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token punctuation">[</span><span class="token char string">'H'</span><span class="token punctuation">]</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>или вот из четырёх строк, отражающих имена протоколов транспортного уровня OSI-модели:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token punctuation">[</span><span class="token string">"TCP"</span><span class="token punctuation">,</span> <span class="token string">"UDP"</span><span class="token punctuation">,</span> <span class="token string">"DCCP"</span><span class="token punctuation">,</span> <span class="token string">"SCTP"</span><span class="token punctuation">]</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Если у вас есть опыт разработки на языке C, вы можете подумать, что список похож на массив. Однако, хотя сходства имеются, я намеренно избегаю слова «массив», потому что в Haskell существуют массивы (англ. array), это несколько иная структура данных.</p></div><div><p>Список — это тоже выражение, поэтому можно легко создать список списков произвольной вложенности. Вот так будет выглядеть список из ряда протоколов трёх уровней OSI-модели:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token punctuation">[</span> <span class="token punctuation">[</span><span class="token string">"DHCP"</span><span class="token punctuation">,</span> <span class="token string">"FTP"</span><span class="token punctuation">,</span> <span class="token string">"HTTP"</span><span class="token punctuation">]</span>
<span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token string">"TCP"</span><span class="token punctuation">,</span> <span class="token string">"UDP"</span><span class="token punctuation">,</span> <span class="token string">"DCCP"</span><span class="token punctuation">,</span> <span class="token string">"SCTP"</span><span class="token punctuation">]</span>
<span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token string">"ARP"</span><span class="token punctuation">,</span> <span class="token string">"NDP"</span><span class="token punctuation">,</span> <span class="token string">"OSPF"</span><span class="token punctuation">]</span>
<span class="token punctuation">]</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Это список списков строк. Форматирование в отношении квадратных скобок весьма вольное, при желании можно и так написать:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token string">"DHCP"</span><span class="token punctuation">,</span> <span class="token string">"FTP"</span><span class="token punctuation">,</span> <span class="token string">"HTTP"</span>        <span class="token punctuation">]</span><span class="token punctuation">,</span>
 <span class="token punctuation">[</span><span class="token string">"TCP"</span><span class="token punctuation">,</span>  <span class="token string">"UDP"</span><span class="token punctuation">,</span> <span class="token string">"DCCP"</span><span class="token punctuation">,</span> <span class="token string">"SCTP"</span><span class="token punctuation">]</span><span class="token punctuation">,</span>
 <span class="token punctuation">[</span><span class="token string">"ARP"</span><span class="token punctuation">,</span>  <span class="token string">"NDP"</span><span class="token punctuation">,</span> <span class="token string">"OSPF"</span>        <span class="token punctuation">]</span><span class="token punctuation">]</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Список может быть и пустым, то есть не содержать в себе никаких данных:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token punctuation">[</span><span class="token punctuation">]</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><h2 data-heading="Тип списка" id="Тип_списка" style="display: flex;"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>Тип списка</h2></div><div><p>Раз список представляет собой структуру, содержащую данные некоторого типа, каков же тип самого списка? Вот:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token punctuation">[</span><span class="token constant">Int</span><span class="token punctuation">]</span>     <span class="token comment">-- Список целых чисел</span>
<span class="token punctuation">[</span><span class="token constant">Char</span><span class="token punctuation">]</span>    <span class="token comment">-- Список символов</span>
<span class="token punctuation">[</span><span class="token constant">String</span><span class="token punctuation">]</span>  <span class="token comment">-- Список строк</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>То есть тип списка так и указывается, в квадратных скобках. Упомянутый ранее список списков строк имеет такой тип:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token constant">String</span><span class="token punctuation">]</span><span class="token punctuation">]</span>  <span class="token comment">-- Список списков строк</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Модель очень проста:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token punctuation">[</span>   <span class="token punctuation">[</span><span class="token constant">String</span><span class="token punctuation">]</span>    <span class="token punctuation">]</span>

   │  Тип   │
   └ данных ┘

│     Тип       │
│    списка     │
└─ этих данных ─┘
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Хранить данные разных типов в стандартном списке невозможно. Однако вскоре мы познакомимся с другой стандартной структурой данных, которая позволяет это.</p></div><div><h2 data-heading="Действия над списками" id="Действия_над_списками" style="display: flex;"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>Действия над списками</h2></div><div><p>Если списки создаются — значит это кому-нибудь нужно. Со списком можно делать очень много всего. В стандартной Haskell-библиотеке существует отдельный модуль&nbsp;<code>Data.List</code>, включающий широкий набор функций, работающих со списком. Откроем модуль&nbsp;<code>Main</code>&nbsp;и импортируем в него модуль&nbsp;<code>Data.List</code>:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token keyword">module</span> <span class="token constant">Main</span> <span class="token keyword">where</span>

<span class="token comment">-- Стандартный модуль для работы со списками.</span>
<span class="token import-statement"><span class="token keyword">import</span> Data<span class="token punctuation">.</span>List</span>

<span class="token hvariable">main</span> <span class="token operator">::</span> <span class="token constant">IO</span> <span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token hvariable">main</span> <span class="token operator">=</span> <span class="token builtin">putStrLn</span> <span class="token punctuation">(</span><span class="token builtin">head</span> <span class="token punctuation">[</span><span class="token string">"Vim"</span><span class="token punctuation">,</span> <span class="token string">"Emacs"</span><span class="token punctuation">,</span> <span class="token string">"Atom"</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Функция&nbsp;<code>head</code>&nbsp;возвращает голову списка, то есть его первый элемент. При запуске этой программы на выходе получим:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token constant">Vim</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Модель такая:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token punctuation">[</span><span class="token string">"Vim"</span>  <span class="token punctuation">,</span>  <span class="token string">"Emacs"</span><span class="token punctuation">,</span> <span class="token string">"Atom"</span><span class="token punctuation">]</span>

 голова    └─── хвост ───┘
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Эдакая гусеница получается: первый элемент — голова, а всё остальное — хвост. Функция&nbsp;<code>tail</code>&nbsp;возвращает хвост:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">main</span> <span class="token operator">::</span> <span class="token constant">IO</span> <span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token hvariable">main</span> <span class="token operator">=</span> <span class="token builtin">print</span> <span class="token punctuation">(</span><span class="token builtin">tail</span> <span class="token punctuation">[</span><span class="token string">"Vim"</span><span class="token punctuation">,</span> <span class="token string">"Emacs"</span><span class="token punctuation">,</span> <span class="token string">"Atom"</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Вот результат:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token punctuation">[</span><span class="token string">"Emacs"</span><span class="token punctuation">,</span> <span class="token string">"Atom"</span><span class="token punctuation">]</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Функция&nbsp;<code>tail</code>&nbsp;формирует другой список, представляющий собою всё от первоначального списка, кроме головы. Обратите внимание на новую функцию&nbsp;<code>print</code>. В данном случае мы не могли бы использовать нашу знакомую&nbsp;<code>putStrLn</code>, ведь она применяется к значению типа&nbsp;<code>String</code>, в то время как функция&nbsp;<code>tail</code>&nbsp;вернёт нам значение типа&nbsp;<code>[String]</code>. Мы ведь помним про строгость компилятора: что ожидаем, то и получить должны. Функция&nbsp;<code>print</code>&nbsp;предназначена для «стрингификации» значения: она берёт значение некоторого типа и выводит это значение на консоль уже в виде строки.</p></div><div><p>Внимательный читатель спросит, каким же образом функция&nbsp;<code>print</code>&nbsp;узнаёт, как именно отобразить конкретное значение в виде строки? О, это интереснейшая тема, но она относится к Третьему Киту Haskell, до знакомства с которым нам ещё далеко.</p></div><div><p>Можно получить длину списка:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">handleTableRow</span> <span class="token operator">::</span> <span class="token constant">String</span> <span class="token operator">-&gt;</span> <span class="token constant">String</span>
<span class="token hvariable">handleTableRow</span> <span class="token hvariable">row</span>
  <span class="token operator">|</span> <span class="token builtin">length</span> <span class="token hvariable">row</span> <span class="token operator">==</span> <span class="token number">2</span> <span class="token operator">=</span> <span class="token hvariable">composeTwoOptionsFrom</span> <span class="token hvariable">row</span>
  <span class="token operator">|</span> <span class="token builtin">length</span> <span class="token hvariable">row</span> <span class="token operator">==</span> <span class="token number">3</span> <span class="token operator">=</span> <span class="token hvariable">composeThreeOptionsFrom</span> <span class="token hvariable">row</span>
  <span class="token operator">|</span> <span class="token builtin">otherwise</span>       <span class="token operator">=</span> <span class="token hvariable">invalidRow</span> <span class="token hvariable">row</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Это чуток видоизменённый кусочек одной моей программы, функция&nbsp;<code>handleTableRow</code>&nbsp;обрабатывает строку таблицы. Стандартная функция&nbsp;<code>length</code>&nbsp;даёт нам длину списка (число элементов в нём). В данном случае мы узнаём число элементов в строке таблицы&nbsp;<code>row</code>, и в зависимости от этой длины применяем к этой строке функцию&nbsp;<code>composeTwoOptionsFrom</code>&nbsp;или&nbsp;<code>composeThreeOptionsFrom</code>.</p></div><div><p>Но постойте, а где же тут список? Функция&nbsp;<code>handleTableRow</code>&nbsp;применяется к строке и вычисляет строку. А всё дело в том, что строка есть ни что иное, как список символов. То есть тип&nbsp;<code>String</code>&nbsp;эквивалентен типу&nbsp;<code>[Char]</code>. Скажу более:&nbsp;<code>String</code>&nbsp;— это даже не самостоятельный тип, это всего лишь псевдоним для типа&nbsp;<code>[Char]</code>, и вот как он задан:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token keyword">type</span> <span class="token constant">String</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token constant">Char</span><span class="token punctuation">]</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Ключевое слово&nbsp;<code>type</code>&nbsp;вводит синоним для уже существующего типа (англ. type synonym). Иногда его называют «псевдонимом типа». Читается это так:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token keyword">type</span>  <span class="token constant">String</span>  <span class="token operator">=</span>      <span class="token punctuation">[</span><span class="token constant">Char</span><span class="token punctuation">]</span>

тип   этот    равен  тому
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Таким образом, объявление функции&nbsp;<code>handleTableRow</code>&nbsp;можно было бы переписать так:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">handleTableRow</span> <span class="token operator">::</span> <span class="token punctuation">[</span><span class="token constant">Char</span><span class="token punctuation">]</span> <span class="token operator">-&gt;</span> <span class="token punctuation">[</span><span class="token constant">Char</span><span class="token punctuation">]</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>При работе со списками мы можем использовать уже знакомые промежуточные выражения, например:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">handleTableRow</span> <span class="token operator">::</span> <span class="token constant">String</span> <span class="token operator">-&gt;</span> <span class="token constant">String</span>
<span class="token hvariable">handleTableRow</span> <span class="token hvariable">row</span>
  <span class="token operator">|</span> <span class="token hvariable">size</span> <span class="token operator">==</span> <span class="token number">2</span> <span class="token operator">=</span> <span class="token hvariable">composeTwoOptionsFrom</span> <span class="token hvariable">row</span>
  <span class="token operator">|</span> <span class="token hvariable">size</span> <span class="token operator">==</span> <span class="token number">3</span> <span class="token operator">=</span> <span class="token hvariable">composeThreeOptionsFrom</span> <span class="token hvariable">row</span>
  <span class="token operator">|</span> <span class="token builtin">otherwise</span> <span class="token operator">=</span> <span class="token hvariable">invalidRow</span> <span class="token hvariable">row</span>
  <span class="token keyword">where</span> <span class="token hvariable">size</span> <span class="token operator">=</span> <span class="token builtin">length</span> <span class="token hvariable">row</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>А можно и так:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">handleTableRow</span> <span class="token operator">::</span> <span class="token constant">String</span> <span class="token operator">-&gt;</span> <span class="token constant">String</span>
<span class="token hvariable">handleTableRow</span> <span class="token hvariable">row</span>
  <span class="token operator">|</span> <span class="token hvariable">twoOptions</span>   <span class="token operator">=</span> <span class="token hvariable">composeTwoOptionsFrom</span> <span class="token hvariable">row</span>
  <span class="token operator">|</span> <span class="token hvariable">threeOptions</span> <span class="token operator">=</span> <span class="token hvariable">composeThreeOptionsFrom</span> <span class="token hvariable">row</span>
  <span class="token operator">|</span> <span class="token builtin">otherwise</span>    <span class="token operator">=</span> <span class="token hvariable">invalidRow</span> <span class="token hvariable">row</span>
  <span class="token keyword">where</span>
    <span class="token hvariable">size</span>         <span class="token operator">=</span> <span class="token builtin">length</span> <span class="token hvariable">row</span>  <span class="token comment">-- Узнаём длину</span>
    <span class="token hvariable">twoOptions</span>   <span class="token operator">=</span> <span class="token hvariable">size</span> <span class="token operator">==</span> <span class="token number">2</span>   <span class="token comment">-- ... сравниваем</span>
    <span class="token hvariable">threeOptions</span> <span class="token operator">=</span> <span class="token hvariable">size</span> <span class="token operator">==</span> <span class="token number">3</span>   <span class="token comment">-- ... и ещё раз</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Здесь выражения&nbsp;<code>twoOptions</code>&nbsp;и&nbsp;<code>threeOptions</code>&nbsp;имеют уже знакомый нам стандартный тип&nbsp;<code>Bool</code>, ведь они равны результату сравнения значения&nbsp;<code>size</code>&nbsp;с числом.</p></div><div><h2 data-heading="Неизменность списка" id="Неизменность_списка" style="display: flex;"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>Неизменность списка</h2></div><div><p>Как вы уже знаете, все данные в Haskell неизменны, как Египетские пирамиды. Списки — не исключение: мы не можем изменить существующий список, мы можем лишь создать на его основе новый список. Например:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">addTo</span> <span class="token operator">::</span> <span class="token constant">String</span> <span class="token operator">-&gt;</span> <span class="token punctuation">[</span><span class="token constant">String</span><span class="token punctuation">]</span> <span class="token operator">-&gt;</span> <span class="token punctuation">[</span><span class="token constant">String</span><span class="token punctuation">]</span>
<span class="token hvariable">addTo</span> <span class="token hvariable">newHost</span> <span class="token hvariable">hosts</span> <span class="token operator">=</span> <span class="token hvariable">newHost</span> <span class="token operator">:</span> <span class="token hvariable">hosts</span>

<span class="token hvariable">main</span> <span class="token operator">::</span> <span class="token constant">IO</span> <span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token hvariable">main</span> <span class="token operator">=</span> <span class="token builtin">print</span> <span class="token punctuation">(</span><span class="token string">"124.67.54.90"</span> <span class="token operator">`addTo`</span> <span class="token hvariable">hosts</span><span class="token punctuation">)</span>
  <span class="token keyword">where</span> <span class="token hvariable">hosts</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">"45.67.78.89"</span><span class="token punctuation">,</span> <span class="token string">"123.45.65.54"</span><span class="token punctuation">]</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Результат этой программы таков:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token punctuation">[</span><span class="token string">"124.67.54.90"</span><span class="token punctuation">,</span><span class="token string">"45.67.78.89"</span><span class="token punctuation">,</span><span class="token string">"123.45.65.54"</span><span class="token punctuation">]</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Рассмотрим определение функции&nbsp;<code>addTo</code>:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">addTo</span> <span class="token hvariable">newHost</span> <span class="token hvariable">hosts</span> <span class="token operator">=</span> <span class="token hvariable">newHost</span> <span class="token operator">:</span> <span class="token hvariable">hosts</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Стандартный оператор&nbsp;<code>:</code>&nbsp;добавляет значение, являющееся левым операндом, в начало списка, являющегося правым операндом. Читается это так:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">newHost</span>   <span class="token operator">:</span>         <span class="token hvariable">hosts</span>

          этот
          оператор

берёт
это
значение
                    и добавляет
                    его в начало
                    этого списка
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Естественно, тип значения слева обязан совпадать с типом значений, содержащихся в списке справа.</p></div><div><p>С концептуальной точки зрения функция&nbsp;<code>addTo</code>&nbsp;добавила новый IP-адрес в начало списка&nbsp;<code>hosts</code>. В действительности же никакого добавления не произошло, ибо списки неизменны. Оператор&nbsp;<code>:</code>&nbsp;взял значение&nbsp;<code>newHost</code>&nbsp;и список&nbsp;<code>hosts</code>&nbsp;и создал на их основе новый список, содержащий в себе уже три IP-адреса вместо двух.</p></div><div><h2 data-heading="Перечисление" id="Перечисление" style="display: flex;"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>Перечисление</h2></div><div><p>Допустим, понадобился нам список целых чисел от одного до десяти. Пишем:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">main</span> <span class="token operator">::</span> <span class="token constant">IO</span> <span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token hvariable">main</span> <span class="token operator">=</span> <span class="token builtin">print</span> <span class="token hvariable">tenNumbers</span>
  <span class="token keyword">where</span> <span class="token hvariable">tenNumbers</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">,</span> <span class="token number">8</span><span class="token punctuation">,</span> <span class="token number">9</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">]</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Неплохо, но избыточно, ведь чисел могло быть и сто, и тысяча. Есть лучший путь:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">main</span> <span class="token operator">::</span> <span class="token constant">IO</span> <span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token hvariable">main</span> <span class="token operator">=</span> <span class="token builtin">print</span> <span class="token hvariable">tenNumbers</span>
  <span class="token keyword">where</span> <span class="token hvariable">tenNumbers</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token operator">..</span><span class="token number">10</span><span class="token punctuation">]</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Красиво, не правда ли? Выражение в квадратных скобках называется перечислением (англ. enumeration или сокращённо enum). Иногда её именуют также арифметической последовательностью. Идея предельно проста: зачем указывать содержимое списка целиком в той ситуации, когда можно указать лишь диапазон значений? Это мы и сделали:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token punctuation">[</span><span class="token number">1</span><span class="token operator">..</span><span class="token number">10</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">,</span><span class="token number">7</span><span class="token punctuation">,</span><span class="token number">8</span><span class="token punctuation">,</span><span class="token number">9</span><span class="token punctuation">,</span><span class="token number">10</span><span class="token punctuation">]</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Значение слева от&nbsp;<code>..</code>&nbsp;— это начало диапазона, а значение справа — его конец. Компилятор сам догадается, что шаг между числами в данной последовательности равен 1. Вот ещё пример:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token punctuation">[</span><span class="token number">3</span><span class="token operator">..</span><span class="token number">17</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">,</span><span class="token number">7</span><span class="token punctuation">,</span><span class="token number">8</span><span class="token punctuation">,</span><span class="token number">9</span><span class="token punctuation">,</span><span class="token number">10</span><span class="token punctuation">,</span><span class="token number">11</span><span class="token punctuation">,</span><span class="token number">12</span><span class="token punctuation">,</span><span class="token number">13</span><span class="token punctuation">,</span><span class="token number">14</span><span class="token punctuation">,</span><span class="token number">15</span><span class="token punctuation">,</span><span class="token number">16</span><span class="token punctuation">,</span><span class="token number">17</span><span class="token punctuation">]</span>

 <span class="token hvariable">_</span>         <span class="token hvariable">_</span>

    <span class="token operator">==</span>                                        <span class="token operator">==</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Мы можем задать шаг и явно:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token operator">..</span><span class="token number">10</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">,</span><span class="token number">8</span><span class="token punctuation">,</span><span class="token number">10</span><span class="token punctuation">]</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Получили только чётные значения. Схема проста:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">,</span>      <span class="token number">4</span>      <span class="token operator">..</span> <span class="token number">10</span><span class="token punctuation">]</span>

 первый            конец
         второй

 │  разница   │
 └─ даёт шаг ─┘
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Вот ещё пример:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">9</span><span class="token operator">..</span><span class="token number">28</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">9</span><span class="token punctuation">,</span><span class="token number">15</span><span class="token punctuation">,</span><span class="token number">21</span><span class="token punctuation">,</span><span class="token number">27</span><span class="token punctuation">]</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Можно задать и нисходящий диапазон:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token punctuation">[</span><span class="token number">9</span><span class="token punctuation">,</span><span class="token number">8</span><span class="token operator">..</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">9</span><span class="token punctuation">,</span><span class="token number">8</span><span class="token punctuation">,</span><span class="token number">7</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">]</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Или так:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">9</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">8</span><span class="token operator">..</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">9</span><span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">8</span><span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">7</span><span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">6</span><span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Да, отрицательные числа тоже работают. Можно взять также и числа с плавающей точкой:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token punctuation">[</span><span class="token number">1.02</span><span class="token punctuation">,</span><span class="token number">1.04</span><span class="token operator">..</span><span class="token number">1.16</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1.02</span><span class="token punctuation">,</span><span class="token number">1.04</span><span class="token punctuation">,</span><span class="token number">1.06</span><span class="token punctuation">,</span><span class="token number">1.08</span><span class="token punctuation">,</span><span class="token number">1.1</span><span class="token punctuation">,</span><span class="token number">1.12</span><span class="token punctuation">,</span><span class="token number">1.14</span><span class="token punctuation">,</span><span class="token number">1.16</span><span class="token punctuation">]</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>В общем, идея ясна. Но что это мы всё с числами да с числами! Возьмём символы:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token punctuation">[</span><span class="token char string">'a'</span><span class="token operator">..</span><span class="token char string">'z'</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">"abcdefghijklmnopqrstuvwxyz"</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Диапазон от&nbsp;<code>'a'</code>&nbsp;до&nbsp;<code>'z'</code>&nbsp;— получили английский алфавит в виде&nbsp;<code>[Char]</code>&nbsp;или, как мы уже знаем, просто&nbsp;<code>String</code>. При большом желании явно задать шаг можно и здесь:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token punctuation">[</span><span class="token char string">'a'</span><span class="token punctuation">,</span><span class="token char string">'c'</span><span class="token operator">..</span><span class="token char string">'z'</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">"acegikmoqsuwy"</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Вот такая красота.</p></div><div><p>Теперь, после знакомства со списком, мы будем использовать их постоянно.</p></div><div><h2 data-heading="Для любопытных" id="Для_любопытных" style="display: flex;"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>Для любопытных</h2></div><div><p>В разделе про диапазоны для списка мы оперировали значениями типа&nbsp;<code>Int</code>,&nbsp;<code>Double</code>&nbsp;и&nbsp;<code>Char</code>. Возникает вопрос: а можно ли использовать значения каких-нибудь других типов? Отвечаю: можно, но с оговоркой. Попробуем проделать это со строкой:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">main</span> <span class="token operator">::</span> <span class="token constant">IO</span> <span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token hvariable">main</span> <span class="token operator">=</span> <span class="token builtin">print</span> <span class="token punctuation">[</span><span class="token string">"a"</span><span class="token punctuation">,</span><span class="token string">"aa"</span><span class="token operator">..</span><span class="token string">"aaaaaa"</span><span class="token punctuation">]</span>  <span class="token comment">-- Ну-ну...</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>При попытке скомпилировать такой код увидим ошибку:</p></div><div><pre class="language-bash" tabindex="0"><code class="language-bash is-loaded">No instance <span class="token keyword">for</span> <span class="token punctuation">(</span>Enum <span class="token punctuation">[</span>Char<span class="token punctuation">]</span><span class="token punctuation">)</span>
  arising from the arithmetic sequence ‘<span class="token string">"a"</span>, <span class="token string">"aa"</span> <span class="token punctuation">..</span> <span class="token string">"aaaaaa"</span>’
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>И удивляться тут нечему: шаг между строками абсурден, и компилятор в замешательстве. Не все типы подходят для перечислений в силу своей природы, однако в будущем, когда мы научимся создавать наши собственные типы, мы узнаем, что их вполне можно использовать в диапазонах. Наберитесь терпения.</p></div><div><p>Приоткрою секрет: этот странный пример с шагом между строками теоретически можно-таки заставить работать, но о том, как это сделать, мы узнаем во время знакомства с Третьим Китом Haskell.</p></div><div><h1 data-heading="Кортеж" id="Кортеж">Кортеж</h1></div><div><p>В этой главе мы познакомимся с кортежем и ещё ближе подружимся с паттерн матчингом.</p></div><div><p>Кортеж (англ. tuple) — ещё одна стандартная структура данных, но, в отличие от списка, она может содержать данные как одного типа, так и разных.</p></div><div><p>Структуры, способные содержать данные разных типов, называют гетерогенными (в переводе с греческого: «разного рода»).</p></div><div><p>Вот как выглядит кортеж:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token punctuation">(</span><span class="token string">"Haskell"</span><span class="token punctuation">,</span> <span class="token number">2010</span><span class="token punctuation">)</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Круглые скобки и значения, разделённые запятыми. Этот кортеж содержит значение типа&nbsp;<code>String</code>&nbsp;и ещё одно, типа&nbsp;<code>Int</code>. Вот ещё пример:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token punctuation">(</span><span class="token string">"Haskell"</span><span class="token punctuation">,</span> <span class="token string">"2010"</span><span class="token punctuation">,</span> <span class="token string">"Standard"</span><span class="token punctuation">)</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>То есть ничто не мешает нам хранить в кортеже данные одного типа.</p></div><div><h2 data-heading="Тип кортежа" id="Тип_кортежа" style="display: flex;"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>Тип кортежа</h2></div><div><p>Тип списка строк, как вы помните,&nbsp;<code>[String]</code>. И не важно, сколько строк мы запихнули в список, одну или миллион — его тип останется неизменным. С кортежем же дело обстоит абсолютно иначе.</p></div><div><p>Тип кортежа зависит от количества его элементов. Вот тип кортежа, содержащего две строки:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token punctuation">(</span><span class="token constant">String</span><span class="token punctuation">,</span> <span class="token constant">String</span><span class="token punctuation">)</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Вот ещё пример:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token punctuation">(</span><span class="token constant">Double</span><span class="token punctuation">,</span> <span class="token constant">Double</span><span class="token punctuation">,</span> <span class="token constant">Int</span><span class="token punctuation">)</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>И ещё:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token punctuation">(</span><span class="token constant">Bool</span><span class="token punctuation">,</span> <span class="token constant">Double</span><span class="token punctuation">,</span> <span class="token constant">Int</span><span class="token punctuation">,</span> <span class="token constant">String</span><span class="token punctuation">)</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Тип кортежа явно отражает его содержимое. Поэтому если функция применяется к кортежу из двух строк, применить её к кортежу из трёх никак не получится, ведь типы этих кортежей различаются:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token comment">-- Разные типы</span>
<span class="token punctuation">(</span><span class="token constant">String</span><span class="token punctuation">,</span> <span class="token constant">String</span><span class="token punctuation">)</span>
<span class="token punctuation">(</span><span class="token constant">String</span><span class="token punctuation">,</span> <span class="token constant">String</span><span class="token punctuation">,</span> <span class="token constant">String</span><span class="token punctuation">)</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><h2 data-heading="Действия над кортежами" id="Действия_над_кортежами" style="display: flex;"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>Действия над кортежами</h2></div><div><p>Со списками можно делать много всего, а вот с кортежами — не очень. Самые частые действия — собственно формирование кортежа и извлечение хранящихся в нём данных. Например:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">makeAlias</span> <span class="token operator">::</span> <span class="token constant">String</span> <span class="token operator">-&gt;</span> <span class="token constant">String</span> <span class="token operator">-&gt;</span> <span class="token punctuation">(</span><span class="token constant">String</span><span class="token punctuation">,</span> <span class="token constant">String</span><span class="token punctuation">)</span>
<span class="token hvariable">makeAlias</span> <span class="token hvariable">host</span> <span class="token hvariable">alias</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token hvariable">host</span><span class="token punctuation">,</span> <span class="token hvariable">alias</span><span class="token punctuation">)</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Пожалуй, ничего проще придумать нельзя: на входе два аргумента, на выходе — двухэлементный кортеж с этими аргументами. Двухэлементный кортеж называют ещё парой (англ. pair). И хотя кортеж может содержать сколько угодно элементов, на практике именно пары встречаются чаще всего.</p></div><div><p>Обратите внимание, насколько легко создаётся кортеж. Причина тому — уже знакомый нам паттерн матчинг:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">makeAlias</span> <span class="token hvariable">host</span> <span class="token hvariable">alias</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token hvariable">host</span><span class="token punctuation">,</span> <span class="token hvariable">alias</span><span class="token punctuation">)</span>

          <span class="token hvariable">____</span>          <span class="token hvariable">____</span>

               <span class="token operator">=====</span>          <span class="token operator">=====</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Мы просто указываем соответствие между левой и правой сторонами определения: «Пусть первый элемент пары будет равен аргументу&nbsp;<code>host</code>, а второй — аргументу&nbsp;<code>alias</code>». Ничего удобнее и проще и придумать нельзя. И если бы мы хотели получить кортеж из трёх элементов, это выглядело бы так:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">makeAlias</span> <span class="token operator">::</span> <span class="token constant">String</span> <span class="token operator">-&gt;</span> <span class="token constant">String</span> <span class="token operator">-&gt;</span> <span class="token punctuation">(</span><span class="token constant">String</span><span class="token punctuation">,</span> <span class="token constant">String</span><span class="token punctuation">,</span> <span class="token constant">String</span><span class="token punctuation">)</span>
<span class="token hvariable">makeAlias</span> <span class="token hvariable">host</span> <span class="token hvariable">alias</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token hvariable">host</span><span class="token punctuation">,</span> <span class="token string">"https://"</span> <span class="token operator">++</span> <span class="token hvariable">host</span><span class="token punctuation">,</span> <span class="token hvariable">alias</span><span class="token punctuation">)</span>

          <span class="token hvariable">____</span>          <span class="token hvariable">____</span>                <span class="token hvariable">____</span>

               <span class="token operator">=====</span>                              <span class="token operator">=====</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Оператор&nbsp;<code>++</code>&nbsp;— это оператор конкатенации, склеивающий две строки в одну. Строго говоря, он склеивает два списка, но мы-то с вами уже знаем, что&nbsp;<code>String</code>&nbsp;есть ни что иное, как&nbsp;<code>[Char]</code>. Таким образом,&nbsp;<code>"https://"</code>&nbsp;++&nbsp;<code>"www.google.com"</code>&nbsp;даёт нам&nbsp;<code>"https://www.google.com"</code>.</p></div><div><p>Извлечение элементов из кортежа также производится через паттерн матчинг:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">main</span> <span class="token operator">::</span> <span class="token constant">IO</span> <span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token hvariable">main</span> <span class="token operator">=</span>
  <span class="token keyword">let</span> <span class="token punctuation">(</span><span class="token hvariable">host</span><span class="token punctuation">,</span> <span class="token hvariable">alias</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token hvariable">makeAlias</span> <span class="token string">"173.194.71.106"</span>
                                <span class="token string">"www.google.com"</span>
  <span class="token keyword">in</span> <span class="token builtin">print</span> <span class="token punctuation">(</span><span class="token hvariable">host</span> <span class="token operator">++</span> <span class="token string">", "</span> <span class="token operator">++</span> <span class="token hvariable">alias</span><span class="token punctuation">)</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Функция&nbsp;<code>makeAlias</code>&nbsp;даёт нам пару из хоста и имени. Но что это за странная запись возле уже знакомого нам слова&nbsp;<code>let</code>? Это промежуточное выражение, но выражение хитрое, образованное через паттерн матчинг. Чтобы было понятнее, сначала перепишем функцию без него:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">main</span> <span class="token operator">::</span> <span class="token constant">IO</span> <span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token hvariable">main</span> <span class="token operator">=</span>
  <span class="token keyword">let</span> <span class="token hvariable">pair</span>  <span class="token operator">=</span> <span class="token hvariable">makeAlias</span> <span class="token string">"173.194.71.106"</span>
                        <span class="token string">"www.google.com"</span>
      <span class="token hvariable">host</span>  <span class="token operator">=</span> <span class="token builtin">fst</span> <span class="token hvariable">pair</span>  <span class="token comment">-- Берём первое...</span>
      <span class="token hvariable">alias</span> <span class="token operator">=</span> <span class="token builtin">snd</span> <span class="token hvariable">pair</span>  <span class="token comment">-- Берём второе...</span>
  <span class="token keyword">in</span> <span class="token builtin">print</span> <span class="token punctuation">(</span><span class="token hvariable">host</span> <span class="token operator">++</span> <span class="token string">", "</span> <span class="token operator">++</span> <span class="token hvariable">alias</span><span class="token punctuation">)</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>При запуске этой программы получим:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token string">"173.194.71.106, www.google.com"</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Стандартные функции&nbsp;<code>fst</code>&nbsp;и&nbsp;<code>snd</code>&nbsp;возвращают первый и второй элемент кортежа соответственно. Выражение&nbsp;<code>pair</code>&nbsp;соответствует паре, выражение&nbsp;<code>host</code>&nbsp;— значению хоста, а&nbsp;<code>alias</code>&nbsp;— значению имени. Но не кажется ли вам такой способ избыточным? Мы в Haskell любим изящные решения, поэтому предпочитаем паттерн матчинг. Вот как получается вышеприведённый способ:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token keyword">let</span> <span class="token punctuation">(</span><span class="token hvariable">host</span><span class="token punctuation">,</span> <span class="token hvariable">alias</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token hvariable">makeAlias</span> <span class="token string">"173.194.71.106"</span> <span class="token string">"www.google.com"</span>

<span class="token keyword">let</span> <span class="token punctuation">(</span><span class="token hvariable">host</span><span class="token punctuation">,</span> <span class="token hvariable">alias</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token string">"173.194.71.106"</span><span class="token punctuation">,</span> <span class="token string">"www.google.com"</span><span class="token punctuation">)</span>

                     данное значение
     это
     хост
                                       а вот это значение
           это
           имя
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Вот такая простая магия. Функция&nbsp;<code>makeAlias</code>&nbsp;даёт нам пару, и мы достоверно знаем это! А если знаем, нам не нужно вводить промежуточные выражения вроде&nbsp;<code>pair</code>. Мы сразу говорим:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token keyword">let</span> <span class="token punctuation">(</span><span class="token hvariable">host</span><span class="token punctuation">,</span> <span class="token hvariable">alias</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token hvariable">makeAlias</span> <span class="token string">"173.194.71.106"</span> <span class="token string">"www.google.com"</span>

                    мы точно знаем<span class="token punctuation">,</span> что выражение<span class="token punctuation">,</span>
                    вычисленное этой функцией
     это вот
     такая пара
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Это «зеркальная» модель: через паттерн матчинг формируем:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token comment">-- Формируем правую сторону</span>
<span class="token comment">-- на основе левой...</span>
<span class="token hvariable">host</span> <span class="token hvariable">alias</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token hvariable">host</span><span class="token punctuation">,</span> <span class="token hvariable">alias</span><span class="token punctuation">)</span>

<span class="token operator">&gt;&gt;&gt;&gt;</span>          <span class="token operator">&gt;&gt;&gt;&gt;</span>

     <span class="token operator">&gt;&gt;&gt;&gt;&gt;</span>          <span class="token operator">&gt;&gt;&gt;&gt;&gt;</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>и через него же извлекаем:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token comment">-- Формируем левую сторону</span>
<span class="token comment">-- на основе правой...</span>
<span class="token punctuation">(</span><span class="token hvariable">host</span><span class="token punctuation">,</span> <span class="token hvariable">alias</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token string">"173.194.71.106"</span><span class="token punctuation">,</span> <span class="token string">"www.google.com"</span><span class="token punctuation">)</span>

 <span class="token operator">&lt;&lt;&lt;&lt;</span>            <span class="token operator">&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;</span>

       <span class="token operator">&lt;&lt;&lt;&lt;&lt;</span>                       <span class="token operator">&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;&lt;</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Вот ещё один пример работы с кортежем через паттерн матчинг:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">chessMove</span> <span class="token operator">::</span> <span class="token constant">String</span>
          <span class="token operator">-&gt;</span> <span class="token punctuation">(</span><span class="token constant">String</span><span class="token punctuation">,</span> <span class="token constant">String</span><span class="token punctuation">)</span>
          <span class="token operator">-&gt;</span> <span class="token punctuation">(</span><span class="token constant">String</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token constant">String</span><span class="token punctuation">,</span> <span class="token constant">String</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token hvariable">chessMove</span> <span class="token hvariable">color</span> <span class="token punctuation">(</span><span class="token hvariable">from</span><span class="token punctuation">,</span> <span class="token hvariable">to</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token hvariable">color</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token hvariable">from</span><span class="token punctuation">,</span> <span class="token hvariable">to</span><span class="token punctuation">)</span><span class="token punctuation">)</span>

<span class="token hvariable">main</span> <span class="token operator">::</span> <span class="token constant">IO</span> <span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token hvariable">main</span> <span class="token operator">=</span> <span class="token builtin">print</span> <span class="token punctuation">(</span><span class="token hvariable">color</span> <span class="token operator">++</span> <span class="token string">": "</span> <span class="token operator">++</span> <span class="token hvariable">from</span> <span class="token operator">++</span> <span class="token string">"-"</span> <span class="token operator">++</span> <span class="token hvariable">to</span><span class="token punctuation">)</span>
  <span class="token keyword">where</span>
    <span class="token punctuation">(</span><span class="token hvariable">color</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token hvariable">from</span><span class="token punctuation">,</span> <span class="token hvariable">to</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token hvariable">chessMove</span> <span class="token string">"white"</span> <span class="token punctuation">(</span><span class="token string">"e2"</span><span class="token punctuation">,</span> <span class="token string">"e4"</span><span class="token punctuation">)</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>И на выходе получаем:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token string">"white: e2-e4"</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Обратите внимание, объявление функции отформатировано чуток иначе: типы выстроены друг под другом через выравнивание стрелок под двоеточием. Вы часто встретите такой стиль в Haskell-проектах.</p></div><div><p>Функция&nbsp;<code>chessMove</code>&nbsp;даёт нам кортеж с кортежем, а раз мы точно знаем вид этого кортежа, сразу указываем&nbsp;<code>where</code>-выражение в виде образца:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token punctuation">(</span><span class="token hvariable">color</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token hvariable">from</span><span class="token punctuation">,</span> <span class="token hvariable">to</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token hvariable">chessMove</span> <span class="token string">"white"</span> <span class="token punctuation">(</span><span class="token string">"e2"</span><span class="token punctuation">,</span> <span class="token string">"e4"</span><span class="token punctuation">)</span>

 <span class="token hvariable">_____</span>                          <span class="token hvariable">_______</span>

         <span class="token operator">====</span>                            <span class="token operator">====</span>

               <span class="token operator">..</span>                              <span class="token operator">....</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><h2 data-heading="Не всё" id="Не_всё" style="display: flex;"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>Не всё</h2></div><div><p>Мы можем вытаскивать по образцу лишь часть нужной нам информации. Помните универсальный образец&nbsp;<code>_</code>? Взгляните:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token comment">-- Поясняющие псевдонимы</span>
<span class="token keyword">type</span> <span class="token constant">UUID</span>     <span class="token operator">=</span> <span class="token constant">String</span>
<span class="token keyword">type</span> <span class="token constant">FullName</span> <span class="token operator">=</span> <span class="token constant">String</span>
<span class="token keyword">type</span> <span class="token constant">Email</span>    <span class="token operator">=</span> <span class="token constant">String</span>
<span class="token keyword">type</span> <span class="token constant">Age</span>      <span class="token operator">=</span> <span class="token constant">Int</span>
<span class="token keyword">type</span> <span class="token constant">Patient</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token constant">UUID</span><span class="token punctuation">,</span> <span class="token constant">FullName</span><span class="token punctuation">,</span> <span class="token constant">Email</span><span class="token punctuation">,</span> <span class="token constant">Age</span><span class="token punctuation">)</span>

<span class="token hvariable">patientEmail</span> <span class="token operator">::</span> <span class="token constant">Patient</span> <span class="token operator">-&gt;</span> <span class="token constant">Email</span>
<span class="token hvariable">patientEmail</span> <span class="token punctuation">(</span><span class="token hvariable">_</span><span class="token punctuation">,</span> <span class="token hvariable">_</span><span class="token punctuation">,</span> <span class="token hvariable">email</span><span class="token punctuation">,</span> <span class="token hvariable">_</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token hvariable">email</span>

<span class="token hvariable">main</span> <span class="token operator">::</span> <span class="token constant">IO</span> <span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token hvariable">main</span> <span class="token operator">=</span>
  <span class="token builtin">putStrLn</span> <span class="token punctuation">(</span><span class="token hvariable">patientEmail</span> <span class="token punctuation">(</span> <span class="token string">"63ab89d"</span>
                         <span class="token punctuation">,</span> <span class="token string">"John Smith"</span>
                         <span class="token punctuation">,</span> <span class="token string">"johnsm@gmail.com"</span>
                         <span class="token punctuation">,</span> <span class="token number">59</span>
                         <span class="token punctuation">)</span><span class="token punctuation">)</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Функция&nbsp;<code>patientEmail</code>&nbsp;даёт нам почту пациента. Тип&nbsp;<code>Patient</code>&nbsp;— это псевдоним для кортежа из четырёх элементов: уникальный идентификатор, полное имя, адрес почты и возраст. Дополнительные псевдонимы делают наш код яснее: одно дело видеть безликую&nbsp;<code>String</code>&nbsp;и совсем другое —&nbsp;<code>Email</code>.</p></div><div><p>Рассмотрим внутренность функции&nbsp;<code>patientEmail</code>:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">patientEmail</span> <span class="token punctuation">(</span><span class="token hvariable">_</span><span class="token punctuation">,</span> <span class="token hvariable">_</span><span class="token punctuation">,</span> <span class="token hvariable">email</span><span class="token punctuation">,</span> <span class="token hvariable">_</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token hvariable">email</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Функция говорит нам: «Да, я знаю, что мой аргумент — это четырёхэлементный кортеж, но меня в нём интересует исключительно третий по счёту элемент, соответствующий адресу почты, его я и верну». Универсальный образец&nbsp;<code>_</code>&nbsp;делает наш код лаконичнее и понятнее, ведь он помогает нам игнорировать то, что нам неинтересно. Строго говоря, мы не обязаны использовать&nbsp;<code>_</code>, но с ним будет лучше.</p></div><div><h2 data-heading="А если ошиблись?" id="А_если_ошиблись?" style="display: flex;"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>А если ошиблись?</h2></div><div><p>При использовании паттерн матчинга в отношении пары следует быть внимательным. Представим себе, что вышеупомянутый тип&nbsp;<code>Patient</code>&nbsp;был расширен:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token keyword">type</span> <span class="token constant">UUID</span>      <span class="token operator">=</span> <span class="token constant">String</span>
<span class="token keyword">type</span> <span class="token constant">FullName</span>  <span class="token operator">=</span> <span class="token constant">String</span>
<span class="token keyword">type</span> <span class="token constant">Email</span>     <span class="token operator">=</span> <span class="token constant">String</span>
<span class="token keyword">type</span> <span class="token constant">Age</span>       <span class="token operator">=</span> <span class="token constant">Int</span>
<span class="token keyword">type</span> <span class="token constant">DiseaseId</span> <span class="token operator">=</span> <span class="token constant">Int</span>  <span class="token comment">-- Новый элемент.</span>
<span class="token keyword">type</span> <span class="token constant">Patient</span> <span class="token operator">=</span> <span class="token punctuation">(</span> <span class="token constant">UUID</span>
               <span class="token punctuation">,</span> <span class="token constant">FullName</span>
               <span class="token punctuation">,</span> <span class="token constant">Email</span>
               <span class="token punctuation">,</span> <span class="token constant">Age</span>
               <span class="token punctuation">,</span> <span class="token constant">DiseaseId</span>
               <span class="token punctuation">)</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Был добавлен идентификатор заболевания. И всё бы хорошо, но внести изменения в функцию&nbsp;<code>patientEmail</code>&nbsp;мы забыли:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">patientEmail</span> <span class="token operator">::</span> <span class="token constant">Patient</span> <span class="token operator">-&gt;</span> <span class="token constant">Email</span>
<span class="token hvariable">patientEmail</span> <span class="token punctuation">(</span><span class="token hvariable">_</span><span class="token punctuation">,</span> <span class="token hvariable">_</span><span class="token punctuation">,</span> <span class="token hvariable">email</span><span class="token punctuation">,</span> <span class="token hvariable">_</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token hvariable">email</span>

              <span class="token operator">^</span>  <span class="token operator">^</span>  <span class="token operator">^</span>      <span class="token operator">^</span>  <span class="token comment">-- А пятый где?</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>К счастью, в этом случае компилятор строго обратит наше внимание на ошибку:</p></div><div><pre class="language-bash" tabindex="0"><code class="language-bash is-loaded">Couldn't match <span class="token builtin class-name">type</span> ‘<span class="token punctuation">(</span>t0, t1, String, t2<span class="token punctuation">)</span>’
               with ‘<span class="token punctuation">(</span>UUID, FullName, Email, Age, DiseaseId<span class="token punctuation">)</span>’
Expected type: Patient
  Actual type: <span class="token punctuation">(</span>t0, t1, String, t2<span class="token punctuation">)</span>
In the pattern: <span class="token punctuation">(</span>_, _, email, _<span class="token punctuation">)</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Оно и понятно: функция&nbsp;<code>patientEmail</code>&nbsp;использует образец, который уже некорректен. Вот почему при использовании паттерн матчинга следует быть внимательным.</p></div><div><p>На этом наше знакомство с кортежем считаю завершённым, в последующих главах мы будем использовать их периодически.</p></div><div><h2 data-heading="Для любопытных" id="Для_любопытных" style="display: flex;"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>Для любопытных</h2></div><div><p>Для работы с элементами многоэлементных кортежей можно использовать готовые библиотеки, во избежании длинных паттерн матчинговых цепочек. Например, пакет&nbsp;<a data-tooltip-position="top" aria-label="http://hackage.haskell.org/package/tuple" rel="noopener" class="external-link" href="http://hackage.haskell.org/package/tuple" target="_blank">tuple</a>:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token constant">Data<span class="token punctuation">.</span>Tuple<span class="token punctuation">.</span>Select</span>

<span class="token hvariable">main</span> <span class="token operator">::</span> <span class="token constant">IO</span> <span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token hvariable">main</span> <span class="token operator">=</span> <span class="token builtin">print</span> <span class="token punctuation">(</span><span class="token hvariable">sel4</span> <span class="token punctuation">(</span><span class="token number">123</span><span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">,</span> <span class="token string">"hydra"</span><span class="token punctuation">,</span> <span class="token string">"DC:4"</span><span class="token punctuation">,</span> <span class="token number">44</span><span class="token punctuation">,</span> <span class="token string">"12.04"</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Функция&nbsp;<code>sel4</code>&nbsp;из модуля&nbsp;<code>Data.Tuple.Select</code>&nbsp;извлекает четвёртый по счёту элемент кортежа, в данном случае строку&nbsp;<code>"DC:4"</code>. Там есть функции вплоть до&nbsp;<code>sel32</code>, авторы вполне разумно сочли, что никто, находясь в здравом уме и твёрдой памяти, не станет оперировать кортежами, состоящими из более чем 32 элементов.</p></div><div><p>Кроме того, мы и обновлять элементы кортежа можем:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token import-statement"><span class="token keyword">import</span> Data<span class="token punctuation">.</span>Tuple<span class="token punctuation">.</span>Update</span>

<span class="token hvariable">main</span> <span class="token operator">::</span> <span class="token constant">IO</span> <span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token hvariable">main</span> <span class="token operator">=</span> <span class="token builtin">print</span> <span class="token punctuation">(</span><span class="token hvariable">upd2</span> <span class="token number">2</span> <span class="token punctuation">(</span><span class="token string">"si"</span><span class="token punctuation">,</span> <span class="token number">45</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Естественно, по причине неизменности кортежа, никакого обновления тут не происходит, но выглядит симпатично. При запуске получаем результат:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token punctuation">(</span><span class="token string">"si"</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">)</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Второй элемент кортежа изменился с&nbsp;<code>45</code>&nbsp;на&nbsp;<code>2</code>.</p></div><div><h1 data-heading="Лямбда-функция" id="Лямбда-функция">Лямбда-функция</h1></div><div><p>Пришло время познакомиться с важной концепцией — лямбда-функцией. Именно с неё всё и началось. Приготовьтесь: в этой главе нас ждут новые открытия.</p></div><div><h2 data-heading="Истоки" id="Истоки" style="display: flex;"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>Истоки</h2></div><div><p>В далёких 1930-х молодой американский математик&nbsp;<a data-tooltip-position="top" aria-label="https://en.wikipedia.org/wiki/Alonzo_Church" rel="noopener" class="external-link" href="https://en.wikipedia.org/wiki/Alonzo_Church" target="_blank">Алонзо Чёрч</a>&nbsp;задался вопросом о том, что значит «вычислить» что-либо. Плодом его размышлений явилась система для формализации понятия «вычисление», и назвал он эту систему «лямбда-исчислением» (англ. lambda calculus, по имени греческой буквы&nbsp;<code>λ</code>). В основе этой системы лежит лямбда-функция, которую в некотором смысле можно считать «матерью функционального программирования» в целом и Haskell в частности. Далее буду называть её ЛФ.</p></div><div><p>В отношении ЛФ можно смело сказать: «Всё гениальное просто». Идея ЛФ столь полезна именно потому, что она предельно проста. ЛФ — это анонимная функция. Вот как она выглядит в Haskell:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token operator">\</span><span class="token hvariable">x</span> <span class="token operator">-&gt;</span> <span class="token hvariable">x</span> <span class="token operator">*</span> <span class="token hvariable">x</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Обратный слэш в начале — признак ЛФ. Сравните с математической формой записи:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded">λ<span class="token hvariable">x</span> <span class="token operator">.</span> <span class="token hvariable">x</span> <span class="token operator">*</span> <span class="token hvariable">x</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Похоже, не правда ли? Воспринимайте обратный слэш в определении ЛФ как спинку буквы&nbsp;<code>λ</code>.</p></div><div><p>ЛФ представляет собой простейший вид функции, эдакая функция, раздетая догола. У неё забрали не только объявление, но и имя, оставив лишь необходимый минимум в виде имён аргументов и внутреннего выражения. Алонзо Чёрч понял: чтобы применить функцию, вовсе необязательно её именовать. И если у обычной функции сначала идёт объявление/определение, а затем (где-то) применение с использованием имени, то у ЛФ всё куда проще: мы её определяем и тут же применяем, на месте. Вот так:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token punctuation">(</span><span class="token operator">\</span><span class="token hvariable">x</span> <span class="token operator">-&gt;</span> <span class="token hvariable">x</span> <span class="token operator">*</span> <span class="token hvariable">x</span><span class="token punctuation">)</span> <span class="token number">5</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Помните функцию&nbsp;<code>square</code>? Вот это её лямбда-аналог:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token punctuation">(</span><span class="token operator">\</span><span class="token hvariable">x</span> <span class="token operator">-&gt;</span> <span class="token hvariable">x</span> <span class="token operator">*</span> <span class="token hvariable">x</span><span class="token punctuation">)</span>      <span class="token number">5</span>

лямбда<span class="token operator">-</span>абстракция  аргумент
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Лямбда-абстракция (англ. lambda abstraction) — это особое выражение, порождающее функцию, которую мы сразу же применяем к аргументу&nbsp;<code>5</code>. ЛФ с одним аргументом, как и простую функцию, называют ещё «ЛФ от одного аргумента» или «ЛФ одного аргумента». Также можно сказать и о «лямбда-абстракции от одного аргумента».</p></div><div><h2 data-heading="Строение" id="Строение" style="display: flex;"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>Строение</h2></div><div><p>Строение лямбда-абстракции предельно простое:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token operator">\</span>        <span class="token hvariable">x</span>          <span class="token operator">-&gt;</span>  <span class="token hvariable">x</span> <span class="token operator">*</span> <span class="token hvariable">x</span>
признак  имя            выражение
ЛФ       аргумента
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Соответственно, если ЛФ применяется к двум аргументам — пишем так:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token operator">\</span>        <span class="token hvariable">x</span>          <span class="token hvariable">y</span>          <span class="token operator">-&gt;</span>  <span class="token hvariable">x</span> <span class="token operator">*</span> <span class="token hvariable">y</span>
признак  имя <span class="token number">1</span>      имя <span class="token number">2</span>          выражение
ЛФ       аргумента  аргумента
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>И когда мы применяем такую функцию:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token punctuation">(</span><span class="token operator">\</span><span class="token hvariable">x</span> <span class="token hvariable">y</span> <span class="token operator">-&gt;</span> <span class="token hvariable">x</span> <span class="token operator">*</span> <span class="token hvariable">y</span><span class="token punctuation">)</span> <span class="token number">10</span> <span class="token number">4</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>то просто подставляем&nbsp;<code>10</code>&nbsp;на место&nbsp;<code>x</code>, а&nbsp;<code>4</code>&nbsp;— на место&nbsp;<code>y</code>, и получаем выражение&nbsp;<code>10 * 4</code>:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded">  <span class="token punctuation">(</span><span class="token operator">\</span><span class="token hvariable">x</span> <span class="token hvariable">y</span> <span class="token operator">-&gt;</span> <span class="token hvariable">x</span> <span class="token operator">*</span> <span class="token hvariable">y</span><span class="token punctuation">)</span> <span class="token number">10</span> <span class="token number">4</span>
<span class="token operator">=</span> <span class="token number">10</span> <span class="token operator">*</span> <span class="token number">4</span>
<span class="token operator">=</span> <span class="token number">40</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>В общем, всё как с обычной функцией, даже проще.</p></div><div><p>Мы можем ввести промежуточное значение для лямбда-абстракции:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">main</span> <span class="token operator">::</span> <span class="token constant">IO</span> <span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token hvariable">main</span> <span class="token operator">=</span> <span class="token builtin">print</span> <span class="token punctuation">(</span><span class="token hvariable">mul</span> <span class="token number">10</span> <span class="token number">4</span><span class="token punctuation">)</span>
  <span class="token keyword">where</span> <span class="token hvariable">mul</span> <span class="token operator">=</span> <span class="token operator">\</span><span class="token hvariable">x</span> <span class="token hvariable">y</span> <span class="token operator">-&gt;</span> <span class="token hvariable">x</span> <span class="token operator">*</span> <span class="token hvariable">y</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Теперь мы можем применять&nbsp;<code>mul</code>&nbsp;так же, как если бы это была сама лямбда-абстракция:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded">  <span class="token hvariable">mul</span> <span class="token number">10</span> <span class="token number">4</span>
<span class="token operator">=</span> <span class="token punctuation">(</span><span class="token operator">\</span><span class="token hvariable">x</span> <span class="token hvariable">y</span> <span class="token operator">-&gt;</span> <span class="token hvariable">x</span> <span class="token operator">*</span> <span class="token hvariable">y</span><span class="token punctuation">)</span> <span class="token number">10</span> <span class="token number">4</span>
<span class="token operator">=</span> <span class="token number">10</span> <span class="token operator">*</span> <span class="token number">4</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>И здесь мы приблизились к одному важному открытию.</p></div><div><h2 data-heading="Тип функции" id="Тип_функции" style="display: flex;"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>Тип функции</h2></div><div><p>Мы знаем, что у всех данных в Haskell-программе обязательно есть какой-то тип, внимательно проверяемый на этапе компиляции. Вопрос: какой тип у выражения&nbsp;<code>mul</code>&nbsp;из предыдущего примера?</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded">  <span class="token keyword">where</span> <span class="token hvariable">mul</span> <span class="token operator">=</span> <span class="token operator">\</span><span class="token hvariable">x</span> <span class="token hvariable">y</span> <span class="token operator">-&gt;</span> <span class="token hvariable">x</span> <span class="token operator">*</span> <span class="token hvariable">y</span>  <span class="token comment">-- Какой тип?</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Ответ прост: тип&nbsp;<code>mul</code>&nbsp;такой же, как и у этой лямбда-абстракции. Из этого мы делаем важный вывод: ЛФ имеет тип, как и обычные данные. Но поскольку ЛФ является частным случаем функции — значит и у обыкновенной функции тоже есть тип!</p></div><div><p>В нефункциональных языках между функциями и данными проведена чёткая граница: вот это функции, а вон то — данные. Однако в Haskell между данными и функциями разницы нет, ведь и то и другое покоится на одной и той же Черепахе. Вот тип функции&nbsp;<code>mul</code>:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">mul</span> <span class="token operator">::</span> <span class="token hvariable">a</span> <span class="token operator">-&gt;</span> <span class="token hvariable">a</span> <span class="token operator">-&gt;</span> <span class="token hvariable">a</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Погодите, скажете вы, но ведь это же объявление функции! Совершенно верно: объявление функции — это и есть указание её типа. Помните, когда мы впервые познакомились с функцией, я уточнил, что её объявление разделено двойным двоеточием? Так вот это двойное двоеточие и представляет собой указание типа:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">mul</span>  <span class="token operator">::</span>     <span class="token hvariable">a</span> <span class="token operator">-&gt;</span> <span class="token hvariable">a</span> <span class="token operator">-&gt;</span> <span class="token hvariable">a</span>

вот  имеет  │   вот   │
это  тип    └─ такой ─┘
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Точно так же мы можем указать тип любых других данных:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token keyword">let</span> <span class="token hvariable">coeff</span> <span class="token operator">=</span> <span class="token number">12</span> <span class="token operator">::</span> <span class="token constant">Double</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Хотя мы знаем, что в Haskell типы выводятся автоматически, иногда мы хотим взять эту заботу на себя. В данном случае мы явно говорим: «Пусть выражение&nbsp;<code>coeff</code>&nbsp;будет равно&nbsp;<code>12</code>, но тип его пусть будет&nbsp;<code>Double</code>, а не&nbsp;<code>Int</code>». Так же и с функцией: когда мы объявляем её — мы тем самым указываем её тип.</p></div><div><p>Но вы спросите, можем ли мы не указывать тип функции явно? Можем:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">square</span> <span class="token hvariable">x</span> <span class="token operator">=</span> <span class="token hvariable">x</span> <span class="token operator">*</span> <span class="token hvariable">x</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Это наша старая знакомая, функция&nbsp;<code>square</code>. Когда она будет применена к значению типа&nbsp;<code>Int</code>, тип аргумента будет выведен автоматически как&nbsp;<code>Int</code>.</p></div><div><p>И раз функция характеризуется типом так же, как и прочие данные, мы делаем ещё одно важное открытие: функциями можно оперировать как данными. Например, можно создать список функций:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">main</span> <span class="token operator">::</span> <span class="token constant">IO</span> <span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token hvariable">main</span> <span class="token operator">=</span> <span class="token builtin">putStrLn</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token builtin">head</span> <span class="token hvariable">functions</span><span class="token punctuation">)</span> <span class="token string">"Hi"</span><span class="token punctuation">)</span>
  <span class="token keyword">where</span>
    <span class="token hvariable">functions</span> <span class="token operator">=</span> <span class="token punctuation">[</span> <span class="token operator">\</span><span class="token hvariable">x</span> <span class="token operator">-&gt;</span> <span class="token hvariable">x</span> <span class="token operator">++</span> <span class="token string">" val1"</span>
                <span class="token punctuation">,</span> <span class="token operator">\</span><span class="token hvariable">x</span> <span class="token operator">-&gt;</span> <span class="token hvariable">x</span> <span class="token operator">++</span> <span class="token string">" val2"</span>
                <span class="token punctuation">]</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Выражение&nbsp;<code>functions</code>&nbsp;— это список из двух функций. Два лямбда-выражения порождают эти две функции, но до момента применения они ничего не делают, они безжизненны и бесполезны. Но когда мы применяем функцию&nbsp;<code>head</code>&nbsp;к этому списку, мы получаем первый элемент списка, то есть первую функцию. И получив, тут же применяем эту функцию к строке&nbsp;<code>"Hi"</code>:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token builtin">putStrLn</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token builtin">head</span> <span class="token hvariable">functions</span><span class="token punctuation">)</span>  <span class="token string">"Hi"</span><span class="token punctuation">)</span>

          │    первая    │  её
          │   функция    │  аргумент
          └─ из списка ──┘
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Это равносильно коду:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token builtin">putStrLn</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token operator">\</span><span class="token hvariable">x</span> <span class="token operator">-&gt;</span> <span class="token hvariable">x</span> <span class="token operator">++</span> <span class="token string">" val1"</span><span class="token punctuation">)</span> <span class="token string">"Hi"</span><span class="token punctuation">)</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>При запуске программы мы получим:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token constant">Hi</span> <span class="token hvariable">val1</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Кстати, а каков тип списка&nbsp;<code>functions</code>? Его тип таков:&nbsp;<code>[String -&gt; String]</code>. То есть список функций с одним аргументом типа&nbsp;<code>String</code>, возвращающих значение типа&nbsp;<code>String</code>.</p></div><div><h2 data-heading="Локальные функции" id="Локальные_функции" style="display: flex;"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>Локальные функции</h2></div><div><p>Раз уж между ЛФ и простыми функциями фактически нет различий, а функции есть частный случай данных, мы можем создавать функции локально для других функций:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token comment">-- Здесь определены функции</span>
<span class="token comment">-- isInfixOf и isSuffixOf.</span>
<span class="token import-statement"><span class="token keyword">import</span> Data<span class="token punctuation">.</span>List</span>

<span class="token hvariable">validComEmail</span> <span class="token operator">::</span> <span class="token constant">String</span> <span class="token operator">-&gt;</span> <span class="token constant">Bool</span>
<span class="token hvariable">validComEmail</span> <span class="token hvariable">email</span> <span class="token operator">=</span>
    <span class="token hvariable">containsAtSign</span> <span class="token hvariable">email</span> <span class="token operator">&amp;&amp;</span> <span class="token hvariable">endsWithCom</span> <span class="token hvariable">email</span>
  <span class="token keyword">where</span>
    <span class="token hvariable">containsAtSign</span> <span class="token hvariable">e</span> <span class="token operator">=</span> <span class="token string">"@"</span> <span class="token operator">`isInfixOf`</span> <span class="token hvariable">e</span>
    <span class="token hvariable">endsWithCom</span> <span class="token hvariable">e</span> <span class="token operator">=</span> <span class="token string">".com"</span> <span class="token operator">`isSuffixOf`</span> <span class="token hvariable">e</span>

<span class="token hvariable">main</span> <span class="token operator">::</span> <span class="token constant">IO</span> <span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token hvariable">main</span> <span class="token operator">=</span> <span class="token builtin">putStrLn</span> <span class="token punctuation">(</span><span class="token keyword">if</span> <span class="token hvariable">validComEmail</span> <span class="token hvariable">my</span>
                   <span class="token keyword">then</span> <span class="token string">"It's ok!"</span>
                   <span class="token keyword">else</span> <span class="token string">"Non-com email!"</span><span class="token punctuation">)</span>
  <span class="token keyword">where</span>
    <span class="token hvariable">my</span> <span class="token operator">=</span> <span class="token string">"haskeller@gmail.com"</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Несколько наивная функция&nbsp;<code>validComEmail</code>&nbsp;проверяет&nbsp;<code>.com</code>-адрес. Её выражение образовано оператором&nbsp;<code>&amp;&amp;</code>&nbsp;и двумя выражениями типа&nbsp;<code>Bool</code>. Вот как образованы эти выражения:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">containsAtSign</span> <span class="token hvariable">e</span> <span class="token operator">=</span> <span class="token string">"@"</span> <span class="token operator">`isInfixOf`</span> <span class="token hvariable">e</span>
<span class="token hvariable">endsWithCom</span> <span class="token hvariable">e</span> <span class="token operator">=</span> <span class="token string">".com"</span> <span class="token operator">`isSuffixOf`</span> <span class="token hvariable">e</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Это — две функции, которые мы определили прямо в&nbsp;<code>where</code>-секции, поэтому они существуют только для основного выражения функции&nbsp;<code>validComEmail</code>. С простыми функциями так поступают очень часто: где она нужна, там её и определяют. Мы могли бы написать и более явно:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">validComEmail</span> <span class="token operator">::</span> <span class="token constant">String</span> <span class="token operator">-&gt;</span> <span class="token constant">Bool</span>
<span class="token hvariable">validComEmail</span> <span class="token hvariable">email</span> <span class="token operator">=</span>
    <span class="token hvariable">containsAtSign</span> <span class="token hvariable">email</span> <span class="token operator">&amp;&amp;</span> <span class="token hvariable">endsWithCom</span> <span class="token hvariable">email</span>
  <span class="token keyword">where</span>
    <span class="token comment">-- Объявляем локальную функцию явно.</span>
    <span class="token hvariable">containsAtSign</span> <span class="token operator">::</span> <span class="token constant">String</span> <span class="token operator">-&gt;</span> <span class="token constant">Bool</span>
    <span class="token hvariable">containsAtSign</span> <span class="token hvariable">e</span> <span class="token operator">=</span> <span class="token string">"@"</span> <span class="token operator">`isInfixOf`</span> <span class="token hvariable">e</span>

    <span class="token comment">-- И эту тоже.</span>
    <span class="token hvariable">endsWithCom</span> <span class="token operator">::</span> <span class="token constant">String</span> <span class="token operator">-&gt;</span> <span class="token constant">Bool</span>
    <span class="token hvariable">endsWithCom</span> <span class="token hvariable">e</span> <span class="token operator">=</span> <span class="token string">".com"</span> <span class="token operator">`isSuffixOf`</span> <span class="token hvariable">e</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Впрочем, указывать тип столь простых функций, как правило, необязательно.</p></div><div><p>Вот как этот код выглядит с лямбда-абстракциями:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">validComEmail</span> <span class="token operator">::</span> <span class="token constant">String</span> <span class="token operator">-&gt;</span> <span class="token constant">Bool</span>
<span class="token hvariable">validComEmail</span> <span class="token hvariable">email</span> <span class="token operator">=</span>
    <span class="token hvariable">containsAtSign</span> <span class="token hvariable">email</span> <span class="token operator">&amp;&amp;</span> <span class="token hvariable">endsWithCom</span> <span class="token hvariable">email</span>
  <span class="token keyword">where</span>
    <span class="token hvariable">containsAtSign</span> <span class="token operator">=</span> <span class="token operator">\</span><span class="token hvariable">e</span> <span class="token operator">-&gt;</span> <span class="token string">"@"</span> <span class="token operator">`isInfixOf`</span> <span class="token hvariable">e</span>
    <span class="token hvariable">endsWithCom</span> <span class="token operator">=</span> <span class="token operator">\</span><span class="token hvariable">e</span> <span class="token operator">-&gt;</span> <span class="token string">".com"</span> <span class="token operator">`isSuffixOf`</span> <span class="token hvariable">e</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Теперь выражения&nbsp;<code>containsAtSign</code>&nbsp;и&nbsp;<code>endsWithCom</code>&nbsp;приравнены к ЛФ от одного аргумента. В этом случае мы не указываем тип этих выражений. Впрочем, если очень хочется, можно и указать:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">containsAtSign</span> <span class="token operator">=</span>
    <span class="token punctuation">(</span><span class="token operator">\</span><span class="token hvariable">e</span> <span class="token operator">-&gt;</span> <span class="token string">"@"</span> <span class="token operator">`isInfixOf`</span> <span class="token hvariable">e</span><span class="token punctuation">)</span> <span class="token operator">::</span> <span class="token constant">String</span> <span class="token operator">-&gt;</span> <span class="token constant">Bool</span>

    лямбда<span class="token operator">-</span>абстракция            тип этой абстракции
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Лямбда-абстракция взята в скобки, чтобы указание типа относилось к функции в целом, а не только к аргументу&nbsp;<code>e</code>:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">containsAtSign</span> <span class="token operator">=</span>
    <span class="token operator">\</span><span class="token hvariable">e</span> <span class="token operator">-&gt;</span> <span class="token string">"@"</span> <span class="token operator">`isInfixOf`</span> <span class="token hvariable">e</span> <span class="token operator">::</span> <span class="token constant">String</span> <span class="token operator">-&gt;</span> <span class="token constant">Bool</span>

                               в этом случае это
                               тип аргумента <span class="token hvariable">e</span><span class="token punctuation">,</span>
                               а вовсе не всей
                               функции<span class="token operator">!</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Для типа функции тоже можно ввести псевдоним:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token comment">-- Псевдоним для типа функции.</span>
<span class="token keyword">type</span> <span class="token constant">Func</span> <span class="token operator">=</span> <span class="token constant">String</span> <span class="token operator">-&gt;</span> <span class="token constant">Bool</span>

<span class="token hvariable">validComEmail</span> <span class="token operator">::</span> <span class="token constant">String</span> <span class="token operator">-&gt;</span> <span class="token constant">Bool</span>
<span class="token hvariable">validComEmail</span> <span class="token hvariable">email</span> <span class="token operator">=</span>
    <span class="token hvariable">containsAtSign</span> <span class="token hvariable">email</span> <span class="token operator">&amp;&amp;</span> <span class="token hvariable">endsWithCom</span> <span class="token hvariable">email</span>
  <span class="token keyword">where</span>
    <span class="token hvariable">containsAtSign</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token operator">\</span><span class="token hvariable">e</span> <span class="token operator">-&gt;</span> <span class="token string">"@"</span> <span class="token operator">`isInfixOf`</span> <span class="token hvariable">e</span><span class="token punctuation">)</span> <span class="token operator">::</span> <span class="token constant">Func</span>
    <span class="token hvariable">endsWithCom</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token operator">\</span><span class="token hvariable">e</span> <span class="token operator">-&gt;</span> <span class="token string">".com"</span> <span class="token operator">`isSuffixOf`</span> <span class="token hvariable">e</span><span class="token punctuation">)</span> <span class="token operator">::</span> <span class="token constant">Func</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Впрочем, на практике указание типа для лямбда-абстракций встречается исключительно редко, ибо незачем.</p></div><div><p>Отныне, познакомившись с ЛФ, мы будем использовать их периодически.</p></div><div><p>И напоследок, вопрос. Помните тип функции&nbsp;<code>mul</code>?</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">mul</span> <span class="token operator">::</span> <span class="token hvariable">a</span> <span class="token operator">-&gt;</span> <span class="token hvariable">a</span> <span class="token operator">-&gt;</span> <span class="token hvariable">a</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Что это за буква&nbsp;<code>a</code>? Во-первых, мы не встречали такой тип ранее, а во-вторых, разве имя типа в Haskell не обязано начинаться с большой буквы? Обязано. А всё дело в том, что буква&nbsp;<code>a</code>&nbsp;в данном случае — это не совсем имя типа. А вот что это такое, мы узнаем в одной из ближайших глав.</p></div><div><h2 data-heading="Для любопытных" id="Для_любопытных" style="display: flex;"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>Для любопытных</h2></div><div><p>А почему, собственно, лямбда? Почему Чёрч выбрал именно эту греческую букву? По одной из версий, произошло это чисто случайно.</p></div><div><p>Шли 30-е годы прошлого века, компьютеров не было, и все научные работы набирались на печатных машинках. В первоначальном варианте, дабы выделять имя аргумента ЛФ, Чёрч ставил над именем аргумента символ, похожий на&nbsp;<code>^</code>. Но когда он сдавал работу наборщику, то вспомнил, что печатная машинка не сможет воспроизвести такой символ над буквой. Тогда он вынес эту «крышу» перед именем аргумента, и получилось что-то наподобие:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token operator">^</span><span class="token hvariable">x</span> <span class="token operator">.</span> <span class="token hvariable">x</span> <span class="token operator">*</span> <span class="token number">10</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>А наборщик, увидев такой символ, использовал заглавную греческую букву&nbsp;<code>Λ</code>:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded">Λ<span class="token hvariable">x</span> <span class="token operator">.</span> <span class="token hvariable">x</span> <span class="token operator">*</span> <span class="token number">10</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Вот так и получилось, лямбда-исчисление.</p></div><div><h1 data-heading="Композиция функций" id="Композиция_функций">Композиция функций</h1></div><div><p>Эта глава рассказывает о том, как объединять функции в цепочки, а также о том, как избавиться от круглых скобок.</p></div><div><h2 data-heading="Скобкам — бой!" id="Скобкам_—_бой!" style="display: flex;"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>Скобкам — бой!</h2></div><div><p>Да, я не люблю круглые скобки. Они делают код визуально избыточным, к тому же нужно следить за симметрией скобок открывающих и закрывающих. Вспомним пример из главы про кортежи:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">main</span> <span class="token operator">::</span> <span class="token constant">IO</span> <span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token hvariable">main</span> <span class="token operator">=</span>
  <span class="token builtin">putStrLn</span> <span class="token punctuation">(</span><span class="token hvariable">patientEmail</span> <span class="token punctuation">(</span> <span class="token string">"63ab89d"</span>
           <span class="token operator">^</span>             <span class="token punctuation">,</span> <span class="token string">"John Smith"</span>
                         <span class="token punctuation">,</span> <span class="token string">"johnsm@gmail.com"</span>
                         <span class="token punctuation">,</span> <span class="token number">59</span>
                         <span class="token punctuation">)</span><span class="token punctuation">)</span>
                          <span class="token operator">^</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Со скобками кортежа мы ничего сделать не можем, ведь они являются синтаксической частью кортежа. А вот скобки вокруг применения функции&nbsp;<code>patientEmail</code>&nbsp;мне абсолютно не нравятся. К счастью, мы можем избавиться от них. Но прежде чем искоренять скобки, задумаемся вот о чём.</p></div><div><p>Если применение функции представляет собой выражение, не можем ли мы как-нибудь компоновать их друг с другом? Конечно можем, мы уже делали это много раз, вспомните:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">main</span> <span class="token operator">::</span> <span class="token constant">IO</span> <span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token hvariable">main</span> <span class="token operator">=</span> <span class="token builtin">putStrLn</span> <span class="token punctuation">(</span><span class="token hvariable">checkLocalhost</span> <span class="token string">"173.194.22.100"</span><span class="token punctuation">)</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Здесь компонуются две функции,&nbsp;<code>putStrLn</code>&nbsp;и&nbsp;<code>checkLocalhost</code>, потому что тип выражения на выходе функции&nbsp;<code>checkLocalhost</code>&nbsp;совпадает с типом выражения на входе функции&nbsp;<code>putStrLn</code>. Схематично это можно изобразить так:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded">         ┌──────────────┐            ┌────────┐
<span class="token constant">String</span> <span class="token operator">-&gt;</span>│<span class="token hvariable">checkLocalhost</span>│<span class="token operator">-&gt;</span> <span class="token constant">String</span> <span class="token operator">-&gt;</span>│<span class="token builtin">putStrLn</span>│<span class="token operator">-&gt;</span> <span class="token operator">...</span>
         └──────────────┘            └────────┘

<span class="token constant">IP</span><span class="token operator">-</span>адрес                    сообщение             текст
                            об этом               в нашем
                            <span class="token constant">IP</span><span class="token operator">-</span>адресе             терминале
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Получается эдакий конвейер: на входе строка с IP-адресом, на выходе — сообщение в нашем терминале. Существует иной способ соединения двух функций воедино.</p></div><div><h2 data-heading="Композиция и применение" id="Композиция_и_применение" style="display: flex;"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>Композиция и применение</h2></div><div><p>Взгляните:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">main</span> <span class="token operator">::</span> <span class="token constant">IO</span> <span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token hvariable">main</span> <span class="token operator">=</span> <span class="token builtin">putStrLn</span> <span class="token operator">.</span> <span class="token hvariable">checkLocalhost</span> <span class="token operator">$</span> <span class="token string">"173.194.22.100"</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Необычно? Перед нами два новых стандартных оператора, избавляющие нас от лишних скобок и делающие наш код проще. Оператор&nbsp;<code>.</code>&nbsp;— это оператор композиции функций (англ. function composition), а оператор&nbsp;<code>$</code>&nbsp;— это оператор применения (англ. application operator). Эти операторы часто используют совместно друг с другом. И отныне мы будем использовать их чуть ли не в каждой главе.</p></div><div><p>Оператор композиции объединяет две функции воедино (или компонует их, англ. compose). Когда мы пишем:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token builtin">putStrLn</span> <span class="token operator">.</span> <span class="token hvariable">checkLocalhost</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>происходит маленькая «магия»: две функции объединяются в новую функцию. Вспомним наш конвейер:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded">         ┌──────────────┐            ┌────────┐
<span class="token constant">String</span> <span class="token operator">-&gt;</span>│<span class="token hvariable">checkLocalhost</span>│<span class="token operator">-&gt;</span> <span class="token constant">String</span> <span class="token operator">-&gt;</span>│<span class="token builtin">putStrLn</span>│<span class="token operator">-&gt;</span> <span class="token operator">...</span>
         └──────────────┘            └────────┘
<span class="token constant">A</span>                           <span class="token constant">B</span>                     <span class="token constant">C</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Раз нам нужно попасть из точки&nbsp;<code>A</code>&nbsp;в точку&nbsp;<code>C</code>, нельзя ли сделать это сразу? Можно, и в этом заключается суть композиции: мы берём две функции и объединяем их в третью функцию. Раз&nbsp;<code>checkLocalhost</code>&nbsp;приводит нас из точки&nbsp;<code>A</code>&nbsp;в точку&nbsp;<code>B</code>, а функция&nbsp;<code>putStrLn</code>&nbsp;— из точки&nbsp;<code>B</code>&nbsp;в&nbsp;<code>C</code>, тогда композиция этих двух функций будет представлять собой функцию, приводящую нас сразу из точки&nbsp;<code>A</code>&nbsp;в точку&nbsp;<code>C</code>:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded">         ┌─────────────────────────┐
<span class="token constant">String</span> <span class="token operator">-&gt;</span>│<span class="token hvariable">checkLocalhost</span> <span class="token operator">+</span> <span class="token builtin">putStrLn</span>│<span class="token operator">-&gt;</span> <span class="token operator">...</span>
         └─────────────────────────┘
<span class="token constant">A</span>                                      <span class="token constant">C</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>В данном случае знак&nbsp;<code>+</code>&nbsp;не относится к конкретному оператору, я лишь показываю факт «объединения» двух функций в третью. Теперь-то нам понятно, почему в типе функции, в качестве разделителя, используется стрелка:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">checkLocalhost</span> <span class="token operator">::</span> <span class="token constant">String</span> <span class="token operator">-&gt;</span> <span class="token constant">String</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>в нашем примере это:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">checkLocalhost</span> <span class="token operator">::</span> <span class="token constant">A</span> <span class="token operator">-&gt;</span> <span class="token constant">B</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Она показывает наше движение из точки&nbsp;<code>A</code>&nbsp;в точку&nbsp;<code>B</code>. Поэтому часто говорят о «функции из&nbsp;<code>A</code>&nbsp;в&nbsp;<code>B</code>». Так, о функции&nbsp;<code>checkLocalhost</code>&nbsp;можно сказать как о «функции из&nbsp;<code>String</code>&nbsp;в&nbsp;<code>String</code>».</p></div><div><p>А оператор применения работает ещё проще. Без него код был бы таким:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">main</span> <span class="token operator">::</span> <span class="token constant">IO</span> <span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token hvariable">main</span> <span class="token operator">=</span>
  <span class="token punctuation">(</span><span class="token builtin">putStrLn</span> <span class="token operator">.</span> <span class="token hvariable">checkLocalhost</span><span class="token punctuation">)</span>  <span class="token string">"173.194.22.100"</span>

  объединённая функция         аргумент
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Но мы ведь хотели избавиться от круглых скобок, а тут они опять. Вот для этого и нужен оператор применения. Его схема проста:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token constant">FUNCTION</span>  <span class="token operator">$</span>            <span class="token constant">ARGUMENT</span>
вот эта   применяется  вот этому
функция   к            аргументу
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Для нашей объединённой функции это выглядит так:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">main</span> <span class="token operator">::</span> <span class="token constant">IO</span> <span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token hvariable">main</span> <span class="token operator">=</span>
  <span class="token builtin">putStrLn</span> <span class="token operator">.</span> <span class="token hvariable">checkLocalhost</span>  <span class="token operator">$</span>            <span class="token string">"173.194.22.100"</span>

  объединённая функция       применяется
                             к            этому аргументу
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Теперь получился настоящий конвейер: справа в него «заезжает» строка и движется «сквозь» функции, а слева «выезжает» результат:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">main</span> <span class="token operator">=</span> <span class="token builtin">putStrLn</span> <span class="token operator">.</span> <span class="token hvariable">checkLocalhost</span> <span class="token operator">$</span>  <span class="token string">"173.194.22.100"</span>

     <span class="token operator">&lt;-</span>         <span class="token operator">&lt;-</span>               <span class="token operator">&lt;-</span> аргумент
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Чтобы было легче читать композицию, вместо оператора&nbsp;<code>.</code>&nbsp;мысленно подставляем фразу «применяется после»:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token builtin">putStrLn</span>  <span class="token operator">.</span>            <span class="token hvariable">checkLocalhost</span>

эта       применяется  этой
функция   после        функции
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>То есть композиция правоассоциативна (англ. right-associative): сначала применяется функция справа, а затем — слева.</p></div><div><p>Ещё одно замечание про оператор применения функции. Он весьма гибок, и мы можем написать так:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">main</span> <span class="token operator">=</span> <span class="token builtin">putStrLn</span> <span class="token operator">.</span> <span class="token hvariable">checkLocalhost</span> <span class="token operator">$</span> <span class="token string">"173.194.22.100"</span>

       объединённая функция        └─ её аргумент ─┘
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>а можем и так:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">main</span> <span class="token operator">=</span> <span class="token builtin">putStrLn</span> <span class="token operator">$</span> <span class="token hvariable">checkLocalhost</span> <span class="token string">"173.194.22.100"</span>

       обычная    └──────── её аргумент ────────┘
       функция
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Эти две формы, как вы уже поняли, эквивалентны. Я показываю это для того, чтобы вновь и вновь продемонстрировать вам, сколь гибко можно работать с данными и функциями в Haskell.</p></div><div><h2 data-heading="Длинные цепочки" id="Длинные_цепочки" style="display: flex;"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>Длинные цепочки</h2></div><div><p>Красота композиции в том, что компоновать мы можем сколько угодно функций:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">logWarn</span> <span class="token operator">::</span> <span class="token constant">String</span> <span class="token operator">-&gt;</span> <span class="token constant">String</span>
<span class="token hvariable">logWarn</span> <span class="token hvariable">rawMessage</span> <span class="token operator">=</span>
  <span class="token hvariable">warning</span> <span class="token operator">.</span> <span class="token hvariable">correctSpaces</span> <span class="token operator">.</span> <span class="token hvariable">asciiOnly</span> <span class="token operator">$</span> <span class="token hvariable">rawMessage</span>

<span class="token hvariable">main</span> <span class="token operator">::</span> <span class="token constant">IO</span> <span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token hvariable">main</span> <span class="token operator">=</span> <span class="token builtin">putStrLn</span> <span class="token operator">$</span>
  <span class="token hvariable">logWarn</span> <span class="token string">"Province   'Gia Viễn' isn't on the map! "</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Функция&nbsp;<code>logWarn</code>&nbsp;готовит переданную ей строку для записи в журнал. Функция&nbsp;<code>asciiOnly</code>&nbsp;готовит строку к выводу в нелокализованном терминале (да, в 2016 году такие всё ещё имеются), функция&nbsp;<code>correctSpaces</code>&nbsp;убирает дублирующиеся пробелы, а функция&nbsp;<code>warning</code>&nbsp;делает строку предупреждением (например, добавляет строку&nbsp;<code>"WARNING: "</code>&nbsp;в начало сообщения). При запуске этой программы мы увидим:</p></div><div><pre class="language-bash" tabindex="0"><code class="language-bash is-loaded">WARNING: Province <span class="token string">'Gia Vi?n'</span> isn't on the map<span class="token operator">!</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Здесь мы объединили в «функциональный конвейер» уже три функции, безо всяких скобок. Вот как это получилось:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">warning</span> <span class="token operator">.</span> <span class="token hvariable">correctSpaces</span> <span class="token operator">.</span> <span class="token hvariable">asciiOnly</span> <span class="token operator">$</span> <span class="token hvariable">rawMessage</span>

                        <span class="token operator">^</span>
          └── первая композиция ──┘

        <span class="token operator">^</span>
└────── вторая композиция ────────┘
                                      аргумент
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Первая композиция объединяет две простые функции,&nbsp;<code>correctSpaces</code>&nbsp;и&nbsp;<code>asciiOnly</code>. Вторая объединяет тоже две функции, простую&nbsp;<code>warning</code>&nbsp;и объединённую, являющуюся результатом первой композиции.</p></div><div><p>Более того, определение функции&nbsp;<code>logWarn</code>&nbsp;можно сделать ещё более простым:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">logWarn</span> <span class="token operator">::</span> <span class="token constant">String</span> <span class="token operator">-&gt;</span> <span class="token constant">String</span>
<span class="token hvariable">logWarn</span> <span class="token operator">=</span> <span class="token hvariable">warning</span> <span class="token operator">.</span> <span class="token hvariable">correctSpaces</span> <span class="token operator">.</span> <span class="token hvariable">asciiOnly</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Погодите, но где же имя аргумента? А его больше нет, оно нам не нужно. Ведь мы знаем, что применение функции можно легко заменить внутренним выражением функции. А раз так, выражение&nbsp;<code>logWarn</code>&nbsp;может быть заменено на выражение&nbsp;<code>warning . correctSpaces . asciiOnly</code>. Сделаем же это:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded">  <span class="token hvariable">logWarn</span> <span class="token string">"Province   'Gia Viễn' isn't on the map! "</span>

<span class="token operator">=</span> <span class="token punctuation">(</span><span class="token hvariable">warning</span>
   <span class="token operator">.</span> <span class="token hvariable">correctSpaces</span>
   <span class="token operator">.</span> <span class="token hvariable">asciiOnly</span><span class="token punctuation">)</span> <span class="token string">"Province   'Gia Viễn' isn't on the map! "</span>

<span class="token operator">=</span>   <span class="token hvariable">warning</span>
  <span class="token operator">.</span> <span class="token hvariable">correctSpaces</span>
  <span class="token operator">.</span> <span class="token hvariable">asciiOnly</span> <span class="token operator">$</span> <span class="token string">"Province   'Gia Viễn' isn't on the map! "</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>И всё работает! В мире Haskell принято именно так: если что-то может быть упрощено — мы это упрощаем.</p></div><div><p>Справедливости ради следует заметить, что не все Haskell-разработчики любят избавляться от круглых скобок, некоторые предпочитают использовать именно их. Что ж, это лишь вопрос стиля и привычек.</p></div><div><h2 data-heading="Как работает композиция" id="Как_работает_композиция" style="display: flex;"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>Как работает композиция</h2></div><div><p>Если вдруг вы подумали, что оператор композиции уникален и встроен в Haskell — спешу вас разочаровать. Никакой магии, всё предельно просто. Этот стандартный оператор определён так же, как и любая другая функция. Вот его определение:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token punctuation">(</span><span class="token punctuation">.</span><span class="token punctuation">)</span> <span class="token hvariable">f</span> <span class="token hvariable">g</span> <span class="token operator">=</span> <span class="token operator">\</span><span class="token hvariable">x</span> <span class="token operator">-&gt;</span> <span class="token hvariable">f</span> <span class="token punctuation">(</span><span class="token hvariable">g</span> <span class="token hvariable">x</span><span class="token punctuation">)</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Опа! Да тут и вправду нет ничего особенного. Оператор композиции применяется к двум функциям. Стоп, скажете вы, как это? Применяется к функциям? Да, именно так. Ведь мы уже выяснили, что функциями можно оперировать как данными. А раз так, что нам мешает передать функцию в качестве аргумента другой функции? Что нам мешает вернуть функцию из другой функции? Ничего.</p></div><div><p>Оператор композиции получает на вход две функции, а потом всего лишь даёт нам ЛФ, внутри которой происходит обыкновенный последовательный вызов этих двух функций через скобки. И никакой магии:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token punctuation">(</span><span class="token punctuation">.</span><span class="token punctuation">)</span>    <span class="token hvariable">f</span>        <span class="token hvariable">g</span>        <span class="token operator">=</span>  <span class="token operator">\</span><span class="token hvariable">x</span> <span class="token operator">-&gt;</span> <span class="token hvariable">f</span> <span class="token punctuation">(</span><span class="token hvariable">g</span> <span class="token hvariable">x</span><span class="token punctuation">)</span>

берём  эту      и эту       и возвращаем
       функцию  функцию     ЛФ<span class="token punctuation">,</span> внутри
                            которой
                            вызываем их
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Подставим наши функции:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token punctuation">(</span><span class="token punctuation">.</span><span class="token punctuation">)</span> <span class="token builtin">putStrLn</span> <span class="token hvariable">checkLocalhost</span> <span class="token operator">=</span> <span class="token operator">\</span><span class="token hvariable">x</span> <span class="token operator">-&gt;</span> <span class="token builtin">putStrLn</span> <span class="token punctuation">(</span><span class="token hvariable">checkLocalhost</span> <span class="token hvariable">x</span><span class="token punctuation">)</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Вот так и происходит «объединение» двух функций: мы просто возвращаем ЛФ от одного аргумента, внутри которой правоассоциативно вызываем обе функции. А аргументом в данном случае является та самая строка с IP-адресом:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token punctuation">(</span><span class="token operator">\</span><span class="token hvariable">x</span> <span class="token operator">-&gt;</span> <span class="token builtin">putStrLn</span> <span class="token punctuation">(</span><span class="token hvariable">checkLocalhost</span> <span class="token hvariable">x</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token string">"173.194.22.100"</span> <span class="token operator">=</span>

<span class="token builtin">putStrLn</span> <span class="token punctuation">(</span><span class="token hvariable">checkLocalhost</span> <span class="token string">"173.194.22.100"</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Но если я вас ещё не убедил, давайте определим собственный оператор композиции функций! Помните, я говорил вам, что ASCII-символы можно гибко объединять в операторы? Давайте возьмём плюс со стрелками, он чем-то похож на объединение. Пишем:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token comment">-- Наш собственный оператор композиции.</span>
<span class="token punctuation">(</span><span class="token operator">&lt;+&gt;</span><span class="token punctuation">)</span> <span class="token hvariable">f</span> <span class="token hvariable">g</span> <span class="token operator">=</span> <span class="token operator">\</span><span class="token hvariable">x</span> <span class="token operator">-&gt;</span> <span class="token hvariable">f</span> <span class="token punctuation">(</span><span class="token hvariable">g</span> <span class="token hvariable">x</span><span class="token punctuation">)</span>

<span class="token operator">...</span>

<span class="token hvariable">main</span> <span class="token operator">::</span> <span class="token constant">IO</span> <span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token hvariable">main</span> <span class="token operator">=</span> <span class="token builtin">putStrLn</span> <span class="token operator">&lt;+&gt;</span> <span class="token hvariable">checkLocalhost</span> <span class="token operator">$</span> <span class="token string">"173.194.22.100"</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Выглядит необычно, но работать будет так, как и ожидается: мы определили собственный оператор&nbsp;<code>&lt;+&gt;</code>&nbsp;с тем же функционалом, что и стандартный оператор композиции. Поэтому можно написать ещё проще:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token punctuation">(</span><span class="token operator">&lt;+&gt;</span><span class="token punctuation">)</span> <span class="token hvariable">f</span> <span class="token hvariable">g</span> <span class="token operator">=</span> <span class="token hvariable">f</span> <span class="token operator">.</span> <span class="token hvariable">g</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Мы говорим: «Пусть оператор&nbsp;<code>&lt;+&gt;</code>&nbsp;будет эквивалентен стандартному оператору композиции функций.». И так оно и будет. А можно — не поверите — ещё проще:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">f</span> <span class="token operator">&lt;+&gt;</span> <span class="token hvariable">g</span> <span class="token operator">=</span> <span class="token hvariable">f</span> <span class="token operator">.</span> <span class="token hvariable">g</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>И это будет работать! Раз оператор предназначен для инфиксного применения, то мы, определяя его, можно сразу указать его в инфиксной форме:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">f</span> <span class="token operator">&lt;+&gt;</span> <span class="token hvariable">g</span>    <span class="token operator">=</span>      <span class="token hvariable">f</span> <span class="token operator">.</span> <span class="token hvariable">g</span>

           пусть

такое
выражение
           будет
           равно
                  такому
                  выражению
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Теперь мы видим, что в композиции функций нет ничего сверхъестественного. Эту мысль я подчёркиваю на протяжении всей книги: в Haskell нет никакой магии, он логичен и последователен.</p></div><div><h1 data-heading="ФВП" id="ФВП">ФВП</h1></div><div><p>ФВП, или Функции Высшего Порядка (англ. HOF, Higher Order Functions) — важная концепция в Haskell, с которой, однако, мы уже знакомы. Как мы узнали из предыдущих глав, функциями можно оперировать как значениями. Так вот функции, оперирующие другими функциями как аргументами и/или как результирующим выражением, носят название функций высшего порядка.</p></div><div><p>Так, оператор композиции функций является ФВП, потому что он, во-первых, принимает функции в качестве аргументов, а во-вторых, возвращает другую функцию (в виде ЛФ) как результат своего применения. Использование функций в качестве аргументов — чрезвычайно распространённая практика в Haskell.</p></div><div><h2 data-heading="Отображение" id="Отображение" style="display: flex;"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>Отображение</h2></div><div><p>Рассмотрим функцию&nbsp;<code>map</code>. Эта стандартная функция используется для отображения (англ. mapping) функции на элементы списка. Пусть вас не смущает такой термин: отображение функции на элемент фактически означает её применение к этому элементу.</p></div><div><p>Вот объявление функции&nbsp;<code>map</code>:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token builtin">map</span> <span class="token operator">::</span> <span class="token punctuation">(</span><span class="token hvariable">a</span> <span class="token operator">-&gt;</span> <span class="token hvariable">b</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token punctuation">[</span><span class="token hvariable">a</span><span class="token punctuation">]</span> <span class="token operator">-&gt;</span> <span class="token punctuation">[</span><span class="token hvariable">b</span><span class="token punctuation">]</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Вот опять эти маленькие буквы! Помните, я обещал рассказать о них? Рассказываю: малой буквой принято именовать полиморфный (англ. polymorphic) тип. Полиморфизм — это многообразность, многоформенность. В данном случае речь идёт не об указании конкретного типа, а о «типовой заглушке». Мы говорим: «Функция&nbsp;<code>map</code>&nbsp;применяется к функции из какого-то типа&nbsp;<code>a</code>&nbsp;в какой-то тип&nbsp;<code>b</code>&nbsp;и к списку типа&nbsp;<code>[a]</code>, а результат её работы — это другой список типа&nbsp;<code>[b]</code>». Типовой заглушкой я назвал их потому, что на их место встают конкретные типы, что делает функцию&nbsp;<code>map</code>&nbsp;очень гибкой. Например:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token import-statement"><span class="token keyword">import</span> Data<span class="token punctuation">.</span>Char</span>

<span class="token hvariable">toUpperCase</span> <span class="token operator">::</span> <span class="token constant">String</span> <span class="token operator">-&gt;</span> <span class="token constant">String</span>
<span class="token hvariable">toUpperCase</span> <span class="token hvariable">str</span> <span class="token operator">=</span> <span class="token builtin">map</span> <span class="token builtin">toUpper</span> <span class="token hvariable">str</span>

<span class="token hvariable">main</span> <span class="token operator">::</span> <span class="token constant">IO</span> <span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token hvariable">main</span> <span class="token operator">=</span> <span class="token builtin">putStrLn</span> <span class="token operator">.</span> <span class="token hvariable">toUpperCase</span> <span class="token operator">$</span> <span class="token string">"haskell.org"</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Результатом работы этой программы будет строка:</p></div><div><pre class="language-bash" tabindex="0"><code class="language-bash is-loaded">HASKELL.ORG
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Функция&nbsp;<code>map</code>&nbsp;применяется к двум аргументам: к функции&nbsp;<code>toUpper</code>&nbsp;и к строке&nbsp;<code>str</code>. Функция&nbsp;<code>toUpper</code>&nbsp;из стандартного модуля&nbsp;<code>Data.Char</code>&nbsp;переводит символ типа&nbsp;<code>Char</code>&nbsp;в верхний регистр:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token builtin">toUpper</span> <span class="token char string">'a'</span> <span class="token operator">=</span> <span class="token char string">'A'</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Вот её объявление:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token builtin">toUpper</span> <span class="token operator">::</span> <span class="token constant">Char</span> <span class="token operator">-&gt;</span> <span class="token constant">Char</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Функция из&nbsp;<code>Char</code>&nbsp;в&nbsp;<code>Char</code>&nbsp;выступает первым аргументом функции&nbsp;<code>map</code>, подставим сигнатуру:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token builtin">map</span> <span class="token operator">::</span> <span class="token punctuation">(</span><span class="token hvariable">a</span>    <span class="token operator">-&gt;</span> <span class="token hvariable">b</span><span class="token punctuation">)</span>    <span class="token operator">-&gt;</span> <span class="token punctuation">[</span><span class="token hvariable">a</span><span class="token punctuation">]</span> <span class="token operator">-&gt;</span> <span class="token punctuation">[</span><span class="token hvariable">b</span><span class="token punctuation">]</span>
       <span class="token punctuation">(</span><span class="token constant">Char</span> <span class="token operator">-&gt;</span> <span class="token constant">Char</span><span class="token punctuation">)</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Ага, уже теплее! Мы сделали два новых открытия: во-первых, заглушки&nbsp;<code>a</code>&nbsp;и&nbsp;<code>b</code>&nbsp;могут быть заняты одним и тем же конкретным типом, а во-вторых, сигнатура позволяет нам тут же понять остальные типы. Подставим их:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token builtin">map</span> <span class="token operator">::</span> <span class="token punctuation">(</span><span class="token hvariable">a</span>    <span class="token operator">-&gt;</span> <span class="token hvariable">b</span><span class="token punctuation">)</span>    <span class="token operator">-&gt;</span> <span class="token punctuation">[</span><span class="token hvariable">a</span><span class="token punctuation">]</span>    <span class="token operator">-&gt;</span> <span class="token punctuation">[</span><span class="token hvariable">b</span><span class="token punctuation">]</span>
       <span class="token punctuation">(</span><span class="token constant">Char</span> <span class="token operator">-&gt;</span> <span class="token constant">Char</span><span class="token punctuation">)</span>    <span class="token punctuation">[</span><span class="token constant">Char</span><span class="token punctuation">]</span>    <span class="token punctuation">[</span><span class="token constant">Char</span><span class="token punctuation">]</span>

        <span class="token hvariable">____</span>              <span class="token hvariable">____</span>

                <span class="token hvariable">____</span>                <span class="token hvariable">____</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>А теперь вспомним о природе типа&nbsp;<code>String</code>:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token builtin">map</span> <span class="token operator">::</span> <span class="token punctuation">(</span><span class="token hvariable">a</span>    <span class="token operator">-&gt;</span> <span class="token hvariable">b</span><span class="token punctuation">)</span>    <span class="token operator">-&gt;</span> <span class="token punctuation">[</span><span class="token hvariable">a</span><span class="token punctuation">]</span>    <span class="token operator">-&gt;</span> <span class="token punctuation">[</span><span class="token hvariable">b</span><span class="token punctuation">]</span>
       <span class="token punctuation">(</span><span class="token constant">Char</span> <span class="token operator">-&gt;</span> <span class="token constant">Char</span><span class="token punctuation">)</span>    <span class="token constant">String</span>    <span class="token constant">String</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Всё встало на свои места. Функция&nbsp;<code>map</code>&nbsp;в данном случае берёт функцию&nbsp;<code>toUpper</code>&nbsp;и бежит по списку, последовательно применяя эту функцию к его элементам:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token builtin">map</span> <span class="token builtin">toUpper</span> <span class="token punctuation">[</span><span class="token char string">'h'</span><span class="token punctuation">,</span><span class="token char string">'a'</span><span class="token punctuation">,</span><span class="token char string">'s'</span><span class="token punctuation">,</span><span class="token char string">'k'</span><span class="token punctuation">,</span><span class="token char string">'e'</span><span class="token punctuation">,</span><span class="token char string">'l'</span><span class="token punctuation">,</span><span class="token char string">'l'</span><span class="token punctuation">,</span><span class="token char string">'.'</span><span class="token punctuation">,</span><span class="token char string">'o'</span><span class="token punctuation">,</span><span class="token char string">'r'</span><span class="token punctuation">,</span><span class="token char string">'g'</span><span class="token punctuation">]</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Так, на первом шаге функция&nbsp;<code>toUpper</code>&nbsp;будет применена к элементу&nbsp;<code>'h'</code>, на втором — к элементу&nbsp;<code>'a'</code>, и так далее до последнего элемента&nbsp;<code>'g'</code>. Когда функция&nbsp;<code>map</code>&nbsp;бежит по этому списку, результат применения функции&nbsp;<code>toUpper</code>&nbsp;к его элементам служит элементами для второго списка, который и будет в конечном итоге возвращён. Так, результатом первого шага будет элемент&nbsp;<code>'H'</code>, результатом второго — элемент&nbsp;<code>'A'</code>, а результатом последнего — элемент&nbsp;<code>'G'</code>. Схема такова:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token builtin">map</span> <span class="token builtin">toUpper</span> <span class="token punctuation">[</span> <span class="token char string">'h'</span>  <span class="token operator">&gt;&gt;</span>  <span class="token punctuation">[</span> <span class="token char string">'H'</span>
            <span class="token punctuation">,</span> <span class="token char string">'a'</span>  <span class="token operator">&gt;&gt;</span>  <span class="token punctuation">,</span> <span class="token char string">'A'</span>
            <span class="token punctuation">,</span> <span class="token char string">'s'</span>  <span class="token operator">&gt;&gt;</span>  <span class="token punctuation">,</span> <span class="token char string">'S'</span>
            <span class="token punctuation">,</span> <span class="token char string">'k'</span>  <span class="token operator">&gt;&gt;</span>  <span class="token punctuation">,</span> <span class="token char string">'K'</span>
            <span class="token punctuation">,</span> <span class="token char string">'e'</span>  <span class="token operator">&gt;&gt;</span>  <span class="token punctuation">,</span> <span class="token char string">'E'</span>
            <span class="token punctuation">,</span> <span class="token char string">'l'</span>  <span class="token operator">&gt;&gt;</span>  <span class="token punctuation">,</span> <span class="token char string">'L'</span>
            <span class="token punctuation">,</span> <span class="token char string">'l'</span>  <span class="token operator">&gt;&gt;</span>  <span class="token punctuation">,</span> <span class="token char string">'L'</span>
            <span class="token punctuation">,</span> <span class="token char string">'.'</span>  <span class="token operator">&gt;&gt;</span>  <span class="token punctuation">,</span> <span class="token char string">'.'</span>
            <span class="token punctuation">,</span> <span class="token char string">'o'</span>  <span class="token operator">&gt;&gt;</span>  <span class="token punctuation">,</span> <span class="token char string">'O'</span>
            <span class="token punctuation">,</span> <span class="token char string">'r'</span>  <span class="token operator">&gt;&gt;</span>  <span class="token punctuation">,</span> <span class="token char string">'R'</span>
            <span class="token punctuation">,</span> <span class="token char string">'g'</span>  <span class="token operator">&gt;&gt;</span>  <span class="token punctuation">,</span> <span class="token char string">'G'</span>
            <span class="token punctuation">]</span>          <span class="token punctuation">]</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Вот и получается:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token builtin">map</span> <span class="token builtin">toUpper</span> <span class="token string">"haskell.org"</span> <span class="token operator">=</span> <span class="token string">"HASKELL.ORG"</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Работа функции&nbsp;<code>map</code>&nbsp;выглядит как изменение списка, однако, в виду неизменности последнего, в действительности формируется новый список. Что самое интересное, функция&nbsp;<code>toUpper</code>&nbsp;пребывает в полном неведении о том, что ею в конечном итоге изменяют регистр целой строки, она знает лишь об отдельных символах этой строки. То есть функция, являющаяся аргументом функции&nbsp;<code>map</code>, ничего не знает о функции&nbsp;<code>map</code>, и это очень хорошо! Чем меньше функции знают друг о друге, тем проще и надёжнее использовать их друг с другом.</p></div><div><p>Рассмотрим другой пример, когда типовые заглушки&nbsp;<code>a</code>&nbsp;и&nbsp;<code>b</code>&nbsp;замещаются разными типами:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">toStr</span> <span class="token operator">::</span> <span class="token punctuation">[</span><span class="token constant">Double</span><span class="token punctuation">]</span> <span class="token operator">-&gt;</span> <span class="token punctuation">[</span><span class="token constant">String</span><span class="token punctuation">]</span>
<span class="token hvariable">toStr</span> <span class="token hvariable">numbers</span> <span class="token operator">=</span> <span class="token builtin">map</span> <span class="token builtin">show</span> <span class="token hvariable">numbers</span>

<span class="token hvariable">main</span> <span class="token operator">::</span> <span class="token constant">IO</span> <span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token hvariable">main</span> <span class="token operator">=</span> <span class="token builtin">print</span> <span class="token operator">.</span> <span class="token hvariable">toStr</span> <span class="token operator">$</span> <span class="token punctuation">[</span><span class="token number">1.2</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">1.6</span><span class="token punctuation">]</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Функция&nbsp;<code>toStr</code>&nbsp;работает уже со списками разных типов: на входе список чисел с плавающей точкой, на выходе список строк. При запуске этой программы мы увидим следующее:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token punctuation">[</span><span class="token string">"1.2"</span><span class="token punctuation">,</span><span class="token string">"1.0"</span><span class="token punctuation">,</span><span class="token string">"4.0"</span><span class="token punctuation">,</span><span class="token string">"1.6"</span><span class="token punctuation">]</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Уже знакомая нам стандартная функция&nbsp;<code>show</code>&nbsp;переводит свой единственный аргумент в строковый вид:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token builtin">show</span> <span class="token number">1.2</span> <span class="token operator">=</span> <span class="token string">"1.2"</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>В данном случае, раз уж мы работаем с числами типа&nbsp;<code>Double</code>, тип функции&nbsp;<code>show</code>&nbsp;такой:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token builtin">show</span> <span class="token operator">::</span> <span class="token constant">Double</span> <span class="token operator">-&gt;</span> <span class="token constant">String</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Подставим в сигнатуру функции&nbsp;<code>map</code>:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token builtin">map</span> <span class="token operator">::</span> <span class="token punctuation">(</span><span class="token hvariable">a</span>      <span class="token operator">-&gt;</span> <span class="token hvariable">b</span><span class="token punctuation">)</span>      <span class="token operator">-&gt;</span> <span class="token punctuation">[</span><span class="token hvariable">a</span><span class="token punctuation">]</span>      <span class="token operator">-&gt;</span> <span class="token punctuation">[</span><span class="token hvariable">b</span><span class="token punctuation">]</span>
       <span class="token punctuation">(</span><span class="token constant">Double</span> <span class="token operator">-&gt;</span> <span class="token constant">String</span><span class="token punctuation">)</span>    <span class="token punctuation">[</span><span class="token constant">Double</span><span class="token punctuation">]</span>    <span class="token punctuation">[</span><span class="token constant">String</span><span class="token punctuation">]</span>

        <span class="token hvariable">______</span>                <span class="token hvariable">______</span>

                  <span class="token operator">======</span>                  <span class="token operator">======</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Именно так, как у нас и есть:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token builtin">map</span> <span class="token builtin">show</span> <span class="token punctuation">[</span><span class="token number">1.2</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">1.6</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">"1.2"</span><span class="token punctuation">,</span><span class="token string">"1.0"</span><span class="token punctuation">,</span><span class="token string">"4.0"</span><span class="token punctuation">,</span><span class="token string">"1.6"</span><span class="token punctuation">]</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Функция&nbsp;<code>map</code>&nbsp;применяет функцию&nbsp;<code>show</code>&nbsp;к числам из первого списка, на выходе получаем второй список, уже со строками. И как и в случае с&nbsp;<code>toUpper</code>, функция&nbsp;<code>show</code>&nbsp;ничего не подозревает о том, что ею оперировали в качестве аргумента функции&nbsp;<code>map</code>.</p></div><div><p>Разумеется, в качестве аргумента функции&nbsp;<code>map</code>&nbsp;мы можем использовать и наши собственные функции:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">ten</span> <span class="token operator">::</span> <span class="token punctuation">[</span><span class="token constant">Double</span><span class="token punctuation">]</span> <span class="token operator">-&gt;</span> <span class="token punctuation">[</span><span class="token constant">Double</span><span class="token punctuation">]</span>
<span class="token hvariable">ten</span> <span class="token operator">=</span> <span class="token builtin">map</span> <span class="token punctuation">(</span><span class="token operator">\</span><span class="token hvariable">n</span> <span class="token operator">-&gt;</span> <span class="token hvariable">n</span> <span class="token operator">*</span> <span class="token number">10</span><span class="token punctuation">)</span>

<span class="token hvariable">main</span> <span class="token operator">::</span> <span class="token constant">IO</span> <span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token hvariable">main</span> <span class="token operator">=</span> <span class="token builtin">print</span> <span class="token operator">.</span> <span class="token hvariable">ten</span> <span class="token operator">$</span> <span class="token punctuation">[</span><span class="token number">1.2</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">1.6</span><span class="token punctuation">]</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Результат работы:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token punctuation">[</span><span class="token number">12.0</span><span class="token punctuation">,</span><span class="token number">10.0</span><span class="token punctuation">,</span><span class="token number">40.0</span><span class="token punctuation">,</span><span class="token number">16.0</span><span class="token punctuation">]</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Мы передали функции&nbsp;<code>map</code>&nbsp;нашу собственную ЛФ, умножающую свой единственный аргумент на&nbsp;<code>10</code>. Обратите внимание, мы вновь использовали краткую форму определения функции&nbsp;<code>ten</code>, опустив имя её аргумента. Раскроем подробнее:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">main</span> <span class="token operator">=</span> <span class="token builtin">print</span> <span class="token operator">.</span>         <span class="token hvariable">ten</span>        <span class="token operator">$</span> <span class="token punctuation">[</span><span class="token number">1.2</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">1.6</span><span class="token punctuation">]</span> <span class="token operator">=</span>
                 <span class="token hvariable">_____</span><span class="token operator">/</span>  <span class="token operator">\</span><span class="token hvariable">_____</span>
                <span class="token operator">/</span>              <span class="token operator">\</span>
               <span class="token operator">/</span>                <span class="token operator">\</span>
<span class="token hvariable">main</span> <span class="token operator">=</span> <span class="token builtin">print</span> <span class="token operator">.</span> <span class="token builtin">map</span> <span class="token punctuation">(</span><span class="token operator">\</span><span class="token hvariable">n</span> <span class="token operator">-&gt;</span> <span class="token hvariable">n</span> <span class="token operator">*</span> <span class="token number">10</span><span class="token punctuation">)</span> <span class="token operator">$</span> <span class="token punctuation">[</span><span class="token number">1.2</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">1.6</span><span class="token punctuation">]</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Вы спросите, как же вышло, что оператор применения расположен между двумя аргументами функции&nbsp;<code>map</code>? Разве он не предназначен для применения функции к единственному аргументу? Совершенно верно. Пришло время открыть ещё один секрет Haskell.</p></div><div><h2 data-heading="Частичное применение" id="Частичное_применение" style="display: flex;"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>Частичное применение</h2></div><div><p>Функция&nbsp;<code>map</code>&nbsp;ожидает два аргумента, это отражено в её типе. Но что будет, если применить её не к двум аргументам, а лишь к одному? В этом случае произойдёт ещё одно «магическое» превращение, называющееся частичным применением (англ. partial application) функции. Частичным называют такое применение, когда аргументов меньше чем ожидается.</p></div><div><p>Вспомним сокращённое определение функции&nbsp;<code>ten</code>:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">ten</span> <span class="token operator">=</span> <span class="token builtin">map</span> <span class="token punctuation">(</span><span class="token operator">\</span><span class="token hvariable">n</span> <span class="token operator">-&gt;</span> <span class="token hvariable">n</span> <span class="token operator">*</span> <span class="token number">10</span><span class="token punctuation">)</span>

          первый         а где же
          аргумент       второй<span class="token operator">??</span>
          есть
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Функция&nbsp;<code>map</code>&nbsp;получила лишь первый аргумент, а где же второй? Второй, как мы уже знаем, будет получен ею уже потом, после того, как мы подставим это выражение на место функции&nbsp;<code>ten</code>. Но что же происходит с функцией&nbsp;<code>map</code>&nbsp;до этого? А до этого с ней происходит частичное применение. Понятно, что она ещё не может выполнить свою работу, поэтому, будучи применённой лишь к одному аргументу, она возвращает ЛФ! Сопоставим с типом функции&nbsp;<code>map</code>, и всё встанет на свои места:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token builtin">map</span> <span class="token operator">::</span> <span class="token punctuation">(</span><span class="token hvariable">a</span> <span class="token operator">-&gt;</span> <span class="token hvariable">b</span><span class="token punctuation">)</span>        <span class="token operator">-&gt;</span> <span class="token punctuation">[</span><span class="token hvariable">a</span><span class="token punctuation">]</span>            <span class="token operator">-&gt;</span> <span class="token punctuation">[</span><span class="token hvariable">b</span><span class="token punctuation">]</span>

<span class="token builtin">map</span>    <span class="token punctuation">(</span><span class="token operator">\</span><span class="token hvariable">n</span> <span class="token operator">-&gt;</span> <span class="token hvariable">n</span> <span class="token operator">*</span> <span class="token number">10</span><span class="token punctuation">)</span>

       только первый
       аргумент

│      частично     │
│    применённая    │
└─────── <span class="token builtin">map</span> ───────┘
                          аргумент          ответ
                          для частично
                          применённой
                          функции <span class="token builtin">map</span>

                          <span class="token punctuation">[</span><span class="token number">1.2</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">1.6</span><span class="token punctuation">]</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Тип ЛФ, возвращённой после применения&nbsp;<code>map</code>&nbsp;к первому аргументу —&nbsp;<code>[a] -&gt; [b]</code>. Это «типовой хвост», оставшийся от полного типа функции&nbsp;<code>map</code>:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token builtin">map</span> <span class="token operator">::</span> <span class="token punctuation">(</span><span class="token hvariable">a</span> <span class="token operator">-&gt;</span> <span class="token hvariable">b</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token punctuation">[</span><span class="token hvariable">a</span><span class="token punctuation">]</span>  <span class="token operator">-&gt;</span>  <span class="token punctuation">[</span><span class="token hvariable">b</span><span class="token punctuation">]</span>

       голова      └── хвост ─┘
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Поскольку голова в виде первого аргумента типа&nbsp;<code>(a -&gt; b)</code>&nbsp;уже дана, осталось получить второй аргумент. Поэтому ЛФ, порождённая частичным применением, ожидает единственный аргумент, которым и будет тот самый второй, а именно список&nbsp;<code>[1.2, 1,4, 1.6]</code>.</p></div><div><p>Сопоставим тип функции&nbsp;<code>ten</code>&nbsp;с типом&nbsp;<code>map</code>, чтобы понять, где наш хвост:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">ten</span> <span class="token operator">::</span>             <span class="token punctuation">[</span><span class="token constant">Double</span><span class="token punctuation">]</span> <span class="token operator">-&gt;</span> <span class="token punctuation">[</span><span class="token constant">Double</span><span class="token punctuation">]</span>

<span class="token builtin">map</span> <span class="token operator">::</span> <span class="token punctuation">(</span><span class="token hvariable">a</span> <span class="token operator">-&gt;</span> <span class="token hvariable">b</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token punctuation">[</span><span class="token hvariable">a</span><span class="token punctuation">]</span>      <span class="token operator">-&gt;</span> <span class="token punctuation">[</span><span class="token hvariable">b</span><span class="token punctuation">]</span>

       голова      └────── хвост ─────┘
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Вот почему мы можем использовать краткую форму определения для функции&nbsp;<code>ten</code>: она уже является нашим хвостом!</p></div><div><p>Рассмотрим ещё один пример частичного применения, дабы закрепить наше понимание:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">replace</span> <span class="token operator">::</span> <span class="token constant">String</span> <span class="token operator">-&gt;</span> <span class="token constant">String</span> <span class="token operator">-&gt;</span> <span class="token constant">String</span> <span class="token operator">-&gt;</span> <span class="token constant">String</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Это объявление функции&nbsp;<code>replace</code>, принимающей три строки: первая содержит то, что ищем, вторая содержит то, на что заменяем, а в третьей лежит то, где ищем. Например:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">replace</span> <span class="token string">"http"</span>
        <span class="token string">"https"</span>
        <span class="token string">"http://google.com"</span> <span class="token operator">=</span> <span class="token string">"https://google.com"</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Определение функции&nbsp;<code>replace</code>&nbsp;нас сейчас не интересует, рассмотрим пошаговое применение:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">main</span> <span class="token operator">::</span> <span class="token constant">IO</span> <span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token hvariable">main</span> <span class="token operator">=</span> <span class="token builtin">putStrLn</span> <span class="token hvariable">result</span>
  <span class="token keyword">where</span>
    <span class="token hvariable">first</span>  <span class="token operator">=</span> <span class="token hvariable">replace</span> <span class="token string">"http"</span>
    <span class="token hvariable">second</span> <span class="token operator">=</span> <span class="token hvariable">first</span>   <span class="token string">"https"</span>
    <span class="token hvariable">result</span> <span class="token operator">=</span> <span class="token hvariable">second</span>  <span class="token string">"http://google.com"</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Тип выражения&nbsp;<code>first</code>&nbsp;—&nbsp;<code>String -&gt; String -&gt; String</code>, оно явилось результатом частичного применения функции&nbsp;<code>replace</code>&nbsp;к первому аргументу, строке&nbsp;<code>"http"</code>. Тип выражения&nbsp;<code>second</code>&nbsp;—&nbsp;<code>String -&gt; String</code>, оно явилось результатом вторичного частичного применения функции&nbsp;<code>first</code>&nbsp;к уже второму аргументу, строке&nbsp;<code>"https"</code>. И наконец, применив функцию&nbsp;<code>second</code>&nbsp;к третьему аргументу, строке&nbsp;<code>"http://google.com"</code>, мы наконец-то получаем конечный результат, ассоциированный с выражением&nbsp;<code>result</code>.</p></div><div><p>Из этого мы делаем интересное открытие:</p></div><div><blockquote>
<p>Функция от нескольких аргументов может быть разложена на последовательность применений временных функций от одного аргумента каждая.</p>
</blockquote></div><div><p>Поэтому мы и смогли подставить частично применённую&nbsp;<code>map</code>&nbsp;на место выражения&nbsp;<code>ten</code>. Используем круглые скобки, дабы яснее показать, что есть что:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">main</span> <span class="token operator">=</span> <span class="token builtin">print</span> <span class="token operator">.</span> <span class="token punctuation">(</span><span class="token builtin">map</span> <span class="token punctuation">(</span><span class="token operator">\</span><span class="token hvariable">n</span> <span class="token operator">-&gt;</span> <span class="token hvariable">n</span> <span class="token operator">*</span> <span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">$</span> <span class="token punctuation">[</span><span class="token number">1.2</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">1.6</span><span class="token punctuation">]</span>

               │     частично     │
               └─ применённая <span class="token builtin">map</span> ┘

       │    композиция функции    │
       │     <span class="token builtin">print</span> и частично     │
       └───── применённой <span class="token builtin">map</span> ────┘
                                      аргумент для
                                      композиции
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Гибко, не правда ли? Теперь мы знакомы с частичным применением функции.</p></div><div><h2 data-heading="Композиция для отображения" id="Композиция_для_отображения" style="display: flex;"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>Композиция для отображения</h2></div><div><p>Вернёмся к функции&nbsp;<code>map</code>. Если мы можем передать ей некую функцию для работы с элементами списка, значит мы можем передать ей и композицию двух или более функций. Например:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token import-statement"><span class="token keyword">import</span> Data<span class="token punctuation">.</span>Char</span>

<span class="token hvariable">pretty</span> <span class="token operator">::</span> <span class="token punctuation">[</span><span class="token constant">String</span><span class="token punctuation">]</span> <span class="token operator">-&gt;</span> <span class="token punctuation">[</span><span class="token constant">String</span><span class="token punctuation">]</span>
<span class="token hvariable">pretty</span> <span class="token operator">=</span> <span class="token builtin">map</span> <span class="token punctuation">(</span><span class="token hvariable">stars</span> <span class="token operator">.</span> <span class="token hvariable">big</span><span class="token punctuation">)</span>
  <span class="token keyword">where</span>
    <span class="token hvariable">big</span> <span class="token operator">=</span> <span class="token builtin">map</span> <span class="token builtin">toUpper</span>
    <span class="token hvariable">stars</span> <span class="token operator">=</span> <span class="token operator">\</span><span class="token hvariable">s</span> <span class="token operator">-&gt;</span> <span class="token string">"* "</span> <span class="token operator">++</span> <span class="token hvariable">s</span> <span class="token operator">++</span> <span class="token string">" *"</span>

<span class="token hvariable">main</span> <span class="token operator">::</span> <span class="token constant">IO</span> <span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token hvariable">main</span> <span class="token operator">=</span> <span class="token builtin">print</span> <span class="token operator">.</span> <span class="token hvariable">pretty</span> <span class="token operator">$</span> <span class="token punctuation">[</span><span class="token string">"haskell"</span><span class="token punctuation">,</span> <span class="token string">"lisp"</span><span class="token punctuation">,</span> <span class="token string">"coq"</span><span class="token punctuation">]</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Мы хотим украсить имена трёх языков программирования. Для этого мы пробегаемся по списку композицией двух функций,&nbsp;<code>big</code>&nbsp;и&nbsp;<code>stars</code>. Функция&nbsp;<code>big</code>&nbsp;переводит строки в верхний регистр, а функция&nbsp;<code>stars</code>&nbsp;украшает имя двумя звёздочками в начале и в конце. В результате имеем:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token punctuation">[</span><span class="token string">"* HASKELL *"</span><span class="token punctuation">,</span><span class="token string">"* LISP *"</span><span class="token punctuation">,</span><span class="token string">"* COQ *"</span><span class="token punctuation">]</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Пройтись по списку композицией&nbsp;<code>stars . big</code>&nbsp;равносильно тому, как если бы мы прошлись сначала функцией&nbsp;<code>big</code>, а затем функцией&nbsp;<code>stars</code>. При этом, как мы уже знаем, обе эти функции ничего не знают ни о том, что их скомпоновали, ни о том, что эту композицию передали функции&nbsp;<code>map</code>.</p></div><div><p>Ну что ж, теперь мы знаем о функции&nbsp;<code>map</code>, и последующих главах мы увидим множество других ФВП. Отныне они будут нашими постоянными спутниками.</p></div><div><h1 data-heading="Hackage и библиотеки" id="Hackage_и_библиотеки">Hackage и библиотеки</h1></div><div><p>Ранее я уже упоминал о библиотеках, пришло время познакомиться с ними поближе, ведь в последующих главах мы будем использовать их постоянно.</p></div><div><h2 data-heading="Библиотеки большие и маленькие" id="Библиотеки_большие_и_маленькие" style="display: flex;"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>Библиотеки большие и маленькие</h2></div><div><p>За годы существования Haskell разработчики со всего мира создали множество библиотек. Библиотеки избавляют нас от необходимости вновь и вновь писать то, что уже написано до нас. Для любого живого языка программирования написано множество библиотек. В мире Haskell их, конечно, не такая туча, как для той же Java, но порядочно: стабильных есть не менее двух тысяч, многие из которых очень качественные и уже многократно испытаны в серьёзных проектах.</p></div><div><p>С модулями — файлами, содержащими Haskell-код, — мы уже знакомы, они являются основным кирпичом любого Haskell-проекта. Библиотека, также являясь Haskell-проектом, тоже состоит из модулей (не важно, из одного или из сотен). Поэтому использование библиотеки сводится к использованию входящих в неё модулей. И мы уже неоднократно делали это в предыдущих главах.</p></div><div><p>Вспомним пример из главы про ФВП:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token import-statement"><span class="token keyword">import</span> Data<span class="token punctuation">.</span>Char</span>

<span class="token hvariable">toUpperCase</span> <span class="token operator">::</span> <span class="token constant">String</span> <span class="token operator">-&gt;</span> <span class="token constant">String</span>
<span class="token hvariable">toUpperCase</span> <span class="token hvariable">str</span> <span class="token operator">=</span> <span class="token builtin">map</span> <span class="token builtin">toUpper</span> <span class="token hvariable">str</span>

<span class="token hvariable">main</span> <span class="token operator">::</span> <span class="token constant">IO</span> <span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token hvariable">main</span> <span class="token operator">=</span> <span class="token builtin">putStrLn</span> <span class="token operator">.</span> <span class="token hvariable">toUpperCase</span> <span class="token operator">$</span> <span class="token string">"haskell.org"</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Функция&nbsp;<code>toUpper</code>&nbsp;определена в модуле&nbsp;<code>Data.Char</code>, который, в свою очередь, живёт в стандартной библиотеке. Библиотек есть множество, но стандартная лишь одна. Она содержит самые базовые, наиболее широко используемые инструменты. А прежде чем продолжить, зададимся важным вопросом: «Где живут все эти библиотеки?» Они живут в разных местах, но главное из них — Hackage.</p></div><div><h2 data-heading="Hackage" id="Hackage" style="display: flex;"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>Hackage</h2></div><div><p>Hackage — это центральный репозиторий Haskell-библиотек, или, как принято у нас называть, пакетов (англ. package). Название репозитория происходит от слияния слов&nbsp;<code>Haskell</code>&nbsp;и&nbsp;<code>package</code>. Hackage существует с 2008 года и живёт&nbsp;<a data-tooltip-position="top" aria-label="http://hackage.haskell.org/" rel="noopener" class="external-link" href="http://hackage.haskell.org/" target="_blank">здесь</a>. Ранее упомянутая стандартная библиотека тоже живёт в Hackage и называется она&nbsp;<code>base</code>. Каждой библиотеке выделена своя страница.</p></div><div><p>Каждый из Hackage-пакетов живёт по адресу, сформированному по неизменной схеме:&nbsp;<code>http://hackage.haskell.org/package/ИМЯПАКЕТА</code>. Так, дом стандартной библиотеки —&nbsp;<code>http://hackage.haskell.org/package/base</code>. Hackage — открытый репозиторий: любой разработчик может добавить туда свои пакеты.</p></div><div><p>Стандартная библиотека включает в себя более сотни модулей, но есть среди них самый известный, носящий имя&nbsp;<code>Prelude</code>. Этот модуль по умолчанию всегда с нами: всё его содержимое автоматически импортируется во все модули нашего проекта. Например, уже известные нам&nbsp;<code>map</code>&nbsp;или операторы конкатенации списков живут в модуле&nbsp;<code>Prelude</code>, поэтому доступны нам всегда. Помимо них (и многих-многих десятков других функций) в&nbsp;<code>Prelude</code>&nbsp;располагаются функции для работы с вводом-выводом, такие как наши знакомые&nbsp;<code>putStrLn</code>&nbsp;и&nbsp;<code>print</code>.</p></div><div><p>Hackage весьма большой, поэтому искать пакеты можно двумя способами. Первый — на&nbsp;<a data-tooltip-position="top" aria-label="http://hackage.haskell.org/packages/" rel="noopener" class="external-link" href="http://hackage.haskell.org/packages/" target="_blank">единой странице всех пакетов</a>. Здесь перечислены все пакеты, а для нашего удобства они расположены по тематическим категориям.</p></div><div><p>Второй способ — через специальный поисковик, коих существует два:</p></div><div><ol>
<li data-line="0"><a data-tooltip-position="top" aria-label="http://www.haskell.org/hoogle/" rel="noopener" class="external-link" href="http://www.haskell.org/hoogle/" target="_blank">Hoogle</a></li>
<li data-line="1"><a data-tooltip-position="top" aria-label="http://holumbus.fh-wedel.de/hayoo/hayoo.html" rel="noopener" class="external-link" href="http://holumbus.fh-wedel.de/hayoo/hayoo.html" target="_blank">Hayoo!</a></li>
</ol></div><div><p>Эти поисковики скрупулёзно просматривают внутренности Hackage, и вы будете часто ими пользоваться. Лично я предпочитаю&nbsp;<a data-tooltip-position="top" aria-label="http://holumbus.fh-wedel.de/hayoo/hayoo.html" rel="noopener" class="external-link" href="http://holumbus.fh-wedel.de/hayoo/hayoo.html" target="_blank">Hayoo!</a>. Пользуемся оным как обычным поисковиком: например, знаем мы имя функции, а в каком пакете/модуле она живёт — забыли. Вбиваем в поиск — получаем результаты.</p></div><div><p>Чтобы воспользоваться пакетом в нашем проекте, нужно для начала включить его в наш проект. Для примера рассмотрим пакет&nbsp;<code>text</code>, предназначенный для работы с текстом. Он нам в любом случае понадобится, поэтому включим его в наш проект незамедлительно.</p></div><div><p>Открываем сборочный файл проекта&nbsp;<code>real.cabal</code>, находим секцию&nbsp;<code>executable real-exe</code>&nbsp;и в поле&nbsp;<code>build-depends</code>&nbsp;через запятую дописываем имя пакета:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded">  <span class="token hvariable">build</span><span class="token operator">-</span><span class="token hvariable">depends</span><span class="token operator">:</span>   <span class="token hvariable">base</span>  <span class="token comment">-- Уже здесь!</span>
                 <span class="token punctuation">,</span> <span class="token hvariable">real</span>
                 <span class="token punctuation">,</span> <span class="token hvariable">text</span>  <span class="token comment">-- А это новый пакет.</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Файл с расширением&nbsp;<code>.cabal</code>&nbsp;— это обязательный сборочный файл Haskell-проекта. Он содержит главные инструкции, касающиеся сборки проекта. С синтаксисом сборочного файла мы будем постепенно знакомиться в следующих главах.</p></div><div><p>Как видите, пакет&nbsp;<code>base</code>&nbsp;уже тут. Включив пакет&nbsp;<code>text</code>&nbsp;в секцию&nbsp;<code>build-depends</code>, мы объявили тем самым, что наш проект отныне зависит от этого пакета. Теперь, находясь в корне проекта, выполняем уже знакомую нам команду:</p></div><div><pre class="language-bash" tabindex="0"><code class="language-bash is-loaded">$ stack build
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Помните, когда мы впервые настраивали проект, я упомянул, что утилита&nbsp;<code>stack</code>&nbsp;умеет ещё и библиотеки устанавливать? Она увидит новую зависимость нашего проекта и установит как сам пакет&nbsp;<code>text</code>, так и все те пакеты, от которых, в свою очередь, зависит пакет&nbsp;<code>text</code>. После сборки мы можем импортировать модули из этого пакета в наши модули. И теперь пришла пора узнать, как это можно делать.</p></div><div><h2 data-heading="Иерархия в имени" id="Иерархия_в_имени" style="display: flex;"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>Иерархия в имени</h2></div><div><p>Когда мы пишем:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token import-statement"><span class="token keyword">import</span> Data<span class="token punctuation">.</span>Char</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>в имени модуля отражена иерархия пакета.&nbsp;<code>Data.Char</code>&nbsp;означает, что внутри пакета&nbsp;<code>base</code>&nbsp;есть каталог&nbsp;<code>Data</code>, внутри которого живёт файл&nbsp;<code>Char.hs</code>, открыв который, мы увидим:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token keyword">module</span> <span class="token constant">Data<span class="token punctuation">.</span>Char</span>
<span class="token operator">...</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Таким образом, точка в имени модуля отражает файловую иерархию внутри данного пакета. Можете воспринимать эту точку как слэш в Unix-пути. Есть пакеты со значительно более длинными именами, например:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token keyword">module</span> <span class="token constant">GHC<span class="token punctuation">.</span>IO<span class="token punctuation">.</span>Encoding<span class="token punctuation">.</span>UTF8</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Соответственно, имена наших собственных модулей тоже отражают место, в котором они живут. Так, один из модулей в моём рабочем проекте носит название&nbsp;<code>Common.Performers.Click</code>. Это означает, что живёт этот модуль здесь:&nbsp;<code>src/Common/Performers/Click.hs</code>.</p></div><div><h2 data-heading="Лицо" id="Лицо" style="display: flex;"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>Лицо</h2></div><div><p>Вернёмся к нашему примеру:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token import-statement"><span class="token keyword">import</span> Data<span class="token punctuation">.</span>Char</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Импорт модуля&nbsp;<code>Data.Char</code>&nbsp;делает доступным для нас всё то, что включено в интерфейс этого модуля. Откроем наш собственный модуль&nbsp;<code>Lib</code>:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token keyword">module</span> <span class="token constant">Lib</span>
    <span class="token punctuation">(</span> <span class="token hvariable">someFunc</span>
    <span class="token punctuation">)</span> <span class="token keyword">where</span>

<span class="token hvariable">someFunc</span> <span class="token operator">::</span> <span class="token constant">IO</span> <span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token hvariable">someFunc</span> <span class="token operator">=</span> <span class="token builtin">putStrLn</span> <span class="token string">"someFunc"</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Имя функции&nbsp;<code>someFunc</code>&nbsp;упомянуто в интерфейсе модуля, а именно между круглыми скобками, следующими за именем модуля. Чуток переформатируем скобки:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token keyword">module</span> <span class="token constant">Lib</span> <span class="token punctuation">(</span>
    <span class="token hvariable">someFunc</span>
<span class="token punctuation">)</span> <span class="token keyword">where</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>В настоящий момент только функция&nbsp;<code>someFunc</code>&nbsp;доступна всем импортёрам данного модуля. Если же мы определим в этом модуле другую функцию&nbsp;<code>anotherFunc</code>:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token keyword">module</span> <span class="token constant">Lib</span> <span class="token punctuation">(</span>
    <span class="token hvariable">someFunc</span>
<span class="token punctuation">)</span> <span class="token keyword">where</span>

<span class="token hvariable">someFunc</span> <span class="token operator">::</span> <span class="token constant">IO</span> <span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token hvariable">someFunc</span> <span class="token operator">=</span> <span class="token builtin">putStrLn</span> <span class="token string">"someFunc"</span>

<span class="token hvariable">anotherFunc</span> <span class="token operator">::</span> <span class="token constant">String</span> <span class="token operator">-&gt;</span> <span class="token constant">String</span>
<span class="token hvariable">anotherFunc</span> <span class="token hvariable">s</span> <span class="token operator">=</span> <span class="token hvariable">s</span> <span class="token operator">++</span> <span class="token string">"!"</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>она останется невидимой для внешнего мира, потому что её имя не упомянуто в интерфейсе модуля. И если в модуле&nbsp;<code>Main</code>&nbsp;мы напишем так:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token keyword">module</span> <span class="token constant">Main</span>

<span class="token import-statement"><span class="token keyword">import</span> Lib</span>

<span class="token hvariable">main</span> <span class="token operator">::</span> <span class="token constant">IO</span> <span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token hvariable">main</span> <span class="token operator">=</span> <span class="token builtin">putStrLn</span> <span class="token operator">.</span> <span class="token hvariable">anotherFunc</span> <span class="token operator">$</span> <span class="token string">"Hi"</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>компилятор справедливо ругнётся, мол, не знаю функцию&nbsp;<code>anotherFunc</code>. Если же мы добавим её в интерфейс модуля&nbsp;<code>Lib</code>:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token keyword">module</span> <span class="token constant">Lib</span> <span class="token punctuation">(</span>
    <span class="token hvariable">someFunc</span><span class="token punctuation">,</span>
    <span class="token hvariable">anotherFunc</span>
<span class="token punctuation">)</span> <span class="token keyword">where</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>тогда функция&nbsp;<code>anotherFunc</code>&nbsp;тоже станет видимой всему миру. Интерфейс позволяет нам показывать окружающим лишь то, что мы хотим им показать, оставляя служебные внутренности нашего модуля тайной за семью печатями.</p></div><div><h2 data-heading="Импортируем по-разному" id="Импортируем_по-разному" style="display: flex;"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>Импортируем по-разному</h2></div><div><p>В реальных проектах мы импортируем множество модулей из различных пакетов. Иногда это является причиной конфликтов, с которыми приходится иметь дело.</p></div><div><p>Вспомним функцию&nbsp;<code>putStrLn</code>: она существует не только в незримом модуле&nbsp;<code>Prelude</code>, но и в модуле&nbsp;<code>Data.Text.IO</code>&nbsp;из пакета&nbsp;<code>text</code>:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token comment">-- Здесь тоже есть функция по имени putStrLn.</span>
<span class="token import-statement"><span class="token keyword">import</span> Data<span class="token punctuation">.</span>Text<span class="token punctuation">.</span>IO</span>

<span class="token hvariable">main</span> <span class="token operator">::</span> <span class="token constant">IO</span> <span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token hvariable">main</span> <span class="token operator">=</span> <span class="token builtin">putStrLn</span> <span class="token operator">...</span>  <span class="token comment">-- И откуда эта функция?</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>При попытке скомпилировать такой код мы упрёмся в ошибку:</p></div><div><pre class="language-bash" tabindex="0"><code class="language-bash is-loaded">Ambiguous occurrence ‘putStrLn’
It could refer to either ‘Prelude.putStrLn’,
                         imported from ‘Prelude’ <span class="token punctuation">..</span>.
                      or ‘Data.Text.IO.putStrLn’,
                         imported from ‘Data.Text.IO’ <span class="token punctuation">..</span>.
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Нам необходимо как-то указать, какую из функций&nbsp;<code>putStrLn</code>&nbsp;мы имеем в виду. Это можно сделать несколькими способами.</p></div><div><p>Можно указать принадлежность функции конкретному модулю. Из сообщения об ошибке уже видно, как это можно сделать:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token comment">-- Здесь тоже есть функция по имени putStrLn.</span>
<span class="token import-statement"><span class="token keyword">import</span> Data<span class="token punctuation">.</span>Text<span class="token punctuation">.</span>IO</span>

<span class="token hvariable">main</span> <span class="token operator">::</span> <span class="token constant">IO</span> <span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token hvariable">main</span> <span class="token operator">=</span> <span class="token constant">Data<span class="token punctuation">.</span>Text<span class="token punctuation">.</span>IO</span><span class="token punctuation">.</span><span class="token builtin">putStrLn</span> <span class="token operator">...</span>  <span class="token comment">-- Сомнений нет!</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Теперь уже сомнений не осталось: используемая нами&nbsp;<code>putStrLn</code>&nbsp;принадлежит модулю&nbsp;<code>Data.Text.IO</code>, поэтому коллизий нет.</p></div><div><p>Впрочем, не кажется ли вам подобная форма слишком длинной? В упомянутом ранее стандартном модуле&nbsp;<code>GHC.IO.Encoding.UTF8</code>&nbsp;есть функция&nbsp;<code>mkUTF8</code>, и представьте себе:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token import-statement"><span class="token keyword">import</span> GHC<span class="token punctuation">.</span>IO<span class="token punctuation">.</span>Encoding<span class="token punctuation">.</span>UTF8</span>

<span class="token hvariable">main</span> <span class="token operator">::</span> <span class="token constant">IO</span> <span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token hvariable">main</span> <span class="token operator">=</span>
  <span class="token keyword">let</span> <span class="token hvariable">enc</span> <span class="token operator">=</span> <span class="token hvariable">GHC<span class="token punctuation">.</span>IO<span class="token punctuation">.</span>Encoding<span class="token punctuation">.</span>UTF8<span class="token punctuation">.</span>mkUTF8</span> <span class="token operator">...</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Слишком длинно, нужно укоротить. Импортируем модуля под коротким именем:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token import-statement"><span class="token keyword">import</span>    Data<span class="token punctuation">.</span>Text<span class="token punctuation">.</span>IO  <span class="token keyword">as</span>   TIO</span>

включить  этот модуль   как  это

<span class="token hvariable">main</span> <span class="token operator">::</span> <span class="token constant">IO</span> <span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token hvariable">main</span> <span class="token operator">=</span> <span class="token constant">TIO</span><span class="token punctuation">.</span><span class="token builtin">putStrLn</span> <span class="token operator">...</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Вот, так значительно лучше. Короткое имя может состоять даже из одной буквы, но как и полное имя модуля, оно обязательно должно начинаться с большой буквы, поэтому:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token import-statement"><span class="token keyword">import</span> Data<span class="token punctuation">.</span>Text<span class="token punctuation">.</span>IO</span> <span class="token hvariable">as</span> <span class="token hvariable">tIO</span>  <span class="token comment">-- Ошибка</span>
<span class="token import-statement"><span class="token keyword">import</span> Data<span class="token punctuation">.</span>Text<span class="token punctuation">.</span>IO</span> <span class="token hvariable">as</span> <span class="token hvariable">i</span>    <span class="token comment">-- Тоже ошибка</span>
<span class="token import-statement"><span class="token keyword">import</span> Data<span class="token punctuation">.</span>Text<span class="token punctuation">.</span>IO <span class="token keyword">as</span> I</span>    <span class="token comment">-- Порядок!</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Иногда, для большего порядка, используют qualified-импорт:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token import-statement"><span class="token keyword">import</span> <span class="token keyword">qualified</span> Data<span class="token punctuation">.</span>Text<span class="token punctuation">.</span>IO <span class="token keyword">as</span> TIO</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Ключевое слово&nbsp;<code>qualified</code>&nbsp;используется для «строгого» включения модуля: в этом случае мы обязаны указывать принадлежность к нему. Например:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token import-statement"><span class="token keyword">import</span> <span class="token keyword">qualified</span> Data<span class="token punctuation">.</span>Text <span class="token keyword">as</span> T</span>

<span class="token hvariable">main</span> <span class="token operator">::</span> <span class="token constant">IO</span> <span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token hvariable">main</span> <span class="token operator">=</span> <span class="token hvariable">T<span class="token punctuation">.</span>justifyLeft</span> <span class="token operator">...</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Даже несмотря на то, что функция&nbsp;<code>justifyLeft</code>&nbsp;есть только в модуле&nbsp;<code>Data.Text</code>&nbsp;и никаких коллизий с&nbsp;<code>Prelude</code>&nbsp;нет, мы обязаны указать, что эта функция именно из&nbsp;<code>Data.Text</code>. В больших модулях qualified-импорт бывает полезен: с одной стороны, гарантированно не будет никаких конфликтов, с другой, мы сразу видим, откуда родом та или иная функция.</p></div><div><p>Впрочем, некоторым Haskell-программистам любое указание принадлежности к модулю кажется избыточным. Поэтому они идут по другому пути: выборочное включение/выключение. Например:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token import-statement"><span class="token keyword">import</span> Data<span class="token punctuation">.</span>Char</span>
<span class="token import-statement"><span class="token keyword">import</span> Data<span class="token punctuation">.</span>Text</span> <span class="token punctuation">(</span><span class="token builtin">pack</span><span class="token punctuation">)</span>  <span class="token comment">-- Только её!</span>

<span class="token hvariable">main</span> <span class="token operator">::</span> <span class="token constant">IO</span> <span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token hvariable">main</span> <span class="token operator">=</span> <span class="token builtin">putStrLn</span> <span class="token operator">$</span> <span class="token builtin">map</span> <span class="token builtin">toUpper</span> <span class="token string">"haskell.org"</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Мы подразумеваем стандартную функцию&nbsp;<code>map</code>, однако в модуле&nbsp;<code>Data.Text</code>&nbsp;тоже содержится функция по имени&nbsp;<code>map</code>. К счастью, никакой коллизии не будет, ведь мы импортировали не всё содержимое модуля&nbsp;<code>Data.Text</code>, а лишь одну его функцию&nbsp;<code>pack</code>:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token import-statement"><span class="token keyword">import</span>       Data<span class="token punctuation">.</span>Text</span>  <span class="token punctuation">(</span><span class="token builtin">pack</span><span class="token punctuation">)</span>

импортируем  отсюда      только
                         это
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Если же мы хотим импортировать две или более функции, перечисляем их через запятую:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token import-statement"><span class="token keyword">import</span> Data<span class="token punctuation">.</span>Text</span> <span class="token punctuation">(</span><span class="token builtin">pack</span><span class="token punctuation">,</span> <span class="token hvariable">unpack</span><span class="token punctuation">)</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Существует и прямо противоположный путь: вместо выборочного включения — выборочное выключение. Избежать коллизии между функциями&nbsp;<code>putStrLn</code>&nbsp;можно было бы и так:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token import-statement"><span class="token keyword">import</span> Data<span class="token punctuation">.</span>Text<span class="token punctuation">.</span>IO <span class="token keyword">hiding</span></span> <span class="token punctuation">(</span><span class="token builtin">putStrLn</span><span class="token punctuation">)</span>

<span class="token hvariable">main</span> <span class="token operator">::</span> <span class="token constant">IO</span> <span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token hvariable">main</span> <span class="token operator">=</span> <span class="token builtin">putStrLn</span> <span class="token operator">...</span>  <span class="token comment">-- Сомнений нет: из Prelude.</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Слово&nbsp;<code>hiding</code>&nbsp;позволяет скрывать кое-что из импортируемого модуля:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token import-statement"><span class="token keyword">import</span>       Data<span class="token punctuation">.</span>Text<span class="token punctuation">.</span>IO  <span class="token keyword">hiding</span></span> <span class="token punctuation">(</span><span class="token builtin">putStrLn</span><span class="token punctuation">)</span>

импортируем  всё отсюда    кроме   этого
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Можно и несколько функций скрыть:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token import-statement"><span class="token keyword">import</span> Data<span class="token punctuation">.</span>Text<span class="token punctuation">.</span>IO <span class="token keyword">hiding</span></span> <span class="token punctuation">(</span> <span class="token builtin">readFile</span>
                           <span class="token punctuation">,</span> <span class="token builtin">writeFile</span>
                           <span class="token punctuation">,</span> <span class="token builtin">appendFile</span>
                           <span class="token punctuation">)</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>При желании можно скрыть и из&nbsp;<code>Prelude</code>:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token import-statement"><span class="token keyword">import</span> Prelude <span class="token keyword">hiding</span></span> <span class="token punctuation">(</span><span class="token builtin">putStrLn</span><span class="token punctuation">)</span>
<span class="token import-statement"><span class="token keyword">import</span> Data<span class="token punctuation">.</span>Text<span class="token punctuation">.</span>IO</span>

<span class="token hvariable">main</span> <span class="token operator">::</span> <span class="token constant">IO</span> <span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token hvariable">main</span> <span class="token operator">=</span> <span class="token builtin">putStrLn</span> <span class="token operator">...</span>  <span class="token comment">-- Она точно из Data.Text.IO.</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><h2 data-heading="Оформление" id="Оформление" style="display: flex;"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>Оформление</h2></div><div><p>Общая рекомендация такова — оформляйте так, чтобы было легче читать. В реальном проекте в каждый из ваших модулей будет импортироваться довольно много всего. Вот кусочек из одного моего рабочего модуля:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token import-statement"><span class="token keyword">import</span> <span class="token keyword">qualified</span> Test<span class="token punctuation">.</span>WebDriver<span class="token punctuation">.</span>Commands    <span class="token keyword">as</span> WDC</span>
<span class="token import-statement"><span class="token keyword">import</span>           Test<span class="token punctuation">.</span>WebDriver<span class="token punctuation">.</span>Exceptions</span>
<span class="token import-statement"><span class="token keyword">import</span> <span class="token keyword">qualified</span> Data<span class="token punctuation">.</span>Text                  <span class="token keyword">as</span> T</span>
<span class="token import-statement"><span class="token keyword">import</span>           Data<span class="token punctuation">.</span>Maybe</span>                 <span class="token punctuation">(</span><span class="token hvariable">fromJust</span><span class="token punctuation">)</span>
<span class="token import-statement"><span class="token keyword">import</span>           Control<span class="token punctuation">.</span>Monad<span class="token punctuation">.</span>IO<span class="token punctuation">.</span>Class</span>
<span class="token import-statement"><span class="token keyword">import</span>           Control<span class="token punctuation">.</span>Monad<span class="token punctuation">.</span>Catch</span>
<span class="token import-statement"><span class="token keyword">import</span>           Control<span class="token punctuation">.</span>Monad</span>              <span class="token punctuation">(</span><span class="token hvariable">void</span><span class="token punctuation">)</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Как полные, так и краткие имена модулей выровнены, такой код проще читать и изменять. Не все программисты согласятся с таким стилем, но попробуем убрать выравнивание:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token import-statement"><span class="token keyword">import</span> <span class="token keyword">qualified</span> Test<span class="token punctuation">.</span>WebDriver<span class="token punctuation">.</span>Commands <span class="token keyword">as</span> WDC</span>
<span class="token import-statement"><span class="token keyword">import</span> Test<span class="token punctuation">.</span>WebDriver<span class="token punctuation">.</span>Exceptions</span>
<span class="token import-statement"><span class="token keyword">import</span> <span class="token keyword">qualified</span> Data<span class="token punctuation">.</span>Text <span class="token keyword">as</span> T</span>
<span class="token import-statement"><span class="token keyword">import</span> Data<span class="token punctuation">.</span>Maybe</span> <span class="token punctuation">(</span><span class="token hvariable">fromJust</span><span class="token punctuation">)</span>
<span class="token import-statement"><span class="token keyword">import</span> Control<span class="token punctuation">.</span>Monad<span class="token punctuation">.</span>IO<span class="token punctuation">.</span>Class</span>
<span class="token import-statement"><span class="token keyword">import</span> Control<span class="token punctuation">.</span>Monad<span class="token punctuation">.</span>Catch</span>
<span class="token import-statement"><span class="token keyword">import</span> Control<span class="token punctuation">.</span>Monad</span> <span class="token punctuation">(</span><span class="token hvariable">void</span><span class="token punctuation">)</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Теперь код выглядит скомканным, его труднее воспринимать. Впрочем, выбор за вами.</p></div><div><h1 data-heading="Рекурсия" id="Рекурсия">Рекурсия</h1></div><div><blockquote>
<p>Чтобы понять рекурсию, нужно сначала понять рекурсию.</p>
</blockquote></div><div><p>Эта старая шутка про рекурсию иногда пугает новичков, как в своё время напугала и меня. В действительности в рекурсии нет ничего страшного, и в этой главе мы познакомимся с этим важным механизмом.</p></div><div><h2 data-heading="Цикл" id="Цикл" style="display: flex;"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>Цикл</h2></div><div><p>Удивительно, но в Haskell нет встроенных циклических конструкций, столь привычных для других языков. Ни тебе&nbsp;<code>for</code>, ни тебе&nbsp;<code>while</code>. Однако обойтись без циклов в нашем коде мы не сможем. Как же нам их организовывать?</p></div><div><p>К счастью, чаще всего нам это и не нужно. Вспомним нашу знакомую, функцию&nbsp;<code>map</code>:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token builtin">map</span> <span class="token builtin">toUpper</span> <span class="token hvariable">someList</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Ну и чем же не цикл? На том же C это выглядело бы как-то так:</p></div><div><pre class="language-c" tabindex="0"><code class="language-c is-loaded"><span class="token keyword">int</span> length <span class="token operator">=</span> <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">int</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> length<span class="token punctuation">;</span> <span class="token operator">++</span>i<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">char</span> result <span class="token operator">=</span> <span class="token function">toUpper</span><span class="token punctuation">(</span>someList<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">.</span><span class="token punctuation">.</span><span class="token punctuation">.</span>
<span class="token punctuation">}</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Функции наподобие&nbsp;<code>map</code>&nbsp;в подавляющем большинстве случаев избавляют нас от написания явных циклических конструкций, и это не может не радовать. Однако изредка нам всё-так придётся писать циклы явно. В Haskell, из-за отсутствия&nbsp;<code>for</code>-конструкции, сделать это можно только одним способом — через рекурсию (англ. recursion).</p></div><div><p>Идея рекурсии предельно проста:</p></div><div><blockquote>
<p>Если нам нужно повторить вычисление, производимое некой функцией, мы должны применить эту функцию внутри себя самой. И получится зацикливание.</p>
</blockquote></div><div><p>Взглянем на определение функции&nbsp;<code>map</code>:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token builtin">map</span> <span class="token hvariable">_</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>     <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
<span class="token builtin">map</span> <span class="token hvariable">f</span> <span class="token punctuation">(</span><span class="token hvariable">x</span><span class="token operator">:</span><span class="token hvariable">xs</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token hvariable">f</span> <span class="token hvariable">x</span> <span class="token operator">:</span> <span class="token builtin">map</span> <span class="token hvariable">f</span> <span class="token hvariable">xs</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>А теперь разберём это интереснейшее определение по косточкам.</p></div><div><h2 data-heading="Правда о списке" id="Правда_о_списке" style="display: flex;"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>Правда о списке</h2></div><div><p>Первым аргументом, как мы помним, выступает некая функция, а вторым — список, к элементам которого применяется эта функция. Но что это за странного вида конструкция в круглых скобках?</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token punctuation">(</span><span class="token hvariable">x</span><span class="token operator">:</span><span class="token hvariable">xs</span><span class="token punctuation">)</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Это — особый образец, используемый для работы со списками. И чтобы он стал понятен, я должен рассказать вам правду о формировании списка.</p></div><div><p>Как мы помним, формируется список предельно просто:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span>  <span class="token comment">-- Список из трёх целых чисел.</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Однако в действительности он формируется несколько иначе. Привычная нам конструкция в квадратных скобках есть ни что иное, как синтаксический сахар (англ. syntactic sugar). Синтаксическим сахаром называют некое упрощение кода, делающее его слаще, приятнее для нас. Если же мы уберём сахар (или, как ещё говорят, рассахарим код), то увидим вот что:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token number">1</span> <span class="token operator">:</span> <span class="token number">2</span> <span class="token operator">:</span> <span class="token number">3</span> <span class="token operator">:</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Именно так список из трёх целых чисел формируется на самом деле. Стандартный оператор&nbsp;<code>:</code>&nbsp;нам уже знаком, мы встретились с ним в главе о списках:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">newHost</span>   <span class="token operator">:</span>         <span class="token hvariable">hosts</span>

          этот
          оператор

берёт
это
значение
                    и добавляет
                    его в начало
                    этого списка
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>То есть список строится путём добавления элемента в его «голову», начиная с пустого списка:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded">  <span class="token number">1</span> <span class="token operator">:</span> <span class="token number">2</span> <span class="token operator">:</span> <span class="token number">3</span> <span class="token operator">:</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>

<span class="token operator">=</span> <span class="token number">1</span> <span class="token operator">:</span> <span class="token number">2</span> <span class="token operator">:</span> <span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span>

<span class="token operator">=</span> <span class="token number">1</span> <span class="token operator">:</span> <span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span>

<span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Начиная с правого края, мы сначала применяем оператор&nbsp;<code>:</code>&nbsp;к&nbsp;<code>3</code>&nbsp;и пустому списку, в результате чего получаем список с единственным элементом&nbsp;<code>[3]</code>. Затем, применяя второй оператор&nbsp;<code>:</code>&nbsp;к&nbsp;<code>2</code>&nbsp;и к только что полученному списку&nbsp;<code>[3]</code>, мы получаем новый список&nbsp;<code>[2, 3]</code>. И в конце, вновь применив оператор&nbsp;<code>:</code>&nbsp;к&nbsp;<code>1</code>&nbsp;и к списку&nbsp;<code>[2, 3]</code>, мы получаем итоговый список&nbsp;<code>[1, 2, 3]</code>. Вот почему столь удобно оперировать «головой» и «хвостом» списка. И именно поэтому был создан особый образец для паттерн-матчинговой работы со списком:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token punctuation">(</span><span class="token builtin">head</span> <span class="token operator">:</span> <span class="token builtin">tail</span><span class="token punctuation">)</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>В данном случае слова&nbsp;<code>head</code>&nbsp;и&nbsp;<code>tail</code>&nbsp;не относятся к стандартным функциям, я лишь показываю назначение элементов данного образца. Вот более живой пример:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">main</span> <span class="token operator">::</span> <span class="token constant">IO</span> <span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token hvariable">main</span> <span class="token operator">=</span> <span class="token builtin">print</span> <span class="token hvariable">first</span>
  <span class="token keyword">where</span>
    <span class="token punctuation">(</span><span class="token hvariable">first</span><span class="token operator">:</span><span class="token hvariable">others</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">"He"</span><span class="token punctuation">,</span> <span class="token string">"Li"</span><span class="token punctuation">,</span> <span class="token string">"Be"</span><span class="token punctuation">]</span>

     <span class="token hvariable">_____</span>            <span class="token hvariable">____</span>

           <span class="token operator">======</span>           <span class="token operator">==========</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Поскольку мы точно знаем, что справа у нас список, слева мы пишем образец для списка, в котором&nbsp;<code>first</code>&nbsp;ассоциирован с первым элементом, с «головой», а шаблон&nbsp;<code>others</code>&nbsp;— с оставшимися элементами, с «хвостом».</p></div><div><p>Но вы спросите, зачем нам это нужно? Если уж мы так хотим работать со списком через паттерн матчинг, можно ведь воспользоваться явным образцом:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">main</span> <span class="token operator">::</span> <span class="token constant">IO</span> <span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token hvariable">main</span> <span class="token operator">=</span> <span class="token builtin">print</span> <span class="token hvariable">first</span>
  <span class="token keyword">where</span>
    <span class="token punctuation">[</span><span class="token hvariable">first</span><span class="token punctuation">,</span> <span class="token hvariable">second</span><span class="token punctuation">,</span> <span class="token hvariable">third</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">"He"</span><span class="token punctuation">,</span> <span class="token string">"Li"</span><span class="token punctuation">,</span> <span class="token string">"Be"</span><span class="token punctuation">]</span>

     <span class="token hvariable">_____</span>                    <span class="token hvariable">____</span>

            <span class="token operator">======</span>                  <span class="token operator">====</span>

                    <span class="token operator">+++++</span>                 <span class="token operator">++++</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Всё верно, однако образец с круглыми скобками чрезвычайно удобен именно для рекурсивной работы со списком, и вот почему. Вспомним определение функции&nbsp;<code>map</code>:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token builtin">map</span> <span class="token hvariable">f</span> <span class="token punctuation">(</span><span class="token hvariable">x</span><span class="token operator">:</span><span class="token hvariable">xs</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token hvariable">f</span> <span class="token hvariable">x</span> <span class="token operator">:</span> <span class="token builtin">map</span> <span class="token hvariable">f</span> <span class="token hvariable">xs</span>

       <span class="token hvariable">_</span>         <span class="token hvariable">_</span>

         <span class="token operator">==</span>                <span class="token operator">==</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Подставим реальные значения на основе примера про перевод символов строки в верхний регистр:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token builtin">map</span> <span class="token hvariable">f</span>       <span class="token punctuation">(</span><span class="token hvariable">x</span><span class="token operator">:</span><span class="token hvariable">xs</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token hvariable">f</span>       <span class="token hvariable">x</span>   <span class="token operator">:</span> <span class="token builtin">map</span> <span class="token hvariable">f</span>       <span class="token hvariable">xs</span>

<span class="token builtin">map</span> <span class="token builtin">toUpper</span> <span class="token string">"neon"</span> <span class="token operator">=</span> <span class="token builtin">toUpper</span> <span class="token char string">'n'</span> <span class="token operator">:</span> <span class="token builtin">map</span> <span class="token builtin">toUpper</span> <span class="token string">"eon"</span>

             <span class="token hvariable">_</span>                <span class="token hvariable">_</span>

              <span class="token operator">===</span>                               <span class="token operator">===</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Вот теперь-то мы видим, каким образом функция&nbsp;<code>map</code>&nbsp;пробегается по всему списку. Пройдёмся по итерациям, чтобы всё окончательно встало на свои места. У нас же цикл, верно? А где цикл — там итерации.</p></div><div><p>На первой из них оператор&nbsp;<code>:</code>&nbsp;применяется к выражениям&nbsp;<code>toUpper 'n'</code>&nbsp;и&nbsp;<code>map toUpper "eon"</code>. Выражение слева вычисляется и даёт нам символ&nbsp;<code>'N'</code>:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token builtin">toUpper</span> <span class="token char string">'n'</span> <span class="token operator">:</span> <span class="token builtin">map</span> <span class="token builtin">toUpper</span> <span class="token string">"eon"</span>

<span class="token char string">'N'</span>         <span class="token operator">:</span> <span class="token builtin">map</span> <span class="token builtin">toUpper</span> <span class="token string">"eon"</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Выражение справа содержит применение той же функции&nbsp;<code>map</code>, то есть мы входим в цикл, во вторую его итерацию:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token builtin">map</span> <span class="token builtin">toUpper</span> <span class="token string">"eon"</span> <span class="token operator">=</span> <span class="token builtin">toUpper</span> <span class="token char string">'e'</span> <span class="token operator">:</span> <span class="token builtin">map</span> <span class="token builtin">toUpper</span> <span class="token string">"on"</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Выражение слева вычисляется и даёт нам&nbsp;<code>'E'</code>:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token builtin">toUpper</span> <span class="token char string">'e'</span> <span class="token operator">:</span> <span class="token builtin">map</span> <span class="token builtin">toUpper</span> <span class="token string">"on"</span>

<span class="token char string">'E'</span>         <span class="token operator">:</span> <span class="token builtin">map</span> <span class="token builtin">toUpper</span> <span class="token string">"on"</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Вычисляем выражение справа — и входим в следующую итерацию:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token builtin">map</span> <span class="token builtin">toUpper</span> <span class="token string">"on"</span> <span class="token operator">=</span> <span class="token builtin">toUpper</span> <span class="token char string">'o'</span> <span class="token operator">:</span> <span class="token builtin">map</span> <span class="token builtin">toUpper</span> <span class="token string">"n"</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Выражение слева даёт нам&nbsp;<code>'O'</code>:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token builtin">toUpper</span> <span class="token char string">'o'</span> <span class="token operator">:</span> <span class="token builtin">map</span> <span class="token builtin">toUpper</span> <span class="token string">"n"</span>

<span class="token char string">'O'</span>         <span class="token operator">:</span> <span class="token builtin">map</span> <span class="token builtin">toUpper</span> <span class="token string">"n"</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Справа вновь применение&nbsp;<code>map</code>&nbsp;— и наша последняя итерация:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token builtin">map</span> <span class="token builtin">toUpper</span> <span class="token string">"n"</span> <span class="token operator">=</span> <span class="token builtin">toUpper</span> <span class="token char string">'n'</span> <span class="token operator">:</span> <span class="token builtin">map</span> <span class="token builtin">toUpper</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Выражение слева даёт нам&nbsp;<code>'N'</code>:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token builtin">toUpper</span> <span class="token char string">'n'</span> <span class="token operator">:</span> <span class="token builtin">map</span> <span class="token builtin">toUpper</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>

<span class="token char string">'N'</span>         <span class="token operator">:</span> <span class="token builtin">map</span> <span class="token builtin">toUpper</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Мы вытащили из списка последний из четырёх символов, и список остался пустым. Что же мы будем делать дальше? А дальше мы вспоминаем первый вариант определения функции&nbsp;<code>map</code>:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token builtin">map</span> <span class="token hvariable">_</span> <span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Здесь функция говорит: «Как только я вторым аргументом получу пустой список, я, игнорируя первый аргумент, немедленно дам тот же самый пустой список». Поэтому оставшееся на последней итерации выражение справа:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token builtin">map</span> <span class="token builtin">toUpper</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>подойдёт под данный случай и просто даст нам пустой список. Всё, готово, работа функции завершена. На каждой итерации мы откусываем «голову» списка и передаём её функции&nbsp;<code>toUpper</code>, «хвост» же передаём вновь функции&nbsp;<code>map</code>. На четвёртой итерации упираемся в пустой список и возвращаем его же. Совместив все итерации воедино, получаем вот что:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token char string">'N'</span> <span class="token operator">:</span> <span class="token char string">'E'</span> <span class="token operator">:</span> <span class="token char string">'O'</span> <span class="token operator">:</span> <span class="token char string">'N'</span> <span class="token operator">:</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Узнаёте? Это же наш рассахаренный список, соединяющийся воедино:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token punctuation">[</span><span class="token char string">'N'</span><span class="token punctuation">,</span> <span class="token char string">'E'</span><span class="token punctuation">,</span> <span class="token char string">'O'</span><span class="token punctuation">,</span> <span class="token char string">'N'</span><span class="token punctuation">]</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Вот мы и пришли к нашему равенству:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded">  <span class="token builtin">map</span> <span class="token builtin">toUpper</span> <span class="token string">"neon"</span>

<span class="token operator">=</span> <span class="token builtin">map</span> <span class="token builtin">toUpper</span> <span class="token punctuation">[</span><span class="token char string">'n'</span><span class="token punctuation">,</span> <span class="token char string">'e'</span><span class="token punctuation">,</span> <span class="token char string">'o'</span><span class="token punctuation">,</span> <span class="token char string">'n'</span><span class="token punctuation">]</span>

<span class="token operator">=</span> <span class="token punctuation">[</span><span class="token char string">'N'</span><span class="token punctuation">,</span> <span class="token char string">'E'</span><span class="token punctuation">,</span> <span class="token char string">'O'</span><span class="token punctuation">,</span> <span class="token char string">'N'</span><span class="token punctuation">]</span>

<span class="token operator">=</span> <span class="token string">"NEON"</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><h2 data-heading="Туда и обратно" id="Туда_и_обратно" style="display: flex;"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>Туда и обратно</h2></div><div><p>Определяя рекурсивную функцию, важно помнить о том, что в ней должно быть как правило зацикливания, так и правило выхода из цикла:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token builtin">map</span> <span class="token hvariable">_</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>     <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>              <span class="token comment">-- Выходим из цикла.</span>
<span class="token builtin">map</span> <span class="token hvariable">f</span> <span class="token punctuation">(</span><span class="token hvariable">x</span><span class="token operator">:</span><span class="token hvariable">xs</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token hvariable">f</span> <span class="token hvariable">x</span> <span class="token operator">:</span> <span class="token builtin">map</span> <span class="token hvariable">f</span> <span class="token hvariable">xs</span>  <span class="token comment">-- Зацикливаемся,</span>
                               <span class="token comment">-- применяя саму себя.</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Если бы мы опустили первое определение, компилятор предусмотрительно сообщил бы нам о проблеме:</p></div><div><pre class="language-bash" tabindex="0"><code class="language-bash is-loaded">Pattern match<span class="token punctuation">(</span>es<span class="token punctuation">)</span> are non-exhaustive
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>И это совершенно правильно: если на каждой итерации мы уменьшаем список, то рано или поздно список точно останется пустым, а следовательно, мы обязаны объяснить, что же делать в этом случае.</p></div><div><h2 data-heading="Для любопытных" id="Для_любопытных" style="display: flex;"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>Для любопытных</h2></div><div><p>Открою секрет: рекурсивными в Haskell бывают не только функции, но и типы. Но об этом в последующих главах.</p></div><div><h1 data-heading="Лень" id="Лень">Лень</h1></div><div><p>Помните, в главе с первыми вопросами о Haskell я упомянул, что этот язык является ленивым? Сейчас мы наконец-то узнаем о ленивых вычислениях и познакомимся с их светлой и тёмной сторонами.</p></div><div><h2 data-heading="Две модели вычислений" id="Две_модели_вычислений" style="display: flex;"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>Две модели вычислений</h2></div><div><p>Как мы уже знаем, Haskell-программа состоит из выражений, а запуск программы суть начало длинной цепочки вычислений. Вспомним функцию&nbsp;<code>square</code>, возводящую свой единственный аргумент в квадрат:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">main</span> <span class="token operator">::</span> <span class="token constant">IO</span> <span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token hvariable">main</span> <span class="token operator">=</span> <span class="token builtin">print</span> <span class="token operator">.</span> <span class="token hvariable">square</span> <span class="token operator">$</span> <span class="token number">4</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Здесь всё просто: функция&nbsp;<code>square</code>&nbsp;применяется к нередуцируемому выражению&nbsp;<code>4</code>&nbsp;и даёт нам&nbsp;<code>16</code>. А если так:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">main</span> <span class="token operator">::</span> <span class="token constant">IO</span> <span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token hvariable">main</span> <span class="token operator">=</span> <span class="token builtin">print</span> <span class="token operator">.</span> <span class="token hvariable">square</span> <span class="token operator">$</span> <span class="token number">2</span> <span class="token operator">+</span> <span class="token number">2</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Теперь функция&nbsp;<code>square</code>&nbsp;применяется уже к редуцируемому выражению:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">square</span>   <span class="token operator">$</span>            <span class="token number">2</span> <span class="token operator">+</span> <span class="token number">2</span>

функция  применяется  редуцируемому
         к            выражению
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Как вы думаете, что произойдёт раньше? Применение оператора сложения или же применение функции&nbsp;<code>square</code>? Вопрос хитрый, ведь правильного ответа на него нет, поскольку существует две модели вычисления аргументов, а именно энергичная (англ. eager) и ленивая (англ. lazy).</p></div><div><p>При энергичной модели (называемой ещё «жадной» или «строгой») выражение, являющееся аргументом функции, будет вычислено ещё до того, как попадёт в тело функции. На фоне определения функции&nbsp;<code>square</code>&nbsp;будет яснее:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">square</span>     <span class="token hvariable">x</span>   <span class="token operator">=</span> <span class="token hvariable">x</span> <span class="token operator">*</span> <span class="token hvariable">x</span>
         <span class="token operator">/</span>   <span class="token operator">\</span>
<span class="token hvariable">square</span> <span class="token operator">$</span> <span class="token number">2</span> <span class="token operator">+</span> <span class="token number">2</span>
         <span class="token operator">\</span>   <span class="token operator">/</span>
           <span class="token number">4</span>   <span class="token operator">=</span> <span class="token number">4</span> <span class="token operator">*</span> <span class="token number">4</span> <span class="token operator">=</span> <span class="token number">16</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>То есть видим выражение&nbsp;<code>2 + 2</code>, жадно на него набрасываемся, полностью вычисляем, а уже потом результат этого вычисления передаём в функцию&nbsp;<code>square</code>.</p></div><div><p>При ленивой же модели всё наоборот: выражение, являющееся аргументом функции, передаётся в функцию прямо так, без вычисления. Изобразить это можно следующим образом:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">square</span>     <span class="token hvariable">x</span>   <span class="token operator">=</span>    <span class="token hvariable">x</span>    <span class="token operator">*</span>    <span class="token hvariable">x</span>
         <span class="token operator">/</span>   <span class="token operator">\</span>    <span class="token operator">/</span>   <span class="token operator">\</span>     <span class="token operator">/</span>   <span class="token operator">\</span>
<span class="token hvariable">square</span> <span class="token operator">$</span> <span class="token number">2</span> <span class="token operator">+</span> <span class="token number">2</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token number">2</span> <span class="token operator">+</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token punctuation">(</span><span class="token number">2</span> <span class="token operator">+</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token number">16</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Но какая разница, спросите вы? Всё равно в итоге получим&nbsp;<code>16</code>, хоть там сложили, хоть тут. Так и есть: модель вычисления не влияет на результат этого вычисления, но она влияет на путь к этому результату.</p></div><div><p>Жадная модель нашла своё воплощение практически во всех современных языках программирования. Напишем на C:</p></div><div><pre class="language-c" tabindex="0"><code class="language-c is-loaded"><span class="token macro property"><span class="token directive-hash">#</span><span class="token directive keyword">include</span> <span class="token string">&lt;stdio.h&gt;</span></span>

<span class="token keyword">int</span> <span class="token function">strange</span><span class="token punctuation">(</span><span class="token keyword">int</span> i<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token number">22</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">int</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token function">printf</span><span class="token punctuation">(</span><span class="token string">"%d\n"</span><span class="token punctuation">,</span> <span class="token function">strange</span><span class="token punctuation">(</span><span class="token number">2</span> <span class="token operator">/</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Функция&nbsp;<code>strange</code>&nbsp;действительно странная, ведь она игнорирует свой аргумент и просто возвращает число&nbsp;<code>22</code>. И всё же при запуске этой программы вы гарантированно получите ошибку&nbsp;<code>Floating point exception</code>, ибо компилятор языка C категорически не терпит деления на ноль. А всё потому, что язык C придерживается энергичной модели вычислений: оператор деления&nbsp;<code>2</code>&nbsp;на&nbsp;<code>0</code>&nbsp;будет вызван ещё до того, как мы войдём в тело функции&nbsp;<code>strange</code>, поэтому программа упадёт.</p></div><div><p>Такой подход прямолинеен и строг: сказали нам сначала разделить на ноль — разделим, не задумываясь. Ленивая же модель придерживается иного подхода. Взгляните на Haskell-вариант:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">strange</span> <span class="token operator">::</span> <span class="token constant">Int</span> <span class="token operator">-&gt;</span> <span class="token constant">Int</span>
<span class="token hvariable">strange</span> <span class="token hvariable">i</span> <span class="token operator">=</span> <span class="token number">22</span>

<span class="token hvariable">main</span> <span class="token operator">::</span> <span class="token constant">IO</span> <span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token hvariable">main</span> <span class="token operator">=</span> <span class="token builtin">print</span> <span class="token operator">.</span> <span class="token hvariable">strange</span> <span class="token operator">$</span> <span class="token number">2</span> <span class="token operator">`div`</span> <span class="token number">0</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Удивительно, но при запуске этой программы мы увидим:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token number">22</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Впрочем, почему удивительно? Функция&nbsp;<code>strange</code>, проигнорировав свой аргумент, дала нам значение&nbsp;<code>22</code>, которое, попав на вход функции&nbsp;<code>print</code>, вылетело в наш терминал. Но где же ошибка деления&nbsp;<code>2</code>&nbsp;на&nbsp;<code>0</code>, спросите вы? Её нет.</p></div><div><p>Ленивый подход вполне гармонирует со своим названием: нам лень делать работу сразу же. Вместо этого мы, подобно ребёнку, которого заставили убрать разбросанные по комнате игрушки, откладываем работу до последнего. Ленивая модель гарантирует, что работа будет выполнена лишь тогда, когда результат этой работы кому-то понадобится. Если же он никому не понадобится, тогда работа не будет выполнена вовсе.</p></div><div><p>Функция&nbsp;<code>strange</code>&nbsp;ленива и потому рациональна. Она смотрит на свой аргумент&nbsp;<code>i</code>:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">strange</span> <span class="token hvariable">i</span> <span class="token operator">=</span> <span class="token number">22</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>и понимает, что он нигде не используется в её теле. Значит, он не нужен. А раз так, то и вычислен он не будет. Кстати, если аргумент функции игнорируется, определение принято писать с универсальным образцом:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">strange</span> <span class="token hvariable">_</span>     <span class="token operator">=</span> <span class="token number">22</span>

        <span class="token operator">^</span>
        нам
        всё
        равно
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Так и получается:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">strange</span>       <span class="token hvariable">_</span>     <span class="token operator">=</span> <span class="token number">22</span>
          <span class="token operator">/</span>       <span class="token operator">\</span>
<span class="token hvariable">strange</span> <span class="token operator">$</span> <span class="token number">2</span> <span class="token operator">`div`</span> <span class="token number">0</span> <span class="token operator">=</span> <span class="token number">22</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Выражение, содержащее деление на ноль, попадает внутрь функции, будучи ещё невычисленным, но поскольку в теле функции оно нигде не используется, оно так и останется невычисленным. Девиз лени: если результат работы никому не нужен — зачем же её делать? Вот почему фактического деления на ноль здесь не произойдёт и программа не рухнет.</p></div><div><p>Разумеется, если бы мы определили функцию&nbsp;<code>strange</code>&nbsp;иначе:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">strange</span> <span class="token operator">::</span> <span class="token constant">Int</span> <span class="token operator">-&gt;</span> <span class="token constant">Int</span>
<span class="token hvariable">strange</span> <span class="token hvariable">i</span> <span class="token operator">=</span> <span class="token hvariable">i</span> <span class="token operator">+</span> <span class="token number">1</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>тогда другое дело: значение аргумента уже используется в теле функции, а значит вычисление аргумента непременно произойдёт:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">strange</span>       <span class="token hvariable">i</span>     <span class="token operator">=</span>      <span class="token hvariable">i</span>      <span class="token operator">+</span> <span class="token number">1</span>
          <span class="token operator">/</span>       <span class="token operator">\</span>    <span class="token operator">/</span>       <span class="token operator">\</span>
<span class="token hvariable">strange</span> <span class="token operator">$</span> <span class="token number">2</span> <span class="token operator">`div`</span> <span class="token number">0</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token number">2</span> <span class="token operator">`div`</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Оператору сложения требуется значение обоих своих аргументов, в том числе левого, а потому получите ошибку деления на ноль.</p></div><div><h2 data-heading="Как можно меньше" id="Как_можно_меньше" style="display: flex;"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>Как можно меньше</h2></div><div><p>До тех пор, пока результат вычисления никому не нужен, оно не производится. Однако даже тогда, когда результат кому-то понадобился, вычисление происходит не до конца. Помните, выше я сказал, что при жадной модели вычисления выражение, являющееся аргументом, вычисляется «полностью»? А вот при ленивой модели мы вычисляем выражение лишь настолько, насколько это необходимо. Как вышеупомянутый ребёнок, убирающий игрушки в комнате, убирает их вовсе не до конца, а лишь до такой степени, чтобы его не ругали родители.</p></div><div><p>С точки зрения вычисления любое выражение в Haskell проходит через три стадии:</p></div><div><ol>
<li data-line="0">невычисленное,</li>
<li data-line="1">вычисленное не до конца,</li>
<li data-line="2">вычисленное до конца.</li>
</ol></div><div><p>Невычисленным называется такое выражение, которое вообще не трогали. Вспомним вышеупомянутое деление на ноль:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token number">2</span> <span class="token operator">`div`</span> <span class="token number">0</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Мы увидели, что программа не упала, и это говорит нам о том, что деления не было. То есть функция&nbsp;<code>div</code>&nbsp;так и не была применена к своим аргументам. Вообще. Такое выражение называют thunk (можно перевести как «задумка»). То есть мы задумали применить функцию&nbsp;<code>div</code>&nbsp;к&nbsp;<code>2</code>&nbsp;и к&nbsp;<code>0</code>, приготовились сделать это — но в итоге так и не сделали.</p></div><div><p>Вычисленным до конца называют такое выражение, которое вычислено до своей окончательной, нередуцируемой формы. О таком выражении говорят как о выражении в «нормальной форме» (англ. normal form).</p></div><div><p>А вот вычисленным не до конца называют такое выражение, которое начали было вычислять, но сделали это не до конца, то есть не до нормальной формы, а до так называемой «слабой головной формы» (англ. Weak Head Normal Form, WHNF). Вы спросите, как же это можно вычислить выражение не до конца? Рассмотрим пример:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">main</span> <span class="token operator">::</span> <span class="token constant">IO</span> <span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token hvariable">main</span> <span class="token operator">=</span>
  <span class="token keyword">let</span> <span class="token hvariable">cx</span>     <span class="token operator">=</span> <span class="token number">2</span> <span class="token operator">/</span> <span class="token number">6.054</span>   <span class="token comment">-- thunk</span>
      <span class="token hvariable">nk</span>     <span class="token operator">=</span> <span class="token number">4</span> <span class="token operator">*</span> <span class="token number">12.003</span>  <span class="token comment">-- thunk</span>
      <span class="token hvariable">coeffs</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token hvariable">cx</span><span class="token punctuation">,</span> <span class="token hvariable">nk</span><span class="token punctuation">]</span>    <span class="token comment">-- thunk</span>
  <span class="token keyword">in</span> <span class="token builtin">putStrLn</span> <span class="token string">"Nothing..."</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Есть у нас два коэффициента,&nbsp;<code>cx</code>&nbsp;и&nbsp;<code>nk</code>, и ещё список&nbsp;<code>coeffs</code>, в который мы поместили эти коэффициенты. Но, как мы видим, в итоге ни эти коэффициенты, ни этот список нам не понадобились: мы просто вывели строку и тихо вышли. В этом случае ни одно из этих выражений так и не было вычислено, оставшись в виде thunk. То есть оператор деления так и не был применён к&nbsp;<code>2</code>&nbsp;и&nbsp;<code>6.054</code>, оператор умножения не прикоснулся ни к&nbsp;<code>4</code>, ни к&nbsp;<code>12.003</code>, а список остался лишь в наших умах. Ленивая стратегия рациональна: зачем тратить компьютерные ресурсы на создание того, что в итоге никому не понадобится?</p></div><div><p>Изменим код:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">main</span> <span class="token operator">::</span> <span class="token constant">IO</span> <span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token hvariable">main</span> <span class="token operator">=</span>
  <span class="token keyword">let</span> <span class="token hvariable">cx</span>     <span class="token operator">=</span> <span class="token number">2</span> <span class="token operator">/</span> <span class="token number">6.054</span>   <span class="token comment">-- thunk</span>
      <span class="token hvariable">nk</span>     <span class="token operator">=</span> <span class="token number">4</span> <span class="token operator">*</span> <span class="token number">12.003</span>  <span class="token comment">-- thunk</span>
      <span class="token hvariable">coeffs</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token hvariable">cx</span><span class="token punctuation">,</span> <span class="token hvariable">nk</span><span class="token punctuation">]</span>    <span class="token comment">-- WHNF</span>
  <span class="token keyword">in</span> <span class="token builtin">print</span> <span class="token operator">$</span> <span class="token builtin">length</span> <span class="token hvariable">coeffs</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Ага, уже интереснее. В этот раз захотелось нам узнать длину списка&nbsp;<code>coeffs</code>. В этом случае нам уже не обойтись без списка, иначе как же мы узнаем его длину? Однако фокус в том, что выражение&nbsp;<code>[cx, nk]</code>&nbsp;вычисляется не до конца, а лишь до той своей формы, которая удовлетворит функцию&nbsp;<code>length</code>.</p></div><div><p>Задумаемся: функция&nbsp;<code>length</code>&nbsp;возвращает число элементов списка, но какое ей дело до содержимого этих элементов? Ровным счётом никакого. Поэтому в данном случае список формируется из thunk-ов:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">coeffs</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token hvariable">thunk</span><span class="token punctuation">,</span> <span class="token hvariable">thunk</span><span class="token punctuation">]</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Первым элементом этого списка является thunk, ассоциированный с невычисленным выражением&nbsp;<code>2 / 6.054</code>, а вторым элементом списка является thunk, ассоциированный с невычисленным выражением&nbsp;<code>4 * 12.003</code>. Фактически, список&nbsp;<code>coeffs</code>&nbsp;получился как бы не совсем настоящим, пустышечным: он был сформирован в памяти как корректный список, однако внутри обоих его элементов — вакуум. И всё же даже такая его форма вполне подходит для функции&nbsp;<code>length</code>, которая и так прекрасно поймёт, что в списке два элемента. О таком списке говорят как о выражении в слабой головной форме.</p></div><div><p>Ещё чуток изменим код:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">main</span> <span class="token operator">::</span> <span class="token constant">IO</span> <span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token hvariable">main</span> <span class="token operator">=</span>
  <span class="token keyword">let</span> <span class="token hvariable">cx</span>     <span class="token operator">=</span> <span class="token number">2</span> <span class="token operator">/</span> <span class="token number">6.054</span>   <span class="token comment">-- thunk</span>
      <span class="token hvariable">nk</span>     <span class="token operator">=</span> <span class="token number">4</span> <span class="token operator">*</span> <span class="token number">12.003</span>  <span class="token comment">-- normal</span>
      <span class="token hvariable">coeffs</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token hvariable">cx</span><span class="token punctuation">,</span> <span class="token hvariable">nk</span><span class="token punctuation">]</span>    <span class="token comment">-- WHNF</span>
  <span class="token keyword">in</span> <span class="token builtin">print</span> <span class="token operator">$</span> <span class="token hvariable">coeffs</span> <span class="token operator">!!</span> <span class="token number">1</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Необычного вида оператор&nbsp;<code>!!</code>&nbsp;извлекает из списка элемент по индексу, в данном случае нас интересует второй по счёту элемент. Теперь нам уже недостаточно просто сформировать список, нам действительно нужен его второй элемент, иначе как бы мы смогли вывести его на консоль? В этом случае выражение&nbsp;<code>4 * 12.003</code>&nbsp;будет вычислено до своей окончательной, нормальной формы, а результат этого вычисления ляжет вторым элементом списка, вот так:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">coeffs</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token hvariable">thunk</span><span class="token punctuation">,</span> <span class="token number">48.012</span><span class="token punctuation">]</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Однако первый элемент списка так и остался невостребованным, поэтому выражение&nbsp;<code>2 / 6.054</code>&nbsp;по-прежнему остаётся лишь нашей мыслью, не более чем. В этом случае список&nbsp;<code>coeffs</code>&nbsp;всё равно остаётся в слабой головной форме, ведь внутри первого его элемента всё ещё вакуум.</p></div><div><p>И теперь напишем так:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">main</span> <span class="token operator">::</span> <span class="token constant">IO</span> <span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token hvariable">main</span> <span class="token operator">=</span>
  <span class="token keyword">let</span> <span class="token hvariable">cx</span>     <span class="token operator">=</span> <span class="token number">2</span> <span class="token operator">/</span> <span class="token number">6.054</span>   <span class="token comment">-- normal</span>
      <span class="token hvariable">nk</span>     <span class="token operator">=</span> <span class="token number">4</span> <span class="token operator">*</span> <span class="token number">12.003</span>  <span class="token comment">-- normal</span>
      <span class="token hvariable">coeffs</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token hvariable">cx</span><span class="token punctuation">,</span> <span class="token hvariable">nk</span><span class="token punctuation">]</span>    <span class="token comment">-- normal</span>
  <span class="token keyword">in</span> <span class="token builtin">print</span> <span class="token hvariable">coeffs</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Вот, теперь никакой лени. Список&nbsp;<code>coeffs</code>&nbsp;должен быть выведен на консоль полностью, а следовательно, оба его элемента должны быть вычислены до своей нормальной формы, в противном случае мы не смогли бы показать их в консоли.</p></div><div><p>Вот философия ленивой стратегии: даже если нам нужно вычислить выражение, мы вычисляем его лишь до той формы, достаточной в конкретных условиях, и не более того.</p></div><div><h2 data-heading="Рациональность" id="Рациональность" style="display: flex;"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>Рациональность</h2></div><div><p>Как уже было упомянуто, ленивая стратегия помогает программе быть рациональной и не делать лишнюю работу. Рассмотрим пример:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">main</span> <span class="token operator">::</span> <span class="token constant">IO</span> <span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token hvariable">main</span> <span class="token operator">=</span> <span class="token builtin">print</span> <span class="token operator">$</span> <span class="token builtin">take</span> <span class="token number">5</span> <span class="token hvariable">evens</span>
  <span class="token keyword">where</span> <span class="token hvariable">evens</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">4</span> <span class="token operator">..</span> <span class="token number">100</span><span class="token punctuation">]</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Список&nbsp;<code>evens</code>, формируемый через арифметическую последовательность, содержит в себе чётные числа от&nbsp;<code>2</code>&nbsp;до&nbsp;<code>100</code>&nbsp;включительно. Используется этот список в качестве второго аргумента стандартной функции&nbsp;<code>take</code>, которая даёт нам N первых элементов из переданного ей списка:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token builtin">take</span>    <span class="token number">5</span>          <span class="token hvariable">evens</span>

возьми  лишь
        пять
        элементов  из этого
                   списка
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>При запуске этой программы мы получим ожидаемый результат:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">,</span><span class="token number">8</span><span class="token punctuation">,</span><span class="token number">10</span><span class="token punctuation">]</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>В чём же здесь рациональность, спросите вы? А в том, что список&nbsp;<code>evens</code>&nbsp;в итоге содержал в себе лишь 5 элементов. Да, но ведь чётных чисел от&nbsp;<code>2</code>&nbsp;до&nbsp;<code>100</code>&nbsp;куда больше, нежели пять! Совершенно верно, но лень позволяет нам сделать лишь столько работы, сколько реально требуется. Раз уж список&nbsp;<code>evens</code>&nbsp;нужен лишь функции&nbsp;<code>take</code>, которая, в свою очередь, хочет только пять первых его элементов — зачем же создавать оставшиеся элементы? Нужно первые пять — получи пять. Если же напишем так:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">main</span> <span class="token operator">::</span> <span class="token constant">IO</span> <span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token hvariable">main</span> <span class="token operator">=</span> <span class="token builtin">print</span> <span class="token operator">$</span> <span class="token builtin">take</span> <span class="token number">50</span> <span class="token hvariable">evens</span>
  <span class="token keyword">where</span> <span class="token hvariable">evens</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">4</span> <span class="token operator">..</span> <span class="token number">100</span><span class="token punctuation">]</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>тогда в списке&nbsp;<code>evens</code>&nbsp;окажется уже пятьдесят элементов, потому что именно столько запросила функция&nbsp;<code>take</code>. Повторю философию ленивого рационализма: сделаем не столько, сколько нам сказали, а лишь столько, сколько действительно понадобится.</p></div><div><h2 data-heading="Бесконечность" id="Бесконечность" style="display: flex;"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>Бесконечность</h2></div><div><p>А что будет, если мы запросим из списка&nbsp;<code>evens</code>&nbsp;500 элементов? Вот так:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">main</span> <span class="token operator">::</span> <span class="token constant">IO</span> <span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token hvariable">main</span> <span class="token operator">=</span> <span class="token builtin">print</span> <span class="token operator">$</span> <span class="token builtin">take</span> <span class="token number">500</span> <span class="token hvariable">evens</span>
  <span class="token keyword">where</span> <span class="token hvariable">evens</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">4</span> <span class="token operator">..</span> <span class="token number">100</span><span class="token punctuation">]</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Ничего страшного не случится, функция&nbsp;<code>take</code>&nbsp;проверяет выход за границы и в случае, если её первый аргумент превышает длину списка, она просто даёт нам тот же список. Да, но ведь мы хотим увидеть пятьсот чётных чисел, а не пятьдесят! Можно было бы увеличить список:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">main</span> <span class="token operator">::</span> <span class="token constant">IO</span> <span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token hvariable">main</span> <span class="token operator">=</span> <span class="token builtin">print</span> <span class="token operator">$</span> <span class="token builtin">take</span> <span class="token number">500</span> <span class="token hvariable">evens</span>
  <span class="token keyword">where</span> <span class="token hvariable">evens</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">4</span> <span class="token operator">..</span> <span class="token number">100000</span><span class="token punctuation">]</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>но это ненадёжно, ведь потом опять может потребоваться ещё больше. Нужно что-нибудь универсальное, и в Haskell есть подходящее решение:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">main</span> <span class="token operator">::</span> <span class="token constant">IO</span> <span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token hvariable">main</span> <span class="token operator">=</span> <span class="token builtin">print</span> <span class="token operator">$</span> <span class="token builtin">take</span> <span class="token number">500</span> <span class="token hvariable">evens</span>
  <span class="token keyword">where</span> <span class="token hvariable">evens</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">4</span> <span class="token operator">..</span><span class="token punctuation">]</span>  <span class="token comment">-- Что это?</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Теперь не сомневайтесь: в списке&nbsp;<code>evens</code>&nbsp;будет не менее пятисот чётных чисел. Но что это за конструкция такая? Начало дано, шаг дан, а где же конец? Познакомьтесь, это бесконечный список:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">4</span> <span class="token operator">..</span><span class="token punctuation">]</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Ленивая модель вычислений позволяет нам работать с бесконечными структурами данных. Вот прямо так, начиная с двойки и, с шагом через один, уходим в бесконечные дали… Шучу. На самом деле, список получится вовсе не бесконечным, а настолько большим, насколько нам это понадобится.</p></div><div><p>В самом деле, если функция&nbsp;<code>take</code>&nbsp;требует от нас N элементов — зачем нам вообще задавать окончание диапазона списка? Всё равно в нём будет не более чем N. Бесконечная структура данных тем и полезна, что из неё всегда можно взять столько, сколько требуется.</p></div><div><p>Конечно, если бы мы решили похулиганить:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">main</span> <span class="token operator">::</span> <span class="token constant">IO</span> <span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token hvariable">main</span> <span class="token operator">=</span> <span class="token builtin">print</span> <span class="token hvariable">evens</span>  <span class="token comment">-- Дай нам всё!</span>
  <span class="token keyword">where</span> <span class="token hvariable">evens</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">4</span> <span class="token operator">..</span><span class="token punctuation">]</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>в этом случае в нашу консоль быстро посыпалось бы очень много чисел…</p></div><div><h2 data-heading="Space leak" id="Space_leak" style="display: flex;"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>Space leak</h2></div><div><p>Да, я должен рассказать вам правду: есть у ленивой стратегии вычислений тёмная сторона, получившая название space leak (букв. «утечка пространства»). И вот в чём её суть.</p></div><div><p>Вспомним пример с делением:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">main</span> <span class="token operator">::</span> <span class="token constant">IO</span> <span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token hvariable">main</span> <span class="token operator">=</span> <span class="token builtin">print</span> <span class="token operator">.</span> <span class="token hvariable">strange</span> <span class="token operator">$</span> <span class="token number">2</span> <span class="token operator">`div`</span> <span class="token number">0</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Как мы помним, деления на ноль так и не произошло за ненадобностью его результата. В этом случае выражение осталось в виде thunk. Возникает вопрос: что же с ним стало? У нас есть функция&nbsp;<code>div</code>&nbsp;и есть два значения типа&nbsp;<code>Int</code>,&nbsp;<code>2</code>&nbsp;и&nbsp;<code>0</code>. Если функция&nbsp;<code>div</code>&nbsp;так и не была применена к ним, где же всё это хозяйство находилось в процессе работы нашей программы? Оно находилось в памяти, в виде особого графа, который можно изобразить так:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"> ┌─────────────┐
 │ <span class="token builtin">div</span> │   │   │
 └─────────────┘
         │   │
         <span class="token hvariable">v</span>   <span class="token hvariable">v</span>
      ┌───┐ ┌───┐
      │ <span class="token number">2</span> │ │ <span class="token number">0</span> │
      └───┘ └───┘
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>То есть сама функция и два значения, которые должны были занять место двух её аргументов. И вот этот граф в памяти так и остался невостребованным. Казалось бы, ну и в чём проблема? А проблема в количестве. Если мы смогли написать код, при работе которого в память отложился один thunk, значит теоретически мы можем написать и такой код, количество thunk-ов при работе которого будет исчисляться миллионами. А учитывая тот факт, что каждый thunk занимает в памяти хотя бы несколько байт, вы можете себе представить масштаб проблемы.</p></div><div><p>Причём возникнуть эта проблема может из весьма невинного на первый взгляд кода:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">bad</span> <span class="token operator">::</span> <span class="token punctuation">[</span><span class="token constant">Int</span><span class="token punctuation">]</span> <span class="token operator">-&gt;</span> <span class="token constant">Int</span> <span class="token operator">-&gt;</span> <span class="token constant">Int</span>
<span class="token hvariable">bad</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>         <span class="token hvariable">c</span> <span class="token operator">=</span> <span class="token hvariable">c</span>
<span class="token hvariable">bad</span> <span class="token punctuation">(</span><span class="token hvariable">_</span><span class="token operator">:</span><span class="token hvariable">others</span><span class="token punctuation">)</span> <span class="token hvariable">c</span> <span class="token operator">=</span> <span class="token hvariable">bad</span> <span class="token hvariable">others</span> <span class="token operator">$</span> <span class="token hvariable">c</span> <span class="token operator">+</span> <span class="token number">1</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Простенькая рекурсивная функция, пробегающаяся по ненужному ей списку и увеличивающаяся свой второй аргумент на единицу. Но я не просто так назвал её&nbsp;<code>bad</code>. Давайте применим её:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">bad</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span> <span class="token number">0</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Подставим в определение, содержащее зацикливание:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">bad</span> <span class="token punctuation">(</span><span class="token hvariable">_</span><span class="token operator">:</span> <span class="token hvariable">others</span><span class="token punctuation">)</span> <span class="token hvariable">c</span> <span class="token operator">=</span> <span class="token hvariable">bad</span> <span class="token hvariable">others</span> <span class="token operator">$</span> <span class="token hvariable">c</span> <span class="token operator">+</span> <span class="token number">1</span>

<span class="token hvariable">bad</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span>   <span class="token number">0</span> <span class="token operator">=</span> <span class="token hvariable">bad</span> <span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span> <span class="token operator">$</span> <span class="token number">0</span> <span class="token operator">+</span> <span class="token number">1</span>

        <span class="token hvariable">____</span>            <span class="token hvariable">______</span>

                <span class="token operator">=</span>                <span class="token operator">=</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>«Голова» списка откусывается и игнорируется, а к&nbsp;<code>0</code>&nbsp;прибавляется&nbsp;<code>1</code>. Но поскольку результат сложения пока что никому не нужен, сложение не производится. Вместо этого, на второй итерации, мы видим следующее:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">bad</span> <span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span> <span class="token operator">$</span> <span class="token number">0</span> <span class="token operator">+</span> <span class="token number">1</span> <span class="token operator">=</span> <span class="token hvariable">bad</span> <span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span> <span class="token operator">$</span> <span class="token punctuation">(</span><span class="token number">0</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>К предыдущему выражению вновь прибавляется единица — и мы опять входим в очередную итерацию, так и не выполнив сложения:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">bad</span> <span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span> <span class="token operator">$</span> <span class="token punctuation">(</span><span class="token number">0</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span> <span class="token operator">=</span> <span class="token hvariable">bad</span> <span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">$</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token number">0</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Опа! Упёрлись в пустой список, вспоминаем правило выхода из рекурсии:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">bad</span> <span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token hvariable">c</span> <span class="token operator">=</span> <span class="token hvariable">c</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Итак, в этом случае мы просто возвращаем значение второго аргумента. Сделаем же это:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">bad</span> <span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">$</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token number">0</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token number">0</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span> <span class="token operator">=</span> <span class="token number">3</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>И вот только здесь мы реально вычисляем второй аргумент, складывая три единицы. Вы спросите, почему же мы накапливали эти сложения вместо того, чтобы делать их сразу? Потому что мы ленивы: раз результат сложения понадобился нам лишь на последней итерации, значит до этой итерации никакого сложения не будет, ведь лень вынуждает нас откладывать работу до конца.</p></div><div><p>Вот в этом-то накоплении вся беда. Представим, что мы написали так:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">main</span> <span class="token operator">::</span> <span class="token constant">IO</span> <span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token hvariable">main</span> <span class="token operator">=</span> <span class="token builtin">print</span> <span class="token operator">$</span> <span class="token hvariable">bad</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token operator">..</span><span class="token number">50000000</span><span class="token punctuation">]</span> <span class="token number">0</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>50 миллионов элементов, а значит, 50 миллионов раз сложение второго аргумента с единицей будет откладываться, накапливая гигантский «хвост» из (пока что) невычисленных выражений. Хотите знать, что произойдёт при запуске такой программы? Её выполнение, на MacBook Pro 2014 года, займёт приблизительно 63 секунды и скушает, ни много ни мало, 6,4 ГБ памяти! А теперь представьте, что случилось бы, если бы элементов в списке было не 50 миллионов, а 50 миллиардов…</p></div><div><p>Иногда space leak ошибочно путают с другой проблемой, называемой memory leak (англ. «утечка памяти»), однако это вовсе не одно и то же. Утечка памяти — это ошибка, характерная для языков с ручным управлением памятью, например, C. Если мы выделим память в куче (англ. heap), а затем потеряем указатель, связывающий нас с этой памятью — всё, выделенная память утекла, она потеряна для нас навеки. Но в случае space leak мы не теряем память: когда весь этот «хвост» из сложений в конце концов вычислится, память, занимаемая миллионами thunk-ов, освободится. Мы не теряем память, мы просто используем её слишком много.</p></div><div><h2 data-heading="Борьба" id="Борьба" style="display: flex;"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>Борьба</h2></div><div><p>Проблема space leak вытекает из самой природы ленивых вычислений. Многие программисты, узнав об этой проблеме, отворачиваются от Haskell. Мол, если в этом языке можно легко написать код, сжирающий уймищу памяти, значит этот язык точно не подходит для серьёзного использования. Но не так страшен чёрт, как его малюют. Я расскажу о двух способах борьбы со space leak.</p></div><div><p>Впрочем, с концептуальной точки зрения способ всего один. Задумаемся: если в примере выше лень явилась причиной откладывания сложений на потом, что же можно сделать? Ответ прост: мы должны убрать излишнюю ленивость и заменить её строгостью. В этом случае применение оператора сложения уже не будет откладываться до последнего, а будет производиться тут же, как в языках со строгой моделью вычислений.</p></div><div><p>И как же мы можем разбавить лень строгостью? Вот два способа.</p></div><div><h3 data-heading="Оптимизация" id="Оптимизация" style="display: flex;"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>Оптимизация</h3></div><div><p>Первый способа самый простой — оптимизация. Когда компилятор превращает наш код в программу, его можно попросить оптимизировать наш код, сделав его более эффективным, по тем или иным критериям. Чтобы попросить компилятор провести оптимизацию, мы должны использовать специальный флаг. Откроем сборочный файл нашего проекта&nbsp;<code>real.cabal</code>, найдём секцию&nbsp;<code>executable real-exe</code>, в которой есть строка:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded">  <span class="token hvariable">ghc</span><span class="token operator">-</span><span class="token hvariable">options</span><span class="token operator">:</span>         <span class="token operator">...</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Эта строка содержит различные опции компилятора GHC, и оптимизационный флаг дописывается именно сюда. Попробуем подставить туда сначала флаг&nbsp;<code>-O0</code>, а затем&nbsp;<code>-O2</code>. Результаты запуска программы будут такими:</p></div><div><pre class="language-bash" tabindex="0"><code class="language-bash is-loaded">Оптимизация    Время    Память

-O0            <span class="token number">63</span> c     <span class="token number">6,4</span> ГБ

-O2            <span class="token number">3,2</span> с    <span class="token number">104</span> кБ
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Впечатляющая разница, не правда ли? Флаг&nbsp;<code>-O0</code>&nbsp;говорит компилятору о том, чтобы тот не производил никакую оптимизацию, в этом случае говорят о нулевом уровне оптимизации. Флаг&nbsp;<code>-O2</code>, напротив, устанавливает стандартный для production-проектов уровень оптимизации. Так вот при стандартном уровне компилятор способен распознать излишнюю ленивость в нашем коде и добавить чуток жадности. В примере выше компилятор увидит накопление thunk-ов сложения и пресечёт оное. Согласитесь, с гигабайтов прыгнуть сразу на килобайты — это круто.</p></div><div><p>Так что же, проблемы нет? Ну, если оптимизация&nbsp;<code>-O2</code>&nbsp;и так стандартна — так давайте ставить её в наши проекты и забудем про space leak! К сожалению, не всё так просто.</p></div><div><p>Во-первых, компиляторная оптимизация сродни чёрной магии, на неё трудно полагаться. Мы очень благодарны компилятору GHC за попытку помочь нам, но эта помощь не всегда соответствует нашим ожиданиям. И во-вторых, к сожалению, компилятор не всегда способен распознать излишнюю лень в нашем коде, и в этом случае нам приходится-таки прибегнуть ко второму способу борьбы со space leak.</p></div><div><h3 data-heading="Вручную" id="Вручную" style="display: flex;"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>Вручную</h3></div><div><p>Вернёмся к определению функции&nbsp;<code>bad</code>:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">bad</span> <span class="token operator">::</span> <span class="token punctuation">[</span><span class="token constant">Int</span><span class="token punctuation">]</span> <span class="token operator">-&gt;</span> <span class="token constant">Int</span> <span class="token operator">-&gt;</span> <span class="token constant">Int</span>
<span class="token hvariable">bad</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>         <span class="token hvariable">c</span> <span class="token operator">=</span> <span class="token hvariable">c</span>
<span class="token hvariable">bad</span> <span class="token punctuation">(</span><span class="token hvariable">_</span><span class="token operator">:</span><span class="token hvariable">others</span><span class="token punctuation">)</span> <span class="token hvariable">c</span> <span class="token operator">=</span> <span class="token hvariable">bad</span> <span class="token hvariable">others</span> <span class="token operator">$</span> <span class="token hvariable">c</span> <span class="token operator">+</span> <span class="token number">1</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Проблема, как мы уже поняли, во втором аргументе:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">bad</span> <span class="token hvariable">others</span> <span class="token operator">$</span> <span class="token hvariable">c</span> <span class="token operator">+</span> <span class="token number">1</span>

             накопление
             <span class="token hvariable">thunk</span><span class="token operator">-</span>ов<span class="token operator">...</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Превратим же злую функцию в добрую:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">good</span> <span class="token operator">::</span> <span class="token punctuation">[</span><span class="token constant">Int</span><span class="token punctuation">]</span> <span class="token operator">-&gt;</span> <span class="token constant">Int</span> <span class="token operator">-&gt;</span> <span class="token constant">Int</span>
<span class="token hvariable">good</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>         <span class="token hvariable">c</span> <span class="token operator">=</span> <span class="token hvariable">c</span>
<span class="token hvariable">good</span> <span class="token punctuation">(</span><span class="token hvariable">_</span><span class="token operator">:</span><span class="token hvariable">others</span><span class="token punctuation">)</span> <span class="token hvariable">c</span> <span class="token operator">=</span> <span class="token hvariable">good</span> <span class="token hvariable">others</span> <span class="token operator">$!</span> <span class="token hvariable">c</span> <span class="token operator">+</span> <span class="token number">1</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Этот код даст нам приблизительно такой же выигрыш, что и оптимизация уровня&nbsp;<code>-O2</code>: секунды вместо минуты и килобайты вместо гигабайтов. Что же изменилось? Смотрим внимательно:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">good</span> <span class="token hvariable">others</span> <span class="token operator">$!</span> <span class="token hvariable">c</span> <span class="token operator">+</span> <span class="token number">1</span>

             <span class="token operator">^</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Вместо привычного оператора применения&nbsp;<code>$</code>&nbsp;мы видим оператор строго применения&nbsp;<code>$!</code>&nbsp;(англ. strict application operator). Этот оператор говорит аргументу: «Забудь о лени, я приказываю тебе немедленно вычислиться до слабой головной формы»:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">good</span> <span class="token hvariable">others</span> <span class="token operator">$!</span>       <span class="token hvariable">c</span> <span class="token operator">+</span> <span class="token number">1</span>

            вычисли  этот
                     аргумент

            строго<span class="token punctuation">,</span>
            а не
            лениво<span class="token operator">!</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Вот потому-то наш «хвост» из thunk-ов и не будет накапливаться, ведь на каждой из 50 миллионов итераций будет происходить незамедлительное применение оператора сложения. Таким образом, заставить аргумент тут же вычислиться до слабой головной или нормальной формы можно как посредством того, что этот аргумент прямо сейчас кому-то понадобился, так и посредством строгого применения.</p></div><div><h2 data-heading="Лень и строгость вместе" id="Лень_и_строгость_вместе" style="display: flex;"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>Лень и строгость вместе</h2></div><div><p>Функцию называют ленивой по тем аргументам, которые не вычисляются, и строгой по тем аргументам, которые вычисляются. Примитивный пример:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">fakeSum</span> <span class="token operator">::</span> <span class="token constant">Int</span> <span class="token operator">-&gt;</span> <span class="token constant">Int</span> <span class="token operator">-&gt;</span> <span class="token constant">Int</span>
<span class="token hvariable">fakeSum</span> <span class="token hvariable">x</span> <span class="token hvariable">_</span> <span class="token operator">=</span> <span class="token hvariable">x</span> <span class="token operator">+</span> <span class="token number">100</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Функция&nbsp;<code>fakeSum</code>&nbsp;строга по своему первому аргументу и ленива по своему второму аргументу. Первый аргумент&nbsp;<code>x</code>&nbsp;непременно будет вычислен, ведь он передаётся оператору сложения. Второй же аргумент игнорируется, оставшись невычисленным. И кстати, существует простой способ проверить, строга ли функция по некоторому аргументу или ленива.</p></div><div><p>В стандартной библиотеке Haskell определена особая функция&nbsp;<code>undefined</code>. Это — чёрная дыра: при попытке прикоснуться к ней программа гарантированно падает с ошибкой. Проверяем:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">main</span> <span class="token operator">::</span> <span class="token constant">IO</span> <span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token hvariable">main</span> <span class="token operator">=</span> <span class="token builtin">print</span> <span class="token operator">$</span> <span class="token hvariable">fakeSum</span> <span class="token number">1</span> <span class="token builtin">undefined</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>В этом случае мы получим результат:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token number">101</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Чёрная дыра была проигнорирована, ведь функция&nbsp;<code>fakeSum</code>&nbsp;ленива по второму аргументу. Если же мы напишем так:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">main</span> <span class="token operator">::</span> <span class="token constant">IO</span> <span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token hvariable">main</span> <span class="token operator">=</span> <span class="token builtin">print</span> <span class="token operator">$</span> <span class="token hvariable">fakeSum</span> <span class="token builtin">undefined</span> <span class="token number">45</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>программа, попытавшись передать&nbsp;<code>undefined</code>&nbsp;оператору сложения, аварийно остановится. Или вот другой пример:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">main</span> <span class="token operator">::</span> <span class="token constant">IO</span> <span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token hvariable">main</span> <span class="token operator">=</span> <span class="token builtin">print</span> <span class="token operator">.</span> <span class="token builtin">head</span> <span class="token operator">$</span> <span class="token punctuation">[</span><span class="token number">23</span><span class="token punctuation">,</span> <span class="token builtin">undefined</span><span class="token punctuation">,</span> <span class="token builtin">undefined</span><span class="token punctuation">]</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Не сомневайтесь: программа спокойно вернёт нам&nbsp;<code>23</code>, ведь функция&nbsp;<code>head</code>&nbsp;строга лишь по первому элементу переданного ей списка, остальное содержимое оного её абсолютно не интересует. Но если попробуете вытащить второй или третий элемент из подобного списка — крах неминуем.</p></div><div><h2 data-heading="Для любопытных" id="Для_любопытных" style="display: flex;"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>Для любопытных</h2></div><div><p>Haskell — не первый язык с ленивой стратегией вычислений. Открою вам исторический факт: у языка Haskell был предшественник, язык программирования с красивым женским именем&nbsp;<a data-tooltip-position="top" aria-label="https://en.wikipedia.org/wiki/Miranda_(programming_language)" rel="noopener" class="external-link" href="https://en.wikipedia.org/wiki/Miranda_(programming_language)" target="_blank">Miranda</a>. Лень и чистая функциональность пришли в Haskell именно из Miranda, и лишь в этих двух языках ленивая стратегия вычисления аргументов используется по умолчанию. На сегодняшний день, насколько мне известно, язык Miranda мёртв. Впрочем, как сугубо исследовательский язык он, может быть, кем-то и используется.</p></div><div><p>Что же касается проблемы space leak, то к счастью, существуют способы обнаружения функций, шибко прожорливых до памяти. В самом деле, представьте себе большой проект, тысячи функций, и что-то кушает гигабайты памяти. Как найти виновного? Этот процесс называют ещё «space leak профилированием». Рассказывать об этом здесь я не стану, материал довольно объёмный. Но для особо любопытных привожу ссылку на неплохую англоязычную статью по теме:&nbsp;<a data-tooltip-position="top" aria-label="http://neilmitchell.blogspot.am/2013/02/chasing-space-leak-in-shake.html" rel="noopener" class="external-link" href="http://neilmitchell.blogspot.am/2013/02/chasing-space-leak-in-shake.html" target="_blank">Chasing a Space Leak in Shake</a>.</p></div><div><p>И ещё вспомним вот это:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">square</span>     <span class="token hvariable">x</span>   <span class="token operator">=</span>    <span class="token hvariable">x</span>      <span class="token operator">*</span>    <span class="token hvariable">x</span>
         <span class="token operator">/</span>   <span class="token operator">\</span>    <span class="token operator">/</span>   <span class="token operator">\</span>       <span class="token operator">/</span>   <span class="token operator">\</span>
<span class="token hvariable">square</span> <span class="token operator">$</span> <span class="token number">2</span> <span class="token operator">+</span> <span class="token number">2</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token number">2</span> <span class="token operator">+</span> <span class="token number">2</span><span class="token punctuation">)</span>   <span class="token operator">*</span> <span class="token punctuation">(</span><span class="token number">2</span> <span class="token operator">+</span> <span class="token number">2</span><span class="token punctuation">)</span>    <span class="token operator">=</span> <span class="token number">16</span>

                 вычисляем   и что<span class="token punctuation">,</span>
                             опять
                             вычисляем<span class="token operator">?!</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Внимательный читатель удивится, мол, неужели выражение&nbsp;<code>2 + 2</code>&nbsp;вычисляется дважды?! Ведь это нерационально. Конечно нерационально, поэтому в действительности оно будет вычислено единожды. В Haskell есть особый механизм «шаринга» (англ. sharing), позволяющий избежать напрасной работы. И если у нас есть несколько одинаковых выражений, вычисление оного происходит один раз, результат же сохраняется и потом просто подставляется в нужные места. Например:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">main</span> <span class="token operator">::</span> <span class="token constant">IO</span> <span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token hvariable">main</span> <span class="token operator">=</span>
  <span class="token keyword">let</span> <span class="token hvariable">x</span> <span class="token operator">=</span> <span class="token builtin">sin</span> <span class="token number">2</span> <span class="token keyword">in</span> <span class="token builtin">print</span> <span class="token hvariable">x</span> <span class="token operator">*</span> <span class="token hvariable">x</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Если бы не sharing-механизм, функция&nbsp;<code>sin</code>&nbsp;была бы применена к&nbsp;<code>2</code>&nbsp;дважды. К счастью, значение синуса будет вычислено единожды и тут же сохранено, чтобы потом просто встать на места тех двух&nbsp;<code>x</code>.</p></div><div><h1 data-heading="Наши типы" id="Наши_типы">Наши типы</h1></div><div><p>Вот мы и добрались до Второго Кита Haskell — до&nbsp;<strong>Типов</strong>. Конечно, мы работали с типами почти с самого начала, но вам уже порядком надоели все эти&nbsp;<code>Int</code>&nbsp;и&nbsp;<code>String</code>, не правда ли? Пришла пора познакомиться с типами куда ближе.</p></div><div><h2 data-heading="Знакомство" id="Знакомство" style="display: flex;"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>Знакомство</h2></div><div><p>Удивительно, но в Haskell очень мало встроенных типов, то есть таких, о которых компилятор знает с самого начала. Есть&nbsp;<code>Int</code>, есть&nbsp;<code>Double</code>,&nbsp;<code>Char</code>, ну и ещё несколько. Все же остальные типы, даже носящие статус стандартных, не являются встроенными в язык. Вместо этого они определены в стандартной или иных библиотеках, причём определены точно так же, как мы будем определять и наши собственные типы. А поскольку без своих типов написать сколь-нибудь серьёзное приложение у нас не получится, тема эта достойна самого пристального взгляда.</p></div><div><p>Определим тип&nbsp;<code>Transport</code>&nbsp;для двух известных протоколов транспортного уровня модели OSI:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token keyword">data</span> <span class="token constant">Transport</span> <span class="token operator">=</span> <span class="token constant">TCP</span> <span class="token operator">|</span> <span class="token constant">UDP</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Перед нами — очень простой, но уже наш собственный тип. Рассмотрим его внимательнее.</p></div><div><p>Ключевое слово&nbsp;<code>data</code>&nbsp;— это начало определения типа. Далее следует название типа, в данном случае&nbsp;<code>Transport</code>. Имя любого типа обязано начинаться с большой буквы. Затем идёт знак равенства, после которого начинается фактическое описание типа, его «тело». В данном случае оно состоит из двух простейших конструкторов. Конструктор значения (англ. data constructor) — это то, что строит значение данного типа. Здесь у нас два конструктора,&nbsp;<code>TCP</code>&nbsp;и&nbsp;<code>UDP</code>, каждый из которых строит значение типа&nbsp;<code>Transport</code>. Имя конструктора тоже обязано начинаться с большой буквы. Иногда для краткости конструктор значения называют просто конструктором.</p></div><div><p>Подобное определение легко читается:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token keyword">data</span>  <span class="token constant">Transport</span>  <span class="token operator">=</span>    <span class="token constant">TCP</span>  <span class="token operator">|</span>    <span class="token constant">UDP</span>

тип   <span class="token constant">Transport</span>  это  <span class="token constant">TCP</span>  или  <span class="token constant">UDP</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Теперь мы можем использовать тип&nbsp;<code>Transport</code>, то есть создавать значения этого типа и что-то с ними делать. Например, в&nbsp;<code>let</code>-выражении:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded">  <span class="token keyword">let</span> <span class="token hvariable">protocol</span> <span class="token operator">=</span> <span class="token constant">TCP</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Мы создали значение&nbsp;<code>protocol</code>&nbsp;типа&nbsp;<code>Transport</code>, использовав конструктор&nbsp;<code>TCP</code>. А можно и так:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded">  <span class="token keyword">let</span> <span class="token hvariable">protocol</span> <span class="token operator">=</span> <span class="token constant">UDP</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Хотя мы использовали разные конструкторы, тип значения&nbsp;<code>protocol</code>&nbsp;в обоих случаях один и тот же —&nbsp;<code>Transport</code>.</p></div><div><p>Расширить подобный тип предельно просто. Добавим новый протокол SCTP (Stream Control Transmission Protocol):</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token keyword">data</span> <span class="token constant">Transport</span> <span class="token operator">=</span> <span class="token constant">TCP</span> <span class="token operator">|</span> <span class="token constant">UDP</span> <span class="token operator">|</span> <span class="token constant">SCTP</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Третий конструктор значения дал нам третий способ создать значение типа&nbsp;<code>Transport</code>.</p></div><div><h2 data-heading="Значение-пустышка" id="Значение-пустышка" style="display: flex;"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>Значение-пустышка</h2></div><div><p>Задумаемся: говоря о значении типа&nbsp;<code>Transport</code>&nbsp;— о чём в действительности идёт речь? Казалось бы, значения-то фактического нет: ни числа никакого, ни строки — просто три конструктора. Так вот они и есть значения. Когда мы пишем:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded">  <span class="token keyword">let</span> <span class="token hvariable">protocol</span> <span class="token operator">=</span> <span class="token constant">SCTP</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>мы создаём значение типа&nbsp;<code>Transport</code>&nbsp;с конкретным содержимым в виде&nbsp;<code>SCTP</code>. Конструктор — это и есть содержимое. Данный вид конструктора называется нульарным (англ. nullary). Тип&nbsp;<code>Transport</code>&nbsp;имеет три нульарных конструктора. И даже столь простой тип уже может быть полезен нам:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">checkProtocol</span> <span class="token operator">::</span> <span class="token constant">Transport</span> <span class="token operator">-&gt;</span> <span class="token constant">String</span>
<span class="token hvariable">checkProtocol</span> <span class="token hvariable">transport</span> <span class="token operator">=</span> <span class="token keyword">case</span> <span class="token hvariable">transport</span> <span class="token keyword">of</span>
  <span class="token constant">TCP</span>  <span class="token operator">-&gt;</span> <span class="token string">"That's TCP protocol."</span>
  <span class="token constant">UDP</span>  <span class="token operator">-&gt;</span> <span class="token string">"That's UDP protocol."</span>
  <span class="token constant">SCTP</span> <span class="token operator">-&gt;</span> <span class="token string">"That's SCTP protocol."</span>

<span class="token hvariable">main</span> <span class="token operator">::</span> <span class="token constant">IO</span> <span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token hvariable">main</span> <span class="token operator">=</span> <span class="token builtin">putStrLn</span> <span class="token operator">.</span> <span class="token hvariable">checkProtocol</span> <span class="token operator">$</span> <span class="token constant">TCP</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>В результате увидим:</p></div><div><pre class="language-bash" tabindex="0"><code class="language-bash is-loaded">That's TCP protocol.
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Функция&nbsp;<code>checkProtocol</code>&nbsp;объявлена как принимающая аргумент типа&nbsp;<code>Transport</code>, а применяется она к значению, порождённому конструктором&nbsp;<code>TCP</code>. В данном случае конструкция&nbsp;<code>case-of</code>&nbsp;сравнивает аргумент с конструкторами. Именно поэтому нам не нужна функция&nbsp;<code>otherwise</code>, ведь никаким иным способом, кроме как с помощью трёх конструкторов, значение типа&nbsp;<code>Transport</code>&nbsp;создать невозможно, а значит, один из конструкторов гарантированно совпадёт.</p></div><div><p>Тип, состоящий только из нульарных конструкторов, называют ещё перечислением (англ. enumeration). Конструкторов может быть сколько угодно, в том числе один-единственный (хотя польза от подобного типа была бы невелика). Вот ещё один известный пример:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token keyword">data</span> <span class="token constant">Day</span> <span class="token operator">=</span> <span class="token constant">Sunday</span>
         <span class="token operator">|</span> <span class="token constant">Monday</span>
         <span class="token operator">|</span> <span class="token constant">Tuesday</span>
         <span class="token operator">|</span> <span class="token constant">Wednesday</span>
         <span class="token operator">|</span> <span class="token constant">Thursday</span>
         <span class="token operator">|</span> <span class="token constant">Friday</span>
         <span class="token operator">|</span> <span class="token constant">Saturday</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Обратите внимание на форматирование, когда ментальные «ИЛИ» выровнены строго под знаком равенства. Такой стиль вы встретите во многих реальных Haskell-проектах.</p></div><div><p>Значение типа&nbsp;<code>Day</code>&nbsp;отражено одним из семи конструкторов. Сделаем же с ними что-нибудь:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token keyword">data</span> <span class="token constant">WorkMode</span> <span class="token operator">=</span> <span class="token constant">FiveDays</span> <span class="token operator">|</span> <span class="token constant">SixDays</span>

<span class="token hvariable">workingDays</span> <span class="token operator">::</span> <span class="token constant">WorkMode</span> <span class="token operator">-&gt;</span> <span class="token punctuation">[</span><span class="token constant">Day</span><span class="token punctuation">]</span>
<span class="token hvariable">workingDays</span> <span class="token constant">FiveDays</span> <span class="token operator">=</span> <span class="token punctuation">[</span> <span class="token constant">Monday</span>
                       <span class="token punctuation">,</span> <span class="token constant">Tuesday</span>
                       <span class="token punctuation">,</span> <span class="token constant">Wednesday</span>
                       <span class="token punctuation">,</span> <span class="token constant">Thursday</span>
                       <span class="token punctuation">,</span> <span class="token constant">Friday</span>
                       <span class="token punctuation">]</span>
<span class="token hvariable">workingDays</span> <span class="token constant">SixDays</span> <span class="token operator">=</span> <span class="token punctuation">[</span> <span class="token constant">Monday</span>
                      <span class="token punctuation">,</span> <span class="token constant">Tuesday</span>
                      <span class="token punctuation">,</span> <span class="token constant">Wednesday</span>
                      <span class="token punctuation">,</span> <span class="token constant">Thursday</span>
                      <span class="token punctuation">,</span> <span class="token constant">Friday</span>
                      <span class="token punctuation">,</span> <span class="token constant">Saturday</span>
                      <span class="token punctuation">]</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Функция&nbsp;<code>workingDays</code>&nbsp;возвращает список типа&nbsp;<code>[Day]</code>, и в случае пятидневной рабочей недели, отражённой конструктором&nbsp;<code>FiveDays</code>, этот список сформирован пятью конструкторами, а в случае шестидневной — шестью конструкторами.</p></div><div><p>Польза от типов, сформированных нульарными конструкторами, не очень велика, хотя встречаться с такими типами вы будете часто.</p></div><div><p>Приоткрою секрет: новый тип можно определить не только с помощью ключевого слова&nbsp;<code>data</code>, но об этом узнаем в одной из следующих глав.</p></div><div><p>А теперь мы можем познакомиться с типами куда более полезными.</p></div><div><h1 data-heading="АТД" id="АТД">АТД</h1></div><div><p>АТД, или Алгебраические Типы Данных (англ. ADT, Algebraic Data Type), занимают почётное место в мире типов Haskell. Абсолютно подавляющее большинство ваших собственных типов будут алгебраическими, и то же можно сказать о типах из множества Haskell-пакетов. Алгебраическим типом данных называют такой тип, который составлен из других типов. Мы берём простые типы и строим из них, как из кирпичей, типы сложные, а из них — ещё более сложные. Это даёт нам невероятный простор для творчества.</p></div><div><p>Оставим сетевые протоколы и дни недели, рассмотрим такой пример:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token keyword">data</span> <span class="token constant">IPAddress</span> <span class="token operator">=</span> <span class="token constant">IPAddress</span> <span class="token constant">String</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Тип&nbsp;<code>IPAddress</code>&nbsp;использует один-единственный конструктор значения, но кое-что изменилось. Во-первых, имена типа и конструктора совпадают. Это вполне легально, вы встретите такое не раз. Во-вторых, конструктор уже не нульарный, а унарный (англ. unary), потому что теперь он связан с одним значением типа&nbsp;<code>String</code>. И вот как создаются значения типа&nbsp;<code>IPAddress</code>:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded">  <span class="token keyword">let</span> <span class="token hvariable">ip</span> <span class="token operator">=</span> <span class="token constant">IPAddress</span> <span class="token string">"127.0.0.1"</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Значение&nbsp;<code>ip</code>&nbsp;типа&nbsp;<code>IPAddress</code>&nbsp;образовано конструктором и конкретным значением некоего типа:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded">  <span class="token keyword">let</span> <span class="token hvariable">ip</span> <span class="token operator">=</span> <span class="token constant">IPAddress</span>       <span class="token string">"127.0.0.1"</span>

           конструктор     значение
           значения        типа
           типа <span class="token constant">IPAddress</span>  <span class="token constant">String</span>

           └ значение типа <span class="token constant">IPAddress</span> ┘
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Значение внутри нашего типа называют ещё полем (англ. field):</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token keyword">data</span> <span class="token constant">IPAddress</span> <span class="token operator">=</span> <span class="token constant">IPAddress</span>    <span class="token constant">String</span>

     тип         конструктор  поле
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Расширим тип&nbsp;<code>IPAddress</code>, сделав его более современным:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token keyword">data</span> <span class="token constant">IPAddress</span> <span class="token operator">=</span> <span class="token constant">IPv4</span> <span class="token constant">String</span> <span class="token operator">|</span> <span class="token constant">IPv6</span> <span class="token constant">String</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Теперь у нас два конструктора, соответствующих разным IP-версиям. Это позволит нам создавать значение типа&nbsp;<code>IPAddress</code>&nbsp;так:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded">  <span class="token keyword">let</span> <span class="token hvariable">ip</span> <span class="token operator">=</span> <span class="token constant">IPv4</span> <span class="token string">"127.0.0.1"</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>или так:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded">  <span class="token keyword">let</span> <span class="token hvariable">ip</span> <span class="token operator">=</span> <span class="token constant">IPv6</span> <span class="token string">"2001:0db8:0000:0042:0000:8a2e:0370:7334"</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Сделаем тип ещё более удобным. Так, при работе с IP-адресом нам часто требуется&nbsp;<code>localhost</code>. И чтобы явно не писать&nbsp;<code>"127.0.0.1"</code>&nbsp;и&nbsp;<code>"0:0:0:0:0:0:0:1"</code>, введём ещё два конструктора:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token keyword">data</span> <span class="token constant">IPAddress</span> <span class="token operator">=</span> <span class="token constant">IPv4</span> <span class="token constant">String</span>
               <span class="token operator">|</span> <span class="token constant">IPv4Localhost</span>
               <span class="token operator">|</span> <span class="token constant">IPv6</span> <span class="token constant">String</span>
               <span class="token operator">|</span> <span class="token constant">IPv6Localhost</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Поскольку значения&nbsp;<code>localhost</code>&nbsp;нам заведомо известны, нет нужды указывать их явно. Вместо этого, когда нам понадобится&nbsp;<code>IPv4-localhost</code>, пишем так:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded">    <span class="token keyword">let</span> <span class="token hvariable">ip</span> <span class="token operator">=</span> <span class="token constant">IPv4Localhost</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><h2 data-heading="Извлекаем значение" id="Извлекаем_значение" style="display: flex;"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>Извлекаем значение</h2></div><div><p>Допустим, мы создали значение&nbsp;<code>google</code>:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded">  <span class="token keyword">let</span> <span class="token hvariable">google</span> <span class="token operator">=</span> <span class="token constant">IPv4</span> <span class="token string">"173.194.122.194"</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Как же нам потом извлечь конкретное строковое значение из&nbsp;<code>google</code>? С помощью нашего старого друга, паттерн матчинга:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">checkIP</span> <span class="token operator">::</span> <span class="token constant">IPAddress</span> <span class="token operator">-&gt;</span> <span class="token constant">String</span>
<span class="token hvariable">checkIP</span> <span class="token punctuation">(</span><span class="token constant">IPv4</span> <span class="token hvariable">address</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token string">"IP is '"</span> <span class="token operator">++</span> <span class="token hvariable">address</span> <span class="token operator">++</span> <span class="token string">"'."</span>

<span class="token hvariable">main</span> <span class="token operator">::</span> <span class="token constant">IO</span> <span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token hvariable">main</span> <span class="token operator">=</span> <span class="token builtin">putStrLn</span> <span class="token operator">.</span> <span class="token hvariable">checkIP</span> <span class="token operator">$</span> <span class="token constant">IPv4</span> <span class="token string">"173.194.122.194"</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Результат:</p></div><div><pre class="language-bash" tabindex="0"><code class="language-bash is-loaded">IP is <span class="token string">'173.194.122.194'</span><span class="token builtin class-name">.</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Взглянем на определение:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">checkIP</span> <span class="token punctuation">(</span><span class="token constant">IPv4</span> <span class="token hvariable">address</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token string">"IP is '"</span> <span class="token operator">++</span> <span class="token hvariable">address</span> <span class="token operator">++</span> <span class="token string">"'."</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Здесь мы говорим: «Мы знаем, что значение типа&nbsp;<code>IPAddress</code>&nbsp;сформировано с конструктором и строкой». Однако внимательный компилятор сделает нам замечание:</p></div><div><pre class="language-bash" tabindex="0"><code class="language-bash is-loaded">Pattern match<span class="token punctuation">(</span>es<span class="token punctuation">)</span> are non-exhaustive
In an equation <span class="token keyword">for</span> ‘checkIP’:
    Patterns not matched:
        IPv4Localhost
        IPv6 _
        IPv6Localhost
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>В самом деле, откуда мы знаем, что значение, к которому применили функцию&nbsp;<code>checkIP</code>, было сформировано именно с помощью конструктора&nbsp;<code>IPv4</code>? У нас же есть ещё три конструктора, и нам следует проверить их все:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">checkIP</span> <span class="token operator">::</span> <span class="token constant">IPAddress</span> <span class="token operator">-&gt;</span> <span class="token constant">String</span>
<span class="token hvariable">checkIP</span> <span class="token punctuation">(</span><span class="token constant">IPv4</span> <span class="token hvariable">address</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token string">"IPv4 is '"</span> <span class="token operator">++</span> <span class="token hvariable">address</span> <span class="token operator">++</span> <span class="token string">"'."</span>
<span class="token hvariable">checkIP</span> <span class="token constant">IPv4Localhost</span>  <span class="token operator">=</span> <span class="token string">"IPv4, localhost."</span>
<span class="token hvariable">checkIP</span> <span class="token punctuation">(</span><span class="token constant">IPv6</span> <span class="token hvariable">address</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token string">"IPv6 is '"</span> <span class="token operator">++</span> <span class="token hvariable">address</span> <span class="token operator">++</span> <span class="token string">"'."</span>
<span class="token hvariable">checkIP</span> <span class="token constant">IPv6Localhost</span>  <span class="token operator">=</span> <span class="token string">"IPv6, localhost."</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>С каким конструктором совпало — с таким и было создано значение. Можно, конечно, и так проверить:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">checkIP</span> <span class="token operator">::</span> <span class="token constant">IPAddress</span> <span class="token operator">-&gt;</span> <span class="token constant">String</span>
<span class="token hvariable">checkIP</span> <span class="token hvariable">addr</span> <span class="token operator">=</span> <span class="token keyword">case</span> <span class="token hvariable">addr</span> <span class="token keyword">of</span>
    <span class="token constant">IPv4</span> <span class="token hvariable">address</span>  <span class="token operator">-&gt;</span> <span class="token string">"IPv4 is '"</span> <span class="token operator">++</span> <span class="token hvariable">address</span> <span class="token operator">++</span> <span class="token string">"'."</span>
    <span class="token constant">IPv4Localhost</span> <span class="token operator">-&gt;</span> <span class="token string">"IPv4, localhost."</span>
    <span class="token constant">IPv6</span> <span class="token hvariable">address</span>  <span class="token operator">-&gt;</span> <span class="token string">"IPv6 is '"</span> <span class="token operator">++</span> <span class="token hvariable">address</span> <span class="token operator">++</span> <span class="token string">"'."</span>
    <span class="token constant">IPv6Localhost</span> <span class="token operator">-&gt;</span> <span class="token string">"IPv6, localhost."</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><h2 data-heading="Строим" id="Строим" style="display: flex;"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>Строим</h2></div><div><p>Определим тип для сетевой точки:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token keyword">data</span> <span class="token constant">EndPoint</span> <span class="token operator">=</span> <span class="token constant">EndPoint</span> <span class="token constant">String</span> <span class="token constant">Int</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Конструктор&nbsp;<code>EndPoint</code>&nbsp;— бинарный, ведь здесь уже два значения. Создаём обычным образом:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded">  <span class="token keyword">let</span> <span class="token hvariable">googlePoint</span> <span class="token operator">=</span> <span class="token constant">EndPoint</span> <span class="token string">"173.194.122.194"</span> <span class="token number">80</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Конкретные значения извлекаем опять-таки через паттерн матчинг:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">main</span> <span class="token operator">::</span> <span class="token constant">IO</span> <span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token hvariable">main</span> <span class="token operator">=</span> <span class="token builtin">putStrLn</span> <span class="token operator">$</span> <span class="token string">"The host is: "</span> <span class="token operator">++</span> <span class="token hvariable">host</span>
  <span class="token keyword">where</span>
    <span class="token constant">EndPoint</span> <span class="token hvariable">host</span> <span class="token hvariable">_</span> <span class="token operator">=</span> <span class="token constant">EndPoint</span> <span class="token string">"173.194.122.194"</span> <span class="token number">80</span>

    └── образец ──┘   └──────── значение ─────────┘
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Обратите внимание, что второе поле, соответствующее порту, отражено универсальным образцом&nbsp;<code>_</code>, потому что в данном случае нас интересует только значение хоста, а порт просто игнорируется.</p></div><div><p>И всё бы хорошо, но тип&nbsp;<code>EndPoint</code>&nbsp;мне не очень нравится. Есть в нём что-то некрасивое. Первым полем выступает строка, содержащая IP-адрес, но зачем нам строка? У нас же есть прекрасный тип&nbsp;<code>IPAddress</code>, он куда лучше безликой строки. Это общее правило для Haskell-разработчика: чем больше информации несёт в себе тип, тем он лучше. Давайте заменим определение:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token keyword">data</span> <span class="token constant">EndPoint</span> <span class="token operator">=</span> <span class="token constant">EndPoint</span> <span class="token constant">IPAddress</span> <span class="token constant">Int</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Тип стал понятнее, и вот как мы теперь будем создавать значения:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded">  <span class="token keyword">let</span> <span class="token hvariable">google</span> <span class="token operator">=</span> <span class="token constant">EndPoint</span> <span class="token punctuation">(</span><span class="token constant">IPv4</span> <span class="token string">"173.194.122.194"</span><span class="token punctuation">)</span> <span class="token number">80</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Красиво. Извлекать конкретные значения будем так:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">main</span> <span class="token operator">::</span> <span class="token constant">IO</span> <span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token hvariable">main</span> <span class="token operator">=</span> <span class="token builtin">putStrLn</span> <span class="token operator">$</span> <span class="token string">"The host is: "</span> <span class="token operator">++</span> <span class="token hvariable">ip</span>
  <span class="token keyword">where</span>
    <span class="token constant">EndPoint</span> <span class="token punctuation">(</span><span class="token constant">IPv4</span> <span class="token hvariable">ip</span><span class="token punctuation">)</span> <span class="token hvariable">_</span> <span class="token operator">=</span> <span class="token constant">EndPoint</span> <span class="token punctuation">(</span><span class="token constant">IPv4</span> <span class="token string">"173.194.122.194"</span><span class="token punctuation">)</span> <span class="token number">80</span>
              <span class="token hvariable">____</span>                   <span class="token hvariable">____</span>

                   <span class="token operator">==</span>                     <span class="token operator">=================</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Здесь мы опять-таки игнорируем порт, но значение IP-адреса извлекаем уже на основе образца с конструктором&nbsp;<code>IPv4</code>.</p></div><div><p>Это простой пример того, как из простых типов строятся более сложные. Но сложный тип вовсе не означает сложную работу с ним, паттерн матчинг элегантен как всегда. А вскоре мы узнаем о другом способе работы с полями типов, без паттерн матчинга.</p></div><div><p>Любопытно, что конструкторы типов тоже можно компоновать, взгляните:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">main</span> <span class="token operator">::</span> <span class="token constant">IO</span> <span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token hvariable">main</span> <span class="token operator">=</span> <span class="token builtin">putStrLn</span> <span class="token operator">$</span> <span class="token string">"The host is: "</span> <span class="token operator">++</span> <span class="token hvariable">ip</span>
  <span class="token keyword">where</span>
    <span class="token constant">EndPoint</span> <span class="token punctuation">(</span><span class="token constant">IPv4</span> <span class="token hvariable">ip</span><span class="token punctuation">)</span> <span class="token hvariable">_</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token constant">EndPoint</span> <span class="token operator">.</span> <span class="token constant">IPv4</span> <span class="token operator">$</span> <span class="token string">"173.194.122.194"</span><span class="token punctuation">)</span> <span class="token number">80</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Это похоже на маленькое волшебство, но конструкторы типов можно компоновать знакомым нам оператором композиции функций:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token punctuation">(</span><span class="token constant">EndPoint</span> <span class="token operator">.</span> <span class="token constant">IPv4</span> <span class="token operator">$</span> <span class="token string">"173.194.122.194"</span><span class="token punctuation">)</span> <span class="token number">80</span>

            │       значение типа      │
            └──────── <span class="token constant">IPAddress</span> ───────┘
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Вам это ничего не напоминает? Это же в точности так, как мы работали с функциями! Из этого мы делаем вывод: конструктор значения можно рассматривать как особую функцию. В самом деле:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token constant">EndPoint</span>   <span class="token punctuation">(</span><span class="token constant">IPv4</span> <span class="token string">"173.194.122.194"</span><span class="token punctuation">)</span>  <span class="token number">80</span>

<span class="token string">"функция"</span>  │        первый        │  второй
           └────── аргумент ──────┘  аргумент
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Мы как бы применяем конструктор к конкретным значениям как к аргументам, в результате чего получаем значение нашего типа. А раз так, мы можем компоновать конструкторы так же, как и обычные функции, лишь бы их типы были комбинируемыми. В данном случае всё в порядке: тип значения, возвращаемого конструктором&nbsp;<code>IPv4</code>, совпадает с типом первого аргумента конструктора&nbsp;<code>EndPoint</code>.</p></div><div><p>Вот мы и познакомились с настоящими типами. Пришло время узнать о более удобной работе с полями типов.</p></div><div><h1 data-heading="АТД: поля с метками" id="АТД:_поля_с_метками">АТД: поля с метками</h1></div><div><p>Многие типы в реальных проектах довольно велики. Взгляните:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token keyword">data</span> <span class="token constant">Arguments</span> <span class="token operator">=</span> <span class="token constant">Arguments</span> <span class="token constant">Port</span>
                           <span class="token constant">Endpoint</span>
                           <span class="token constant">RedirectData</span>
                           <span class="token constant">FilePath</span>
                           <span class="token constant">FilePath</span>
                           <span class="token constant">Bool</span>
                           <span class="token constant">FilePath</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Значение типа&nbsp;<code>Arguments</code>&nbsp;хранит в своих полях некоторые значения, извлечённые из параметров командной строки, с которыми запущена одна из моих программ. И всё бы хорошо, но работать с таким типом абсолютно неудобно. Он содержит семь полей, и паттерн матчинг был бы слишком громоздким, представьте себе:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token operator">...</span>
  <span class="token keyword">where</span>
    <span class="token constant">Arguments</span> <span class="token hvariable">_</span> <span class="token hvariable">_</span> <span class="token hvariable">_</span> <span class="token hvariable">redirectLib</span> <span class="token hvariable">_</span> <span class="token hvariable">_</span> <span class="token hvariable">xpi</span> <span class="token operator">=</span> <span class="token hvariable">arguments</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Более того, когда мы смотрим на определение типа, назначение его полей остаётся тайной за семью печатями. Видите предпоследнее поле? Оно имеет тип&nbsp;<code>Bool</code>&nbsp;и, понятное дело, отражает какой-то флаг. Но что это за флаг, читатель не представляет. К счастью, существует способ, спасающих нас от обеих этих проблем.</p></div><div><h2 data-heading="Метки" id="Метки" style="display: flex;"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>Метки</h2></div><div><p>Мы можем снабдить наши поля метками (англ. label). Вот как это выглядит:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token keyword">data</span> <span class="token constant">Arguments</span> <span class="token operator">=</span> <span class="token constant">Arguments</span> <span class="token punctuation">{</span> <span class="token hvariable">runWDServer</span>    <span class="token operator">::</span> <span class="token constant">Port</span>
                           <span class="token punctuation">,</span> <span class="token hvariable">withWDServer</span>   <span class="token operator">::</span> <span class="token constant">Endpoint</span>
                           <span class="token punctuation">,</span> <span class="token hvariable">redirect</span>       <span class="token operator">::</span> <span class="token constant">RedirectData</span>
                           <span class="token punctuation">,</span> <span class="token hvariable">redirectLib</span>    <span class="token operator">::</span> <span class="token constant">FilePath</span>
                           <span class="token punctuation">,</span> <span class="token hvariable">screenshotsDir</span> <span class="token operator">::</span> <span class="token constant">FilePath</span>
                           <span class="token punctuation">,</span> <span class="token hvariable">noScreenshots</span>  <span class="token operator">::</span> <span class="token constant">Bool</span>
                           <span class="token punctuation">,</span> <span class="token hvariable">harWithXPI</span>     <span class="token operator">::</span> <span class="token constant">FilePath</span>
                           <span class="token punctuation">}</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Теперь назначение меток куда понятнее. Схема определения такова:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token keyword">data</span> <span class="token constant">Arguments</span> <span class="token operator">=</span> <span class="token constant">Arguments</span>   <span class="token punctuation">{</span> <span class="token hvariable">runWDServer</span> <span class="token operator">::</span> <span class="token constant">Port</span> <span class="token punctuation">}</span>

тип  такой<span class="token operator">-</span>то    конструктор   метка поля     тип
                                              поля
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Теперь поле имеет не только тип, но и название, что и делает наше определение значительно более читабельным. Поля в этом случае разделены запятыми и заключены в фигурные скобки.</p></div><div><p>Если подряд идут два или более поля одного типа, его можно указать лишь для последней из меток. Так, если у нас есть вот такой тип:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token keyword">data</span> <span class="token constant">Patient</span> <span class="token operator">=</span> <span class="token constant">Patient</span> <span class="token punctuation">{</span> <span class="token hvariable">firstName</span> <span class="token operator">::</span> <span class="token constant">String</span>
                       <span class="token punctuation">,</span> <span class="token hvariable">lastName</span>  <span class="token operator">::</span> <span class="token constant">String</span>
                       <span class="token punctuation">,</span> <span class="token hvariable">email</span>     <span class="token operator">::</span> <span class="token constant">String</span>
                       <span class="token punctuation">}</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>его определение можно чуток упростить и написать так:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token keyword">data</span> <span class="token constant">Patient</span> <span class="token operator">=</span> <span class="token constant">Patient</span> <span class="token punctuation">{</span> <span class="token hvariable">firstName</span>
                       <span class="token punctuation">,</span> <span class="token hvariable">lastName</span>
                       <span class="token punctuation">,</span> <span class="token hvariable">email</span>     <span class="token operator">::</span> <span class="token constant">String</span>
                       <span class="token punctuation">}</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Раз тип всех трёх полей одинаков, мы указываем его лишь для последней из меток. Ещё пример полной формы:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token keyword">data</span> <span class="token constant">Patient</span> <span class="token operator">=</span> <span class="token constant">Patient</span> <span class="token punctuation">{</span> <span class="token hvariable">firstName</span>    <span class="token operator">::</span> <span class="token constant">String</span>
                       <span class="token punctuation">,</span> <span class="token hvariable">lastName</span>     <span class="token operator">::</span> <span class="token constant">String</span>
                       <span class="token punctuation">,</span> <span class="token hvariable">email</span>        <span class="token operator">::</span> <span class="token constant">String</span>
                       <span class="token punctuation">,</span> <span class="token hvariable">age</span>          <span class="token operator">::</span> <span class="token constant">Int</span>
                       <span class="token punctuation">,</span> <span class="token hvariable">diseaseId</span>    <span class="token operator">::</span> <span class="token constant">Int</span>
                       <span class="token punctuation">,</span> <span class="token hvariable">isIndoor</span>     <span class="token operator">::</span> <span class="token constant">Bool</span>
                       <span class="token punctuation">,</span> <span class="token hvariable">hasInsurance</span> <span class="token operator">::</span> <span class="token constant">Bool</span>
                       <span class="token punctuation">}</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>и тут же упрощаем:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token keyword">data</span> <span class="token constant">Patient</span> <span class="token operator">=</span> <span class="token constant">Patient</span> <span class="token punctuation">{</span> <span class="token hvariable">firstName</span>
                       <span class="token punctuation">,</span> <span class="token hvariable">lastName</span>
                       <span class="token punctuation">,</span> <span class="token hvariable">email</span>        <span class="token operator">::</span> <span class="token constant">String</span>
                       <span class="token punctuation">,</span> <span class="token hvariable">age</span>
                       <span class="token punctuation">,</span> <span class="token hvariable">diseaseId</span>    <span class="token operator">::</span> <span class="token constant">Int</span>
                       <span class="token punctuation">,</span> <span class="token hvariable">isIndoor</span>
                       <span class="token punctuation">,</span> <span class="token hvariable">hasInsurance</span> <span class="token operator">::</span> <span class="token constant">Bool</span>
                       <span class="token punctuation">}</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Поля&nbsp;<code>firstName</code>,&nbsp;<code>lastName</code>&nbsp;и&nbsp;<code>email</code>&nbsp;имеют тип&nbsp;<code>String</code>, поля&nbsp;<code>age</code>&nbsp;и&nbsp;<code>diseaseId</code>&nbsp;— тип&nbsp;<code>Int</code>, и оставшиеся два поля — тип&nbsp;<code>Bool</code>.</p></div><div><h2 data-heading="Getter и Setter?" id="Getter_и_Setter?" style="display: flex;"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>Getter и Setter?</h2></div><div><p>Что же представляют собой метки? Фактически, это особые функции, сгенерированные автоматически. Эти функции имеют три предназначения: создавать, извлекать и изменять. Да, я не оговорился, изменять. Но об этом чуть позже, пусть будет маленькая интрига.</p></div><div><p>Вот как мы создаём значение типа&nbsp;<code>Patient</code></p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">main</span> <span class="token operator">::</span> <span class="token constant">IO</span> <span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token hvariable">main</span> <span class="token operator">=</span> <span class="token builtin">print</span> <span class="token operator">$</span> <span class="token hvariable">diseaseId</span> <span class="token hvariable">patient</span>
  <span class="token keyword">where</span>
    <span class="token hvariable">patient</span> <span class="token operator">=</span> <span class="token constant">Patient</span> <span class="token punctuation">{</span>
        <span class="token hvariable">firstName</span>    <span class="token operator">=</span> <span class="token string">"John"</span>
      <span class="token punctuation">,</span> <span class="token hvariable">lastName</span>     <span class="token operator">=</span> <span class="token string">"Doe"</span>
      <span class="token punctuation">,</span> <span class="token hvariable">email</span>        <span class="token operator">=</span> <span class="token string">"john.doe@gmail.com"</span>
      <span class="token punctuation">,</span> <span class="token hvariable">age</span>          <span class="token operator">=</span> <span class="token number">24</span>
      <span class="token punctuation">,</span> <span class="token hvariable">diseaseId</span>    <span class="token operator">=</span> <span class="token number">431</span>
      <span class="token punctuation">,</span> <span class="token hvariable">isIndoor</span>     <span class="token operator">=</span> <span class="token constant">True</span>
      <span class="token punctuation">,</span> <span class="token hvariable">hasInsurance</span> <span class="token operator">=</span> <span class="token constant">True</span>
    <span class="token punctuation">}</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Метки полей используются как своего рода setter (от англ. set, «устанавливать»):</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">patient</span> <span class="token operator">=</span> <span class="token constant">Patient</span> <span class="token punctuation">{</span> <span class="token hvariable">firstName</span>    <span class="token operator">=</span>      <span class="token string">"John"</span>
в этом    типа      поле с
значении  <span class="token constant">Patient</span>   этой меткой  равно  этой строке
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Кроме того, метку можно использовать и как getter (от англ. get, «получать»):</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">main</span> <span class="token operator">=</span> <span class="token builtin">print</span> <span class="token operator">$</span> <span class="token hvariable">diseaseId</span>  <span class="token hvariable">patient</span>

               метка как  аргумент
               функции
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Мы применяем метку к значению типа&nbsp;<code>Patient</code>&nbsp;и получаем значение соответствующего данной метке поля. Поэтому для получения значений полей нам уже не нужен паттерн матчинг.</p></div><div><p>Но что же за интригу я приготовил под конец? Выше я упомянул, что метки используются не только для задания значений полей и для их извлечения, но и для изменения. Вот что я имел в виду:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">main</span> <span class="token operator">::</span> <span class="token constant">IO</span> <span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token hvariable">main</span> <span class="token operator">=</span> <span class="token builtin">print</span> <span class="token operator">$</span> <span class="token hvariable">email</span> <span class="token hvariable">patientWithChangedEmail</span>
  <span class="token keyword">where</span>
    <span class="token hvariable">patientWithChangedEmail</span> <span class="token operator">=</span> <span class="token hvariable">patient</span> <span class="token punctuation">{</span>
      <span class="token hvariable">email</span> <span class="token operator">=</span> <span class="token string">"j.d@gmail.com"</span>  <span class="token comment">-- Изменяем???</span>
    <span class="token punctuation">}</span>

    <span class="token hvariable">patient</span> <span class="token operator">=</span> <span class="token constant">Patient</span> <span class="token punctuation">{</span>
        <span class="token hvariable">firstName</span>    <span class="token operator">=</span> <span class="token string">"John"</span>
      <span class="token punctuation">,</span> <span class="token hvariable">lastName</span>     <span class="token operator">=</span> <span class="token string">"Doe"</span>
      <span class="token punctuation">,</span> <span class="token hvariable">email</span>        <span class="token operator">=</span> <span class="token string">"john.doe@gmail.com"</span>
      <span class="token punctuation">,</span> <span class="token hvariable">age</span>          <span class="token operator">=</span> <span class="token number">24</span>
      <span class="token punctuation">,</span> <span class="token hvariable">diseaseId</span>    <span class="token operator">=</span> <span class="token number">431</span>
      <span class="token punctuation">,</span> <span class="token hvariable">isIndoor</span>     <span class="token operator">=</span> <span class="token constant">True</span>
      <span class="token punctuation">,</span> <span class="token hvariable">hasInsurance</span> <span class="token operator">=</span> <span class="token constant">True</span>
    <span class="token punctuation">}</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>При запуске программы получим:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">j</span><span class="token punctuation">.</span><span class="token hvariable">d</span><span class="token operator">@</span><span class="token hvariable">gmail</span><span class="token punctuation">.</span><span class="token hvariable">com</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Но постойте, что же тут произошло? Ведь в Haskell, как мы знаем, нет оператора присваивания, однако значение поля с меткой&nbsp;<code>email</code>&nbsp;поменялось. Помню, когда я впервые увидел подобный пример, то очень удивился, мол, уж не ввели ли меня в заблуждение по поводу неизменности значений в Haskell?!</p></div><div><p>Нет, не ввели. Подобная запись:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">patientWithChangedEmail</span> <span class="token operator">=</span> <span class="token hvariable">patient</span> <span class="token punctuation">{</span>
  <span class="token hvariable">email</span> <span class="token operator">=</span> <span class="token string">"j.d@gmail.com"</span>
<span class="token punctuation">}</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>действительно похожа на изменение поля через присваивание ему нового значения, но в действительности никакого изменения не произошло. Когда я назвал метку setter-ом, я немного слукавил, ведь классический setter из мира ООП был бы невозможен в Haskell. Посмотрим ещё раз внимательнее:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token operator">...</span>
  <span class="token keyword">where</span>
    <span class="token hvariable">patientWithChangedEmail</span> <span class="token operator">=</span> <span class="token hvariable">patient</span> <span class="token punctuation">{</span>
      <span class="token hvariable">email</span> <span class="token operator">=</span> <span class="token string">"j.d@gmail.com"</span>  <span class="token comment">-- Изменяем???</span>
    <span class="token punctuation">}</span>

    <span class="token hvariable">patient</span> <span class="token operator">=</span> <span class="token constant">Patient</span> <span class="token punctuation">{</span>
        <span class="token hvariable">firstName</span>    <span class="token operator">=</span> <span class="token string">"John"</span>
      <span class="token punctuation">,</span> <span class="token hvariable">lastName</span>     <span class="token operator">=</span> <span class="token string">"Doe"</span>
      <span class="token punctuation">,</span> <span class="token hvariable">email</span>        <span class="token operator">=</span> <span class="token string">"john.doe@gmail.com"</span>
      <span class="token punctuation">,</span> <span class="token hvariable">age</span>          <span class="token operator">=</span> <span class="token number">24</span>
      <span class="token punctuation">,</span> <span class="token hvariable">diseaseId</span>    <span class="token operator">=</span> <span class="token number">431</span>
      <span class="token punctuation">,</span> <span class="token hvariable">isIndoor</span>     <span class="token operator">=</span> <span class="token constant">True</span>
      <span class="token punctuation">,</span> <span class="token hvariable">hasInsurance</span> <span class="token operator">=</span> <span class="token constant">True</span>
    <span class="token punctuation">}</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Взгляните, ведь у нас теперь два значения типа&nbsp;<code>Patient</code>,&nbsp;<code>patient</code>&nbsp;и&nbsp;<code>patientWithChangedEmail</code>. Эти значения не имеют друг ко другу ни малейшего отношения. Вспомните, как я говорил, что в Haskell нельзя изменить имеющееся значение, а можно лишь создать на основе имеющегося новое значение. Это именно то, что здесь произошло: мы взяли имеющееся значение&nbsp;<code>patient</code>&nbsp;и на его основе создали уже новое значение&nbsp;<code>patientWithChangedEmail</code>, значение поля&nbsp;<code>email</code>&nbsp;в котором теперь другое. Понятно, что поле&nbsp;<code>email</code>&nbsp;в значении&nbsp;<code>patient</code>&nbsp;осталось неизменным.</p></div><div><p>Будьте внимательны при инициализации значения с полями: вы обязаны предоставить значения для всех полей. Если вы напишете так:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">main</span> <span class="token operator">::</span> <span class="token constant">IO</span> <span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token hvariable">main</span> <span class="token operator">=</span> <span class="token builtin">print</span> <span class="token operator">$</span> <span class="token hvariable">email</span> <span class="token hvariable">patientWithChangedEmail</span>
  <span class="token keyword">where</span>
    <span class="token hvariable">patientWithChangedEmail</span> <span class="token operator">=</span> <span class="token hvariable">patient</span> <span class="token punctuation">{</span>
      <span class="token hvariable">email</span> <span class="token operator">=</span> <span class="token string">"j.d@gmail.com"</span>  <span class="token comment">-- Изменяем???</span>
    <span class="token punctuation">}</span>

    <span class="token hvariable">patient</span> <span class="token operator">=</span> <span class="token constant">Patient</span> <span class="token punctuation">{</span>
        <span class="token hvariable">firstName</span>    <span class="token operator">=</span> <span class="token string">"John"</span>
      <span class="token punctuation">,</span> <span class="token hvariable">lastName</span>     <span class="token operator">=</span> <span class="token string">"Doe"</span>
      <span class="token punctuation">,</span> <span class="token hvariable">email</span>        <span class="token operator">=</span> <span class="token string">"john.doe@gmail.com"</span>
      <span class="token punctuation">,</span> <span class="token hvariable">age</span>          <span class="token operator">=</span> <span class="token number">24</span>
      <span class="token punctuation">,</span> <span class="token hvariable">diseaseId</span>    <span class="token operator">=</span> <span class="token number">431</span>
      <span class="token punctuation">,</span> <span class="token hvariable">isIndoor</span>     <span class="token operator">=</span> <span class="token constant">True</span>
    <span class="token punctuation">}</span>

    <span class="token comment">-- Поле hasInsurance забыли!</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>код скомпилируется, но внимательный компилятор предупредит вас о проблеме:</p></div><div><pre class="language-bash" tabindex="0"><code class="language-bash is-loaded">Fields of ‘Patient’ not initialised: hasInsurance
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Пожалуйста, не пренебрегайте подобным предупреждением, ведь если вы проигнорируете его и затем попытаетесь обратиться к неинициализированному полю:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">main</span> <span class="token operator">=</span> <span class="token builtin">print</span> <span class="token operator">$</span> <span class="token hvariable">hasInsurance</span> <span class="token hvariable">patient</span>
  <span class="token operator">...</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>ваша программа аварийно завершится на этапе выполнения с ожидаемой ошибкой:</p></div><div><pre class="language-bash" tabindex="0"><code class="language-bash is-loaded">Missing field <span class="token keyword">in</span> record construction hasInsurance
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Не забывайте: компилятор — ваш добрый друг.</p></div><div><h2 data-heading="Без меток" id="Без_меток" style="display: flex;"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>Без меток</h2></div><div><p>Помните, что метки полей — это синтаксический сахар, без которого мы вполне можем обойтись. Даже если тип был определён с метками, как наш&nbsp;<code>Patient</code>, мы можем работать с ним по-старинке:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token keyword">data</span> <span class="token constant">Patient</span> <span class="token operator">=</span> <span class="token constant">Patient</span> <span class="token punctuation">{</span> <span class="token hvariable">firstName</span>    <span class="token operator">::</span> <span class="token constant">String</span>
                       <span class="token punctuation">,</span> <span class="token hvariable">lastName</span>     <span class="token operator">::</span> <span class="token constant">String</span>
                       <span class="token punctuation">,</span> <span class="token hvariable">email</span>        <span class="token operator">::</span> <span class="token constant">String</span>
                       <span class="token punctuation">,</span> <span class="token hvariable">age</span>          <span class="token operator">::</span> <span class="token constant">Int</span>
                       <span class="token punctuation">,</span> <span class="token hvariable">diseaseId</span>    <span class="token operator">::</span> <span class="token constant">Int</span>
                       <span class="token punctuation">,</span> <span class="token hvariable">isIndoor</span>     <span class="token operator">::</span> <span class="token constant">Bool</span>
                       <span class="token punctuation">,</span> <span class="token hvariable">hasInsurance</span> <span class="token operator">::</span> <span class="token constant">Bool</span>
                       <span class="token punctuation">}</span>

<span class="token hvariable">main</span> <span class="token operator">::</span> <span class="token constant">IO</span> <span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token hvariable">main</span> <span class="token operator">=</span> <span class="token builtin">print</span> <span class="token operator">$</span> <span class="token hvariable">hasInsurance</span> <span class="token hvariable">patient</span>
  <span class="token keyword">where</span>
    <span class="token comment">-- Создаём по-старинке...</span>
    <span class="token hvariable">patient</span> <span class="token operator">=</span> <span class="token constant">Patient</span> <span class="token string">"John"</span>
                      <span class="token string">"Doe"</span>
                      <span class="token string">"john.doe@gmail.com"</span>
                      <span class="token number">24</span>
                      <span class="token number">431</span>
                      <span class="token constant">True</span>
                      <span class="token constant">True</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Соответственно, извлекать значения полей тоже можно по-старинке, через паттерн матчинг:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">main</span> <span class="token operator">::</span> <span class="token constant">IO</span> <span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token hvariable">main</span> <span class="token operator">=</span> <span class="token builtin">print</span> <span class="token hvariable">insurance</span>
  <span class="token keyword">where</span>
    <span class="token comment">-- Жутко неудобно, но если желаете...</span>
    <span class="token constant">Patient</span> <span class="token hvariable">_</span> <span class="token hvariable">_</span> <span class="token hvariable">_</span> <span class="token hvariable">_</span> <span class="token hvariable">_</span> <span class="token hvariable">_</span> <span class="token hvariable">insurance</span> <span class="token operator">=</span> <span class="token hvariable">patient</span>
    <span class="token hvariable">patient</span> <span class="token operator">=</span> <span class="token constant">Patient</span> <span class="token string">"John"</span>
                      <span class="token string">"Doe"</span>
                      <span class="token string">"john.doe@gmail.com"</span>
                      <span class="token number">24</span>
                      <span class="token number">431</span>
                      <span class="token constant">True</span>
                      <span class="token constant">True</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>С другими видами синтаксического сахара мы встретимся ещё не раз, на куда более продвинутых примерах.</p></div><div><h1 data-heading="Новый тип" id="Новый_тип">Новый тип</h1></div><div><p>Помимо&nbsp;<code>data</code>&nbsp;существует ещё одно ключевое слово, предназначенное для определения нового типа. Оно так и называется —&nbsp;<code>newtype</code>. Эти слова похожи друг на друга «в одну сторону»: вы можете поставить&nbsp;<code>data</code>&nbsp;на место&nbsp;<code>newtype</code>, но не наоборот.</p></div><div><h2 data-heading="Различия" id="Различия" style="display: flex;"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>Различия</h2></div><div><p>Тип, определяемый с помощью слова&nbsp;<code>newtype</code>, обязан иметь один и только один конструктор значения. Мы можем написать так: &nbsp;</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token keyword">newtype</span> <span class="token constant">IPAddress</span> <span class="token operator">=</span> <span class="token constant">IP</span> <span class="token constant">String</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>А вот так не можем:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token keyword">newtype</span> <span class="token constant">IPAddress</span> <span class="token operator">=</span> <span class="token constant">IP</span> <span class="token constant">String</span> <span class="token operator">|</span> <span class="token constant">Localhost</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Компилятор заупрямится:</p></div><div><pre class="language-bash" tabindex="0"><code class="language-bash is-loaded">A newtype must have exactly one constructor,
  but ‘IPAddress’ has two
In the newtype declaration <span class="token keyword">for</span> ‘IPAddress’
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Кроме того, в таком типе должно быть одно и лишь одно поле. То есть можно так:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token keyword">newtype</span> <span class="token constant">IPAddress</span> <span class="token operator">=</span> <span class="token constant">IP</span> <span class="token constant">String</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Или же так, с меткой:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token keyword">newtype</span> <span class="token constant">IPAddress</span> <span class="token operator">=</span> <span class="token constant">IP</span> <span class="token punctuation">{</span> <span class="token hvariable">value</span> <span class="token operator">::</span> <span class="token constant">String</span> <span class="token punctuation">}</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>А вот два или более полей запихнуть не удастся:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token keyword">newtype</span> <span class="token constant">EndPoint</span> <span class="token operator">=</span> <span class="token constant">EndPoint</span> <span class="token constant">String</span> <span class="token constant">Int</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Компилятор вновь обратит наше внимание на проблему:</p></div><div><pre class="language-bash" tabindex="0"><code class="language-bash is-loaded">The constructor of a newtype must have exactly one field
  but ‘EndPoint’ has two
In the definition of data constructor ‘EndPoint’
In the newtype declaration <span class="token keyword">for</span> ‘EndPoint’
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Более того, нульарный конструктор тоже не подойдёт:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token keyword">newtype</span> <span class="token constant">HardDay</span> <span class="token operator">=</span> <span class="token constant">Monday</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>И вновь ошибка:</p></div><div><pre class="language-bash" tabindex="0"><code class="language-bash is-loaded">The constructor of a newtype must have exactly one field
  but ‘Monday’ has none
</code><button class="copy-code-button">Копировать</button></pre></div><div><h2 data-heading="Зачем он нужен?" id="Зачем_он_нужен?" style="display: flex;"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>Зачем он нужен?</h2></div><div><p>В самом деле, зачем нам нужно такое хозяйство? Это нельзя, то нельзя. Какой смысл?</p></div><div><p>Смысл в оптимизации. Обратите внимание на модель&nbsp;<code>newtype</code>:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token keyword">newtype</span> <span class="token constant">IPAddress</span> <span class="token operator">=</span> <span class="token constant">IP</span>           <span class="token constant">String</span>

новый   название    конструктор  Поле
тип                 значения
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Фактически,&nbsp;<code>newtype</code>&nbsp;берёт одно-единственное значение некоторого существующего типа и всего лишь оборачивает его в свой конструктор. Именно поэтому тип, введённый с помощью&nbsp;<code>newtype</code>, не относится к АТД, и с точки зрения компилятора он является лишь переименованием типа (англ. type renaming). Это делает такой тип более простым и эффективным с точки зрения представления в памяти, нежели тип, определяемый с&nbsp;<code>data</code>.</p></div><div><p>Когда мы пишем так:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token keyword">data</span> <span class="token constant">IPAddress</span> <span class="token operator">=</span> <span class="token constant">IP</span> <span class="token constant">String</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>мы говорим компилятору: «<code>IPAddress</code>&nbsp;— это абсолютно новый и самобытный тип, которого никогда не было ранее». А когда пишем так:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token keyword">newtype</span> <span class="token constant">IPAddress</span> <span class="token operator">=</span> <span class="token constant">IP</span> <span class="token constant">String</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>мы говорим: «<code>IPAddress</code>&nbsp;— это всего лишь обёртка для значения уже существующего типа&nbsp;<code>String</code>».</p></div><div><h2 data-heading="type vs newtype" id="type_vs_newtype" style="display: flex;"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>type vs newtype</h2></div><div><p>Внимательный читатель спросит, в чём же фундаментальное отличие типов, вводимых с помощью&nbsp;<code>newtype</code>, от типов, вводимых с помощью&nbsp;<code>type</code>? Там синоним, тут — обёртка. Отличие вот в чём.</p></div><div><p>Когда мы пишем так:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token keyword">type</span> <span class="token constant">String</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token constant">Char</span><span class="token punctuation">]</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>мы объявляем: «Тип&nbsp;<code>String</code>&nbsp;— это эквивалентная замена типу&nbsp;<code>[Char]</code>». И поэтому везде, где в коде стоит&nbsp;<code>[Char]</code>, мы можем поставить&nbsp;<code>String</code>, и везде, где стоит&nbsp;<code>String</code>, мы можем поставить&nbsp;<code>[Char]</code>. Например, если функция объявлена так:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">replace</span> <span class="token operator">::</span> <span class="token constant">String</span>
        <span class="token operator">-&gt;</span> <span class="token constant">String</span>
        <span class="token operator">-&gt;</span> <span class="token constant">String</span>
        <span class="token operator">-&gt;</span> <span class="token constant">String</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>мы можем спокойно переписать объявление:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">replace</span> <span class="token operator">::</span> <span class="token punctuation">[</span><span class="token constant">Char</span><span class="token punctuation">]</span>
        <span class="token operator">-&gt;</span> <span class="token punctuation">[</span><span class="token constant">Char</span><span class="token punctuation">]</span>
        <span class="token operator">-&gt;</span> <span class="token punctuation">[</span><span class="token constant">Char</span><span class="token punctuation">]</span>
        <span class="token operator">-&gt;</span> <span class="token punctuation">[</span><span class="token constant">Char</span><span class="token punctuation">]</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>и ничего не изменится.</p></div><div><p>Когда же мы пишем так:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token keyword">newtype</span> <span class="token constant">MyInt</span> <span class="token operator">=</span> <span class="token constant">MyInt</span> <span class="token constant">Int</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>мы объявляем: «Тип&nbsp;<code>MyInt</code>&nbsp;— это новый тип, представление которого такое же, как у типа&nbsp;<code>Int</code>». Мы не можем просто взять и поставить&nbsp;<code>MyInt</code>&nbsp;на место&nbsp;<code>Int</code>, потому что эти типы равны лишь с точки зрения представления в памяти, с точки зрения системы типов они абсолютно различны.</p></div><div><p>А зачем же нам нужно это? Для простоты и надёжности кода. Допустим, есть такая функция:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">getBuildsInfo</span> <span class="token operator">::</span> <span class="token constant">String</span> <span class="token operator">-&gt;</span> <span class="token constant">Int</span> <span class="token operator">-&gt;</span> <span class="token constant">BuildsInfo</span>
<span class="token hvariable">getBuildsInfo</span> <span class="token hvariable">projectName</span> <span class="token hvariable">limit</span> <span class="token operator">=</span> <span class="token operator">...</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Эта функция запрашивает у CI-сервиса (через REST API) информацию о сборках проекта. Из определения мы видим, что первым аргументом выступает имя проекта, а вторым — количество сборок. Однако в месте применения функции это может быть не столь очевидным:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded">  <span class="token keyword">let</span> <span class="token hvariable">info</span> <span class="token operator">=</span> <span class="token hvariable">getBuildsInfo</span> <span class="token string">"ohaskell.guide"</span> <span class="token number">4</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Что такое первая строка? Что такое второе число? Неясно, нужно глядеть в определение, ведь даже объявление не расскажет нам правду:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">getBuildsInfo</span> <span class="token operator">::</span> <span class="token constant">String</span>  <span class="token operator">-&gt;</span> <span class="token constant">Int</span>    <span class="token operator">-&gt;</span> <span class="token constant">BuildsInfo</span>

                 что за     что за
                 строка<span class="token operator">?</span>    число<span class="token operator">?</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Вот тут нам и помогают наши типы, ведь стандартные&nbsp;<code>String</code>&nbsp;и&nbsp;<code>Int</code>&nbsp;сами по себе не несут никакой полезной информации о своём содержимом. Конечно, мы могли бы обойтись и без типов, просто введя промежуточные выражения:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded">  <span class="token keyword">let</span> <span class="token hvariable">project</span> <span class="token operator">=</span> <span class="token string">"ohaskell.guide"</span>
      <span class="token hvariable">limit</span>   <span class="token operator">=</span> <span class="token number">4</span>
      <span class="token hvariable">info</span>    <span class="token operator">=</span> <span class="token hvariable">getBuildsInfo</span> <span class="token hvariable">project</span> <span class="token hvariable">limit</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Однако программист может этого и не сделать, и тогда мы получим «магические значения», смысл которых нам неизвестен. Куда лучше ввести собственные типы:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token keyword">newtype</span> <span class="token constant">Project</span> <span class="token operator">=</span> <span class="token constant">Project</span> <span class="token constant">String</span>
<span class="token keyword">newtype</span> <span class="token constant">Limit</span> <span class="token operator">=</span> <span class="token constant">Limit</span> <span class="token constant">Int</span>

<span class="token hvariable">getBuildsInfo</span> <span class="token operator">::</span> <span class="token constant">Project</span> <span class="token operator">-&gt;</span> <span class="token constant">Limit</span>  <span class="token operator">-&gt;</span> <span class="token constant">BuildsInfo</span>

                 уже не     уже не
                 просто     просто
                 строка     число
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Это заставит нас писать явно:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded">  <span class="token keyword">let</span> <span class="token hvariable">info</span> <span class="token operator">=</span> <span class="token hvariable">getBuildsInfo</span> <span class="token punctuation">(</span><span class="token constant">Project</span> <span class="token string">"ohaskell.guide"</span><span class="token punctuation">)</span>
                           <span class="token punctuation">(</span><span class="token constant">Limit</span> <span class="token number">4</span><span class="token punctuation">)</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Теперь, даже без промежуточных выражений, смысл строки и числа вполне очевиден. Это важный принцип в Haskell: безликие типы наподобие&nbsp;<code>String</code>&nbsp;или&nbsp;<code>Int</code>&nbsp;заменять на типы, имеющие конкретный смысл для нас.</p></div><div><p>Кроме того,&nbsp;<code>newtype</code>-типы помогают нам не допускать глупых ошибок. Например, есть другая функция:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">getArtifacts</span> <span class="token operator">::</span> <span class="token constant">String</span> <span class="token operator">-&gt;</span> <span class="token constant">Int</span> <span class="token operator">-&gt;</span> <span class="token constant">Int</span> <span class="token operator">-&gt;</span> <span class="token punctuation">[</span><span class="token constant">Project</span><span class="token punctuation">]</span>
<span class="token hvariable">getArtifacts</span> <span class="token hvariable">projectName</span> <span class="token hvariable">limit</span> <span class="token hvariable">offset</span> <span class="token operator">=</span> <span class="token operator">...</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Мало того, что перед нами вновь безликие&nbsp;<code>Int</code>, так их ещё и два. И вот какая нелепая ошибка может нас поджидать:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded">  <span class="token keyword">let</span> <span class="token hvariable">project</span> <span class="token operator">=</span> <span class="token string">"ohaskell.guide"</span>
      <span class="token hvariable">limit</span>   <span class="token operator">=</span> <span class="token number">4</span>
      <span class="token hvariable">offset</span>  <span class="token operator">=</span> <span class="token number">1</span>
      <span class="token hvariable">info</span>    <span class="token operator">=</span> <span class="token hvariable">getArtifacts</span> <span class="token hvariable">project</span> <span class="token hvariable">offset</span> <span class="token hvariable">limit</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Заметили? Мы случайно перепутали аргументы местами, поставив&nbsp;<code>offset</code>&nbsp;на место&nbsp;<code>limit</code>. Работа функции при этом нарушится, однако компилятор останется нем как рыба, ведь с точки зрения системы типов ошибки не произошло: и там&nbsp;<code>Int</code>, и тут&nbsp;<code>Int</code>. Синонимы для&nbsp;<code>Int</code>&nbsp;также не помогли бы. Однако если у нас будут&nbsp;<code>newtype</code>-типы:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token keyword">newtype</span> <span class="token constant">Limit</span> <span class="token operator">=</span> <span class="token constant">Limit</span> <span class="token constant">Int</span>
<span class="token keyword">newtype</span> <span class="token constant">Offset</span> <span class="token operator">=</span> <span class="token constant">Offset</span> <span class="token constant">Int</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>тогда подобная ошибка не пройдёт незамеченной:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded">  <span class="token keyword">let</span> <span class="token hvariable">project</span> <span class="token operator">=</span> <span class="token string">"ohaskell.guide"</span>
      <span class="token hvariable">limit</span>   <span class="token operator">=</span> <span class="token constant">Limit</span> <span class="token number">4</span>
      <span class="token hvariable">offset</span>  <span class="token operator">=</span> <span class="token constant">Offset</span> <span class="token number">1</span>
      <span class="token hvariable">info</span>    <span class="token operator">=</span> <span class="token hvariable">getArtifacts</span> <span class="token hvariable">offset</span> <span class="token hvariable">limit</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Типы аргументов теперь разные, а значит, путаница между ними гарантированно прервёт компиляцию.</p></div><div><p>Вот такие они,&nbsp;<code>newtype</code>-типы. В последующих главах мы увидим ещё большую мощь системы типов Haskell.</p></div><div><h1 data-heading="Конструктор типа" id="Конструктор_типа">Конструктор типа</h1></div><div><p>В предыдущих главах мы познакомились с АТД, которые сами по себе уже весьма полезны. И всё же есть в них одно ограничение: они напрочь лишены гибкости. Вот тебе конкретные поля, а вот тебе конкретные типы, будь счастлив. Но существует способ наделить наши тип куда большей силой. Эта глава станет для нас переломной, ведь с неё начнётся наш путь в мир действительно мощных типов.</p></div><div><h2 data-heading="Опциональный тип" id="Опциональный_тип" style="display: flex;"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>Опциональный тип</h2></div><div><p>Допустим, у нас есть список пар следующего вида:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token keyword">type</span> <span class="token constant">Chapters</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">(</span><span class="token constant">FilePath</span><span class="token punctuation">,</span> <span class="token constant">String</span><span class="token punctuation">)</span><span class="token punctuation">]</span>

<span class="token hvariable">chapters</span> <span class="token operator">::</span> <span class="token constant">Chapters</span>
<span class="token hvariable">chapters</span> <span class="token operator">=</span> <span class="token punctuation">[</span> <span class="token punctuation">(</span><span class="token string">"/list.html"</span><span class="token punctuation">,</span>  <span class="token string">"Список"</span><span class="token punctuation">)</span>
           <span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token string">"/tuple.html"</span><span class="token punctuation">,</span> <span class="token string">"Кортеж"</span><span class="token punctuation">)</span>
           <span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token string">"/hof.html"</span><span class="token punctuation">,</span>   <span class="token string">"ФВП"</span><span class="token punctuation">)</span>
           <span class="token punctuation">]</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Тип&nbsp;<code>FilePath</code>&nbsp;есть не более чем стандартный синоним для типа&nbsp;<code>String</code>, но он более информативен. Итак, этот список содержит названия трёх глав данной книги и пути к ним. И вот понадобилась нам функция, которая извлекает название главы по её пути:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">lookupChapterNameBy</span> <span class="token operator">::</span> <span class="token constant">FilePath</span> <span class="token operator">-&gt;</span> <span class="token constant">Chapters</span> <span class="token operator">-&gt;</span> <span class="token constant">String</span>
<span class="token hvariable">lookupChapterNameBy</span> <span class="token hvariable">_</span> <span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">""</span>  <span class="token comment">-- Так ничего и не нашли...</span>
<span class="token hvariable">lookupChapterNameBy</span> <span class="token hvariable">path</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token hvariable">realPath</span><span class="token punctuation">,</span> <span class="token hvariable">name</span><span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token hvariable">others</span><span class="token punctuation">)</span>
  <span class="token operator">|</span> <span class="token hvariable">path</span> <span class="token operator">==</span> <span class="token hvariable">realPath</span> <span class="token operator">=</span> <span class="token hvariable">name</span> <span class="token comment">-- Пути совпадают, вот вам имя.</span>
  <span class="token operator">|</span> <span class="token builtin">otherwise</span>        <span class="token operator">=</span> <span class="token hvariable">lookupChapterNameBy</span> <span class="token hvariable">path</span> <span class="token hvariable">others</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Всё предельно просто: рекурсивно бежим по списку пар&nbsp;<code>chapters</code>, на каждом шаге извлекая через паттерн матчинг путь ко главе и её имя. Сравниваем пути и, ежели совпадают — на выходе получается имя, соответствующее заданному пути. Если же, пройдя весь список, мы так и не нашли соответствующего пути, на выходе будет пустая строка.</p></div><div><p>Используем так:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">main</span> <span class="token operator">::</span> <span class="token constant">IO</span> <span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token hvariable">main</span> <span class="token operator">=</span> <span class="token builtin">putStrLn</span> <span class="token operator">$</span>
  <span class="token keyword">if</span> <span class="token operator">|</span> <span class="token builtin">null</span> <span class="token hvariable">name</span> <span class="token operator">-&gt;</span> <span class="token string">"No such chapter, sorry..."</span>
     <span class="token operator">|</span> <span class="token builtin">otherwise</span> <span class="token operator">-&gt;</span> <span class="token string">"This is chapter name: "</span> <span class="token operator">++</span> <span class="token hvariable">name</span>
  <span class="token keyword">where</span>
    <span class="token hvariable">name</span> <span class="token operator">=</span> <span class="token hvariable">lookupChapterNameBy</span> <span class="token string">"/tuple.html"</span> <span class="token hvariable">chapters</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Если на выходе функции&nbsp;<code>lookupChapterNameBy</code>&nbsp;пустая строка, значит мы ничего не нашли, в противном же случае показываем найденное имя.</p></div><div><p>Ну и как вам такое решение? Вроде бы красивое, но почему, собственно, пустая строка? Я вполне мог написать заготовку для очередной главы и ещё не дать ей имя:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">chapters</span> <span class="token operator">::</span> <span class="token constant">Chapters</span>
<span class="token hvariable">chapters</span> <span class="token operator">=</span> <span class="token punctuation">[</span> <span class="token punctuation">(</span><span class="token string">"/list.html"</span><span class="token punctuation">,</span>  <span class="token string">"Список"</span><span class="token punctuation">)</span>
           <span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token string">"/tuple.html"</span><span class="token punctuation">,</span> <span class="token string">"Кортеж"</span><span class="token punctuation">)</span>
           <span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token string">"/hof.html"</span><span class="token punctuation">,</span>   <span class="token string">"ФВП"</span><span class="token punctuation">)</span>
           <span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token string">"/monad.html"</span><span class="token punctuation">,</span> <span class="token string">""</span><span class="token punctuation">)</span>  <span class="token comment">-- Заготовка</span>
           <span class="token punctuation">]</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>В этом случае наше решение ломается: пустая строка на выходе функции&nbsp;<code>lookupChapterNameBy</code>&nbsp;может означать теперь как то, что мы не нашли главы с таким путём, так и то, что глава-то существует, просто её имя пока не задано. Следовательно, нам нужен другой механизм проверки результата поиска, более однозначный.</p></div><div><p>Определим опциональный тип. Опциональным (англ. optional) называют такой тип, внутри которого либо есть нечто полезное, либо нет. Выглядеть он будет так:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token keyword">data</span> <span class="token constant">Optional</span> <span class="token operator">=</span> <span class="token constant">NoSuchChapter</span>
              <span class="token operator">|</span> <span class="token constant">Chapter</span> <span class="token constant">String</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Если значение типа&nbsp;<code>Optional</code>&nbsp;создано с помощью нульарного конструктора&nbsp;<code>NoSuchChapter</code>, это означает, что внутри ничего нет, перед нами значение-пустышка. Это и будет соответствовать тому случаю, когда нужную главу мы не нашли. А вот если значение было создано с помощью унарного конструктора&nbsp;<code>Chapter</code>, это несомненно будет означать то, что мы нашли интересующую нас главу. Перепишем функцию&nbsp;<code>lookupChapterNameBy</code>:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">lookupChapterNameBy</span> <span class="token operator">::</span> <span class="token constant">FilePath</span> <span class="token operator">-&gt;</span> <span class="token constant">Chapters</span> <span class="token operator">-&gt;</span> <span class="token constant">Optional</span>
<span class="token hvariable">lookupChapterNameBy</span> <span class="token hvariable">_</span> <span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token constant">NoSuchChapter</span> <span class="token comment">-- Пустышка</span>
<span class="token hvariable">lookupChapterNameBy</span> <span class="token hvariable">path</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token hvariable">realPath</span><span class="token punctuation">,</span> <span class="token hvariable">name</span><span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token hvariable">others</span><span class="token punctuation">)</span>
  <span class="token operator">|</span> <span class="token hvariable">path</span> <span class="token operator">==</span> <span class="token hvariable">realPath</span> <span class="token operator">=</span> <span class="token constant">Chapter</span> <span class="token hvariable">name</span>      <span class="token comment">-- Реальное имя</span>
  <span class="token operator">|</span> <span class="token builtin">otherwise</span>        <span class="token operator">=</span> <span class="token hvariable">lookupChapterNameBy</span> <span class="token hvariable">path</span> <span class="token hvariable">others</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Код стал более понятным. И вот как мы будем работать с этой функцией:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">main</span> <span class="token operator">::</span> <span class="token constant">IO</span> <span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token hvariable">main</span> <span class="token operator">=</span> <span class="token builtin">putStrLn</span> <span class="token operator">$</span>
  <span class="token keyword">case</span> <span class="token hvariable">result</span> <span class="token keyword">of</span>
    <span class="token constant">NoSuchChapter</span> <span class="token operator">-&gt;</span> <span class="token string">"No such chapter, sorry..."</span>
    <span class="token constant">Chapter</span> <span class="token hvariable">name</span>  <span class="token operator">-&gt;</span> <span class="token string">"This is chapter name: "</span> <span class="token operator">++</span> <span class="token hvariable">name</span>
  <span class="token keyword">where</span>
    <span class="token hvariable">result</span> <span class="token operator">=</span> <span class="token hvariable">lookupChapterNameBy</span> <span class="token string">"/tuple.html"</span> <span class="token hvariable">chapters</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Отныне функция&nbsp;<code>lookupChapterNameBy</code>&nbsp;сигнализирует о неудачном поиске не посредством пустой строки, а посредством нульарного конструктора. Это и надёжнее, и читабельнее.</p></div><div><p>Красиво, но в этом элегантном решении всё-таки остаётся один изъян: оно намертво привязано к типу&nbsp;<code>String</code>:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token keyword">data</span> <span class="token constant">Optional</span> <span class="token operator">=</span> <span class="token constant">NoSuchChapter</span>
              <span class="token operator">|</span> <span class="token constant">Chapter</span> <span class="token constant">String</span>

                        Почему
                        именно
                        <span class="token constant">String</span><span class="token operator">?</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>В самом деле, почему? Например, в Haskell широкое применение получил тип&nbsp;<code>Text</code>&nbsp;из одноимённого пакета. Этот тип, кстати, значительно мощнее и эффективнее стандартной&nbsp;<code>String</code>. Значит, если мы захотим определить опциональный тип и для&nbsp;<code>Text</code>, придётся дублировать:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token keyword">data</span> <span class="token constant">Optional</span> <span class="token operator">=</span> <span class="token constant">NoSuchChapter</span> <span class="token operator">|</span> <span class="token constant">Chapter</span> <span class="token constant">String</span>

<span class="token keyword">data</span> <span class="token constant">Optional</span> <span class="token operator">=</span> <span class="token constant">NoSuchChapter</span> <span class="token operator">|</span> <span class="token constant">Chapter</span> <span class="token constant">Text</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Однако компилятор наотрез откажется принимать такой код:</p></div><div><pre class="language-bash" tabindex="0"><code class="language-bash is-loaded">Multiple declarations of ‘Optional’
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Имена-то типов одинаковые! Хорошо, уточним:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token keyword">data</span> <span class="token constant">OptionalString</span> <span class="token operator">=</span> <span class="token constant">NoSuchChapter</span> <span class="token operator">|</span> <span class="token constant">Chapter</span> <span class="token constant">String</span>

<span class="token keyword">data</span> <span class="token constant">OptionalText</span>   <span class="token operator">=</span> <span class="token constant">NoSuchChapter</span> <span class="token operator">|</span> <span class="token constant">Chapter</span> <span class="token constant">Text</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Но и в этом случае компиляция не пройдёт:</p></div><div><pre class="language-bash" tabindex="0"><code class="language-bash is-loaded">Multiple declarations of ‘NoSuchChapter’

<span class="token punctuation">..</span>.

Multiple declarations of ‘Chapter’
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Конструкторы значений тоже одноимённые, опять уточняем:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token keyword">data</span> <span class="token constant">OptionalString</span> <span class="token operator">=</span> <span class="token constant">NoSuchChapterString</span>
                    <span class="token operator">|</span> <span class="token constant">ChapterString</span> <span class="token constant">String</span>

<span class="token keyword">data</span> <span class="token constant">OptionalText</span>   <span class="token operator">=</span> <span class="token constant">NoSuchChapterText</span>
                    <span class="token operator">|</span> <span class="token constant">ChapterText</span> <span class="token constant">Text</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Вот теперь это работает, но код стал избыточным. А вдруг мы пожелаем добавить к двум строковым типам ещё и третий? Или четвёртый? Что ж нам, для каждого типа вот так вот уточнять? Нет, умный в гору не пойдёт — есть лучший путь.</p></div><div><h2 data-heading="Может быть" id="Может_быть" style="display: flex;"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>Может быть</h2></div><div><p>В стандартной библиотеке живёт тип по имени&nbsp;<code>Maybe</code>:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token keyword">data</span> <span class="token constant">Maybe</span> <span class="token hvariable">a</span> <span class="token operator">=</span> <span class="token constant">Nothing</span> <span class="token operator">|</span> <span class="token constant">Just</span> <span class="token hvariable">a</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Тип&nbsp;<code>Maybe</code>&nbsp;(от англ. maybe, «может быть») нужен для создания тех самых опциональных значений. Впрочем, я выразился неточно, ведь, несмотря на ключевое слово&nbsp;<code>data</code>,&nbsp;<code>Maybe</code>&nbsp;— это не совсем тип, это конструктор типа (англ. type constructor). Данная концепция используется в Haskell чрезвычайно часто, и, как и большинство концепций в этом языке, она столь полезна потому, что очень проста.</p></div><div><p>Конструктор типа — это то, что создаёт новый тип (потенциально, бесконечное множество типов). Когда мы явно определяем тип, он прямолинеен и однозначен:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token keyword">data</span> <span class="token constant">Optional</span> <span class="token operator">=</span> <span class="token constant">NoSuchChapter</span> <span class="token operator">|</span> <span class="token constant">Chapter</span>      <span class="token constant">String</span>

     имя типа   нульарный       унарный      поле
                конструктор     конструктор  типа
                значения        значения     <span class="token constant">String</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Когда же мы определяем конструктор типа, мы создаём концептуальный скелет для будущих типов. Взглянем ещё раз (к-тор — это конструктор, для краткости):</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded">              <span class="token hvariable">______________________________</span>
             <span class="token operator">/</span>                              `<span class="token hvariable">v</span>

<span class="token keyword">data</span> <span class="token constant">Maybe</span>  <span class="token hvariable">a</span>        <span class="token operator">=</span> <span class="token constant">Nothing</span>   <span class="token operator">|</span> <span class="token constant">Just</span>      <span class="token hvariable">a</span>

     к<span class="token operator">-</span>тор  типовая    нульарный   унарный   поле
     типа   заглушка   к<span class="token operator">-</span>тор       к<span class="token operator">-</span>тор     типа
                       значения    значения  <span class="token hvariable">a</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Здесь присутствует уже знакомая нам типовая заглушка&nbsp;<code>a</code>, она-то и делает&nbsp;<code>Maybe</code>&nbsp;конструктором типа. Как мы помним, на место типовой заглушки всегда встаёт какой-то тип. Перепишем функцию&nbsp;<code>lookupChapterNameBy</code>&nbsp;для работы с&nbsp;<code>Maybe</code>:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">lookupChapterNameBy</span> <span class="token operator">::</span> <span class="token constant">FilePath</span> <span class="token operator">-&gt;</span> <span class="token constant">Chapters</span> <span class="token operator">-&gt;</span> <span class="token constant">Maybe</span> <span class="token constant">String</span>
<span class="token hvariable">lookupChapterNameBy</span> <span class="token hvariable">_</span> <span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token constant">Nothing</span>  <span class="token comment">-- Пустышка</span>
<span class="token hvariable">lookupChapterNameBy</span> <span class="token hvariable">path</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token hvariable">realPath</span><span class="token punctuation">,</span> <span class="token hvariable">name</span><span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token hvariable">others</span><span class="token punctuation">)</span>
  <span class="token operator">|</span> <span class="token hvariable">path</span> <span class="token operator">==</span> <span class="token hvariable">realPath</span> <span class="token operator">=</span> <span class="token constant">Just</span> <span class="token hvariable">name</span>    <span class="token comment">-- Реальное имя</span>
  <span class="token operator">|</span> <span class="token builtin">otherwise</span>        <span class="token operator">=</span> <span class="token hvariable">lookupChapterNameBy</span> <span class="token hvariable">path</span> <span class="token hvariable">others</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Рассмотрим обновлённое объявление:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">lookupChapterNameBy</span> <span class="token operator">::</span> <span class="token constant">FilePath</span>
                    <span class="token operator">-&gt;</span> <span class="token constant">Chapters</span> <span class="token operator">-&gt;</span> <span class="token constant">Maybe</span> <span class="token constant">String</span>

                                   это тип такой<span class="token punctuation">,</span>
                                   называется
                                   <span class="token constant">Maybe</span> <span class="token constant">String</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>На выходе видим значение типа&nbsp;<code>Maybe String</code>. Этот тип был порождён конструктором&nbsp;<code>Maybe</code>, применённым к типу&nbsp;<code>String</code>. Стоп, я сказал «применённым»? Да, именно так: вы можете воспринимать конструктор типа как особую «функцию», назовём её «типовая функция». Нет, это не официальный термин из Haskell, это просто аналогия: обычная функция работает с данными, а типовая функция работает с типами. Сравните это:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token builtin">length</span>   <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">3</span>

функция  данное    <span class="token operator">=</span> другое данное
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>и это:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token constant">Maybe</span>    <span class="token constant">String</span>    <span class="token operator">=</span> <span class="token constant">Maybe</span> <span class="token constant">String</span>

типовая  тип       <span class="token operator">=</span> другой тип
функция
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Применение конструктора типа к существующему типу порождает некий новый тип, и это очень мощная техника, используемая в Haskell почти на каждом шагу. Например, если нам нужно завернуть в опциональное значение уже не&nbsp;<code>String</code>, а ранее упомянутый&nbsp;<code>Text</code>, мы ничего не должны менять в конструкторе&nbsp;<code>Maybe</code>:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token constant">Maybe</span>    <span class="token constant">Text</span> <span class="token operator">=</span> <span class="token constant">Maybe</span> <span class="token constant">Text</span>

типовая  тип  <span class="token operator">=</span> другой тип
функция
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Какой тип подставляем на место&nbsp;<code>a</code>, такой тип и станет опциональным. В этом и заключается красота конструкторов типов, ведь они дают нам колоссальный простор для творчества.</p></div><div><p>А теперь мы подошли к очень важной теме.</p></div><div><h2 data-heading="Этажи" id="Этажи" style="display: flex;"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>Этажи</h2></div><div><p>Что такое тип&nbsp;<code>Maybe String</code>? Да, мы уже знаем, это АТД. Но что это такое по сути? Зачем мы конструируем сложные типы из простых? Я предлагаю вам аналогию, которая поможет нам взглянуть на этот вопрос несколько иначе. Эта аналогия отнюдь не аксиома, просто я нашёл её полезной для себя самого. Думаю, вам она тоже будет полезна. Конечно, предлагать аналогии — дело неблагодарное, ведь любая из них несовершенна и может быть так или иначе подвергнута критике. Поэтому не воспринимайте мою аналогию как единственно верную.</p></div><div><p>С точки зрения типов любую Haskell-программу можно сравнить с многоэтажным домом. И вот представьте, мы смотрим на этот дом со стороны.</p></div><div><p>На самом нижнем этаже расположены простейшие стандартные типы, такие как&nbsp;<code>Int</code>,&nbsp;<code>Double</code>,&nbsp;<code>Char</code>&nbsp;или список. Возьмём, например, тип&nbsp;<code>Int</code>. Что это такое? Целое число. Оно не несёт в себе никакого смысла, это всего лишь число в вакууме. Или вот строка — что она такое? Это просто набор каких-то символов в том же вакууме, и ничего более. И если бы мы были ограничены лишь этими типами, наша программистская жизнь была бы весьма грустной.</p></div><div><p>А вот на втором и последующих этажах живут типы куда более интересные. Например, на одном из этажей живёт тип&nbsp;<code>Maybe String</code>. При создании типа&nbsp;<code>Maybe String</code>&nbsp;происходит важное событие: мы поднимаемся с первого на более высокий этаж. Считайте эти этажи уровнями абстракции. Если тип&nbsp;<code>String</code>&nbsp;— это всего лишь безликая строка, то тип&nbsp;<code>Maybe String</code>&nbsp;— это уже не просто строка, это опциональная строка, или, если хотите, строка, наделённая опциональностью. Подняться на тот или иной этаж в нашем типовом небоскрёбе — это значит взять более простой тип и наделить его новым смыслом, новыми возможностями.</p></div><div><p>Или вот вспомним тип&nbsp;<code>IPAddress</code>:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token keyword">data</span> <span class="token constant">IPAddress</span> <span class="token operator">=</span> <span class="token constant">IPAddress</span> <span class="token constant">String</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Мы опять-таки взяли ничего не значащую строку и подняли её на этаж под названием&nbsp;<code>IPAddress</code>, и теперь это уже не просто какая-то строка, это IP-адрес. Новый тип наделил бессмысленную строку вполне определённым смыслом. А когда мы вытаскиваем внутреннюю строку из&nbsp;<code>IPAddress</code>&nbsp;с помощью паттерн матчинга, мы вновь оказываемся на первом этаже.</p></div><div><p>А вот ещё наш тип,&nbsp;<code>EndPoint</code>:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token keyword">data</span> <span class="token constant">EndPoint</span> <span class="token operator">=</span> <span class="token constant">EndPoint</span> <span class="token constant">IPAddress</span> <span class="token constant">Int</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Тут мы поднялись ещё чуток: сначала подняли строку на этаж IP-адреса, а затем взяли его и тип&nbsp;<code>Int</code>&nbsp;и подняли их на следующий этаж под названием&nbsp;<code>EndPoint</code>, и на этом этаже перед нами уже не просто какой-то IP-адрес и какое-то число, перед нами уже связанные друг с другом адрес и порт.</p></div><div><p>А вот ещё один пример, знакомство с которым я откладывал до сих пор. Вспомним определение главной функции&nbsp;<code>main</code>:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">main</span> <span class="token operator">::</span> <span class="token constant">IO</span> <span class="token punctuation">(</span><span class="token punctuation">)</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Я обещал рассказать о том, что такое&nbsp;<code>IO</code>, и вот теперь рассказываю:&nbsp;<code>IO</code>&nbsp;— это тоже конструктор типа. Правда, конструктор особенный, непохожий на наши&nbsp;<code>IPAddress</code>&nbsp;или&nbsp;<code>EndPoint</code>, но об этом подробнее в следующих главах. Так вот поднявшись на этаж под названием&nbsp;<code>IO</code>, мы получаем очень важную способность — способность взаимодействовать с внешним миром: файл прочесть, на консоль текст вывести, и в том же духе. И потому тип&nbsp;<code>IO String</code>&nbsp;— это уже не просто невесть откуда взявшаяся строка, но строка, полученная из внешнего мира (например, из файла). И единственная возможность наделить наши функции способностью взаимодействовать с внешним миром — поднять (ну или опустить) их на&nbsp;<code>IO</code>-этаж. Вот так и получается: в процессе работы программы мы постоянно прыгаем в лифт и переезжаем с одного типового этажа на другой.</p></div><div><p>Но запомните: не все этажи одинаковы! Не со всякого этажа можно напрямую попасть на любой другой. Более того, есть такие этажи, оказавшись на котором, мы в конечном итоге обязаны на него и вернуться. Понимаю, сейчас это порождает больше вопросов, нежели ответов, но не беспокойтесь: ответы ждут нас в последующих главах.</p></div><div><h1 data-heading="Продолжение следует?.." id="Продолжение_следует?..">Продолжение следует?..</h1></div><div><p>Проект заморожен. Будет ли продолжение - не знаю, время покажет. Следите за новостями в&nbsp;твиттере автора. Здесь ссылки на твиттер не будет.</p></div><div class="mod-footer"><div class="embedded-backlinks" style="display: none;"></div></div></div></div></div><div class="sidebar-right sidebar"><div class="sidebar-content"><span class="sidebar-section-header">Interactive Graph</span><div class="graph-view-placeholder">
		<div class="graph-view-container">
			<div class="graph-icon graph-expand" role="button" aria-label="Expand" data-tooltip-position="top"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon lucide-arrow-up-right"><line x1="7" y1="17" x2="17" y2="7"></line><polyline points="7 7 17 7 17 17"></polyline></svg></div>
			<canvas id="graph-canvas" width="512px" height="512px"></canvas>
		</div>
		</div><div class="tree-container outline-tree" data-depth="0"><div class="tree-header"><span class="sidebar-section-header">Table Of Contents</span><button class="clickable-icon collapse-tree-button"><iconify-icon icon="ph:arrows-in-line-horizontal-bold" width="18px" height="18px" rotate="90deg" color="currentColor"></iconify-icon></button></div><div class="tree-scroll-area"><div class="tree-item mod-tree-heading" data-depth="1"><div class="tree-item-contents"><a class="tree-item-link" href="#Приветствую!"><span class="tree-item-title">Приветствую!</span></a></div><div class="tree-item-children"><div class="tree-item mod-tree-heading" data-depth="2"><div class="tree-item-contents"><a class="tree-item-link" href="#Почему_эта_книга_появилась"><span class="tree-item-title">Почему эта книга появилась</span></a></div><div class="tree-item-children"></div></div><div class="tree-item mod-tree-heading" data-depth="2"><div class="tree-item-contents"><a class="tree-item-link" href="#Цель"><span class="tree-item-title">Цель</span></a></div><div class="tree-item-children"></div></div><div class="tree-item mod-tree-heading" data-depth="2"><div class="tree-item-contents"><a class="tree-item-link" href="#О_себе"><span class="tree-item-title">О себе</span></a></div><div class="tree-item-children"></div></div><div class="tree-item mod-tree-heading" data-depth="2"><div class="tree-item-contents"><a class="tree-item-link" href="#О_вас"><span class="tree-item-title">О вас</span></a></div><div class="tree-item-children"></div></div><div class="tree-item mod-tree-heading" data-depth="2"><div class="tree-item-contents"><a class="tree-item-link" href="#Обещание"><span class="tree-item-title">Обещание</span></a></div><div class="tree-item-children"></div></div></div></div><div class="tree-item mod-tree-heading" data-depth="1"><div class="tree-item-contents"><a class="tree-item-link" href="#Первые_вопросы"><span class="tree-item-title">Первые вопросы</span></a></div><div class="tree-item-children"><div class="tree-item mod-tree-heading" data-depth="2"><div class="tree-item-contents"><a class="tree-item-link" href="#«Что_такое_этот_ваш_Haskell?»"><span class="tree-item-title">«Что такое этот ваш Haskell?»</span></a></div><div class="tree-item-children"></div></div><div class="tree-item mod-tree-heading" data-depth="2"><div class="tree-item-contents"><a class="tree-item-link" href="#«Это_что,_какой-то_новый_язык?»"><span class="tree-item-title">«Это что, какой-то новый язык?»</span></a></div><div class="tree-item-children"></div></div><div class="tree-item mod-tree-heading" data-depth="2"><div class="tree-item-contents"><a class="tree-item-link" href="#«И_кто_его_сделал?»"><span class="tree-item-title">«И кто его сделал?»</span></a></div><div class="tree-item-children"></div></div><div class="tree-item mod-tree-heading" data-depth="2"><div class="tree-item-contents"><a class="tree-item-link" href="#«А_библиотеки_для_Haskell_имеются?»"><span class="tree-item-title">«А библиотеки для Haskell имеются?»</span></a></div><div class="tree-item-children"></div></div><div class="tree-item mod-tree-heading" data-depth="2"><div class="tree-item-contents"><a class="tree-item-link" href="#«И_что,_его_уже_можно_в_production?»"><span class="tree-item-title">«И что, его уже можно в production?»</span></a></div><div class="tree-item-children"></div></div><div class="tree-item mod-tree-heading" data-depth="2"><div class="tree-item-contents"><a class="tree-item-link" href="#«А_порог_вхождения_в_Haskell_высокий?»"><span class="tree-item-title">«А порог вхождения в Haskell высокий?»</span></a></div><div class="tree-item-children"></div></div><div class="tree-item mod-tree-heading" data-depth="2"><div class="tree-item-contents"><a class="tree-item-link" href="#«А_я_слышал_ещё_про_какие-то_монады…»"><span class="tree-item-title">«А я слышал ещё про какие-то монады…»</span></a></div><div class="tree-item-children"></div></div><div class="tree-item mod-tree-heading" data-depth="2"><div class="tree-item-contents"><a class="tree-item-link" href="#«А_если_сравнить_его_с_C++/Python/Scala…»"><span class="tree-item-title">«А если сравнить его с C++/Python/Scala…»</span></a></div><div class="tree-item-children"></div></div></div></div><div class="tree-item mod-tree-heading" data-depth="1"><div class="tree-item-contents"><a class="tree-item-link" href="#Об_этой_книге"><span class="tree-item-title">Об этой книге</span></a></div><div class="tree-item-children"><div class="tree-item mod-tree-heading" data-depth="2"><div class="tree-item-contents"><a class="tree-item-link" href="#Чего_здесь_нет"><span class="tree-item-title">Чего здесь нет</span></a></div><div class="tree-item-children"></div></div><div class="tree-item mod-tree-heading" data-depth="2"><div class="tree-item-contents"><a class="tree-item-link" href="#О_первом_и_втором_издании"><span class="tree-item-title">О первом и втором издании</span></a></div><div class="tree-item-children"></div></div><div class="tree-item mod-tree-heading" data-depth="2"><div class="tree-item-contents"><a class="tree-item-link" href="#Читайте_последовательно"><span class="tree-item-title">Читайте последовательно</span></a></div><div class="tree-item-children"></div></div><div class="tree-item mod-tree-heading" data-depth="2"><div class="tree-item-contents"><a class="tree-item-link" href="#Для_любопытных"><span class="tree-item-title">Для любопытных</span></a></div><div class="tree-item-children"></div></div><div class="tree-item mod-tree-heading" data-depth="2"><div class="tree-item-contents"><a class="tree-item-link" href="#О_пояснениях"><span class="tree-item-title">О пояснениях</span></a></div><div class="tree-item-children"></div></div><div class="tree-item mod-tree-heading" data-depth="2"><div class="tree-item-contents"><a class="tree-item-link" href="#Благодарность"><span class="tree-item-title">Благодарность</span></a></div><div class="tree-item-children"></div></div><div class="tree-item mod-tree-heading" data-depth="2"><div class="tree-item-contents"><a class="tree-item-link" href="#Слово_к_читавшим_первое_издание"><span class="tree-item-title">Слово к читавшим первое издание</span></a></div><div class="tree-item-children"></div></div></div></div><div class="tree-item mod-tree-heading" data-depth="1"><div class="tree-item-contents"><a class="tree-item-link" href="#Приготовимся"><span class="tree-item-title">Приготовимся</span></a></div><div class="tree-item-children"><div class="tree-item mod-tree-heading" data-depth="2"><div class="tree-item-contents"><a class="tree-item-link" href="#Устанавливаем"><span class="tree-item-title">Устанавливаем</span></a></div><div class="tree-item-children"></div></div><div class="tree-item mod-tree-heading" data-depth="2"><div class="tree-item-contents"><a class="tree-item-link" href="#Разворачиваем_инфраструктуру"><span class="tree-item-title">Разворачиваем инфраструктуру</span></a></div><div class="tree-item-children"></div></div><div class="tree-item mod-tree-heading" data-depth="2"><div class="tree-item-contents"><a class="tree-item-link" href="#Hi_World"><span class="tree-item-title">Hi World</span></a></div><div class="tree-item-children"></div></div><div class="tree-item mod-tree-heading" data-depth="2"><div class="tree-item-contents"><a class="tree-item-link" href="#Модули:_знакомство"><span class="tree-item-title">Модули: знакомство</span></a></div><div class="tree-item-children"></div></div><div class="tree-item mod-tree-heading" data-depth="2"><div class="tree-item-contents"><a class="tree-item-link" href="#Для_любопытных"><span class="tree-item-title">Для любопытных</span></a></div><div class="tree-item-children"></div></div></div></div><div class="tree-item mod-tree-heading" data-depth="1"><div class="tree-item-contents"><a class="tree-item-link" href="#Киты_и_Черепаха"><span class="tree-item-title">Киты и Черепаха</span></a></div><div class="tree-item-children"><div class="tree-item mod-tree-heading" data-depth="2"><div class="tree-item-contents"><a class="tree-item-link" href="#Черепаха"><span class="tree-item-title">Черепаха</span></a></div><div class="tree-item-children"></div></div><div class="tree-item mod-tree-heading" data-depth="2"><div class="tree-item-contents"><a class="tree-item-link" href="#Первый_Кит"><span class="tree-item-title">Первый Кит</span></a></div><div class="tree-item-children"></div></div><div class="tree-item mod-tree-heading mod-collapsible" data-depth="2"><div class="tree-item-contents"><div class="tree-item-icon collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div><a class="tree-item-link" href="#Второй_Кит"><span class="tree-item-title">Второй Кит</span></a></div><div class="tree-item-children"><div class="tree-item mod-tree-heading" data-depth="3"><div class="tree-item-contents"><a class="tree-item-link" href="#Статическая_проверка"><span class="tree-item-title">Статическая проверка</span></a></div><div class="tree-item-children"></div></div><div class="tree-item mod-tree-heading" data-depth="3"><div class="tree-item-contents"><a class="tree-item-link" href="#Сила"><span class="tree-item-title">Сила</span></a></div><div class="tree-item-children"></div></div><div class="tree-item mod-tree-heading" data-depth="3"><div class="tree-item-contents"><a class="tree-item-link" href="#Выведение"><span class="tree-item-title">Выведение</span></a></div><div class="tree-item-children"></div></div></div></div><div class="tree-item mod-tree-heading" data-depth="2"><div class="tree-item-contents"><a class="tree-item-link" href="#Третий_Кит"><span class="tree-item-title">Третий Кит</span></a></div><div class="tree-item-children"></div></div><div class="tree-item mod-tree-heading" data-depth="2"><div class="tree-item-contents"><a class="tree-item-link" href="#Для_любопытных"><span class="tree-item-title">Для любопытных</span></a></div><div class="tree-item-children"></div></div></div></div><div class="tree-item mod-tree-heading" data-depth="1"><div class="tree-item-contents"><a class="tree-item-link" href="#Неизменность_и_чистота"><span class="tree-item-title">Неизменность и чистота</span></a></div><div class="tree-item-children"><div class="tree-item mod-tree-heading" data-depth="2"><div class="tree-item-contents"><a class="tree-item-link" href="#Объявляем_и_определяем"><span class="tree-item-title">Объявляем и определяем</span></a></div><div class="tree-item-children"></div></div><div class="tree-item mod-tree-heading" data-depth="2"><div class="tree-item-contents"><a class="tree-item-link" href="#Чисто_функциональный"><span class="tree-item-title">Чисто функциональный</span></a></div><div class="tree-item-children"></div></div><div class="tree-item mod-tree-heading" data-depth="2"><div class="tree-item-contents"><a class="tree-item-link" href="#«Присваивание?_Не,_не_слышал…»"><span class="tree-item-title">«Присваивание? Не, не слышал…»</span></a></div><div class="tree-item-children"></div></div><div class="tree-item mod-tree-heading" data-depth="2"><div class="tree-item-contents"><a class="tree-item-link" href="#Для_любопытных"><span class="tree-item-title">Для любопытных</span></a></div><div class="tree-item-children"></div></div></div></div><div class="tree-item mod-tree-heading" data-depth="1"><div class="tree-item-contents"><a class="tree-item-link" href="#Выбираем_и_возвращаемся"><span class="tree-item-title">Выбираем и возвращаемся</span></a></div><div class="tree-item-children"><div class="tree-item mod-tree-heading" data-depth="2"><div class="tree-item-contents"><a class="tree-item-link" href="#Выглянем_во_внешний_мир"><span class="tree-item-title">Выглянем во внешний мир</span></a></div><div class="tree-item-children"></div></div><div class="tree-item mod-tree-heading" data-depth="2"><div class="tree-item-contents"><a class="tree-item-link" href="#Выбор_и_выход"><span class="tree-item-title">Выбор и выход</span></a></div><div class="tree-item-children"></div></div><div class="tree-item mod-tree-heading" data-depth="2"><div class="tree-item-contents"><a class="tree-item-link" href="#Для_любопытных"><span class="tree-item-title">Для любопытных</span></a></div><div class="tree-item-children"></div></div></div></div><div class="tree-item mod-tree-heading" data-depth="1"><div class="tree-item-contents"><a class="tree-item-link" href="#Выбор_и_образцы"><span class="tree-item-title">Выбор и образцы</span></a></div><div class="tree-item-children"><div class="tree-item mod-tree-heading" data-depth="2"><div class="tree-item-contents"><a class="tree-item-link" href="#Не_только_из_двух"><span class="tree-item-title">Не только из двух</span></a></div><div class="tree-item-children"></div></div><div class="tree-item mod-tree-heading" data-depth="2"><div class="tree-item-contents"><a class="tree-item-link" href="#Без_Если"><span class="tree-item-title">Без Если</span></a></div><div class="tree-item-children"></div></div><div class="tree-item mod-tree-heading" data-depth="2"><div class="tree-item-contents"><a class="tree-item-link" href="#Сравнение_с_образцом"><span class="tree-item-title">Сравнение с образцом</span></a></div><div class="tree-item-children"></div></div><div class="tree-item mod-tree-heading" data-depth="2"><div class="tree-item-contents"><a class="tree-item-link" href="#case"><span class="tree-item-title">case</span></a></div><div class="tree-item-children"></div></div></div></div><div class="tree-item mod-tree-heading" data-depth="1"><div class="tree-item-contents"><a class="tree-item-link" href="#Пусть_будет_там,_Где…"><span class="tree-item-title">Пусть будет там, Где…</span></a></div><div class="tree-item-children"><div class="tree-item mod-tree-heading" data-depth="2"><div class="tree-item-contents"><a class="tree-item-link" href="#Пусть"><span class="tree-item-title">Пусть</span></a></div><div class="tree-item-children"></div></div><div class="tree-item mod-tree-heading" data-depth="2"><div class="tree-item-contents"><a class="tree-item-link" href="#Где"><span class="tree-item-title">Где</span></a></div><div class="tree-item-children"></div></div><div class="tree-item mod-tree-heading" data-depth="2"><div class="tree-item-contents"><a class="tree-item-link" href="#Вместе"><span class="tree-item-title">Вместе</span></a></div><div class="tree-item-children"></div></div></div></div><div class="tree-item mod-tree-heading" data-depth="1"><div class="tree-item-contents"><a class="tree-item-link" href="#Мир_операторов"><span class="tree-item-title">Мир операторов</span></a></div><div class="tree-item-children"><div class="tree-item mod-tree-heading" data-depth="2"><div class="tree-item-contents"><a class="tree-item-link" href="#Зачем_это_нужно?"><span class="tree-item-title">Зачем это нужно?</span></a></div><div class="tree-item-children"></div></div></div></div><div class="tree-item mod-tree-heading" data-depth="1"><div class="tree-item-contents"><a class="tree-item-link" href="#Список"><span class="tree-item-title">Список</span></a></div><div class="tree-item-children"><div class="tree-item mod-tree-heading" data-depth="2"><div class="tree-item-contents"><a class="tree-item-link" href="#Тип_списка"><span class="tree-item-title">Тип списка</span></a></div><div class="tree-item-children"></div></div><div class="tree-item mod-tree-heading" data-depth="2"><div class="tree-item-contents"><a class="tree-item-link" href="#Действия_над_списками"><span class="tree-item-title">Действия над списками</span></a></div><div class="tree-item-children"></div></div><div class="tree-item mod-tree-heading" data-depth="2"><div class="tree-item-contents"><a class="tree-item-link" href="#Неизменность_списка"><span class="tree-item-title">Неизменность списка</span></a></div><div class="tree-item-children"></div></div><div class="tree-item mod-tree-heading" data-depth="2"><div class="tree-item-contents"><a class="tree-item-link" href="#Перечисление"><span class="tree-item-title">Перечисление</span></a></div><div class="tree-item-children"></div></div><div class="tree-item mod-tree-heading" data-depth="2"><div class="tree-item-contents"><a class="tree-item-link" href="#Для_любопытных"><span class="tree-item-title">Для любопытных</span></a></div><div class="tree-item-children"></div></div></div></div><div class="tree-item mod-tree-heading" data-depth="1"><div class="tree-item-contents"><a class="tree-item-link" href="#Кортеж"><span class="tree-item-title">Кортеж</span></a></div><div class="tree-item-children"><div class="tree-item mod-tree-heading" data-depth="2"><div class="tree-item-contents"><a class="tree-item-link" href="#Тип_кортежа"><span class="tree-item-title">Тип кортежа</span></a></div><div class="tree-item-children"></div></div><div class="tree-item mod-tree-heading" data-depth="2"><div class="tree-item-contents"><a class="tree-item-link" href="#Действия_над_кортежами"><span class="tree-item-title">Действия над кортежами</span></a></div><div class="tree-item-children"></div></div><div class="tree-item mod-tree-heading" data-depth="2"><div class="tree-item-contents"><a class="tree-item-link" href="#Не_всё"><span class="tree-item-title">Не всё</span></a></div><div class="tree-item-children"></div></div><div class="tree-item mod-tree-heading" data-depth="2"><div class="tree-item-contents"><a class="tree-item-link" href="#А_если_ошиблись?"><span class="tree-item-title">А если ошиблись?</span></a></div><div class="tree-item-children"></div></div><div class="tree-item mod-tree-heading" data-depth="2"><div class="tree-item-contents"><a class="tree-item-link" href="#Для_любопытных"><span class="tree-item-title">Для любопытных</span></a></div><div class="tree-item-children"></div></div></div></div><div class="tree-item mod-tree-heading" data-depth="1"><div class="tree-item-contents"><a class="tree-item-link" href="#Лямбда-функция"><span class="tree-item-title">Лямбда-функция</span></a></div><div class="tree-item-children"><div class="tree-item mod-tree-heading" data-depth="2"><div class="tree-item-contents"><a class="tree-item-link" href="#Истоки"><span class="tree-item-title">Истоки</span></a></div><div class="tree-item-children"></div></div><div class="tree-item mod-tree-heading" data-depth="2"><div class="tree-item-contents"><a class="tree-item-link" href="#Строение"><span class="tree-item-title">Строение</span></a></div><div class="tree-item-children"></div></div><div class="tree-item mod-tree-heading" data-depth="2"><div class="tree-item-contents"><a class="tree-item-link" href="#Тип_функции"><span class="tree-item-title">Тип функции</span></a></div><div class="tree-item-children"></div></div><div class="tree-item mod-tree-heading" data-depth="2"><div class="tree-item-contents"><a class="tree-item-link" href="#Локальные_функции"><span class="tree-item-title">Локальные функции</span></a></div><div class="tree-item-children"></div></div><div class="tree-item mod-tree-heading" data-depth="2"><div class="tree-item-contents"><a class="tree-item-link" href="#Для_любопытных"><span class="tree-item-title">Для любопытных</span></a></div><div class="tree-item-children"></div></div></div></div><div class="tree-item mod-tree-heading" data-depth="1"><div class="tree-item-contents"><a class="tree-item-link" href="#Композиция_функций"><span class="tree-item-title">Композиция функций</span></a></div><div class="tree-item-children"><div class="tree-item mod-tree-heading" data-depth="2"><div class="tree-item-contents"><a class="tree-item-link" href="#Скобкам_—_бой!"><span class="tree-item-title">Скобкам — бой!</span></a></div><div class="tree-item-children"></div></div><div class="tree-item mod-tree-heading" data-depth="2"><div class="tree-item-contents"><a class="tree-item-link" href="#Композиция_и_применение"><span class="tree-item-title">Композиция и применение</span></a></div><div class="tree-item-children"></div></div><div class="tree-item mod-tree-heading" data-depth="2"><div class="tree-item-contents"><a class="tree-item-link" href="#Длинные_цепочки"><span class="tree-item-title">Длинные цепочки</span></a></div><div class="tree-item-children"></div></div><div class="tree-item mod-tree-heading" data-depth="2"><div class="tree-item-contents"><a class="tree-item-link" href="#Как_работает_композиция"><span class="tree-item-title">Как работает композиция</span></a></div><div class="tree-item-children"></div></div></div></div><div class="tree-item mod-tree-heading" data-depth="1"><div class="tree-item-contents"><a class="tree-item-link" href="#ФВП"><span class="tree-item-title">ФВП</span></a></div><div class="tree-item-children"><div class="tree-item mod-tree-heading" data-depth="2"><div class="tree-item-contents"><a class="tree-item-link" href="#Отображение"><span class="tree-item-title">Отображение</span></a></div><div class="tree-item-children"></div></div><div class="tree-item mod-tree-heading" data-depth="2"><div class="tree-item-contents"><a class="tree-item-link" href="#Частичное_применение"><span class="tree-item-title">Частичное применение</span></a></div><div class="tree-item-children"></div></div><div class="tree-item mod-tree-heading" data-depth="2"><div class="tree-item-contents"><a class="tree-item-link" href="#Композиция_для_отображения"><span class="tree-item-title">Композиция для отображения</span></a></div><div class="tree-item-children"></div></div></div></div><div class="tree-item mod-tree-heading" data-depth="1"><div class="tree-item-contents"><a class="tree-item-link" href="#Hackage_и_библиотеки"><span class="tree-item-title">Hackage и библиотеки</span></a></div><div class="tree-item-children"><div class="tree-item mod-tree-heading" data-depth="2"><div class="tree-item-contents"><a class="tree-item-link" href="#Библиотеки_большие_и_маленькие"><span class="tree-item-title">Библиотеки большие и маленькие</span></a></div><div class="tree-item-children"></div></div><div class="tree-item mod-tree-heading" data-depth="2"><div class="tree-item-contents"><a class="tree-item-link" href="#Hackage"><span class="tree-item-title">Hackage</span></a></div><div class="tree-item-children"></div></div><div class="tree-item mod-tree-heading" data-depth="2"><div class="tree-item-contents"><a class="tree-item-link" href="#Иерархия_в_имени"><span class="tree-item-title">Иерархия в имени</span></a></div><div class="tree-item-children"></div></div><div class="tree-item mod-tree-heading" data-depth="2"><div class="tree-item-contents"><a class="tree-item-link" href="#Лицо"><span class="tree-item-title">Лицо</span></a></div><div class="tree-item-children"></div></div><div class="tree-item mod-tree-heading" data-depth="2"><div class="tree-item-contents"><a class="tree-item-link" href="#Импортируем_по-разному"><span class="tree-item-title">Импортируем по-разному</span></a></div><div class="tree-item-children"></div></div><div class="tree-item mod-tree-heading" data-depth="2"><div class="tree-item-contents"><a class="tree-item-link" href="#Оформление"><span class="tree-item-title">Оформление</span></a></div><div class="tree-item-children"></div></div></div></div><div class="tree-item mod-tree-heading" data-depth="1"><div class="tree-item-contents"><a class="tree-item-link" href="#Рекурсия"><span class="tree-item-title">Рекурсия</span></a></div><div class="tree-item-children"><div class="tree-item mod-tree-heading" data-depth="2"><div class="tree-item-contents"><a class="tree-item-link" href="#Цикл"><span class="tree-item-title">Цикл</span></a></div><div class="tree-item-children"></div></div><div class="tree-item mod-tree-heading" data-depth="2"><div class="tree-item-contents"><a class="tree-item-link" href="#Правда_о_списке"><span class="tree-item-title">Правда о списке</span></a></div><div class="tree-item-children"></div></div><div class="tree-item mod-tree-heading" data-depth="2"><div class="tree-item-contents"><a class="tree-item-link" href="#Туда_и_обратно"><span class="tree-item-title">Туда и обратно</span></a></div><div class="tree-item-children"></div></div><div class="tree-item mod-tree-heading" data-depth="2"><div class="tree-item-contents"><a class="tree-item-link" href="#Для_любопытных"><span class="tree-item-title">Для любопытных</span></a></div><div class="tree-item-children"></div></div></div></div><div class="tree-item mod-tree-heading" data-depth="1"><div class="tree-item-contents"><a class="tree-item-link" href="#Лень"><span class="tree-item-title">Лень</span></a></div><div class="tree-item-children"><div class="tree-item mod-tree-heading" data-depth="2"><div class="tree-item-contents"><a class="tree-item-link" href="#Две_модели_вычислений"><span class="tree-item-title">Две модели вычислений</span></a></div><div class="tree-item-children"></div></div><div class="tree-item mod-tree-heading" data-depth="2"><div class="tree-item-contents"><a class="tree-item-link" href="#Как_можно_меньше"><span class="tree-item-title">Как можно меньше</span></a></div><div class="tree-item-children"></div></div><div class="tree-item mod-tree-heading" data-depth="2"><div class="tree-item-contents"><a class="tree-item-link" href="#Рациональность"><span class="tree-item-title">Рациональность</span></a></div><div class="tree-item-children"></div></div><div class="tree-item mod-tree-heading" data-depth="2"><div class="tree-item-contents"><a class="tree-item-link" href="#Бесконечность"><span class="tree-item-title">Бесконечность</span></a></div><div class="tree-item-children"></div></div><div class="tree-item mod-tree-heading" data-depth="2"><div class="tree-item-contents"><a class="tree-item-link" href="#Space_leak"><span class="tree-item-title">Space leak</span></a></div><div class="tree-item-children"></div></div><div class="tree-item mod-tree-heading mod-collapsible" data-depth="2"><div class="tree-item-contents"><div class="tree-item-icon collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div><a class="tree-item-link" href="#Борьба"><span class="tree-item-title">Борьба</span></a></div><div class="tree-item-children"><div class="tree-item mod-tree-heading" data-depth="3"><div class="tree-item-contents"><a class="tree-item-link" href="#Оптимизация"><span class="tree-item-title">Оптимизация</span></a></div><div class="tree-item-children"></div></div><div class="tree-item mod-tree-heading" data-depth="3"><div class="tree-item-contents"><a class="tree-item-link" href="#Вручную"><span class="tree-item-title">Вручную</span></a></div><div class="tree-item-children"></div></div></div></div><div class="tree-item mod-tree-heading" data-depth="2"><div class="tree-item-contents"><a class="tree-item-link" href="#Лень_и_строгость_вместе"><span class="tree-item-title">Лень и строгость вместе</span></a></div><div class="tree-item-children"></div></div><div class="tree-item mod-tree-heading" data-depth="2"><div class="tree-item-contents"><a class="tree-item-link" href="#Для_любопытных"><span class="tree-item-title">Для любопытных</span></a></div><div class="tree-item-children"></div></div></div></div><div class="tree-item mod-tree-heading" data-depth="1"><div class="tree-item-contents"><a class="tree-item-link" href="#Наши_типы"><span class="tree-item-title">Наши типы</span></a></div><div class="tree-item-children"><div class="tree-item mod-tree-heading" data-depth="2"><div class="tree-item-contents"><a class="tree-item-link" href="#Знакомство"><span class="tree-item-title">Знакомство</span></a></div><div class="tree-item-children"></div></div><div class="tree-item mod-tree-heading" data-depth="2"><div class="tree-item-contents"><a class="tree-item-link" href="#Значение-пустышка"><span class="tree-item-title">Значение-пустышка</span></a></div><div class="tree-item-children"></div></div></div></div><div class="tree-item mod-tree-heading" data-depth="1"><div class="tree-item-contents"><a class="tree-item-link" href="#АТД"><span class="tree-item-title">АТД</span></a></div><div class="tree-item-children"><div class="tree-item mod-tree-heading" data-depth="2"><div class="tree-item-contents"><a class="tree-item-link" href="#Извлекаем_значение"><span class="tree-item-title">Извлекаем значение</span></a></div><div class="tree-item-children"></div></div><div class="tree-item mod-tree-heading" data-depth="2"><div class="tree-item-contents"><a class="tree-item-link" href="#Строим"><span class="tree-item-title">Строим</span></a></div><div class="tree-item-children"></div></div></div></div><div class="tree-item mod-tree-heading" data-depth="1"><div class="tree-item-contents"><a class="tree-item-link" href="#АТД:_поля_с_метками"><span class="tree-item-title">АТД: поля с метками</span></a></div><div class="tree-item-children"><div class="tree-item mod-tree-heading" data-depth="2"><div class="tree-item-contents"><a class="tree-item-link" href="#Метки"><span class="tree-item-title">Метки</span></a></div><div class="tree-item-children"></div></div><div class="tree-item mod-tree-heading" data-depth="2"><div class="tree-item-contents"><a class="tree-item-link" href="#Getter_и_Setter?"><span class="tree-item-title">Getter и Setter?</span></a></div><div class="tree-item-children"></div></div><div class="tree-item mod-tree-heading" data-depth="2"><div class="tree-item-contents"><a class="tree-item-link" href="#Без_меток"><span class="tree-item-title">Без меток</span></a></div><div class="tree-item-children"></div></div></div></div><div class="tree-item mod-tree-heading" data-depth="1"><div class="tree-item-contents"><a class="tree-item-link" href="#Новый_тип"><span class="tree-item-title">Новый тип</span></a></div><div class="tree-item-children"><div class="tree-item mod-tree-heading" data-depth="2"><div class="tree-item-contents"><a class="tree-item-link" href="#Различия"><span class="tree-item-title">Различия</span></a></div><div class="tree-item-children"></div></div><div class="tree-item mod-tree-heading" data-depth="2"><div class="tree-item-contents"><a class="tree-item-link" href="#Зачем_он_нужен?"><span class="tree-item-title">Зачем он нужен?</span></a></div><div class="tree-item-children"></div></div><div class="tree-item mod-tree-heading" data-depth="2"><div class="tree-item-contents"><a class="tree-item-link" href="#type_vs_newtype"><span class="tree-item-title">type vs newtype</span></a></div><div class="tree-item-children"></div></div></div></div><div class="tree-item mod-tree-heading" data-depth="1"><div class="tree-item-contents"><a class="tree-item-link" href="#Конструктор_типа"><span class="tree-item-title">Конструктор типа</span></a></div><div class="tree-item-children"><div class="tree-item mod-tree-heading" data-depth="2"><div class="tree-item-contents"><a class="tree-item-link" href="#Опциональный_тип"><span class="tree-item-title">Опциональный тип</span></a></div><div class="tree-item-children"></div></div><div class="tree-item mod-tree-heading" data-depth="2"><div class="tree-item-contents"><a class="tree-item-link" href="#Может_быть"><span class="tree-item-title">Может быть</span></a></div><div class="tree-item-children"></div></div><div class="tree-item mod-tree-heading" data-depth="2"><div class="tree-item-contents"><a class="tree-item-link" href="#Этажи"><span class="tree-item-title">Этажи</span></a></div><div class="tree-item-children"></div></div></div></div><div class="tree-item mod-tree-heading" data-depth="1"><div class="tree-item-contents"><a class="tree-item-link" href="#Продолжение_следует?.."><span class="tree-item-title">Продолжение следует?..</span></a></div><div class="tree-item-children"></div></div></div></div></div></div></div></body></html>