<!DOCTYPE html>
<html><head>
			
		<title>О Haskell по-человечески (Итого)</title>
		<base href="../../">
		<meta id="root-path" root-path="../../">

		<link rel="icon" sizes="96x96" href="https://publish-01.obsidian.md/access/f786db9fac45774fa4f0d8112e232d67/favicon-96x96.png">
		<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes, minimum-scale=1.0, maximum-scale=5.0">
		<meta charset="UTF-8">
		<script src="https://code.iconify.design/iconify-icon/1.0.3/iconify-icon.min.js"></script>

			<link rel="stylesheet" href="lib/styles/obsidian-styles.css">
			<link rel="stylesheet" href="lib/styles/theme.css">
			<link rel="stylesheet" href="lib/styles/plugin-styles.css">
			<link rel="stylesheet" href="lib/styles/snippets.css">
			<style>  </style>

			
			<!-- Graph View Data -->
			<script>
			let nodes=
{"nodeCount":11,"linkCount":10,"radii":[6,5.353316326530613,4.7602040816326525,3.975765306122449,3.975765306122449,3.975765306122449,3.975765306122449,3.975765306122449,3.975765306122449,3.975765306122449,3.975765306122449],"labels":["Отчеты","README","README","Полезные ресурсы","О Haskell по-человечески (Итого)","О Haskell по-человечески (Оригинал)","Learn You a Haskell for Great Good! ru","Learn You a Haskell for Great Good! en","py Конвертация txt в xlsx","py код оптимизации mdx","nodejs - зло"],"paths":["отчеты.html","курсы/learn-you-a-haskell-for-great-good!/readme.html","readme.html","полезные-ресурсы.html","мои-решения/о-haskell-по-человечески/о-haskell-по-человечески-(итого).html","курсы/о-haskell-по-человечески/о-haskell-по-человечески-(оригинал).html","курсы/learn-you-a-haskell-for-great-good!/learn-you-a-haskell-for-great-good!-ru.html","курсы/learn-you-a-haskell-for-great-good!/learn-you-a-haskell-for-great-good!-en.html","для-отчета/py-конвертация-txt-в-xlsx.html","для-отчета/py-код-оптимизации-mdx.html","для-отчета/nodejs-зло.html"],"linkSources":[2,2,1,1,0,0,0,0,0,0],"linkTargets":[3,0,7,6,5,4,1,10,9,8]};
			let attractionForce = 1;
			let linkLength = 10;
			let repulsionForce = 150;
			let centralForce = 3;
			let edgePruning = 100;
			</script>
			
<script type="module" src="lib/scripts/graph_view.js"></script>

<script src="lib/scripts/graph_wasm.js"></script>

<script src="lib/scripts/tinycolor.js"></script>

<script src="https://cdnjs.cloudflare.com/ajax/libs/pixi.js/7.2.4/pixi.min.js" integrity="sha512-Ch/O6kL8BqUwAfCF7Ie5SX1Hin+BJgYH4pNjRqXdTEqMsis1TUYg+j6nnI9uduPjGaj7DN4UKCZgpvoExt6dkw==" crossorigin="anonymous" referrerpolicy="no-referrer"></script>

<script src="lib/scripts/webpage.js"></script>

			</head><body class="theme-dark mod-windows is-frameless is-maximized is-hidden-frameless obsidian-app show-inline-title show-view-header" style="--zoom-factor:1; --font-text-size:16px; --line-width:100%; --line-width-adaptive:100%; --file-line-width:100%; --content-width:500em; --sidebar-width:25em; --collapse-arrow-size:0.4em; --tree-horizontal-spacing:1em; --tree-vertical-spacing:0.5em; --sidebar-margin:12px;"><div class="webpage-container"><div class="sidebar-left sidebar"><div class="sidebar-content"><div><label class="theme-toggle-container" for="theme_toggle"><input class="theme-toggle-input" type="checkbox" id="theme_toggle"><div class="toggle-background"></div></label></div><div class="tree-container file-tree mod-nav-indicator" data-depth="0"><div class="tree-header"><span class="sidebar-section-header">learn-haskell-valut</span><button class="clickable-icon collapse-tree-button is-collapsed"><iconify-icon icon="ph:arrows-in-line-horizontal-bold" width="18px" height="18px" rotate="90deg" color="currentColor"></iconify-icon></button></div><div class="tree-scroll-area"><div class="tree-item mod-tree-folder mod-collapsible is-collapsed" data-depth="1"><div class="tree-item-contents"><div class="tree-item-icon collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div><a class="tree-item-link" href="для-отчета"><span class="tree-item-title">Для отчета</span></a></div><div class="tree-item-children"><div class="tree-item mod-tree-file" data-depth="2"><div class="tree-item-contents"><a class="tree-item-link" href="для-отчета/nodejs-зло.html"><span class="tree-item-title">nodejs - зло</span></a></div><div class="tree-item-children"></div></div><div class="tree-item mod-tree-file" data-depth="2"><div class="tree-item-contents"><a class="tree-item-link" href="для-отчета/py-код-оптимизации-mdx.html"><span class="tree-item-title">py код оптимизации mdx</span></a></div><div class="tree-item-children"></div></div><div class="tree-item mod-tree-file" data-depth="2"><div class="tree-item-contents"><a class="tree-item-link" href="для-отчета/py-конвертация-txt-в-xlsx.html"><span class="tree-item-title">py Конвертация txt в xlsx</span></a></div><div class="tree-item-children"></div></div></div></div><div class="tree-item mod-tree-folder mod-collapsible is-collapsed" data-depth="1"><div class="tree-item-contents"><div class="tree-item-icon collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div><a class="tree-item-link" href="курсы"><span class="tree-item-title">Курсы</span></a></div><div class="tree-item-children"><div class="tree-item mod-tree-folder mod-collapsible is-collapsed" data-depth="2"><div class="tree-item-contents"><div class="tree-item-icon collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div><a class="tree-item-link" href="курсы/о-haskell-по-человечески"><span class="tree-item-title">О Haskell по-человечески</span></a></div><div class="tree-item-children"><div class="tree-item mod-tree-file" data-depth="3"><div class="tree-item-contents"><a class="tree-item-link" href="курсы/о-haskell-по-человечески/о-haskell-по-человечески-(оригинал).html"><span class="tree-item-title">О Haskell по-человечески (Оригинал)</span></a></div><div class="tree-item-children"></div></div></div></div><div class="tree-item mod-tree-folder mod-collapsible is-collapsed" data-depth="2"><div class="tree-item-contents"><div class="tree-item-icon collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div><a class="tree-item-link" href="курсы/learn-you-a-haskell-for-great-good!"><span class="tree-item-title">Learn You a Haskell for Great Good!</span></a></div><div class="tree-item-children"><div class="tree-item mod-tree-file" data-depth="3"><div class="tree-item-contents"><a class="tree-item-link" href="курсы/learn-you-a-haskell-for-great-good!/learn-you-a-haskell-for-great-good!-en.html"><span class="tree-item-title">Learn You a Haskell for Great Good! en</span></a></div><div class="tree-item-children"></div></div><div class="tree-item mod-tree-file" data-depth="3"><div class="tree-item-contents"><a class="tree-item-link" href="курсы/learn-you-a-haskell-for-great-good!/learn-you-a-haskell-for-great-good!-ru.html"><span class="tree-item-title">Learn You a Haskell for Great Good! ru</span></a></div><div class="tree-item-children"></div></div><div class="tree-item mod-tree-file" data-depth="3"><div class="tree-item-contents"><a class="tree-item-link" href="курсы/learn-you-a-haskell-for-great-good!/readme.html"><span class="tree-item-title">README</span></a></div><div class="tree-item-children"></div></div></div></div></div></div><div class="tree-item mod-tree-folder mod-collapsible is-collapsed" data-depth="1"><div class="tree-item-contents"><div class="tree-item-icon collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div><a class="tree-item-link" href="мои-решения"><span class="tree-item-title">Мои решения</span></a></div><div class="tree-item-children"><div class="tree-item mod-tree-folder mod-collapsible is-collapsed" data-depth="2"><div class="tree-item-contents"><div class="tree-item-icon collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div><a class="tree-item-link" href="мои-решения/о-haskell-по-человечески"><span class="tree-item-title">О Haskell по-человечески</span></a></div><div class="tree-item-children"><div class="tree-item mod-tree-file" data-depth="3"><div class="tree-item-contents"><a class="tree-item-link" href="мои-решения/о-haskell-по-человечески/о-haskell-по-человечески-(итого).html"><span class="tree-item-title">О Haskell по-человечески (Итого)</span></a></div><div class="tree-item-children"></div></div></div></div></div></div><div class="tree-item mod-tree-file" data-depth="1"><div class="tree-item-contents"><a class="tree-item-link" href="отчеты.html"><span class="tree-item-title">Отчеты</span></a></div><div class="tree-item-children"></div></div><div class="tree-item mod-tree-file" data-depth="1"><div class="tree-item-contents"><a class="tree-item-link" href="полезные-ресурсы.html"><span class="tree-item-title">Полезные ресурсы</span></a></div><div class="tree-item-children"></div></div><div class="tree-item mod-tree-file" data-depth="1"><div class="tree-item-contents"><a class="tree-item-link" href="readme.html"><span class="tree-item-title">README</span></a></div><div class="tree-item-children"></div></div></div></div></div></div><div class="document-container"><div class="markdown-preview-view markdown-rendered node-insert-event allow-fold-headings show-indentation-guide allow-fold-lists show-frontmatter" style="tab-size: 4;"><style id="MJX-CHTML-styles"></style><div class="markdown-preview-sizer markdown-preview-section" style="padding-bottom: ; padding-top: var(--file-margins); padding-right: var(--file-margins); padding-left: var(--file-margins); width: 100%; position: absolute;"><div class="markdown-preview-pusher" style="width: 1px; height: 0.1px; margin-bottom: 0px;"></div><div class="mod-header"><div class="inline-title" contenteditable="true" spellcheck="true" autocapitalize="on" tabindex="-1" enterkeyhint="done">О Haskell по-человечески (Итого)</div></div><div><h1 data-heading="Приветствие" id="Приветствие">Приветствие</h1></div><div><p>Приветствие с читателем. В нём указывается цель книги, причины её на писания.</p></div><div><h1 data-heading="Первые вопросы" id="Первые_вопросы">Первые вопросы</h1></div><div><p>Введение, в котором рассказывается некоторые особенности книги, языка программирования, порога входа в язык и небольшое сравнение с другими языками программирования</p></div><div><h1 data-heading="Об этой книге" id="Об_этой_книге">Об этой книге</h1></div><div><p>Рассказывается о чем будет книга, чего не будет в книге, что будет в книге, как читать книгу, пояснение как читать код, благодарность членам сообщества Haskell, которые помогли советами, замечаниями и исправлениями, а так же что изменило с первым изданием.</p></div><div><h1 data-heading="Приготовимся" id="Приготовимся">Приготовимся</h1></div><div><ol>
<li data-line="0">Установка stack (Установил ранее)</li>
<li data-line="1">Установка инфраструктуры <code>stack setup</code></li>
<li data-line="2">Создание проекта: <code>stack new real</code></li>
<li data-line="3">Структура проекта</li>
<li data-line="4">Сборка проекта: <code>stack build</code></li>
<li data-line="5">Запуск исполнительного файла <code>stack exec real-exe</code></li>
<li data-line="6">Копирования исполнительного файла в <code>~/.local/bin</code>: <code>stack install</code></li>
<li data-line="7">Содержимое начальных файлов</li>
</ol></div><div><h1 data-heading="Киты и Черепаха" id="Киты_и_Черепаха">Киты и Черепаха</h1></div><div><h2 data-heading="Черепаха" id="Черепаха" style="display: flex;"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>Черепаха</h2></div><div><p>Haskell стоит на Трёх Китах:&nbsp;<strong>Функция</strong>,&nbsp;<strong>Тип</strong>&nbsp;и&nbsp;<strong>Класс типов</strong>. Они же, в свою очередь, покоятся на огромной Черепахе, имя которой —&nbsp;<strong>Выражение</strong>.</p></div><div><p>Haskell-программа представляет собой совокупность выражений (англ. expression). </p></div><div><blockquote>
<p>Выражение — это то, что может дать нам некий полезный результат.</p>
</blockquote></div><div><p>Полезный результат мы получаем в результате вычисления (англ. evaluation) выражения.
Все выражения являются вычисляемыми.
Одни выражения в результате вычисления уменьшаются (англ. reduce), а другие — нет. Первые называются редуцируемыми выражениями, а вторые — нередуцируемые.</p></div><div><h2 data-heading="Первый Кит" id="Первый_Кит" style="display: flex;"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>Первый Кит</h2></div><div><blockquote>
<p>Функция — это закон, описывающий зависимость одного значения от другого.</p>
</blockquote></div><div><p>Входное значение функции называют аргументом. А так как функция определяет однозначную зависимость выходного значения от аргумента, её, функцию, называют ещё отображением: она отображает/проецирует входное значение на выходное.</p></div><div><blockquote>
<p>Вычислить выражение — это значит применить какие-то функции (одну или более) к каким-то аргументам (одному или более).</p>
</blockquote></div><div><p>В Haskell функции не вызывают. В Haskell функция — это функция в математическом смысле слова, поэтому её не вызывают, а применяют к чему-то.</p></div><div><h2 data-heading="Второй Кит" id="Второй_Кит" style="display: flex;"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>Второй Кит</h2></div><div><p>Аргумент представляет собой некоторое значение, его ещё называют «данное» (англ. data). Данные в Haskell — это сущности, обладающие двумя главными характеристиками: типом и конкретным значением/содержимым.</p></div><div><p>Тип — это Второй Кит в Haskell. Тип отражает конкретное содержимое данных, а потому все данные в программе обязательно имеют некий тип. Когда мы видим данное типа&nbsp;<code>Double</code>, мы точно знаем, что перед нами число с плавающей точкой, а когда видим данные типа&nbsp;<code>String</code>&nbsp;— можем ручаться, что перед нами строки.</p></div><div><p>Отношение к типам в Haskell очень серьёзное, и работа с типами характеризуется тремя важными чертами:</p></div><div><ol>
<li data-line="0"><div class="list-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>статическая проверка,
<ol>
<li data-line="1">Статическая проверка типов (англ. static type checking) — это проверка типов всех данных в программе, осуществляемая на этапе компиляции. Haskell-компилятор упрям: когда ему что-либо не нравится в типах, он громко ругается.</li>
</ol>
</li>
<li data-line="2"><div class="list-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>сила,
<ol>
<li data-line="3">Сильная (англ. strong) система типов — это бескомпромиссный контроль соответствия ожидаемого действительному. Сила делает работу с типами ещё более аккуратной.</li>
<li data-line="4">Гарантирует отсутствие скрытого приведения типов (англ. implicit type casting)</li>
<li data-line="5">Компилятор скрупулёзно отслеживает соответствие ожидаемого типа фактическому, поэтому когда компиляция завершается успешно, мы абсолютно уверены в гармонии между типами всех наших данных.</li>
</ol>
</li>
<li data-line="6"><div class="list-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>выведение.
<ol>
<li data-line="7">Выведение (англ. inference) типов — это способность определить тип данных автоматически, по конкретному выражению.</li>
<li data-line="8">однако в Haskell мы напишем просто: <code>value = 122.04</code>, и компилятор автоматически выведет тип <code>value</code> как <code>Double</code>.</li>
</ol>
</li>
</ol></div><div><p>Простейшие типы данных:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token number">123</span>         <span class="token constant">Int</span><span class="token punctuation">,</span>    Целое число
<span class="token number">23.5798</span>     <span class="token constant">Double</span><span class="token punctuation">,</span> Дробное число
<span class="token char string">'a'</span>         <span class="token constant">Char</span><span class="token punctuation">,</span>   Буква
<span class="token string">"Hello!"</span>    <span class="token constant">String</span><span class="token punctuation">,</span> Строка
<span class="token constant">True</span>        <span class="token constant">Bool</span><span class="token punctuation">,</span>   Истина
<span class="token constant">False</span>       <span class="token constant">Bool</span><span class="token punctuation">,</span>   Ложь
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Имя типа в Haskell всегда начинается с большой буквы.</p></div><div><h2 data-heading="Третий Кит" id="Третий_Кит" style="display: flex;"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>Третий Кит</h2></div><div><p>А вот о Третьем Ките, о&nbsp;<strong>Классе типов</strong>, нам не рассказали, но обещали рассказать позже.</p></div><div><h1 data-heading="Неизменность и чистота" id="Неизменность_и_чистота">Неизменность и чистота</h1></div><div><p>Haskell «чисто функциональный» язык и почему в нём нет места оператору присваивания.</p></div><div><p>Объявление (англ. declaration) функции. (Говорит о том, что функция существует и о том, с какими типами она работает)</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">square</span> <span class="token operator">::</span> <span class="token constant">Int</span> <span class="token operator">-&gt;</span> <span class="token constant">Int</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Определение (англ. definition) функции. (Говорит о том, что конкретно она делает)</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">square</span> <span class="token hvariable">v</span> <span class="token operator">=</span> <span class="token hvariable">v</span> <span class="token operator">*</span> <span class="token hvariable">v</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Здесь идёт именно о знаке равенства, а никак не об операторе присваивания. Мы ничего не присваиваем, мы лишь декларируем равенство левой и правой частей.</p></div><div><p>Haskell — чисто функциональный (англ. purely functional) язык. Центральное место в нём уделено чистой функции (англ. pure function).</p></div><div><p>Чистая функция характеризуется отсутствием побочных эффектов (англ. side effects): она не способна сделать ничего, кроме как вернуть произведение двух своих аргументов.</p></div><div><p>Присваивание (англ. assignment) пришло к нам из императивных языков.
Императивное программирование (англ. imperative programming) — это направление в разработке, объединяющее несколько парадигм программирования, одной из которых является знаменитая объектно-ориентированная парадигма. В рамках этого направления программа воспринимается как набор инструкций, выполнение которых неразрывно связано с изменением состояния (англ. state) этой программы. Вот почему в императивных языках обязательно присутствует понятие «переменная» (англ. variable).</p></div><div><p>Однако существует принципиально иной подход к разработке, а именно декларативное программирование (англ. declarative programming). Данное направление также включает в себя несколько парадигм, одной из которых является функциональная парадигма, нашедшая своё воплощение в Haskell. При этом подходе программа воспринимается уже не как набор инструкций, а как набор выражений. А поскольку выражения вычисляются путём применения функций к аргументам (то есть, по сути, к другим выражениям), там нет места ни переменным, ни оператору присваивания. Все данные в Haskell-программе, будучи созданными единожды, уже не могут быть изменены. Поэтому нам не нужен не только оператор присваивания, но и ключевое слово&nbsp;<code>const</code>.</p></div><div><h1 data-heading="Выбираем и возвращаемся" id="Выбираем_и_возвращаемся">Выбираем и возвращаемся</h1></div><div><ul class="has-list-bullet">
<li data-line="0"><div class="list-bullet"></div>Комментарии в Haskell</li>
<li data-line="1"><div class="list-bullet"></div>оператор условной конструкции:</li>
</ul></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token keyword">if</span> <span class="token constant">CONDITION</span> <span class="token keyword">then</span> <span class="token constant">EXPR1</span> <span class="token keyword">else</span> <span class="token constant">EXPR2</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><ul class="has-list-bullet">
<li data-line="0"><div class="list-bullet"></div><code>CONDITION</code>&nbsp;— логическое выражение, дающее ложь или истину</li>
<li data-line="1"><div class="list-bullet"></div><code>EXPR1</code>&nbsp;— выражение, используемое в случае&nbsp;<code>True</code>,</li>
<li data-line="2"><div class="list-bullet"></div><code>EXPR2</code>&nbsp;— выражение, используемое в случае&nbsp;<code>False</code></li>
</ul></div><div><h1 data-heading="Выбор и образцы" id="Выбор_и_образцы">Выбор и образцы</h1></div><div><h2 data-heading="Не только из двух" id="Не_только_из_двух" style="display: flex;"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>Не только из двух</h2></div><div><ul class="has-list-bullet">
<li data-line="0"><div class="list-bullet"></div>Как сократить вложенное ветвление</li>
<li data-line="1"><div class="list-bullet"></div>В начале модуля должна присутствовать <code>магия</code></li>
</ul></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token comment">{-# LANGUAGE MultiWayIf #-}</span>  <span class="token comment">-- магия</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><ul class="has-list-bullet">
<li data-line="0"><div class="list-bullet"></div>Схема работы:</li>
</ul></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token keyword">if</span> <span class="token operator">|</span> <span class="token constant">COND1</span> <span class="token operator">-&gt;</span> <span class="token constant">EXPR1</span>
   <span class="token operator">|</span> <span class="token constant">COND2</span> <span class="token operator">-&gt;</span> <span class="token constant">EXPR2</span>
   <span class="token operator">|</span> <span class="token operator">...</span>
   <span class="token operator">|</span> <span class="token constant">CONDn</span> <span class="token operator">-&gt;</span> <span class="token constant">EXPRn</span>
   <span class="token operator">|</span> <span class="token builtin">otherwise</span> <span class="token operator">-&gt;</span> <span class="token constant">COMMON_EXPR</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><ol>
<li data-line="0"><code>COND1..n</code>&nbsp;— выражения, дающие ложь или истину</li>
<li data-line="1"><code>EXPR1..n</code>&nbsp;— соответствующие им результирующие выражения</li>
<li data-line="2">Особая функция&nbsp;<code>otherwise</code>&nbsp;соответствует общему случаю, когда ни одно из логических выражений не дало&nbsp;<code>True</code>, и в этой ситуации результатом условной конструкции послужит выражение&nbsp;<code>COMMON_EXPR</code></li>
<li data-line="3">Если не указать <code>otherwise</code>, то компиляция завершится успешно, однако в момент запуска программы вас ожидает неприятный сюрприз в виде ошибки.</li>
<li data-line="4">Так что используем <code>otherwise</code> и всё в порядке:</li>
</ol></div><div><p>Но что это за <code>магия</code> в начале модуля?</p></div><div><p>Стандарт&nbsp;<a data-tooltip-position="top" aria-label="https://www.haskell.org/onlinereport/haskell2010/" rel="noopener" class="external-link" href="https://www.haskell.org/onlinereport/haskell2010/" target="_blank">Haskell 2010</a>&nbsp;— это официальный стержень языка. Однако компилятор GHC, давно уж ставший компилятором по умолчанию при разработке на Haskell, обладает рядом особых возможностей. По умолчанию многие из этих возможностей выключены, а прагма&nbsp;<code>LANGUAGE</code>&nbsp;как раз для того и предназначена, чтобы их включать/активизировать. В данном случае мы включили расширение&nbsp;<code>MultiWayIf</code>. Именно это расширение позволяет нам использовать множественный&nbsp;<code>if</code>. Такого рода расширений существует очень много, и мы будем часто их использовать.</p></div><div><p>Расширение, в включенное в модуле, действует лишь в рамках текущего модуля</p></div><div><p>Добавлю от себя: С одной стороны, люди хотели снова собраться и создать новый стандарт, но возникло противоречие.</p></div><div><ol>
<li data-line="0">У языка Haskell основной компилятор один - <code>ghc</code></li>
<li data-line="1">Так как конкуренты отсутствуют, то и стандарт расширять будет просто переписыванием решений принятых <code>ghc</code>? Поэтому некоторые не видят необходимости в создании нового стандарта, так как <code>ghc</code> стандарт де факто.</li>
<li data-line="2">Все новшества обрабатываются и включаются в языковые расширения, так что необходимости в новом стандарте нету.</li>
</ol></div><div><h2 data-heading="Без Если" id="Без_Если" style="display: flex;"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>Без Если</h2></div><div><ol>
<li data-line="0">Так же можно ещё сократить и избавиться от оператора <code>if</code></li>
</ol></div><div><blockquote>
<p>Так называемые <strong>Охранные выражения</strong></p>
</blockquote></div><div><p>Схема:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">function</span> <span class="token hvariable">arg</span>  <span class="token comment">-- Нет знака равенства?</span>
  <span class="token operator">|</span> <span class="token constant">COND1</span> <span class="token operator">=</span> <span class="token constant">EXPR1</span>
  <span class="token operator">|</span> <span class="token constant">COND2</span> <span class="token operator">=</span> <span class="token constant">EXPR2</span>
  <span class="token operator">|</span> <span class="token operator">...</span>
  <span class="token operator">|</span> <span class="token constant">CONDn</span> <span class="token operator">=</span> <span class="token constant">EXPRn</span>
  <span class="token operator">|</span> <span class="token builtin">otherwise</span> <span class="token operator">=</span> <span class="token constant">COMMON_EXPR</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><h2 data-heading="Сравнение с образцом" id="Сравнение_с_образцом" style="display: flex;"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>Сравнение с образцом</h2></div><div><p>Так же мы можем избавиться от наших «ИЛИ»:</p></div><div><p>Схема:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">function</span> <span class="token constant">ARG1</span> <span class="token operator">=</span> <span class="token constant">EXPR1</span>
<span class="token hvariable">function</span> <span class="token constant">ARG2</span> <span class="token operator">=</span> <span class="token constant">EXPR2</span>
<span class="token hvariable">function</span> <span class="token operator">...</span>
<span class="token hvariable">function</span> <span class="token constant">ARGn</span> <span class="token operator">=</span> <span class="token constant">EXPRn</span>
<span class="token hvariable">function</span> <span class="token hvariable">_</span> <span class="token operator">=</span> <span class="token constant">COMMON_EXPR</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Сравнение с образцом, называемое ещё «сопоставлением с образцом» используется в Haskell чрезвычайно широко. В русскоязычной литературе перевод словосочетания «pattern matching» не особо закрепился, вместо этого так и говорят «паттерн матчинг».</p></div><div><p>Символ <code>_</code> — это универсальный образец, сравнение с которым всегда истинно (ещё говорят, что с ним матчится (англ. match) всё что угодно).
Если просто, то символ, который можно прочесть как «всё равно».
Мы как бы говорим: «В данном случае нас не интересует конкретное содержимое аргумента, нам всё равно, мы просто возвращаем строку&nbsp;<code>I don't know such a standard...</code>».</p></div><div><p>Сравнение аргумента с образцами происходит последовательно, сверху вниз.</p></div><div><p>Если мы напишем:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">function</span> <span class="token hvariable">_</span> <span class="token operator">=</span> <span class="token constant">COMMON_EXPR</span>
<span class="token hvariable">function</span> <span class="token constant">ARG1</span> <span class="token operator">=</span> <span class="token constant">EXPR1</span>
<span class="token hvariable">function</span> <span class="token constant">ARG2</span> <span class="token operator">=</span> <span class="token constant">EXPR2</span>
<span class="token hvariable">function</span> <span class="token operator">...</span>
<span class="token hvariable">function</span> <span class="token constant">ARGn</span> <span class="token operator">=</span> <span class="token constant">EXPRn</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Функция <code>function</code> всегда будет возвращать <code>COMMON_EXPR</code></p></div><div><p>Существует ещё один вид паттерн матчинга, с помощью конструкции&nbsp;<code>case-of</code>.</p></div><div><p>Схема:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token keyword">case</span> <span class="token constant">EXPRESSION</span> <span class="token keyword">of</span>
  <span class="token constant">PATTERN1</span> <span class="token operator">-&gt;</span> <span class="token constant">EXPR1</span>
  <span class="token constant">PATTERN2</span> <span class="token operator">-&gt;</span> <span class="token constant">EXPR2</span>
  <span class="token operator">...</span>
  <span class="token constant">PATTERNn</span> <span class="token operator">-&gt;</span> <span class="token constant">EXPRn</span>
  <span class="token hvariable">_</span>        <span class="token operator">-&gt;</span> <span class="token constant">COMMON_EXPR</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><ul class="has-list-bullet">
<li data-line="0"><div class="list-bullet"></div><code>EXPRESSION</code>&nbsp;— анализируемое выражение, последовательно сравниваемое с образцами <code>PATTERN1..n</code></li>
<li data-line="1"><div class="list-bullet"></div>Если ни одно не сработало — как обычно, упираемся в универсальный образец&nbsp;<code>_</code>&nbsp;и выдаём&nbsp;<code>COMMON_EXPR</code>.</li>
</ul></div><div><p>Обещали показать другие виды паттерн матчинага.</p></div><div><h1 data-heading="Пусть будет там, Где…" id="Пусть_будет_там,_Где…">Пусть будет там, Где…</h1></div><div><h2 data-heading="Пусть" id="Пусть" style="display: flex;"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>Пусть</h2></div><div><p>Схема конструкции <code>let-in</code>:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token keyword">let</span> <span class="token constant">DECLARATIONS</span> <span class="token keyword">in</span> <span class="token constant">EXPRESSION</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><ul class="has-list-bullet">
<li data-line="0"><div class="list-bullet"></div><code>DECLARATIONS</code>&nbsp;— выражения, декларируемые нами</li>
<li data-line="1"><div class="list-bullet"></div><code>EXPRESSION</code>&nbsp;— выражение, в котором используется выражения из&nbsp;<code>DECLARATION</code></li>
<li data-line="2"><div class="list-bullet"></div>Все введённые конструкцией&nbsp;<code>let-in</code>&nbsp;выражения существуют лишь в рамках выражения, следующего за словом&nbsp;<code>in</code></li>
</ul></div><div><h2 data-heading="Где" id="Где" style="display: flex;"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>Где</h2></div><div><p>Схема с <code>where</code>:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token constant">EXPRESSION</span> <span class="token keyword">where</span> <span class="token constant">DECLARATIONS</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Ключевое слово&nbsp;<code>where</code>&nbsp;делает примерно то же, что и&nbsp;<code>let</code>, но промежуточные выражения задаются в конце функции. Такая конструкция читается подобно научной формуле:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token constant">S</span> <span class="token operator">=</span> <span class="token constant">V</span> <span class="token operator">*</span> <span class="token hvariable">t</span><span class="token punctuation">,</span>      <span class="token comment">-- Выражение</span>
 где
  <span class="token comment">-- Всё то, что</span>
  <span class="token comment">-- используется</span>
  <span class="token comment">-- в выражении.</span>
  <span class="token constant">S</span> <span class="token operator">=</span> расстояние<span class="token punctuation">,</span>
  <span class="token constant">V</span> <span class="token operator">=</span> скорость<span class="token punctuation">,</span>
  <span class="token hvariable">t</span> <span class="token operator">=</span> время<span class="token punctuation">.</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><h2 data-heading="Вместе" id="Вместе" style="display: flex;"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>Вместе</h2></div><div><p>Мы можем использовать&nbsp;<code>let-in</code>&nbsp;и&nbsp;<code>where</code>&nbsp;совместно, в рамках одной функции:</p></div><div><p>Общая рекомендация: не смешивайте let-in и where без особой надобности, такой код читается тяжело, избыточно.</p></div><div><p>В качестве промежуточных могут выступать и более сложные выражения. </p></div><div><p>Внутри конструкции <code>let-in</code> можно использовать выражения из <code>where</code>, но обратное делать нельзя.</p></div><div><h1 data-heading="Мир операторов" id="Мир_операторов">Мир операторов</h1></div><div><blockquote>
<p>Оператор (англ. operator) — частный случай функции</p>
</blockquote></div><div><p>Функция&nbsp;<code>+</code>&nbsp;записана в инфиксной (англ. infix) форме, то есть между своими аргументами. Такая запись выглядит естественнее, нежели обычная:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token punctuation">(</span><span class="token operator">+</span><span class="token punctuation">)</span> <span class="token number">1</span> <span class="token number">2</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Для использования функции в инфиксной форме по умолчанию имя функции в определении заключено в круглые скобки:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token punctuation">(</span><span class="token operator">+</span><span class="token punctuation">)</span> <span class="token operator">::</span> <span class="token operator">...</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><blockquote>
<p>Функции, предназначенные для инфиксной формы применения, называют операторами.</p>
</blockquote></div><div><p>Если же имя функции не заключено в круглые скобки, то используется обычная форма применения. Однако функцию можно применять инфиксно.
Для этого имя функции должно заключаться в обратные одинарные кавычки (англ. backtick).</p></div><div><p>Определим функцию&nbsp;<code>function</code>, являющуюся аналогом оператора проверки на равенство для двух целочисленных значений:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">function</span> <span class="token operator">::</span> <span class="token constant">Int</span> <span class="token operator">-&gt;</span> <span class="token constant">Int</span> <span class="token operator">-&gt;</span> <span class="token constant">Bool</span>
<span class="token hvariable">function</span> <span class="token hvariable">x</span> <span class="token hvariable">y</span> <span class="token operator">=</span> <span class="token hvariable">x</span> <span class="token operator">==</span> <span class="token hvariable">y</span>

<span class="token comment">-- Обычная запись</span>
<span class="token keyword">if</span> <span class="token hvariable">isEqualTo</span> <span class="token hvariable">code1</span> <span class="token hvariable">code2</span> <span class="token keyword">then</span> <span class="token operator">...</span> <span class="token keyword">else</span> <span class="token operator">...</span>
<span class="token keyword">where</span> <span class="token hvariable">code1</span> <span class="token operator">=</span> <span class="token number">123</span>
	  <span class="token hvariable">code2</span> <span class="token operator">=</span> <span class="token number">124</span>

<span class="token comment">-- Инфиксная форма</span>
<span class="token keyword">if</span> <span class="token hvariable">code1</span> <span class="token operator">`isEqualTo`</span> <span class="token hvariable">code2</span> <span class="token keyword">then</span> <span class="token operator">...</span> <span class="token keyword">else</span> <span class="token operator">...</span>
<span class="token keyword">where</span> <span class="token hvariable">code1</span> <span class="token operator">=</span> <span class="token number">123</span>
	  <span class="token hvariable">code2</span> <span class="token operator">=</span> <span class="token number">124</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><h2 data-heading="Зачем это нужно?" id="Зачем_это_нужно?" style="display: flex;"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>Зачем это нужно?</h2></div><div><p>Почти все ASCII-символы (а также их всевозможные комбинации) можно использовать в качестве операторов в Haskell. Это даёт нам широкие возможности для реализации различных EDSL (англ. Embedded Domain Specific Language), своего рода «языков в языке». Вот пример:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token builtin">div</span> <span class="token operator">!</span> <span class="token hvariable">class_</span> <span class="token string">"nav-wrapper"</span> <span class="token operator">$</span>
  <span class="token hvariable">a</span> <span class="token operator">!</span> <span class="token hvariable">class_</span> <span class="token string">"brand-logo sans"</span> <span class="token operator">!</span> <span class="token hvariable">href</span> <span class="token string">"/"</span> <span class="token operator">$</span>
    <span class="token string">"#ohaskell"</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Это&nbsp;<a data-tooltip-position="top" aria-label="https://github.com/denisshevchenko/ohaskell.guide/blob/master/src/CreateHtmlTemplates.hs#L56" rel="noopener" class="external-link" href="https://github.com/denisshevchenko/ohaskell.guide/blob/master/src/CreateHtmlTemplates.hs#L56" target="_blank">кусочек кода</a>, строящего HTML-шаблон для веб-варианта данной книги. То что вы видите — это совершенно легальный Haskell-код, в процессе работы которого генерируется реальный HTML: тег&nbsp;<code>&lt;div&gt;</code>&nbsp;с классом&nbsp;<code>nav-wrapper</code>, внутри которого лежит&nbsp;<code>&lt;a&gt;</code>-ссылка с двумя классами, корневым адресом и внутренним текстом&nbsp;<code>#ohaskell</code>.</p></div><div><p>Идентификаторы&nbsp;<code>div</code>,&nbsp;<code>class_</code>&nbsp;и&nbsp;<code>href</code>&nbsp;— это имена функций, а символы&nbsp;<code>!</code>&nbsp;и&nbsp;<code>$</code>&nbsp;— это операторы, записанные в инфиксной форме. Самое главное, что для понимания этого кода нам абсолютно необязательно знать, где определены все эти функции/операторы и как они работают.</p></div><div><blockquote>
<p>Чтобы использовать функции, нам вовсе необязательно знать их внутренности.</p>
</blockquote></div><div><p>Нам обещали ещё встретится с EDSL.</p></div><div><h1 data-heading="Список" id="Список">Список</h1></div><div><p>Список (англ. list) — это стандартный тип, характеризующий уже не просто данные, но структуру данных (англ. data structure). Эта структура представляет собой набор данных одного типа, и едва ли хоть одна реальная Haskell-программа может обойтись без списков.</p></div><div><blockquote>
<p>Структуры, содержащие данные одного типа, называют ещё гомогенными (в переводе с греческого: «одного рода»).</p>
</blockquote></div><div><p>Список состоит из квадратных скобок и значений, разделённых запятыми. </p></div><div><p>Список может содержать много элементов, один или быть пустым.</p></div><div><p>В Haskell существуют массивы (англ. array), но это несколько иная структура данных, так что не следует её путать со списками.</p></div><div><h2 data-heading="Тип списка" id="Тип_списка" style="display: flex;"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>Тип списка</h2></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token punctuation">[</span><span class="token constant">Int</span><span class="token punctuation">]</span>       <span class="token comment">-- Список целых чисел</span>
<span class="token punctuation">[</span><span class="token constant">Char</span><span class="token punctuation">]</span>      <span class="token comment">-- Список символов</span>
<span class="token punctuation">[</span><span class="token constant">String</span><span class="token punctuation">]</span>    <span class="token comment">-- Список строк</span>
<span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token constant">String</span><span class="token punctuation">]</span><span class="token punctuation">]</span>  <span class="token comment">-- Список списков строк</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Схема:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token punctuation">[</span>   <span class="token punctuation">[</span><span class="token constant">String</span><span class="token punctuation">]</span>    <span class="token punctuation">]</span>

   │  Тип   │
   └ данных ┘

│     Тип       │
│    списка     │
└─ этих данных ─┘
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Хранить данные разных типов в стандартном списке невозможно.</p></div><div><h2 data-heading="Действия над списками" id="Действия_над_списками" style="display: flex;"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>Действия над списками</h2></div><div><p>&nbsp;В стандартной Haskell-библиотеке существует отдельный модуль&nbsp;<code>Data.List</code>, включающий широкий набор функций, работающих со списком.</p></div><div><p>Функции:</p></div><div><ul class="has-list-bullet">
<li data-line="0"><div class="list-bullet"></div><code>head</code> -&nbsp;возвращает голову списка.</li>
<li data-line="1"><div class="list-bullet"></div><code>tail</code> - возвращает хвост.</li>
<li data-line="2"><div class="list-bullet"></div><code>length</code> - возвращает длину списка.</li>
</ul></div><div><p>Модель такая:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token punctuation">[</span><span class="token string">"Vim"</span>  <span class="token punctuation">,</span>  <span class="token string">"Emacs"</span><span class="token punctuation">,</span> <span class="token string">"Atom"</span><span class="token punctuation">]</span>

 голова    └─── хвост ───┘
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Тип&nbsp;<code>String</code>&nbsp;эквивалентен типу&nbsp;<code>[Char]</code>. <code>String</code>&nbsp;— не самостоятельный тип, это псевдоним для типа&nbsp;<code>[Char]</code>, и он задан:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token keyword">type</span> <span class="token constant">String</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token constant">Char</span><span class="token punctuation">]</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Ключевое слово&nbsp;<code>type</code>&nbsp;вводит синоним для уже существующего типа (англ. type synonym). Иногда его называют «псевдонимом типа».</p></div><div><h2 data-heading="Неизменность списка" id="Неизменность_списка" style="display: flex;"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>Неизменность списка</h2></div><div><p>Мы не можем изменить существующий список, мы можем лишь создать на его основе новый список</p></div><div><p>Стандартный оператор&nbsp;<code>:</code>&nbsp;добавляет значение, являющееся левым операндом, в начало списка, являющегося правым операндом. Читается это так:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">newHost</span>   <span class="token operator">:</span>         <span class="token hvariable">hosts</span>

          этот
          оператор

берёт
это
значение
                    и добавляет
                    его в начало
                    этого списка
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Тип значения слева обязан совпадать с типом значений, содержащихся в списке справа.</p></div><div><h2 data-heading="Перечисление" id="Перечисление" style="display: flex;"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>Перечисление</h2></div><div><p>Нам понадобился список целых чисел от одного до десяти :</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">,</span> <span class="token number">8</span><span class="token punctuation">,</span> <span class="token number">9</span><span class="token punctuation">,</span> <span class="token number">10</span><span class="token punctuation">]</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Сокращаем до:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token punctuation">[</span><span class="token number">1</span><span class="token operator">..</span><span class="token number">10</span><span class="token punctuation">]</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Мы можем задать шаг</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token operator">..</span><span class="token number">10</span><span class="token punctuation">]</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Схема:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">,</span>      <span class="token number">4</span>      <span class="token operator">..</span> <span class="token number">10</span><span class="token punctuation">]</span>

 первый            конец
         второй

 │  разница   │
 └─ даёт шаг ─┘
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Можно задать и нисходящий диапазон:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token punctuation">[</span><span class="token number">9</span><span class="token punctuation">,</span><span class="token number">8</span><span class="token operator">..</span><span class="token number">1</span><span class="token punctuation">]</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Можно даже отрицательные числа:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">9</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">8</span><span class="token operator">..</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Можно взять также и числа с плавающей точкой:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token punctuation">[</span><span class="token number">1.02</span><span class="token punctuation">,</span><span class="token number">1.04</span><span class="token operator">..</span><span class="token number">1.16</span><span class="token punctuation">]</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Символы:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token punctuation">[</span><span class="token char string">'a'</span><span class="token operator">..</span><span class="token char string">'z'</span><span class="token punctuation">]</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Символы с шагом:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token punctuation">[</span><span class="token char string">'a'</span><span class="token punctuation">,</span><span class="token char string">'c'</span><span class="token operator">..</span><span class="token char string">'z'</span><span class="token punctuation">]</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><h1 data-heading="Кортеж" id="Кортеж">Кортеж</h1></div><div><p>Кортеж (англ. tuple) — ещё одна стандартная структура данных, но, в отличие от списка, она может содержать данные как одного типа, так и разных.</p></div><div><p>Структуры, способные содержать данные разных типов, называют гетерогенными (в переводе с греческого: «разного рода»).</p></div><div><p>Вот как выглядит кортеж:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token punctuation">(</span><span class="token string">"Haskell"</span><span class="token punctuation">,</span> <span class="token number">2010</span><span class="token punctuation">)</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><h2 data-heading="Тип кортежа" id="Тип_кортежа" style="display: flex;"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>Тип кортежа</h2></div><div><p>Тип списка строк, как вы помните,&nbsp;<code>[String]</code>. И не важно, сколько строк мы запихнули в список, одну или миллион — его тип останется неизменным. С кортежем же дело обстоит абсолютно иначе.</p></div><div><p>Тип кортежа зависит от количества его элементов.</p></div><div><p>Тип кортежа явно отражает его содержимое. Поэтому если функция применяется к кортежу из двух строк, применить её к кортежу из трёх никак не получится, ведь типы этих кортежей различаются:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token comment">-- Разные типы</span>
<span class="token punctuation">(</span><span class="token constant">String</span><span class="token punctuation">,</span> <span class="token constant">String</span><span class="token punctuation">)</span>
<span class="token punctuation">(</span><span class="token constant">String</span><span class="token punctuation">,</span> <span class="token constant">String</span><span class="token punctuation">,</span> <span class="token constant">String</span><span class="token punctuation">)</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><h2 data-heading="Действия над кортежами" id="Действия_над_кортежами" style="display: flex;"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>Действия над кортежами</h2></div><div><p>Со списками можно делать много всего, а вот с кортежами — не очень. Самые частые действия — собственно формирование кортежа и извлечение хранящихся в нём данных. </p></div><div><p>Оператор&nbsp;<code>++</code>&nbsp;— это оператор конкатенации, склеивающий две строки в одну. (Т.е. создаёт новый список, из двух старых)</p></div><div><p>Пример:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded">
<span class="token comment">-- Создание кортежа</span>
<span class="token hvariable">makeAlias</span> <span class="token operator">::</span> <span class="token constant">String</span> <span class="token operator">-&gt;</span> <span class="token constant">String</span> <span class="token operator">-&gt;</span> <span class="token punctuation">(</span><span class="token constant">String</span><span class="token punctuation">,</span> <span class="token constant">String</span><span class="token punctuation">,</span> <span class="token constant">String</span><span class="token punctuation">)</span>
<span class="token hvariable">makeAlias</span> <span class="token hvariable">host</span> <span class="token hvariable">alias</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token hvariable">host</span><span class="token punctuation">,</span> <span class="token string">"https://"</span> <span class="token operator">++</span> <span class="token hvariable">host</span><span class="token punctuation">,</span> <span class="token hvariable">alias</span><span class="token punctuation">)</span>

<span class="token comment">-- Извлечение из кортежа</span>
<span class="token hvariable">getHttps</span> <span class="token operator">::</span> <span class="token punctuation">(</span><span class="token constant">String</span><span class="token punctuation">,</span> <span class="token constant">String</span><span class="token punctuation">,</span> <span class="token constant">String</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token constant">String</span>
<span class="token hvariable">getHttps</span> <span class="token punctuation">(</span><span class="token hvariable">host</span><span class="token punctuation">,</span> <span class="token hvariable">https</span><span class="token punctuation">,</span> <span class="token hvariable">alias</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token hvariable">host</span>

<span class="token hvariable">main</span> <span class="token operator">::</span> <span class="token constant">IO</span> <span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token hvariable">main</span> <span class="token operator">=</span> <span class="token builtin">print</span> <span class="token punctuation">(</span> <span class="token hvariable">getHttps</span> <span class="token punctuation">(</span><span class="token hvariable">makeAlias</span> <span class="token string">"173.194.71.106"</span> <span class="token string">"www.ohaskell.guide"</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Ещё один пример:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">chessMove</span> <span class="token operator">::</span> <span class="token constant">String</span>
          <span class="token operator">-&gt;</span> <span class="token punctuation">(</span><span class="token constant">String</span><span class="token punctuation">,</span> <span class="token constant">String</span><span class="token punctuation">)</span>
          <span class="token operator">-&gt;</span> <span class="token punctuation">(</span><span class="token constant">String</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token constant">String</span><span class="token punctuation">,</span> <span class="token constant">String</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token hvariable">chessMove</span> <span class="token hvariable">color</span> <span class="token punctuation">(</span><span class="token hvariable">from</span><span class="token punctuation">,</span> <span class="token hvariable">to</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token hvariable">color</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token hvariable">from</span><span class="token punctuation">,</span> <span class="token hvariable">to</span><span class="token punctuation">)</span><span class="token punctuation">)</span>

<span class="token hvariable">main</span> <span class="token operator">::</span> <span class="token constant">IO</span> <span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token hvariable">main</span> <span class="token operator">=</span> <span class="token builtin">print</span> <span class="token punctuation">(</span><span class="token hvariable">color</span> <span class="token operator">++</span> <span class="token string">": "</span> <span class="token operator">++</span> <span class="token hvariable">from</span> <span class="token operator">++</span> <span class="token string">"-"</span> <span class="token operator">++</span> <span class="token hvariable">to</span><span class="token punctuation">)</span>
  <span class="token keyword">where</span>
    <span class="token punctuation">(</span><span class="token hvariable">color</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token hvariable">from</span><span class="token punctuation">,</span> <span class="token hvariable">to</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token hvariable">chessMove</span> <span class="token string">"white"</span> <span class="token punctuation">(</span><span class="token string">"e2"</span><span class="token punctuation">,</span> <span class="token string">"e4"</span><span class="token punctuation">)</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Можно использовать универсальный образец:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token comment">-- Поясняющие псевдонимы</span>
<span class="token keyword">type</span> <span class="token constant">UUID</span>     <span class="token operator">=</span> <span class="token constant">String</span>
<span class="token keyword">type</span> <span class="token constant">FullName</span> <span class="token operator">=</span> <span class="token constant">String</span>
<span class="token keyword">type</span> <span class="token constant">Email</span>    <span class="token operator">=</span> <span class="token constant">String</span>
<span class="token keyword">type</span> <span class="token constant">Age</span>      <span class="token operator">=</span> <span class="token constant">Int</span>
<span class="token keyword">type</span> <span class="token constant">Patient</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token constant">UUID</span><span class="token punctuation">,</span> <span class="token constant">FullName</span><span class="token punctuation">,</span> <span class="token constant">Email</span><span class="token punctuation">,</span> <span class="token constant">Age</span><span class="token punctuation">)</span>

<span class="token hvariable">patientEmail</span> <span class="token operator">::</span> <span class="token constant">Patient</span> <span class="token operator">-&gt;</span> <span class="token constant">Email</span>
<span class="token hvariable">patientEmail</span> <span class="token punctuation">(</span><span class="token hvariable">_</span><span class="token punctuation">,</span> <span class="token hvariable">_</span><span class="token punctuation">,</span> <span class="token hvariable">email</span><span class="token punctuation">,</span> <span class="token hvariable">_</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token hvariable">email</span>

<span class="token hvariable">main</span> <span class="token operator">::</span> <span class="token constant">IO</span> <span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token hvariable">main</span> <span class="token operator">=</span>
  <span class="token builtin">putStrLn</span> <span class="token punctuation">(</span><span class="token hvariable">patientEmail</span> <span class="token punctuation">(</span> <span class="token string">"63ab89d"</span>
                         <span class="token punctuation">,</span> <span class="token string">"John Smith"</span>
                         <span class="token punctuation">,</span> <span class="token string">"johnsm@gmail.com"</span>
                         <span class="token punctuation">,</span> <span class="token number">59</span>
                         <span class="token punctuation">)</span><span class="token punctuation">)</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><h2 data-heading="Дополнение" id="Дополнение" style="display: flex;"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>Дополнение</h2></div><div><p>Для работы с элементами многоэлементных кортежей можно использовать готовые библиотеки, во избежание длинных паттерн матчинговых цепочек. Например, пакет&nbsp;<a data-tooltip-position="top" aria-label="http://hackage.haskell.org/package/tuple" rel="noopener" class="external-link" href="http://hackage.haskell.org/package/tuple" target="_blank">tuple</a>:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token constant">Data<span class="token punctuation">.</span>Tuple<span class="token punctuation">.</span>Select</span>

<span class="token hvariable">main</span> <span class="token operator">::</span> <span class="token constant">IO</span> <span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token hvariable">main</span> <span class="token operator">=</span> <span class="token builtin">print</span> <span class="token punctuation">(</span><span class="token hvariable">sel4</span> <span class="token punctuation">(</span><span class="token number">123</span><span class="token punctuation">,</span> <span class="token number">7</span><span class="token punctuation">,</span> <span class="token string">"hydra"</span><span class="token punctuation">,</span> <span class="token string">"DC:4"</span><span class="token punctuation">,</span> <span class="token number">44</span><span class="token punctuation">,</span> <span class="token string">"12.04"</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Функция&nbsp;<code>sel4</code>&nbsp;из модуля&nbsp;<code>Data.Tuple.Select</code>&nbsp;извлекает четвёртый по счёту элемент кортежа, в данном случае строку&nbsp;<code>"DC:4"</code>. Там есть функции вплоть до&nbsp;<code>sel32</code>, авторы вполне разумно сочли, что никто, находясь в здравом уме и твёрдой памяти, не станет оперировать кортежами, состоящими из более чем 32 элементов.</p></div><div><p>Кроме того, мы и обновлять элементы кортежа можем:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token import-statement"><span class="token keyword">import</span> Data<span class="token punctuation">.</span>Tuple<span class="token punctuation">.</span>Update</span>

<span class="token hvariable">main</span> <span class="token operator">::</span> <span class="token constant">IO</span> <span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token hvariable">main</span> <span class="token operator">=</span> <span class="token builtin">print</span> <span class="token punctuation">(</span><span class="token hvariable">upd2</span> <span class="token number">2</span> <span class="token punctuation">(</span><span class="token string">"si"</span><span class="token punctuation">,</span> <span class="token number">45</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Естественно, по причине неизменности кортежа, никакого обновления тут не происходит, но выглядит симпатично. При запуске получаем результат:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token punctuation">(</span><span class="token string">"si"</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">)</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Второй элемент кортежа изменился с&nbsp;<code>45</code>&nbsp;на&nbsp;<code>2</code>.</p></div><div><h1 data-heading="Лямбда-функция" id="Лямбда-функция">Лямбда-функция</h1></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token operator">\</span><span class="token hvariable">x</span> <span class="token operator">-&gt;</span> <span class="token hvariable">x</span> <span class="token operator">*</span> <span class="token hvariable">x</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Лямбда функции (они же анонимные функции)</p></div><div><p>Функцию можно записать как промежуточное значение </p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">main</span> <span class="token operator">::</span> <span class="token constant">IO</span> <span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token hvariable">main</span> <span class="token operator">=</span> <span class="token builtin">print</span> <span class="token punctuation">(</span><span class="token hvariable">mul</span> <span class="token number">10</span> <span class="token number">4</span><span class="token punctuation">)</span>
  <span class="token keyword">where</span> <span class="token hvariable">mul</span> <span class="token operator">=</span> <span class="token operator">\</span><span class="token hvariable">x</span> <span class="token hvariable">y</span> <span class="token operator">-&gt;</span> <span class="token hvariable">x</span> <span class="token operator">*</span> <span class="token hvariable">y</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><h2 data-heading="Локальные функции" id="Локальные_функции" style="display: flex;"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>Локальные функции</h2></div><div><p>Раз уж между ЛФ и простыми функциями фактически нет различий, а функции есть частный случай данных, мы можем создавать функции локально для других функций:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token comment">-- Здесь определены функции</span>
<span class="token comment">-- isInfixOf и isSuffixOf.</span>
<span class="token import-statement"><span class="token keyword">import</span> Data<span class="token punctuation">.</span>List</span>

<span class="token hvariable">validComEmail</span> <span class="token operator">::</span> <span class="token constant">String</span> <span class="token operator">-&gt;</span> <span class="token constant">Bool</span>
<span class="token hvariable">validComEmail</span> <span class="token hvariable">email</span> <span class="token operator">=</span>
    <span class="token hvariable">containsAtSign</span> <span class="token hvariable">email</span> <span class="token operator">&amp;&amp;</span> <span class="token hvariable">endsWithCom</span> <span class="token hvariable">email</span>
  <span class="token keyword">where</span>
    <span class="token hvariable">containsAtSign</span> <span class="token hvariable">e</span> <span class="token operator">=</span> <span class="token string">"@"</span> <span class="token operator">`isInfixOf`</span> <span class="token hvariable">e</span>
    <span class="token hvariable">endsWithCom</span> <span class="token hvariable">e</span> <span class="token operator">=</span> <span class="token string">".com"</span> <span class="token operator">`isSuffixOf`</span> <span class="token hvariable">e</span>

<span class="token hvariable">main</span> <span class="token operator">::</span> <span class="token constant">IO</span> <span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token hvariable">main</span> <span class="token operator">=</span> <span class="token builtin">putStrLn</span> <span class="token punctuation">(</span><span class="token keyword">if</span> <span class="token hvariable">validComEmail</span> <span class="token hvariable">myEmail</span>
                   <span class="token keyword">then</span> <span class="token string">"It's ok!"</span>
                   <span class="token keyword">else</span> <span class="token string">"Non-com email!"</span><span class="token punctuation">)</span>
  <span class="token keyword">where</span>
    <span class="token hvariable">myEmail</span> <span class="token operator">=</span> <span class="token string">"haskeller@gmail.com"</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>С лямбда-абстракциями:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token comment">-- Здесь определены функции</span>
<span class="token comment">-- isInfixOf и isSuffixOf.</span>
<span class="token import-statement"><span class="token keyword">import</span> Data<span class="token punctuation">.</span>List</span>

<span class="token hvariable">validComEmail</span> <span class="token operator">::</span> <span class="token constant">String</span> <span class="token operator">-&gt;</span> <span class="token constant">Bool</span>
<span class="token hvariable">validComEmail</span> <span class="token hvariable">email</span> <span class="token operator">=</span>
    <span class="token hvariable">containsAtSign</span> <span class="token hvariable">email</span> <span class="token operator">&amp;&amp;</span> <span class="token hvariable">endsWithCom</span> <span class="token hvariable">email</span>
  <span class="token keyword">where</span>
    <span class="token hvariable">containsAtSign</span> <span class="token operator">=</span> <span class="token operator">\</span><span class="token hvariable">e</span> <span class="token operator">-&gt;</span> <span class="token string">"@"</span> <span class="token operator">`isInfixOf`</span> <span class="token hvariable">e</span>
    <span class="token hvariable">endsWithCom</span> <span class="token operator">=</span> <span class="token operator">\</span><span class="token hvariable">e</span> <span class="token operator">-&gt;</span> <span class="token string">".com"</span> <span class="token operator">`isSuffixOf`</span> <span class="token hvariable">e</span>

<span class="token hvariable">main</span> <span class="token operator">::</span> <span class="token constant">IO</span> <span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token hvariable">main</span> <span class="token operator">=</span> <span class="token builtin">putStrLn</span> <span class="token punctuation">(</span><span class="token keyword">if</span> <span class="token hvariable">validComEmail</span> <span class="token hvariable">myEmail</span>
                   <span class="token keyword">then</span> <span class="token string">"It's ok!"</span>
                   <span class="token keyword">else</span> <span class="token string">"Non-com email!"</span><span class="token punctuation">)</span>
  <span class="token keyword">where</span>
    <span class="token hvariable">myEmail</span> <span class="token operator">=</span> <span class="token string">"haskeller@gmail.com"</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><h1 data-heading="Композиция функций" id="Композиция_функций">Композиция функций</h1></div><div><p>Если применение функции представляет собой выражение, не можем ли мы как-нибудь компоновать их друг с другом? Конечно можем, мы уже делали это много раз, вспомните:</p></div><div><p>Здесь компонуются две функции,&nbsp;<code>putStrLn</code>&nbsp;и&nbsp;<code>checkLocalhost</code>, потому что тип выражения на выходе функции&nbsp;<code>checkLocalhost</code>&nbsp;совпадает с типом выражения на входе функции&nbsp;<code>putStrLn</code>. Схематично это можно изобразить так:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded">         ┌──────────────┐            ┌────────┐
<span class="token constant">String</span> <span class="token operator">-&gt;</span>│<span class="token hvariable">checkLocalhost</span>│<span class="token operator">-&gt;</span> <span class="token constant">String</span> <span class="token operator">-&gt;</span>│<span class="token builtin">putStrLn</span>│<span class="token operator">-&gt;</span> <span class="token operator">...</span>
         └──────────────┘            └────────┘

<span class="token constant">IP</span><span class="token operator">-</span>адрес                    сообщение             текст
                            об этом               в нашем
                            <span class="token constant">IP</span><span class="token operator">-</span>адресе             терминале
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Получается эдакий конвейер: на входе строка с IP-адресом, на выходе — сообщение в нашем терминале. Существует иной способ соединения двух функций воедино.</p></div><div><h2 data-heading="Композиция и применение" id="Композиция_и_применение" style="display: flex;"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>Композиция и применение</h2></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">main</span> <span class="token operator">::</span> <span class="token constant">IO</span> <span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token hvariable">main</span> <span class="token operator">=</span> <span class="token builtin">putStrLn</span> <span class="token operator">.</span> <span class="token hvariable">checkLocalhost</span> <span class="token operator">$</span> <span class="token string">"173.194.22.100"</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Необычно? Перед нами два новых стандартных оператора, избавляющие нас от лишних скобок и делающие наш код проще. Оператор&nbsp;<code>.</code>&nbsp;— это оператор композиции функций (англ. function composition), а оператор&nbsp;<code>$</code>&nbsp;— это оператор применения (англ. application operator). Эти операторы часто используют совместно друг с другом. И отныне мы будем использовать их чуть ли не в каждой главе.</p></div><div><p>Схема:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token constant">UNCTION</span>  <span class="token operator">$</span>            <span class="token constant">ARGUMENT</span>
вот эта   применяется  вот этому
функция   к            аргументу
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Для нашей объединённой функции это выглядит так:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">main</span> <span class="token operator">::</span> <span class="token constant">IO</span> <span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token hvariable">main</span> <span class="token operator">=</span>
  <span class="token builtin">putStrLn</span> <span class="token operator">.</span> <span class="token hvariable">checkLocalhost</span>  <span class="token operator">$</span>            <span class="token string">"173.194.22.100"</span>

  объединённая функция       применяется
                             к            этому аргументу
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Ещё одно замечание про оператор применения функции. Он весьма гибок, и мы можем написать так:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">main</span> <span class="token operator">=</span> <span class="token builtin">putStrLn</span> <span class="token operator">.</span> <span class="token hvariable">checkLocalhost</span> <span class="token operator">$</span> <span class="token string">"173.194.22.100"</span>

       объединённая функция        └─ её аргумент ─┘
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>а можем и так:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">main</span> <span class="token operator">=</span> <span class="token builtin">putStrLn</span> <span class="token operator">$</span> <span class="token hvariable">checkLocalhost</span> <span class="token string">"173.194.22.100"</span>

       обычная    └──────── её аргумент ────────┘
       функция
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Эти две формы, как вы уже поняли, эквивалентны. Я показываю это для того, чтобы вновь и вновь продемонстрировать вам, сколь гибко можно работать с данными и функциями в Haskell.</p></div><div><h2 data-heading="Длинные цепочки" id="Длинные_цепочки" style="display: flex;"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>Длинные цепочки</h2></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">func0</span> <span class="token operator">=</span> <span class="token operator">\</span><span class="token hvariable">x</span> <span class="token operator">-&gt;</span> <span class="token hvariable">x</span> <span class="token operator">++</span> <span class="token string">"0"</span>
<span class="token hvariable">func1</span> <span class="token operator">=</span> <span class="token operator">\</span><span class="token hvariable">x</span> <span class="token operator">-&gt;</span> <span class="token hvariable">x</span> <span class="token operator">++</span> <span class="token string">"1"</span>
<span class="token hvariable">func2</span> <span class="token operator">=</span> <span class="token operator">\</span><span class="token hvariable">x</span> <span class="token operator">-&gt;</span> <span class="token hvariable">x</span> <span class="token operator">++</span> <span class="token string">"2"</span>
<span class="token hvariable">func3</span> <span class="token operator">=</span> <span class="token operator">\</span><span class="token hvariable">x</span> <span class="token operator">-&gt;</span> <span class="token hvariable">x</span> <span class="token operator">++</span> <span class="token string">"3"</span>
<span class="token hvariable">func4</span> <span class="token operator">=</span> <span class="token operator">\</span><span class="token hvariable">x</span> <span class="token operator">-&gt;</span> <span class="token hvariable">x</span> <span class="token operator">++</span> <span class="token string">"4"</span>
<span class="token hvariable">func5</span> <span class="token operator">=</span> <span class="token operator">\</span><span class="token hvariable">x</span> <span class="token operator">-&gt;</span> <span class="token hvariable">x</span> <span class="token operator">++</span> <span class="token string">"5"</span>
<span class="token hvariable">func6</span> <span class="token operator">=</span> <span class="token operator">\</span><span class="token hvariable">x</span> <span class="token operator">-&gt;</span> <span class="token hvariable">x</span> <span class="token operator">++</span> <span class="token string">"6"</span>
<span class="token hvariable">func7</span> <span class="token operator">=</span> <span class="token operator">\</span><span class="token hvariable">x</span> <span class="token operator">-&gt;</span> <span class="token hvariable">x</span> <span class="token operator">++</span> <span class="token string">"7"</span>

<span class="token hvariable">main</span> <span class="token operator">::</span> <span class="token constant">IO</span> <span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token hvariable">main</span> <span class="token operator">=</span> <span class="token builtin">print</span>
  <span class="token operator">.</span> <span class="token hvariable">func0</span>
  <span class="token operator">.</span> <span class="token hvariable">func1</span>
  <span class="token operator">.</span> <span class="token hvariable">func2</span>
  <span class="token operator">.</span> <span class="token hvariable">func3</span>
  <span class="token operator">.</span> <span class="token hvariable">func4</span>
  <span class="token operator">.</span> <span class="token hvariable">func5</span>
  <span class="token operator">.</span> <span class="token hvariable">func6</span>
  <span class="token operator">.</span> <span class="token hvariable">func7</span> <span class="token operator">$</span> <span class="token string">""</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><h1 data-heading="ФВП" id="ФВП">ФВП</h1></div><div><p>ФВП, или Функции Высшего Порядка (англ. HOF, Higher Order Functions) — важная концепция в Haskell, с которой, однако, мы уже знакомы. Как мы узнали из предыдущих глав, функциями можно оперировать как значениями. Так вот функции, оперирующие другими функциями как аргументами и/или как результирующим выражением, носят название функций высшего порядка.</p></div><div><p>Так, оператор композиции функций является ФВП, потому что он, во-первых, принимает функции в качестве аргументов, а во-вторых, возвращает другую функцию (в виде ЛФ) как результат своего применения. Использование функций в качестве аргументов — чрезвычайно распространённая практика в Haskell.</p></div><div><h2 data-heading="Отображение" id="Отображение" style="display: flex;"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>Отображение</h2></div><div><p>Функция&nbsp;<code>map</code>. Эта стандартная функция используется для отображения (англ. mapping) функции на элементы списка. Отображение функции на элемент фактически означает её применение к этому элементу.</p></div><div><p>Вот объявление функции&nbsp;<code>map</code>:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token builtin">map</span> <span class="token operator">::</span> <span class="token punctuation">(</span><span class="token hvariable">a</span> <span class="token operator">-&gt;</span> <span class="token hvariable">b</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token punctuation">[</span><span class="token hvariable">a</span><span class="token punctuation">]</span> <span class="token operator">-&gt;</span> <span class="token punctuation">[</span><span class="token hvariable">b</span><span class="token punctuation">]</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Малой буквой принято именовать полиморфный (англ. polymorphic) тип. Полиморфизм — это многообразность, многоформенность. В данном случае речь идёт не об указании конкретного типа, а о «типовой заглушке». Мы говорим: «Функция&nbsp;<code>map</code>&nbsp;применяется к функции из какого-то типа&nbsp;<code>a</code>&nbsp;в какой-то тип&nbsp;<code>b</code>&nbsp;и к списку типа&nbsp;<code>[a]</code>, а результат её работы — это другой список типа&nbsp;<code>[b]</code>». Типовой заглушкой я назвал их потому, что на их место встают конкретные типы, что делает функцию&nbsp;<code>map</code>&nbsp;очень гибкой. Например:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token import-statement"><span class="token keyword">import</span> Data<span class="token punctuation">.</span>Char</span>

<span class="token hvariable">toUpperCase</span> <span class="token operator">::</span> <span class="token constant">String</span> <span class="token operator">-&gt;</span> <span class="token constant">String</span>
<span class="token hvariable">toUpperCase</span> <span class="token hvariable">str</span> <span class="token operator">=</span> <span class="token builtin">map</span> <span class="token builtin">toUpper</span> <span class="token hvariable">str</span>

<span class="token hvariable">main</span> <span class="token operator">::</span> <span class="token constant">IO</span> <span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token hvariable">main</span> <span class="token operator">=</span> <span class="token builtin">putStrLn</span> <span class="token operator">.</span> <span class="token hvariable">toUpperCase</span> <span class="token operator">$</span> <span class="token string">"haskell.org"</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Данное выражение:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token builtin">map</span> <span class="token builtin">toUpper</span> <span class="token string">"haskell.org"</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Аналогично:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token builtin">map</span> <span class="token builtin">toUpper</span> <span class="token punctuation">[</span><span class="token char string">'h'</span><span class="token punctuation">,</span><span class="token char string">'a'</span><span class="token punctuation">,</span><span class="token char string">'s'</span><span class="token punctuation">,</span><span class="token char string">'k'</span><span class="token punctuation">,</span><span class="token char string">'e'</span><span class="token punctuation">,</span><span class="token char string">'l'</span><span class="token punctuation">,</span><span class="token char string">'l'</span><span class="token punctuation">,</span><span class="token char string">'.'</span><span class="token punctuation">,</span><span class="token char string">'o'</span><span class="token punctuation">,</span><span class="token char string">'r'</span><span class="token punctuation">,</span><span class="token char string">'g'</span><span class="token punctuation">]</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Схема преобразования:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token builtin">map</span> <span class="token builtin">toUpper</span> <span class="token punctuation">[</span> <span class="token char string">'h'</span>  <span class="token operator">&gt;&gt;</span>  <span class="token punctuation">[</span> <span class="token char string">'H'</span>
            <span class="token punctuation">,</span> <span class="token char string">'a'</span>  <span class="token operator">&gt;&gt;</span>  <span class="token punctuation">,</span> <span class="token char string">'A'</span>
            <span class="token punctuation">,</span> <span class="token char string">'s'</span>  <span class="token operator">&gt;&gt;</span>  <span class="token punctuation">,</span> <span class="token char string">'S'</span>
            <span class="token punctuation">,</span> <span class="token char string">'k'</span>  <span class="token operator">&gt;&gt;</span>  <span class="token punctuation">,</span> <span class="token char string">'K'</span>
            <span class="token punctuation">,</span> <span class="token char string">'e'</span>  <span class="token operator">&gt;&gt;</span>  <span class="token punctuation">,</span> <span class="token char string">'E'</span>
            <span class="token punctuation">,</span> <span class="token char string">'l'</span>  <span class="token operator">&gt;&gt;</span>  <span class="token punctuation">,</span> <span class="token char string">'L'</span>
            <span class="token punctuation">,</span> <span class="token char string">'l'</span>  <span class="token operator">&gt;&gt;</span>  <span class="token punctuation">,</span> <span class="token char string">'L'</span>
            <span class="token punctuation">,</span> <span class="token char string">'.'</span>  <span class="token operator">&gt;&gt;</span>  <span class="token punctuation">,</span> <span class="token char string">'.'</span>
            <span class="token punctuation">,</span> <span class="token char string">'o'</span>  <span class="token operator">&gt;&gt;</span>  <span class="token punctuation">,</span> <span class="token char string">'O'</span>
            <span class="token punctuation">,</span> <span class="token char string">'r'</span>  <span class="token operator">&gt;&gt;</span>  <span class="token punctuation">,</span> <span class="token char string">'R'</span>
            <span class="token punctuation">,</span> <span class="token char string">'g'</span>  <span class="token operator">&gt;&gt;</span>  <span class="token punctuation">,</span> <span class="token char string">'G'</span>
            <span class="token punctuation">]</span>          <span class="token punctuation">]</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Другой пример, когда типовые заглушки&nbsp;<code>a</code>&nbsp;и&nbsp;<code>b</code>&nbsp;замещаются разными типами:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">toStr</span> <span class="token operator">::</span> <span class="token punctuation">[</span><span class="token constant">Double</span><span class="token punctuation">]</span> <span class="token operator">-&gt;</span> <span class="token punctuation">[</span><span class="token constant">String</span><span class="token punctuation">]</span>
<span class="token hvariable">toStr</span> <span class="token hvariable">numbers</span> <span class="token operator">=</span> <span class="token builtin">map</span> <span class="token builtin">show</span> <span class="token hvariable">numbers</span>

<span class="token hvariable">main</span> <span class="token operator">::</span> <span class="token constant">IO</span> <span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token hvariable">main</span> <span class="token operator">=</span> <span class="token builtin">print</span> <span class="token operator">.</span> <span class="token hvariable">toStr</span> <span class="token operator">$</span> <span class="token punctuation">[</span><span class="token number">1.2</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">1.6</span><span class="token punctuation">]</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>И ещё:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">ten</span> <span class="token operator">::</span> <span class="token punctuation">[</span><span class="token constant">Double</span><span class="token punctuation">]</span> <span class="token operator">-&gt;</span> <span class="token punctuation">[</span><span class="token constant">Double</span><span class="token punctuation">]</span>
<span class="token hvariable">ten</span> <span class="token operator">=</span> <span class="token builtin">map</span> <span class="token punctuation">(</span><span class="token operator">\</span><span class="token hvariable">n</span> <span class="token operator">-&gt;</span> <span class="token hvariable">n</span> <span class="token operator">*</span> <span class="token number">10</span><span class="token punctuation">)</span>

<span class="token hvariable">main</span> <span class="token operator">::</span> <span class="token constant">IO</span> <span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token hvariable">main</span> <span class="token operator">=</span> <span class="token builtin">print</span> <span class="token operator">.</span> <span class="token hvariable">ten</span> <span class="token operator">$</span> <span class="token punctuation">[</span><span class="token number">1.2</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">1.6</span><span class="token punctuation">]</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><h2 data-heading="Частичное применение" id="Частичное_применение" style="display: flex;"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>Частичное применение</h2></div><div><p>Функция&nbsp;<code>map</code>&nbsp;ожидает два аргумента, это отражено в её типе. Но что будет, если применить её не к двум аргументам, а лишь к одному? В этом случае произойдёт ещё одно «магическое» превращение, называющееся частичным применением (англ. partial application) функции. Частичным называют такое применение, когда аргументов меньше чем ожидается.</p></div><div><p>Вспомним сокращённое определение функции&nbsp;<code>ten</code>:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">ten</span> <span class="token operator">=</span> <span class="token builtin">map</span> <span class="token punctuation">(</span><span class="token operator">\</span><span class="token hvariable">n</span> <span class="token operator">-&gt;</span> <span class="token hvariable">n</span> <span class="token operator">*</span> <span class="token number">10</span><span class="token punctuation">)</span>

          первый         а где же
          аргумент       второй<span class="token operator">??</span>
          есть
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Функция&nbsp;<code>map</code>&nbsp;получила лишь первый аргумент, а где же второй? Второй, как мы уже знаем, будет получен ею уже потом, после того, как мы подставим это выражение на место функции&nbsp;<code>ten</code>. Но что же происходит с функцией&nbsp;<code>map</code>&nbsp;до этого? А до этого с ней происходит частичное применение. Понятно, что она ещё не может выполнить свою работу, поэтому, будучи применённой лишь к одному аргументу, она возвращает ЛФ!</p></div><div><blockquote>
<p>Функция от нескольких аргументов может быть разложена на последовательность применений временных функций от одного аргумента каждая.</p>
</blockquote></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">main</span> <span class="token operator">=</span> <span class="token builtin">print</span> <span class="token operator">.</span> <span class="token punctuation">(</span><span class="token builtin">map</span> <span class="token punctuation">(</span><span class="token operator">\</span><span class="token hvariable">n</span> <span class="token operator">-&gt;</span> <span class="token hvariable">n</span> <span class="token operator">*</span> <span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">$</span> <span class="token punctuation">[</span><span class="token number">1.2</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span> <span class="token number">1.6</span><span class="token punctuation">]</span>

               │     частично     │
               └─ применённая <span class="token builtin">map</span> ┘

       │    композиция функции    │
       │     <span class="token builtin">print</span> и частично     │
       └───── применённой <span class="token builtin">map</span> ────┘
                                      аргумент для
                                      композиции
</code><button class="copy-code-button">Копировать</button></pre></div><div><h2 data-heading="Композиция для отображения" id="Композиция_для_отображения" style="display: flex;"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>Композиция для отображения</h2></div><div><p>Вернёмся к функции&nbsp;<code>map</code>. Если мы можем передать ей некую функцию для работы с элементами списка, значит мы можем передать ей и композицию двух или более функций. Например:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token import-statement"><span class="token keyword">import</span> Data<span class="token punctuation">.</span>Char</span>

<span class="token hvariable">pretty</span> <span class="token operator">::</span> <span class="token punctuation">[</span><span class="token constant">String</span><span class="token punctuation">]</span> <span class="token operator">-&gt;</span> <span class="token punctuation">[</span><span class="token constant">String</span><span class="token punctuation">]</span>
<span class="token hvariable">pretty</span> <span class="token operator">=</span> <span class="token builtin">map</span> <span class="token punctuation">(</span><span class="token hvariable">stars</span> <span class="token operator">.</span> <span class="token hvariable">big</span><span class="token punctuation">)</span>
  <span class="token keyword">where</span>
    <span class="token hvariable">big</span> <span class="token operator">=</span> <span class="token builtin">map</span> <span class="token builtin">toUpper</span>
    <span class="token hvariable">stars</span> <span class="token operator">=</span> <span class="token operator">\</span><span class="token hvariable">s</span> <span class="token operator">-&gt;</span> <span class="token string">"* "</span> <span class="token operator">++</span> <span class="token hvariable">s</span> <span class="token operator">++</span> <span class="token string">" *"</span>

<span class="token hvariable">main</span> <span class="token operator">::</span> <span class="token constant">IO</span> <span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token hvariable">main</span> <span class="token operator">=</span> <span class="token builtin">print</span> <span class="token operator">.</span> <span class="token hvariable">pretty</span> <span class="token operator">$</span> <span class="token punctuation">[</span><span class="token string">"haskell"</span><span class="token punctuation">,</span> <span class="token string">"lisp"</span><span class="token punctuation">,</span> <span class="token string">"coq"</span><span class="token punctuation">]</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><h1 data-heading="Hackage и библиотеки" id="Hackage_и_библиотеки">Hackage и библиотеки</h1></div><div><p>Ранее я уже упоминал о библиотеках, пришло время познакомиться с ними поближе, ведь в последующих главах мы будем использовать их постоянно.</p></div><div><h2 data-heading="Библиотеки большие и маленькие" id="Библиотеки_большие_и_маленькие" style="display: flex;"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>Библиотеки большие и маленькие</h2></div><div><p>За годы существования Haskell разработчики со всего мира создали множество библиотек. Библиотеки избавляют нас от необходимости вновь и вновь писать то, что уже написано до нас. Для любого живого языка программирования написано множество библиотек. В мире Haskell их, конечно, не такая туча, как для той же Java, но порядочно: стабильных есть не менее двух тысяч, многие из которых очень качественные и уже многократно испытаны в серьёзных проектах.</p></div><div><p>С модулями — файлами, содержащими Haskell-код, — мы уже знакомы, они являются основным кирпичом любого Haskell-проекта. Библиотека, также являясь Haskell-проектом, тоже состоит из модулей (не важно, из одного или из сотен). Поэтому использование библиотеки сводится к использованию входящих в неё модулей. И мы уже неоднократно делали это в предыдущих главах.</p></div><div><p>Вспомним пример из главы про ФВП:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token import-statement"><span class="token keyword">import</span> Data<span class="token punctuation">.</span>Char</span>

<span class="token hvariable">toUpperCase</span> <span class="token operator">::</span> <span class="token constant">String</span> <span class="token operator">-&gt;</span> <span class="token constant">String</span>
<span class="token hvariable">toUpperCase</span> <span class="token hvariable">str</span> <span class="token operator">=</span> <span class="token builtin">map</span> <span class="token builtin">toUpper</span> <span class="token hvariable">str</span>

<span class="token hvariable">main</span> <span class="token operator">::</span> <span class="token constant">IO</span> <span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token hvariable">main</span> <span class="token operator">=</span> <span class="token builtin">putStrLn</span> <span class="token operator">.</span> <span class="token hvariable">toUpperCase</span> <span class="token operator">$</span> <span class="token string">"haskell.org"</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Функция&nbsp;<code>toUpper</code>&nbsp;определена в модуле&nbsp;<code>Data.Char</code>, который, в свою очередь, живёт в стандартной библиотеке. Библиотек есть множество, но стандартная лишь одна. Она содержит самые базовые, наиболее широко используемые инструменты. А прежде чем продолжить, зададимся важным вопросом: «Где живут все эти библиотеки?» Они живут в разных местах, но главное из них — Hackage.</p></div><div><h2 data-heading="Hackage" id="Hackage" style="display: flex;"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>Hackage</h2></div><div><p>Hackage — это центральный репозиторий Haskell-библиотек, или, как принято у нас называть, пакетов (англ. package). Название репозитория происходит от слияния слов&nbsp;<code>Haskell</code>&nbsp;и&nbsp;<code>package</code>. Hackage существует с 2008 года и живёт&nbsp;<a data-tooltip-position="top" aria-label="http://hackage.haskell.org/" rel="noopener" class="external-link" href="http://hackage.haskell.org/" target="_blank">здесь</a>. Ранее упомянутая стандартная библиотека тоже живёт в Hackage и называется она&nbsp;<code>base</code>. Каждой библиотеке выделена своя страница.</p></div><div><p>Каждый из Hackage-пакетов живёт по адресу, сформированному по неизменной схеме:&nbsp;<code>http://hackage.haskell.org/package/ИМЯПАКЕТА</code>. Так, дом стандартной библиотеки —&nbsp;<code>http://hackage.haskell.org/package/base</code>. Hackage — открытый репозиторий: любой разработчик может добавить туда свои пакеты.</p></div><div><p>Стандартная библиотека включает в себя более сотни модулей, но есть среди них самый известный, носящий имя&nbsp;<code>Prelude</code>. Этот модуль по умолчанию всегда с нами: всё его содержимое автоматически импортируется во все модули нашего проекта.</p></div><div><p>Hackage весьма большой, поэтому искать пакеты можно двумя способами. Первый — на&nbsp;<a data-tooltip-position="top" aria-label="http://hackage.haskell.org/packages/" rel="noopener" class="external-link" href="http://hackage.haskell.org/packages/" target="_blank">единой странице всех пакетов</a>. Здесь перечислены все пакеты, а для нашего удобства они расположены по тематическим категориям.</p></div><div><p>Второй способ — через специальный поисковик, коих существует два:</p></div><div><ol>
<li data-line="0"><a data-tooltip-position="top" aria-label="https://hoogle.haskell.org/" rel="noopener" class="external-link" href="https://hoogle.haskell.org/" target="_blank">Hoogle</a></li>
<li data-line="1"><a data-tooltip-position="top" aria-label="http://holumbus.fh-wedel.de/hayoo/hayoo.html" rel="noopener" class="external-link" href="http://holumbus.fh-wedel.de/hayoo/hayoo.html" target="_blank">Hayoo!</a></li>
</ol></div><div><p>К сожалению Hayoo недоступен... </p></div><div><p>Рассказывается как правильно импортировать, экспортировать модули и функции.</p></div><div><h1 data-heading="Рекурсия" id="Рекурсия">Рекурсия</h1></div><div><blockquote>
<p>Чтобы понять рекурсию, нужно сначала понять рекурсию.</p>
</blockquote></div><div><p>Идея рекурсии предельно проста:</p></div><div><blockquote>
<p>Если нам нужно повторить вычисление, производимое некой функцией, мы должны применить эту функцию внутри себя самой. И получится зацикливание.</p>
</blockquote></div><div><p>Взглянем на определение функции&nbsp;<code>map</code>:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token builtin">map</span> <span class="token hvariable">_</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>     <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
<span class="token builtin">map</span> <span class="token hvariable">f</span> <span class="token punctuation">(</span><span class="token hvariable">x</span><span class="token operator">:</span><span class="token hvariable">xs</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token hvariable">f</span> <span class="token hvariable">x</span> <span class="token operator">:</span> <span class="token builtin">map</span> <span class="token hvariable">f</span> <span class="token hvariable">xs</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>А теперь разберём это интереснейшее определение по косточкам.</p></div><div><h2 data-heading="Правда о списке" id="Правда_о_списке" style="display: flex;"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>Правда о списке</h2></div><div><p>Первым аргументом, как мы помним, выступает некая функция, а вторым — список, к элементам которого применяется эта функция. Но что это за странного вида конструкция в круглых скобках?</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token punctuation">(</span><span class="token hvariable">x</span><span class="token operator">:</span><span class="token hvariable">xs</span><span class="token punctuation">)</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Это — особый образец, используемый для работы со списками. И чтобы он стал понятен, я должен рассказать вам правду о формировании списка.</p></div><div><p>Как мы помним, формируется список предельно просто:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span>  <span class="token comment">-- Список из трёх целых чисел.</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Однако в действительности он формируется несколько иначе. Привычная нам конструкция в квадратных скобках есть ни что иное, как синтаксический сахар (англ. syntactic sugar). Синтаксическим сахаром называют некое упрощение кода, делающее его слаще, приятнее для нас. Если же мы уберём сахар (или, как ещё говорят, рассахарим код), то увидим вот что:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token number">1</span> <span class="token operator">:</span> <span class="token number">2</span> <span class="token operator">:</span> <span class="token number">3</span> <span class="token operator">:</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Именно так список из трёх целых чисел формируется на самом деле. Стандартный оператор&nbsp;<code>:</code>&nbsp;нам уже знаком, мы встретились с ним в главе о списках:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">newHost</span>   <span class="token operator">:</span>         <span class="token hvariable">hosts</span>

          этот
          оператор

берёт
это
значение
                    и добавляет
                    его в начало
                    этого списка
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>То есть список строится путём добавления элемента в его «голову», начиная с пустого списка:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded">  <span class="token number">1</span> <span class="token operator">:</span> <span class="token number">2</span> <span class="token operator">:</span> <span class="token number">3</span> <span class="token operator">:</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>

<span class="token operator">=</span> <span class="token number">1</span> <span class="token operator">:</span> <span class="token number">2</span> <span class="token operator">:</span> <span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span>

<span class="token operator">=</span> <span class="token number">1</span> <span class="token operator">:</span> <span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span>

<span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Далее разжевывается как работает функция <code>map</code></p></div><div><h2 data-heading="Туда и обратно" id="Туда_и_обратно" style="display: flex;"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>Туда и обратно</h2></div><div><p>Определяя рекурсивную функцию, важно помнить о том, что в ней должно быть как правило зацикливания, так и правило выхода из цикла:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token builtin">map</span> <span class="token hvariable">_</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>     <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>              <span class="token comment">-- Выходим из цикла.</span>
<span class="token builtin">map</span> <span class="token hvariable">f</span> <span class="token punctuation">(</span><span class="token hvariable">x</span><span class="token operator">:</span><span class="token hvariable">xs</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token hvariable">f</span> <span class="token hvariable">x</span> <span class="token operator">:</span> <span class="token builtin">map</span> <span class="token hvariable">f</span> <span class="token hvariable">xs</span>  <span class="token comment">-- Зацикливаемся,</span>
                               <span class="token comment">-- применяя саму себя.</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Если бы мы опустили первое определение, компилятор предусмотрительно сообщил бы нам о проблеме:</p></div><div><pre><code>Pattern match(es) are non-exhaustive
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>И это совершенно правильно: если на каждой итерации мы уменьшаем список, то рано или поздно список точно останется пустым, а следовательно, мы обязаны объяснить, что же делать в этом случае.</p></div><div><h2 data-heading="Для любопытных" id="Для_любопытных" style="display: flex;"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>Для любопытных</h2></div><div><p>Открою секрет: рекурсивными в Haskell бывают не только функции, но и типы. Но об этом в последующих главах.</p></div><div><h1 data-heading="Лень" id="Лень">Лень</h1></div><div><p>Объясняется две модели вычисления аргументов, а именно энергичная (англ. eager) и ленивая (англ. lazy).</p></div><div><p>При энергичной модели (называемой ещё «жадной» или «строгой») выражение, являющееся аргументом функции, будет вычислено ещё до того, как попадёт в тело функции. На фоне определения функции&nbsp;<code>square</code>&nbsp;будет яснее:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">square</span>     <span class="token hvariable">x</span>   <span class="token operator">=</span> <span class="token hvariable">x</span> <span class="token operator">*</span> <span class="token hvariable">x</span>
         <span class="token operator">/</span>   <span class="token operator">\</span>
<span class="token hvariable">square</span> <span class="token operator">$</span> <span class="token number">2</span> <span class="token operator">+</span> <span class="token number">2</span>
         <span class="token operator">\</span>   <span class="token operator">/</span>
           <span class="token number">4</span>   <span class="token operator">=</span> <span class="token number">4</span> <span class="token operator">*</span> <span class="token number">4</span> <span class="token operator">=</span> <span class="token number">16</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>То есть видим выражение&nbsp;<code>2 + 2</code>, жадно на него набрасываемся, полностью вычисляем, а уже потом результат этого вычисления передаём в функцию&nbsp;<code>square</code>.</p></div><div><p>При ленивой же модели всё наоборот: выражение, являющееся аргументом функции, передаётся в функцию прямо так, без вычисления. Изобразить это можно следующим образом:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">square</span>     <span class="token hvariable">x</span>   <span class="token operator">=</span>    <span class="token hvariable">x</span>    <span class="token operator">*</span>    <span class="token hvariable">x</span>
         <span class="token operator">/</span>   <span class="token operator">\</span>    <span class="token operator">/</span>   <span class="token operator">\</span>     <span class="token operator">/</span>   <span class="token operator">\</span>
<span class="token hvariable">square</span> <span class="token operator">$</span> <span class="token number">2</span> <span class="token operator">+</span> <span class="token number">2</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token number">2</span> <span class="token operator">+</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token punctuation">(</span><span class="token number">2</span> <span class="token operator">+</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token number">16</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Но какая разница, спросите вы? Всё равно в итоге получим&nbsp;<code>16</code>, хоть там сложили, хоть тут. Так и есть: модель вычисления не влияет на результат этого вычисления, но она влияет на путь к этому результату.</p></div><div><h2 data-heading="Рациональность" id="Рациональность" style="display: flex;"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>Рациональность</h2></div><div><p>Как уже было упомянуто, ленивая стратегия помогает программе быть рациональной и не делать лишнюю работу. Рассмотрим пример:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">main</span> <span class="token operator">::</span> <span class="token constant">IO</span> <span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token hvariable">main</span> <span class="token operator">=</span> <span class="token builtin">print</span> <span class="token operator">$</span> <span class="token builtin">take</span> <span class="token number">5</span> <span class="token hvariable">evens</span>
  <span class="token keyword">where</span> <span class="token hvariable">evens</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">4</span> <span class="token operator">..</span> <span class="token number">100</span><span class="token punctuation">]</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><h2 data-heading="Бесконечность" id="Бесконечность" style="display: flex;"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>Бесконечность</h2></div><div><p>А что будет, если мы запросим из списка&nbsp;<code>evens</code>&nbsp;500 элементов? Вот так:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">main</span> <span class="token operator">::</span> <span class="token constant">IO</span> <span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token hvariable">main</span> <span class="token operator">=</span> <span class="token builtin">print</span> <span class="token operator">$</span> <span class="token builtin">take</span> <span class="token number">500</span> <span class="token hvariable">evens</span>
  <span class="token keyword">where</span> <span class="token hvariable">evens</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">4</span> <span class="token operator">..</span> <span class="token number">100</span><span class="token punctuation">]</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Ничего страшного не случится, функция&nbsp;<code>take</code>&nbsp;проверяет выход за границы и в случае, если её первый аргумент превышает длину списка, она просто даёт нам тот же список. Да, но ведь мы хотим увидеть пятьсот чётных чисел, а не пятьдесят! Можно было бы увеличить список:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">main</span> <span class="token operator">::</span> <span class="token constant">IO</span> <span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token hvariable">main</span> <span class="token operator">=</span> <span class="token builtin">print</span> <span class="token operator">$</span> <span class="token builtin">take</span> <span class="token number">500</span> <span class="token hvariable">evens</span>
  <span class="token keyword">where</span> <span class="token hvariable">evens</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">4</span> <span class="token operator">..</span> <span class="token number">100000</span><span class="token punctuation">]</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>но это ненадёжно, ведь потом опять может потребоваться ещё больше. Нужно что-нибудь универсальное, и в Haskell есть подходящее решение:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">main</span> <span class="token operator">::</span> <span class="token constant">IO</span> <span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token hvariable">main</span> <span class="token operator">=</span> <span class="token builtin">print</span> <span class="token operator">$</span> <span class="token builtin">take</span> <span class="token number">500</span> <span class="token hvariable">evens</span>
  <span class="token keyword">where</span> <span class="token hvariable">evens</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">4</span> <span class="token operator">..</span><span class="token punctuation">]</span>  <span class="token comment">-- Что это?</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Теперь не сомневайтесь: в списке&nbsp;<code>evens</code>&nbsp;будет не менее пятисот чётных чисел. Но что это за конструкция такая? Начало дано, шаг дан, а где же конец? Познакомьтесь, это бесконечный список:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">4</span> <span class="token operator">..</span><span class="token punctuation">]</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Конечно, если бы мы решили похулиганить:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">main</span> <span class="token operator">::</span> <span class="token constant">IO</span> <span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token hvariable">main</span> <span class="token operator">=</span> <span class="token builtin">print</span> <span class="token hvariable">evens</span>  <span class="token comment">-- Дай нам всё!</span>
  <span class="token keyword">where</span> <span class="token hvariable">evens</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">4</span> <span class="token operator">..</span><span class="token punctuation">]</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><h2 data-heading="Space leak" id="Space_leak" style="display: flex;"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>Space leak</h2></div><div><p>Да, я должен рассказать вам правду: есть у ленивой стратегии вычислений тёмная сторона, получившая название space leak (букв. «утечка пространства»). И вот в чём её суть.</p></div><div><p>Вспомним пример с делением:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">main</span> <span class="token operator">::</span> <span class="token constant">IO</span> <span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token hvariable">main</span> <span class="token operator">=</span> <span class="token builtin">print</span> <span class="token operator">.</span> <span class="token hvariable">strange</span> <span class="token operator">$</span> <span class="token number">2</span> <span class="token operator">`div`</span> <span class="token number">0</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Как мы помним, деления на ноль так и не произошло за ненадобностью его результата. В этом случае выражение осталось в виде thunk. Возникает вопрос: что же с ним стало? У нас есть функция&nbsp;<code>div</code>&nbsp;и есть два значения типа&nbsp;<code>Int</code>,&nbsp;<code>2</code>&nbsp;и&nbsp;<code>0</code>. Если функция&nbsp;<code>div</code>&nbsp;так и не была применена к ним, где же всё это хозяйство находилось в процессе работы нашей программы? Оно находилось в памяти, в виде особого графа, который можно изобразить так:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"> ┌─────────────┐
 │ <span class="token builtin">div</span> │   │   │
 └─────────────┘
         │   │
         <span class="token hvariable">v</span>   <span class="token hvariable">v</span>
      ┌───┐ ┌───┐
      │ <span class="token number">2</span> │ │ <span class="token number">0</span> │
      └───┘ └───┘
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>То есть сама функция и два значения, которые должны были занять место двух её аргументов. И вот этот граф в памяти так и остался невостребованным. Казалось бы, ну и в чём проблема? А проблема в количестве. Если мы смогли написать код, при работе которого в память отложился один thunk, значит теоретически мы можем написать и такой код, количество thunk-ов при работе которого будет исчисляться миллионами. А учитывая тот факт, что каждый thunk занимает в памяти хотя бы несколько байт, вы можете себе представить масштаб проблемы.</p></div><div><p>Причём возникнуть эта проблема может из весьма невинного на первый взгляд кода:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">bad</span> <span class="token operator">::</span> <span class="token punctuation">[</span><span class="token constant">Int</span><span class="token punctuation">]</span> <span class="token operator">-&gt;</span> <span class="token constant">Int</span> <span class="token operator">-&gt;</span> <span class="token constant">Int</span>
<span class="token hvariable">bad</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>         <span class="token hvariable">c</span> <span class="token operator">=</span> <span class="token hvariable">c</span>
<span class="token hvariable">bad</span> <span class="token punctuation">(</span><span class="token hvariable">_</span><span class="token operator">:</span><span class="token hvariable">others</span><span class="token punctuation">)</span> <span class="token hvariable">c</span> <span class="token operator">=</span> <span class="token hvariable">bad</span> <span class="token hvariable">others</span> <span class="token operator">$</span> <span class="token hvariable">c</span> <span class="token operator">+</span> <span class="token number">1</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Простенькая рекурсивная функция, пробегающаяся по ненужному ей списку и увеличивающаяся свой второй аргумент на единицу. Но я не просто так назвал её&nbsp;<code>bad</code>. Давайте применим её:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">bad</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span> <span class="token number">0</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Подставим в определение, содержащее зацикливание:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">bad</span> <span class="token punctuation">(</span><span class="token hvariable">_</span><span class="token operator">:</span> <span class="token hvariable">others</span><span class="token punctuation">)</span> <span class="token hvariable">c</span> <span class="token operator">=</span> <span class="token hvariable">bad</span> <span class="token hvariable">others</span> <span class="token operator">$</span> <span class="token hvariable">c</span> <span class="token operator">+</span> <span class="token number">1</span>

<span class="token hvariable">bad</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span>   <span class="token number">0</span> <span class="token operator">=</span> <span class="token hvariable">bad</span> <span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span> <span class="token operator">$</span> <span class="token number">0</span> <span class="token operator">+</span> <span class="token number">1</span>

        <span class="token hvariable">____</span>            <span class="token hvariable">______</span>

                <span class="token operator">=</span>                <span class="token operator">=</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>«Голова» списка откусывается и игнорируется, а к&nbsp;<code>0</code>&nbsp;прибавляется&nbsp;<code>1</code>. Но поскольку результат сложения пока что никому не нужен, сложение не производится. Вместо этого, на второй итерации, мы видим следующее:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">bad</span> <span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span> <span class="token operator">$</span> <span class="token number">0</span> <span class="token operator">+</span> <span class="token number">1</span> <span class="token operator">=</span> <span class="token hvariable">bad</span> <span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span> <span class="token operator">$</span> <span class="token punctuation">(</span><span class="token number">0</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>К предыдущему выражению вновь прибавляется единица — и мы опять входим в очередную итерацию, так и не выполнив сложения:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">bad</span> <span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span> <span class="token operator">$</span> <span class="token punctuation">(</span><span class="token number">0</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span> <span class="token operator">=</span> <span class="token hvariable">bad</span> <span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">$</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token number">0</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Опа! Упёрлись в пустой список, вспоминаем правило выхода из рекурсии:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">bad</span> <span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token hvariable">c</span> <span class="token operator">=</span> <span class="token hvariable">c</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Итак, в этом случае мы просто возвращаем значение второго аргумента. Сделаем же это:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">bad</span> <span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">$</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token number">0</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token number">0</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span> <span class="token operator">=</span> <span class="token number">3</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>И вот только здесь мы реально вычисляем второй аргумент, складывая три единицы. Вы спросите, почему же мы накапливали эти сложения вместо того, чтобы делать их сразу? Потому что мы ленивы: раз результат сложения понадобился нам лишь на последней итерации, значит до этой итерации никакого сложения не будет, ведь лень вынуждает нас откладывать работу до конца.</p></div><div><p>Вот в этом-то накоплении вся беда. Представим, что мы написали так:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">main</span> <span class="token operator">::</span> <span class="token constant">IO</span> <span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token hvariable">main</span> <span class="token operator">=</span> <span class="token builtin">print</span> <span class="token operator">$</span> <span class="token hvariable">bad</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token operator">..</span><span class="token number">50000000</span><span class="token punctuation">]</span> <span class="token number">0</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>50 миллионов элементов, а значит, 50 миллионов раз сложение второго аргумента с единицей будет откладываться, накапливая гигантский «хвост» из (пока что) невычисленных выражений. Хотите знать, что произойдёт при запуске такой программы? Её выполнение, на MacBook Pro 2014 года, займёт приблизительно 63 секунды и скушает, ни много ни мало, 6,4 ГБ памяти! А теперь представьте, что случилось бы, если бы элементов в списке было не 50 миллионов, а 50 миллиардов…</p></div><div><p>Иногда space leak ошибочно путают с другой проблемой, называемой memory leak (англ. «утечка памяти»), однако это вовсе не одно и то же. Утечка памяти — это ошибка, характерная для языков с ручным управлением памятью, например, C. Если мы выделим память в куче (англ. heap), а затем потеряем указатель, связывающий нас с этой памятью — всё, выделенная память утекла, она потеряна для нас навеки. Но в случае space leak мы не теряем память: когда весь этот «хвост» из сложений в конце концов вычислится, память, занимаемая миллионами thunk-ов, освободится. Мы не теряем память, мы просто используем её слишком много.</p></div><div><h2 data-heading="Борьба" id="Борьба" style="display: flex;"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>Борьба</h2></div><div><p>мы должны убрать излишнюю ленивость и заменить её строгостью.
Вот два способа.</p></div><div><h3 data-heading="Оптимизация" id="Оптимизация" style="display: flex;"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>Оптимизация</h3></div><div><p>Первый способа самый простой — оптимизация. Когда компилятор превращает наш код в программу, его можно попросить оптимизировать наш код, сделав его более эффективным, по тем или иным критериям. Чтобы попросить компилятор провести оптимизацию, мы должны использовать специальный флаг. Откроем сборочный файл нашего проекта&nbsp;<code>real.cabal</code>, найдём секцию&nbsp;<code>executable real-exe</code>, в которой есть строка:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded">  <span class="token hvariable">ghc</span><span class="token operator">-</span><span class="token hvariable">options</span><span class="token operator">:</span>         <span class="token operator">...</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Эта строка содержит различные опции компилятора GHC, и оптимизационный флаг дописывается именно сюда. Попробуем подставить туда сначала флаг&nbsp;<code>-O0</code>, а затем&nbsp;<code>-O2</code>. Результаты запуска программы будут такими:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded">Оптимизация    Время    Память

<span class="token operator">-</span><span class="token constant">O0</span>            <span class="token number">63</span> <span class="token hvariable">c</span>     <span class="token number">6</span><span class="token punctuation">,</span><span class="token number">4</span> ГБ

<span class="token operator">-</span><span class="token constant">O2</span>            <span class="token number">3</span><span class="token punctuation">,</span><span class="token number">2</span> с    <span class="token number">104</span> кБ
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Впечатляющая разница, не правда ли? Флаг&nbsp;<code>-O0</code>&nbsp;говорит компилятору о том, чтобы тот не производил никакую оптимизацию, в этом случае говорят о нулевом уровне оптимизации. Флаг&nbsp;<code>-O2</code>, напротив, устанавливает стандартный для production-проектов уровень оптимизации. Так вот при стандартном уровне компилятор способен распознать излишнюю ленивость в нашем коде и добавить чуток жадности. В примере выше компилятор увидит накопление thunk-ов сложения и пресечёт оное. Согласитесь, с гигабайтов прыгнуть сразу на килобайты — это круто.</p></div><div><p>Так что же, проблемы нет? Ну, если оптимизация&nbsp;<code>-O2</code>&nbsp;и так стандартна — так давайте ставить её в наши проекты и забудем про space leak! К сожалению, не всё так просто.</p></div><div><p>Во-первых, компиляторная оптимизация сродни чёрной магии, на неё трудно полагаться. Мы очень благодарны компилятору GHC за попытку помочь нам, но эта помощь не всегда соответствует нашим ожиданиям. И во-вторых, к сожалению, компилятор не всегда способен распознать излишнюю лень в нашем коде, и в этом случае нам приходится-таки прибегнуть ко второму способу борьбы со space leak.</p></div><div><h3 data-heading="Вручную" id="Вручную" style="display: flex;"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>Вручную</h3></div><div><p>Вернёмся к определению функции&nbsp;<code>bad</code>:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">bad</span> <span class="token operator">::</span> <span class="token punctuation">[</span><span class="token constant">Int</span><span class="token punctuation">]</span> <span class="token operator">-&gt;</span> <span class="token constant">Int</span> <span class="token operator">-&gt;</span> <span class="token constant">Int</span>
<span class="token hvariable">bad</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>         <span class="token hvariable">c</span> <span class="token operator">=</span> <span class="token hvariable">c</span>
<span class="token hvariable">bad</span> <span class="token punctuation">(</span><span class="token hvariable">_</span><span class="token operator">:</span><span class="token hvariable">others</span><span class="token punctuation">)</span> <span class="token hvariable">c</span> <span class="token operator">=</span> <span class="token hvariable">bad</span> <span class="token hvariable">others</span> <span class="token operator">$</span> <span class="token hvariable">c</span> <span class="token operator">+</span> <span class="token number">1</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Проблема, как мы уже поняли, во втором аргументе:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">bad</span> <span class="token hvariable">others</span> <span class="token operator">$</span> <span class="token hvariable">c</span> <span class="token operator">+</span> <span class="token number">1</span>

             накопление
             <span class="token hvariable">thunk</span><span class="token operator">-</span>ов<span class="token operator">...</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Превратим же злую функцию в добрую:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">good</span> <span class="token operator">::</span> <span class="token punctuation">[</span><span class="token constant">Int</span><span class="token punctuation">]</span> <span class="token operator">-&gt;</span> <span class="token constant">Int</span> <span class="token operator">-&gt;</span> <span class="token constant">Int</span>
<span class="token hvariable">good</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>         <span class="token hvariable">c</span> <span class="token operator">=</span> <span class="token hvariable">c</span>
<span class="token hvariable">good</span> <span class="token punctuation">(</span><span class="token hvariable">_</span><span class="token operator">:</span><span class="token hvariable">others</span><span class="token punctuation">)</span> <span class="token hvariable">c</span> <span class="token operator">=</span> <span class="token hvariable">good</span> <span class="token hvariable">others</span> <span class="token operator">$!</span> <span class="token hvariable">c</span> <span class="token operator">+</span> <span class="token number">1</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Этот код даст нам приблизительно такой же выигрыш, что и оптимизация уровня&nbsp;<code>-O2</code>: секунды вместо минуты и килобайты вместо гигабайтов. Что же изменилось? Смотрим внимательно:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">good</span> <span class="token hvariable">others</span> <span class="token operator">$!</span> <span class="token hvariable">c</span> <span class="token operator">+</span> <span class="token number">1</span>

             <span class="token operator">^</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Вместо привычного оператора применения&nbsp;<code>$</code>&nbsp;мы видим оператор строго применения&nbsp;<code>$!</code>&nbsp;(англ. strict application operator). Этот оператор говорит аргументу: «Забудь о лени, я приказываю тебе немедленно вычислиться до слабой головной формы»:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">good</span> <span class="token hvariable">others</span> <span class="token operator">$!</span>       <span class="token hvariable">c</span> <span class="token operator">+</span> <span class="token number">1</span>

            вычисли  этот
                     аргумент

            строго<span class="token punctuation">,</span>
            а не
            лениво<span class="token operator">!</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Вот потому-то наш «хвост» из thunk-ов и не будет накапливаться, ведь на каждой из 50 миллионов итераций будет происходить незамедлительное применение оператора сложения. Таким образом, заставить аргумент тут же вычислиться до слабой головной или нормальной формы можно как посредством того, что этот аргумент прямо сейчас кому-то понадобился, так и посредством строгого применения.</p></div><div><h2 data-heading="Лень и строгость вместе" id="Лень_и_строгость_вместе" style="display: flex;"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>Лень и строгость вместе</h2></div><div><p>Функцию называют ленивой по тем аргументам, которые не вычисляются, и строгой по тем аргументам, которые вычисляются. Примитивный пример:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">fakeSum</span> <span class="token operator">::</span> <span class="token constant">Int</span> <span class="token operator">-&gt;</span> <span class="token constant">Int</span> <span class="token operator">-&gt;</span> <span class="token constant">Int</span>
<span class="token hvariable">fakeSum</span> <span class="token hvariable">x</span> <span class="token hvariable">_</span> <span class="token operator">=</span> <span class="token hvariable">x</span> <span class="token operator">+</span> <span class="token number">100</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Функция&nbsp;<code>fakeSum</code>&nbsp;строга по своему первому аргументу и ленива по своему второму аргументу. Первый аргумент&nbsp;<code>x</code>&nbsp;непременно будет вычислен, ведь он передаётся оператору сложения. Второй же аргумент игнорируется, оставшись невычисленным. И кстати, существует простой способ проверить, строга ли функция по некоторому аргументу или ленива.</p></div><div><p>В стандартной библиотеке Haskell определена особая функция&nbsp;<code>undefined</code>. Это — чёрная дыра: при попытке прикоснуться к ней программа гарантированно падает с ошибкой. Проверяем:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">main</span> <span class="token operator">::</span> <span class="token constant">IO</span> <span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token hvariable">main</span> <span class="token operator">=</span> <span class="token builtin">print</span> <span class="token operator">$</span> <span class="token hvariable">fakeSum</span> <span class="token number">1</span> <span class="token builtin">undefined</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>В этом случае мы получим результат:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token number">101</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Чёрная дыра была проигнорирована, ведь функция&nbsp;<code>fakeSum</code>&nbsp;ленива по второму аргументу. Если же мы напишем так:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">main</span> <span class="token operator">::</span> <span class="token constant">IO</span> <span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token hvariable">main</span> <span class="token operator">=</span> <span class="token builtin">print</span> <span class="token operator">$</span> <span class="token hvariable">fakeSum</span> <span class="token builtin">undefined</span> <span class="token number">45</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>программа, попытавшись передать&nbsp;<code>undefined</code>&nbsp;оператору сложения, аварийно остановится. Или вот другой пример:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">main</span> <span class="token operator">::</span> <span class="token constant">IO</span> <span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token hvariable">main</span> <span class="token operator">=</span> <span class="token builtin">print</span> <span class="token operator">.</span> <span class="token builtin">head</span> <span class="token operator">$</span> <span class="token punctuation">[</span><span class="token number">23</span><span class="token punctuation">,</span> <span class="token builtin">undefined</span><span class="token punctuation">,</span> <span class="token builtin">undefined</span><span class="token punctuation">]</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Не сомневайтесь: программа спокойно вернёт нам&nbsp;<code>23</code>, ведь функция&nbsp;<code>head</code>&nbsp;строга лишь по первому элементу переданного ей списка, остальное содержимое оного её абсолютно не интересует. Но если попробуете вытащить второй или третий элемент из подобного списка — крах неминуем.</p></div><div><h2 data-heading="Для любопытных" id="Для_любопытных" style="display: flex;"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>Для любопытных</h2></div><div><p>Haskell — не первый язык с ленивой стратегией вычислений. Открою вам исторический факт: у языка Haskell был предшественник, язык программирования с красивым женским именем&nbsp;<a data-tooltip-position="top" aria-label="https://en.wikipedia.org/wiki/Miranda_(programming_language)" rel="noopener" class="external-link" href="https://en.wikipedia.org/wiki/Miranda_(programming_language)" target="_blank">Miranda</a>. Лень и чистая функциональность пришли в Haskell именно из Miranda, и лишь в этих двух языках ленивая стратегия вычисления аргументов используется по умолчанию. На сегодняшний день, насколько мне известно, язык Miranda мёртв. Впрочем, как сугубо исследовательский язык он, может быть, кем-то и используется.</p></div><div><p>Что же касается проблемы space leak, то к счастью, существуют способы обнаружения функций, шибко прожорливых до памяти. В самом деле, представьте себе большой проект, тысячи функций, и что-то кушает гигабайты памяти. Как найти виновного? Этот процесс называют ещё «space leak профилированием». Рассказывать об этом здесь я не стану, материал довольно объёмный. Но для особо любопытных привожу ссылку на неплохую англоязычную статью по теме:&nbsp;<a data-tooltip-position="top" aria-label="http://neilmitchell.blogspot.am/2013/02/chasing-space-leak-in-shake.html" rel="noopener" class="external-link" href="http://neilmitchell.blogspot.am/2013/02/chasing-space-leak-in-shake.html" target="_blank">Chasing a Space Leak in Shake</a>.</p></div><div><p>И ещё вспомним вот это:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">square</span>     <span class="token hvariable">x</span>   <span class="token operator">=</span>    <span class="token hvariable">x</span>      <span class="token operator">*</span>    <span class="token hvariable">x</span>
         <span class="token operator">/</span>   <span class="token operator">\</span>    <span class="token operator">/</span>   <span class="token operator">\</span>       <span class="token operator">/</span>   <span class="token operator">\</span>
<span class="token hvariable">square</span> <span class="token operator">$</span> <span class="token number">2</span> <span class="token operator">+</span> <span class="token number">2</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token number">2</span> <span class="token operator">+</span> <span class="token number">2</span><span class="token punctuation">)</span>   <span class="token operator">*</span> <span class="token punctuation">(</span><span class="token number">2</span> <span class="token operator">+</span> <span class="token number">2</span><span class="token punctuation">)</span>    <span class="token operator">=</span> <span class="token number">16</span>

                 вычисляем   и что<span class="token punctuation">,</span>
                             опять
                             вычисляем<span class="token operator">?!</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Внимательный читатель удивится, мол, неужели выражение&nbsp;<code>2 + 2</code>&nbsp;вычисляется дважды?! Ведь это нерационально. Конечно нерационально, поэтому в действительности оно будет вычислено единожды. В Haskell есть особый механизм «шаринга» (англ. sharing), позволяющий избежать напрасной работы. И если у нас есть несколько одинаковых выражений, вычисление оного происходит один раз, результат же сохраняется и потом просто подставляется в нужные места. Например:</p></div><div><pre><code>main :: IO ()
main =
  let x = sin 2 in print x * x
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Если бы не sharing-механизм, функция&nbsp;<code>sin</code>&nbsp;была бы применена к&nbsp;<code>2</code>&nbsp;дважды. К счастью, значение синуса будет вычислено единожды и тут же сохранено, чтобы потом просто встать на места тех двух&nbsp;<code>x</code>.</p></div><div><h1 data-heading="Наши типы" id="Наши_типы">Наши типы</h1></div><div><p>Удивительно, но в Haskell очень мало встроенных типов, то есть таких, о которых компилятор знает с самого начала. Есть&nbsp;<code>Int</code>, есть&nbsp;<code>Double</code>,&nbsp;<code>Char</code>, ну и ещё несколько. Все же остальные типы, даже носящие статус стандартных, не являются встроенными в язык. Вместо этого они определены в стандартной или иных библиотеках, причём определены точно так же, как мы будем определять и наши собственные типы. А поскольку без своих типов написать сколь-нибудь серьёзное приложение у нас не получится, тема эта достойна самого пристального взгляда.</p></div><div><p>Определим тип&nbsp;<code>Transport</code>&nbsp;для двух известных протоколов транспортного уровня модели OSI:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token keyword">data</span> <span class="token constant">Transport</span> <span class="token operator">=</span> <span class="token constant">TCP</span> <span class="token operator">|</span> <span class="token constant">UDP</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Перед нами — очень простой, но уже наш собственный тип. Рассмотрим его внимательнее.</p></div><div><p>Ключевое слово&nbsp;<code>data</code>&nbsp;— это начало определения типа. Далее следует название типа, в данном случае&nbsp;<code>Transport</code>. Имя любого типа обязано начинаться с большой буквы. Затем идёт знак равенства, после которого начинается фактическое описание типа, его «тело». В данном случае оно состоит из двух простейших конструкторов. Конструктор значения (англ. data constructor) — это то, что строит значение данного типа. Здесь у нас два конструктора,&nbsp;<code>TCP</code>&nbsp;и&nbsp;<code>UDP</code>, каждый из которых строит значение типа&nbsp;<code>Transport</code>. Имя конструктора тоже обязано начинаться с большой буквы. Иногда для краткости конструктор значения называют просто конструктором.</p></div><div><p>Подобное определение легко читается:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token keyword">data</span>  <span class="token constant">Transport</span>  <span class="token operator">=</span>    <span class="token constant">TCP</span>  <span class="token operator">|</span>    <span class="token constant">UDP</span>

тип   <span class="token constant">Transport</span>  это  <span class="token constant">TCP</span>  или  <span class="token constant">UDP</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Теперь мы можем использовать тип&nbsp;<code>Transport</code>, то есть создавать значения этого типа и что-то с ними делать. Например, в&nbsp;<code>let</code>-выражении:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded">  <span class="token keyword">let</span> <span class="token hvariable">protocol</span> <span class="token operator">=</span> <span class="token constant">TCP</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Мы создали значение&nbsp;<code>protocol</code>&nbsp;типа&nbsp;<code>Transport</code>, использовав конструктор&nbsp;<code>TCP</code>. А можно и так:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded">  <span class="token keyword">let</span> <span class="token hvariable">protocol</span> <span class="token operator">=</span> <span class="token constant">UDP</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Хотя мы использовали разные конструкторы, тип значения&nbsp;<code>protocol</code>&nbsp;в обоих случаях один и тот же —&nbsp;<code>Transport</code>.</p></div><div><p>Расширить подобный тип предельно просто. Добавим новый протокол SCTP (Stream Control Transmission Protocol):</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token keyword">data</span> <span class="token constant">Transport</span> <span class="token operator">=</span> <span class="token constant">TCP</span> <span class="token operator">|</span> <span class="token constant">UDP</span> <span class="token operator">|</span> <span class="token constant">SCTP</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Третий конструктор значения дал нам третий способ создать значение типа&nbsp;<code>Transport</code>.</p></div><div><h2 data-heading="Значение-пустышка" id="Значение-пустышка" style="display: flex;"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>Значение-пустышка</h2></div><div><p>Задумаемся: говоря о значении типа&nbsp;<code>Transport</code>&nbsp;— о чём в действительности идёт речь? Казалось бы, значения-то фактического нет: ни числа никакого, ни строки — просто три конструктора. Так вот они и есть значения. Когда мы пишем:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded">  <span class="token keyword">let</span> <span class="token hvariable">protocol</span> <span class="token operator">=</span> <span class="token constant">SCTP</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>мы создаём значение типа&nbsp;<code>Transport</code>&nbsp;с конкретным содержимым в виде&nbsp;<code>SCTP</code>. Конструктор — это и есть содержимое. Данный вид конструктора называется нульарным (англ. nullary). Тип&nbsp;<code>Transport</code>&nbsp;имеет три нульарных конструктора. И даже столь простой тип уже может быть полезен нам:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">checkProtocol</span> <span class="token operator">::</span> <span class="token constant">Transport</span> <span class="token operator">-&gt;</span> <span class="token constant">String</span>
<span class="token hvariable">checkProtocol</span> <span class="token hvariable">transport</span> <span class="token operator">=</span> <span class="token keyword">case</span> <span class="token hvariable">transport</span> <span class="token keyword">of</span>
  <span class="token constant">TCP</span>  <span class="token operator">-&gt;</span> <span class="token string">"That's TCP protocol."</span>
  <span class="token constant">UDP</span>  <span class="token operator">-&gt;</span> <span class="token string">"That's UDP protocol."</span>
  <span class="token constant">SCTP</span> <span class="token operator">-&gt;</span> <span class="token string">"That's SCTP protocol."</span>

<span class="token hvariable">main</span> <span class="token operator">::</span> <span class="token constant">IO</span> <span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token hvariable">main</span> <span class="token operator">=</span> <span class="token builtin">putStrLn</span> <span class="token operator">.</span> <span class="token hvariable">checkProtocol</span> <span class="token operator">$</span> <span class="token constant">TCP</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>В результате увидим:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token constant">That'</span><span class="token hvariable">s</span> <span class="token constant">TCP</span> <span class="token hvariable">protocol</span><span class="token punctuation">.</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Функция&nbsp;<code>checkProtocol</code>&nbsp;объявлена как принимающая аргумент типа&nbsp;<code>Transport</code>, а применяется она к значению, порождённому конструктором&nbsp;<code>TCP</code>. В данном случае конструкция&nbsp;<code>case-of</code>&nbsp;сравнивает аргумент с конструкторами. Именно поэтому нам не нужна функция&nbsp;<code>otherwise</code>, ведь никаким иным способом, кроме как с помощью трёх конструкторов, значение типа&nbsp;<code>Transport</code>&nbsp;создать невозможно, а значит, один из конструкторов гарантированно совпадёт.</p></div><div><p>Тип, состоящий только из нульарных конструкторов, называют ещё перечислением (англ. enumeration). Конструкторов может быть сколько угодно, в том числе один-единственный (хотя польза от подобного типа была бы невелика). Вот ещё один известный пример:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token keyword">data</span> <span class="token constant">Day</span> <span class="token operator">=</span> <span class="token constant">Sunday</span>
         <span class="token operator">|</span> <span class="token constant">Monday</span>
         <span class="token operator">|</span> <span class="token constant">Tuesday</span>
         <span class="token operator">|</span> <span class="token constant">Wednesday</span>
         <span class="token operator">|</span> <span class="token constant">Thursday</span>
         <span class="token operator">|</span> <span class="token constant">Friday</span>
         <span class="token operator">|</span> <span class="token constant">Saturday</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Обратите внимание на форматирование, когда ментальные «ИЛИ» выровнены строго под знаком равенства. Такой стиль вы встретите во многих реальных Haskell-проектах.</p></div><div><p>Значение типа&nbsp;<code>Day</code>&nbsp;отражено одним из семи конструкторов. Сделаем же с ними что-нибудь:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token keyword">data</span> <span class="token constant">WorkMode</span> <span class="token operator">=</span> <span class="token constant">FiveDays</span> <span class="token operator">|</span> <span class="token constant">SixDays</span>

<span class="token hvariable">workingDays</span> <span class="token operator">::</span> <span class="token constant">WorkMode</span> <span class="token operator">-&gt;</span> <span class="token punctuation">[</span><span class="token constant">Day</span><span class="token punctuation">]</span>
<span class="token hvariable">workingDays</span> <span class="token constant">FiveDays</span> <span class="token operator">=</span> <span class="token punctuation">[</span> <span class="token constant">Monday</span>
                       <span class="token punctuation">,</span> <span class="token constant">Tuesday</span>
                       <span class="token punctuation">,</span> <span class="token constant">Wednesday</span>
                       <span class="token punctuation">,</span> <span class="token constant">Thursday</span>
                       <span class="token punctuation">,</span> <span class="token constant">Friday</span>
                       <span class="token punctuation">]</span>
<span class="token hvariable">workingDays</span> <span class="token constant">SixDays</span> <span class="token operator">=</span> <span class="token punctuation">[</span> <span class="token constant">Monday</span>
                      <span class="token punctuation">,</span> <span class="token constant">Tuesday</span>
                      <span class="token punctuation">,</span> <span class="token constant">Wednesday</span>
                      <span class="token punctuation">,</span> <span class="token constant">Thursday</span>
                      <span class="token punctuation">,</span> <span class="token constant">Friday</span>
                      <span class="token punctuation">,</span> <span class="token constant">Saturday</span>
                      <span class="token punctuation">]</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Итого рабочий пример от меня:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token keyword">data</span> <span class="token constant">Day</span> <span class="token operator">=</span> <span class="token constant">Sunday</span>
         <span class="token operator">|</span> <span class="token constant">Monday</span>
         <span class="token operator">|</span> <span class="token constant">Tuesday</span>
         <span class="token operator">|</span> <span class="token constant">Wednesday</span>
         <span class="token operator">|</span> <span class="token constant">Thursday</span>
         <span class="token operator">|</span> <span class="token constant">Friday</span>
         <span class="token operator">|</span> <span class="token constant">Saturday</span>

<span class="token keyword">data</span> <span class="token constant">WorkMode</span> <span class="token operator">=</span> <span class="token constant">FiveDays</span> <span class="token operator">|</span> <span class="token constant">SixDays</span>

<span class="token hvariable">workingDays</span> <span class="token operator">::</span> <span class="token constant">WorkMode</span> <span class="token operator">-&gt;</span> <span class="token punctuation">[</span><span class="token constant">Day</span><span class="token punctuation">]</span>
<span class="token hvariable">workingDays</span> <span class="token constant">FiveDays</span> <span class="token operator">=</span> <span class="token punctuation">[</span> <span class="token constant">Monday</span>
                       <span class="token punctuation">,</span> <span class="token constant">Tuesday</span>
                       <span class="token punctuation">,</span> <span class="token constant">Wednesday</span>
                       <span class="token punctuation">,</span> <span class="token constant">Thursday</span>
                       <span class="token punctuation">,</span> <span class="token constant">Friday</span>
                       <span class="token punctuation">]</span>
<span class="token hvariable">workingDays</span> <span class="token constant">SixDays</span> <span class="token operator">=</span> <span class="token punctuation">[</span> <span class="token constant">Monday</span>
                      <span class="token punctuation">,</span> <span class="token constant">Tuesday</span>
                      <span class="token punctuation">,</span> <span class="token constant">Wednesday</span>
                      <span class="token punctuation">,</span> <span class="token constant">Thursday</span>
                      <span class="token punctuation">,</span> <span class="token constant">Friday</span>
                      <span class="token punctuation">,</span> <span class="token constant">Saturday</span>
                      <span class="token punctuation">]</span>

<span class="token hvariable">dayToString</span> <span class="token operator">::</span> <span class="token constant">Day</span> <span class="token operator">-&gt;</span> <span class="token constant">String</span>
<span class="token hvariable">dayToString</span> <span class="token constant">Sunday</span>    <span class="token operator">=</span> <span class="token string">"Sunday"</span>
<span class="token hvariable">dayToString</span> <span class="token constant">Monday</span>    <span class="token operator">=</span> <span class="token string">"Monday"</span>
<span class="token hvariable">dayToString</span> <span class="token constant">Tuesday</span>   <span class="token operator">=</span> <span class="token string">"Tuesday"</span>
<span class="token hvariable">dayToString</span> <span class="token constant">Wednesday</span> <span class="token operator">=</span> <span class="token string">"Wednesday"</span>
<span class="token hvariable">dayToString</span> <span class="token constant">Thursday</span>  <span class="token operator">=</span> <span class="token string">"Thursday"</span>
<span class="token hvariable">dayToString</span> <span class="token constant">Friday</span>    <span class="token operator">=</span> <span class="token string">"Friday"</span>
<span class="token hvariable">dayToString</span> <span class="token constant">Saturday</span>  <span class="token operator">=</span> <span class="token string">"Saturday"</span>



<span class="token hvariable">main</span> <span class="token operator">::</span> <span class="token constant">IO</span> <span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token hvariable">main</span> <span class="token operator">=</span> <span class="token builtin">print</span> <span class="token operator">.</span> <span class="token builtin">map</span> <span class="token hvariable">dayToString</span> <span class="token operator">$</span> <span class="token hvariable">workingDays</span> <span class="token constant">SixDays</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Функция&nbsp;<code>workingDays</code>&nbsp;возвращает список типа&nbsp;<code>[Day]</code>, и в случае пятидневной рабочей недели, отражённой конструктором&nbsp;<code>FiveDays</code>, этот список сформирован пятью конструкторами, а в случае шестидневной — шестью конструкторами.</p></div><div><p>Польза от типов, сформированных нульарными конструкторами, не очень велика, хотя встречаться с такими типами вы будете часто.</p></div><div><p>Приоткрою секрет: новый тип можно определить не только с помощью ключевого слова&nbsp;<code>data</code>, но об этом узнаем в одной из следующих глав.</p></div><div><p>А теперь мы можем познакомиться с типами куда более полезными.</p></div><div><h1 data-heading="АТД" id="АТД">АТД</h1></div><div><p>АТД, или Алгебраические Типы Данных (англ. ADT, Algebraic Data Type), занимают почётное место в мире типов Haskell. Абсолютно подавляющее большинство ваших собственных типов будут алгебраическими, и то же можно сказать о типах из множества Haskell-пакетов. Алгебраическим типом данных называют такой тип, который составлен из других типов. Мы берём простые типы и строим из них, как из кирпичей, типы сложные, а из них — ещё более сложные. Это даёт нам невероятный простор для творчества.</p></div><div><p>Оставим сетевые протоколы и дни недели, рассмотрим такой пример:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token keyword">data</span> <span class="token constant">IPAddress</span> <span class="token operator">=</span> <span class="token constant">IPAddress</span> <span class="token constant">String</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Тип&nbsp;<code>IPAddress</code>&nbsp;использует один-единственный конструктор значения, но кое-что изменилось. Во-первых, имена типа и конструктора совпадают. Это вполне легально, вы встретите такое не раз. Во-вторых, конструктор уже не нульарный, а унарный (англ. unary), потому что теперь он связан с одним значением типа&nbsp;<code>String</code>. И вот как создаются значения типа&nbsp;<code>IPAddress</code>:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded">  <span class="token keyword">let</span> <span class="token hvariable">ip</span> <span class="token operator">=</span> <span class="token constant">IPAddress</span> <span class="token string">"127.0.0.1"</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Значение&nbsp;<code>ip</code>&nbsp;типа&nbsp;<code>IPAddress</code>&nbsp;образовано конструктором и конкретным значением некоего типа:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded">  <span class="token keyword">let</span> <span class="token hvariable">ip</span> <span class="token operator">=</span> <span class="token constant">IPAddress</span>       <span class="token string">"127.0.0.1"</span>

           конструктор     значение
           значения        типа
           типа <span class="token constant">IPAddress</span>  <span class="token constant">String</span>

           └ значение типа <span class="token constant">IPAddress</span> ┘
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Значение внутри нашего типа называют ещё полем (англ. field):</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token keyword">data</span> <span class="token constant">IPAddress</span> <span class="token operator">=</span> <span class="token constant">IPAddress</span>    <span class="token constant">String</span>

     тип         конструктор  поле
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Расширим тип&nbsp;<code>IPAddress</code>, сделав его более современным:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token keyword">data</span> <span class="token constant">IPAddress</span> <span class="token operator">=</span> <span class="token constant">IPv4</span> <span class="token constant">String</span> <span class="token operator">|</span> <span class="token constant">IPv6</span> <span class="token constant">String</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Теперь у нас два конструктора, соответствующих разным IP-версиям. Это позволит нам создавать значение типа&nbsp;<code>IPAddress</code>&nbsp;так:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded">  <span class="token keyword">let</span> <span class="token hvariable">ip</span> <span class="token operator">=</span> <span class="token constant">IPv4</span> <span class="token string">"127.0.0.1"</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>или так:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded">  <span class="token keyword">let</span> <span class="token hvariable">ip</span> <span class="token operator">=</span> <span class="token constant">IPv6</span> <span class="token string">"2001:0db8:0000:0042:0000:8a2e:0370:7334"</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Сделаем тип ещё более удобным. Так, при работе с IP-адресом нам часто требуется&nbsp;<code>localhost</code>. И чтобы явно не писать&nbsp;<code>"127.0.0.1"</code>&nbsp;и&nbsp;<code>"0:0:0:0:0:0:0:1"</code>, введём ещё два конструктора:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token keyword">data</span> <span class="token constant">IPAddress</span> <span class="token operator">=</span> <span class="token constant">IPv4</span> <span class="token constant">String</span>
               <span class="token operator">|</span> <span class="token constant">IPv4Localhost</span>
               <span class="token operator">|</span> <span class="token constant">IPv6</span> <span class="token constant">String</span>
               <span class="token operator">|</span> <span class="token constant">IPv6Localhost</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Поскольку значения&nbsp;<code>localhost</code>&nbsp;нам заведомо известны, нет нужды указывать их явно. Вместо этого, когда нам понадобится&nbsp;<code>IPv4-localhost</code>, пишем так:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded">    <span class="token keyword">let</span> <span class="token hvariable">ip</span> <span class="token operator">=</span> <span class="token constant">IPv4Localhost</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><h2 data-heading="Извлекаем значение" id="Извлекаем_значение" style="display: flex;"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>Извлекаем значение</h2></div><div><p>Допустим, мы создали значение&nbsp;<code>google</code>:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded">  <span class="token keyword">let</span> <span class="token hvariable">google</span> <span class="token operator">=</span> <span class="token constant">IPv4</span> <span class="token string">"173.194.122.194"</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Как же нам потом извлечь конкретное строковое значение из&nbsp;<code>google</code>? С помощью нашего старого друга, паттерн матчинга:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">checkIP</span> <span class="token operator">::</span> <span class="token constant">IPAddress</span> <span class="token operator">-&gt;</span> <span class="token constant">String</span>
<span class="token hvariable">checkIP</span> <span class="token punctuation">(</span><span class="token constant">IPv4</span> <span class="token hvariable">address</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token string">"IP is '"</span> <span class="token operator">++</span> <span class="token hvariable">address</span> <span class="token operator">++</span> <span class="token string">"'."</span>

<span class="token hvariable">main</span> <span class="token operator">::</span> <span class="token constant">IO</span> <span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token hvariable">main</span> <span class="token operator">=</span> <span class="token builtin">putStrLn</span> <span class="token operator">.</span> <span class="token hvariable">checkIP</span> <span class="token operator">$</span> <span class="token constant">IPv4</span> <span class="token string">"173.194.122.194"</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Результат:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token constant">IP</span> <span class="token hvariable">is</span> '<span class="token number">173.194</span><span class="token punctuation">.</span><span class="token number">122.194</span>'<span class="token punctuation">.</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Взглянем на определение:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">checkIP</span> <span class="token punctuation">(</span><span class="token constant">IPv4</span> <span class="token hvariable">address</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token string">"IP is '"</span> <span class="token operator">++</span> <span class="token hvariable">address</span> <span class="token operator">++</span> <span class="token string">"'."</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Здесь мы говорим: «Мы знаем, что значение типа&nbsp;<code>IPAddress</code>&nbsp;сформировано с конструктором и строкой». Однако внимательный компилятор сделает нам замечание:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token constant">Pattern</span> <span class="token hvariable">match</span><span class="token punctuation">(</span><span class="token hvariable">es</span><span class="token punctuation">)</span> <span class="token hvariable">are</span> <span class="token hvariable">non</span><span class="token operator">-</span><span class="token hvariable">exhaustive</span>
<span class="token constant">In</span> <span class="token hvariable">an</span> <span class="token hvariable">equation</span> <span class="token hvariable">for</span> ‘<span class="token hvariable">checkIP</span>’<span class="token operator">:</span>
    <span class="token constant">Patterns</span> <span class="token builtin">not</span> <span class="token hvariable">matched</span><span class="token operator">:</span>
        <span class="token constant">IPv4Localhost</span>
        <span class="token constant">IPv6</span> <span class="token hvariable">_</span>
        <span class="token constant">IPv6Localhost</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>В самом деле, откуда мы знаем, что значение, к которому применили функцию&nbsp;<code>checkIP</code>, было сформировано именно с помощью конструктора&nbsp;<code>IPv4</code>? У нас же есть ещё три конструктора, и нам следует проверить их все:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">checkIP</span> <span class="token operator">::</span> <span class="token constant">IPAddress</span> <span class="token operator">-&gt;</span> <span class="token constant">String</span>
<span class="token hvariable">checkIP</span> <span class="token punctuation">(</span><span class="token constant">IPv4</span> <span class="token hvariable">address</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token string">"IPv4 is '"</span> <span class="token operator">++</span> <span class="token hvariable">address</span> <span class="token operator">++</span> <span class="token string">"'."</span>
<span class="token hvariable">checkIP</span> <span class="token constant">IPv4Localhost</span>  <span class="token operator">=</span> <span class="token string">"IPv4, localhost."</span>
<span class="token hvariable">checkIP</span> <span class="token punctuation">(</span><span class="token constant">IPv6</span> <span class="token hvariable">address</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token string">"IPv6 is '"</span> <span class="token operator">++</span> <span class="token hvariable">address</span> <span class="token operator">++</span> <span class="token string">"'."</span>
<span class="token hvariable">checkIP</span> <span class="token constant">IPv6Localhost</span>  <span class="token operator">=</span> <span class="token string">"IPv6, localhost."</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>С каким конструктором совпало — с таким и было создано значение. Можно, конечно, и так проверить:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">checkIP</span> <span class="token operator">::</span> <span class="token constant">IPAddress</span> <span class="token operator">-&gt;</span> <span class="token constant">String</span>
<span class="token hvariable">checkIP</span> <span class="token hvariable">addr</span> <span class="token operator">=</span> <span class="token keyword">case</span> <span class="token hvariable">addr</span> <span class="token keyword">of</span>
    <span class="token constant">IPv4</span> <span class="token hvariable">address</span>  <span class="token operator">-&gt;</span> <span class="token string">"IPv4 is '"</span> <span class="token operator">++</span> <span class="token hvariable">address</span> <span class="token operator">++</span> <span class="token string">"'."</span>
    <span class="token constant">IPv4Localhost</span> <span class="token operator">-&gt;</span> <span class="token string">"IPv4, localhost."</span>
    <span class="token constant">IPv6</span> <span class="token hvariable">address</span>  <span class="token operator">-&gt;</span> <span class="token string">"IPv6 is '"</span> <span class="token operator">++</span> <span class="token hvariable">address</span> <span class="token operator">++</span> <span class="token string">"'."</span>
    <span class="token constant">IPv6Localhost</span> <span class="token operator">-&gt;</span> <span class="token string">"IPv6, localhost."</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><h2 data-heading="Строим" id="Строим" style="display: flex;"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>Строим</h2></div><div><p>Определим тип для сетевой точки:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token keyword">data</span> <span class="token constant">EndPoint</span> <span class="token operator">=</span> <span class="token constant">EndPoint</span> <span class="token constant">String</span> <span class="token constant">Int</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Конструктор&nbsp;<code>EndPoint</code>&nbsp;— бинарный, ведь здесь уже два значения. Создаём обычным образом:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded">  <span class="token keyword">let</span> <span class="token hvariable">googlePoint</span> <span class="token operator">=</span> <span class="token constant">EndPoint</span> <span class="token string">"173.194.122.194"</span> <span class="token number">80</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Конкретные значения извлекаем опять-таки через паттерн матчинг:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">main</span> <span class="token operator">::</span> <span class="token constant">IO</span> <span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token hvariable">main</span> <span class="token operator">=</span> <span class="token builtin">putStrLn</span> <span class="token operator">$</span> <span class="token string">"The host is: "</span> <span class="token operator">++</span> <span class="token hvariable">host</span>
  <span class="token keyword">where</span>
    <span class="token constant">EndPoint</span> <span class="token hvariable">host</span> <span class="token hvariable">_</span> <span class="token operator">=</span> <span class="token constant">EndPoint</span> <span class="token string">"173.194.122.194"</span> <span class="token number">80</span>

    └── образец ──┘   └──────── значение ─────────┘
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Обратите внимание, что второе поле, соответствующее порту, отражено универсальным образцом&nbsp;<code>_</code>, потому что в данном случае нас интересует только значение хоста, а порт просто игнорируется.</p></div><div><p>И всё бы хорошо, но тип&nbsp;<code>EndPoint</code>&nbsp;мне не очень нравится. Есть в нём что-то некрасивое. Первым полем выступает строка, содержащая IP-адрес, но зачем нам строка? У нас же есть прекрасный тип&nbsp;<code>IPAddress</code>, он куда лучше безликой строки. Это общее правило для Haskell-разработчика: чем больше информации несёт в себе тип, тем он лучше. Давайте заменим определение:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token keyword">data</span> <span class="token constant">EndPoint</span> <span class="token operator">=</span> <span class="token constant">EndPoint</span> <span class="token constant">IPAddress</span> <span class="token constant">Int</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Тип стал понятнее, и вот как мы теперь будем создавать значения:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded">  <span class="token keyword">let</span> <span class="token hvariable">google</span> <span class="token operator">=</span> <span class="token constant">EndPoint</span> <span class="token punctuation">(</span><span class="token constant">IPv4</span> <span class="token string">"173.194.122.194"</span><span class="token punctuation">)</span> <span class="token number">80</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Красиво. Извлекать конкретные значения будем так:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">main</span> <span class="token operator">::</span> <span class="token constant">IO</span> <span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token hvariable">main</span> <span class="token operator">=</span> <span class="token builtin">putStrLn</span> <span class="token operator">$</span> <span class="token string">"The host is: "</span> <span class="token operator">++</span> <span class="token hvariable">ip</span>
  <span class="token keyword">where</span>
    <span class="token constant">EndPoint</span> <span class="token punctuation">(</span><span class="token constant">IPv4</span> <span class="token hvariable">ip</span><span class="token punctuation">)</span> <span class="token hvariable">_</span> <span class="token operator">=</span> <span class="token constant">EndPoint</span> <span class="token punctuation">(</span><span class="token constant">IPv4</span> <span class="token string">"173.194.122.194"</span><span class="token punctuation">)</span> <span class="token number">80</span>
              <span class="token hvariable">____</span>                   <span class="token hvariable">____</span>

                   <span class="token operator">==</span>                     <span class="token operator">=================</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Здесь мы опять-таки игнорируем порт, но значение IP-адреса извлекаем уже на основе образца с конструктором&nbsp;<code>IPv4</code>.</p></div><div><p>Это простой пример того, как из простых типов строятся более сложные. Но сложный тип вовсе не означает сложную работу с ним, паттерн матчинг элегантен как всегда. А вскоре мы узнаем о другом способе работы с полями типов, без паттерн матчинга.</p></div><div><p>Любопытно, что конструкторы типов тоже можно компоновать, взгляните:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">main</span> <span class="token operator">::</span> <span class="token constant">IO</span> <span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token hvariable">main</span> <span class="token operator">=</span> <span class="token builtin">putStrLn</span> <span class="token operator">$</span> <span class="token string">"The host is: "</span> <span class="token operator">++</span> <span class="token hvariable">ip</span>
  <span class="token keyword">where</span>
    <span class="token constant">EndPoint</span> <span class="token punctuation">(</span><span class="token constant">IPv4</span> <span class="token hvariable">ip</span><span class="token punctuation">)</span> <span class="token hvariable">_</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token constant">EndPoint</span> <span class="token operator">.</span> <span class="token constant">IPv4</span> <span class="token operator">$</span> <span class="token string">"173.194.122.194"</span><span class="token punctuation">)</span> <span class="token number">80</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Это похоже на маленькое волшебство, но конструкторы типов можно компоновать знакомым нам оператором композиции функций:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token punctuation">(</span><span class="token constant">EndPoint</span> <span class="token operator">.</span> <span class="token constant">IPv4</span> <span class="token operator">$</span> <span class="token string">"173.194.122.194"</span><span class="token punctuation">)</span> <span class="token number">80</span>

            │       значение типа      │
            └──────── <span class="token constant">IPAddress</span> ───────┘
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Вам это ничего не напоминает? Это же в точности так, как мы работали с функциями! Из этого мы делаем вывод: конструктор значения можно рассматривать как особую функцию. В самом деле:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token constant">EndPoint</span>   <span class="token punctuation">(</span><span class="token constant">IPv4</span> <span class="token string">"173.194.122.194"</span><span class="token punctuation">)</span>  <span class="token number">80</span>

<span class="token string">"функция"</span>  │        первый        │  второй
           └────── аргумент ──────┘  аргумент
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Мы как бы применяем конструктор к конкретным значениям как к аргументам, в результате чего получаем значение нашего типа. А раз так, мы можем компоновать конструкторы так же, как и обычные функции, лишь бы их типы были комбинируемыми. В данном случае всё в порядке: тип значения, возвращаемого конструктором&nbsp;<code>IPv4</code>, совпадает с типом первого аргумента конструктора&nbsp;<code>EndPoint</code>.</p></div><div><p>Вот мы и познакомились с настоящими типами. Пришло время узнать о более удобной работе с полями типов.</p></div><div><p>Итого:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token keyword">data</span> <span class="token constant">IPAddress</span> <span class="token operator">=</span> <span class="token constant">IPv4</span> <span class="token constant">String</span>
               <span class="token operator">|</span> <span class="token constant">IPv4Localhost</span>
               <span class="token operator">|</span> <span class="token constant">IPv6</span> <span class="token constant">String</span>
               <span class="token operator">|</span> <span class="token constant">IPv6Localhost</span>

<span class="token hvariable">checkIP</span> <span class="token operator">::</span> <span class="token constant">IPAddress</span> <span class="token operator">-&gt;</span> <span class="token constant">String</span>
<span class="token hvariable">checkIP</span> <span class="token punctuation">(</span><span class="token constant">IPv4</span> <span class="token hvariable">address</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token string">"IPv4 is '"</span> <span class="token operator">++</span> <span class="token hvariable">address</span> <span class="token operator">++</span> <span class="token string">"'."</span>
<span class="token hvariable">checkIP</span> <span class="token constant">IPv4Localhost</span>  <span class="token operator">=</span> <span class="token string">"IPv4, localhost."</span>
<span class="token hvariable">checkIP</span> <span class="token punctuation">(</span><span class="token constant">IPv6</span> <span class="token hvariable">address</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token string">"IPv6 is '"</span> <span class="token operator">++</span> <span class="token hvariable">address</span> <span class="token operator">++</span> <span class="token string">"'."</span>
<span class="token hvariable">checkIP</span> <span class="token constant">IPv6Localhost</span>  <span class="token operator">=</span> <span class="token string">"IPv6, localhost."</span>


<span class="token keyword">data</span> <span class="token constant">EndPoint</span> <span class="token operator">=</span> <span class="token constant">EndPoint</span> <span class="token constant">IPAddress</span> <span class="token constant">Int</span>


<span class="token hvariable">main</span> <span class="token operator">::</span> <span class="token constant">IO</span> <span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token hvariable">main</span> <span class="token operator">=</span> <span class="token builtin">putStrLn</span> <span class="token operator">$</span> <span class="token string">"The host is: "</span> <span class="token operator">++</span> <span class="token hvariable">ip</span>
  <span class="token keyword">where</span>
    <span class="token constant">EndPoint</span> <span class="token punctuation">(</span><span class="token constant">IPv4</span> <span class="token hvariable">ip</span><span class="token punctuation">)</span> <span class="token hvariable">_</span> <span class="token operator">=</span> <span class="token constant">EndPoint</span> <span class="token punctuation">(</span><span class="token constant">IPv4</span>  <span class="token string">"173.194.122.194"</span><span class="token punctuation">)</span> <span class="token number">80</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><h1 data-heading="АТД: поля с метками" id="АТД:_поля_с_метками">АТД: поля с метками</h1></div><div><p>Многие типы в реальных проектах довольно велики. Взгляните:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token keyword">data</span> <span class="token constant">Arguments</span> <span class="token operator">=</span> <span class="token constant">Arguments</span> <span class="token constant">Port</span>
                           <span class="token constant">Endpoint</span>
                           <span class="token constant">RedirectData</span>
                           <span class="token constant">FilePath</span>
                           <span class="token constant">FilePath</span>
                           <span class="token constant">Bool</span>
                           <span class="token constant">FilePath</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Значение типа&nbsp;<code>Arguments</code>&nbsp;хранит в своих полях некоторые значения, извлечённые из параметров командной строки, с которыми запущена одна из моих программ. И всё бы хорошо, но работать с таким типом абсолютно неудобно. Он содержит семь полей, и паттерн матчинг был бы слишком громоздким, представьте себе:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token operator">...</span>
  <span class="token keyword">where</span>
    <span class="token constant">Arguments</span> <span class="token hvariable">_</span> <span class="token hvariable">_</span> <span class="token hvariable">_</span> <span class="token hvariable">redirectLib</span> <span class="token hvariable">_</span> <span class="token hvariable">_</span> <span class="token hvariable">xpi</span> <span class="token operator">=</span> <span class="token hvariable">arguments</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Более того, когда мы смотрим на определение типа, назначение его полей остаётся тайной за семью печатями. Видите предпоследнее поле? Оно имеет тип&nbsp;<code>Bool</code>&nbsp;и, понятное дело, отражает какой-то флаг. Но что это за флаг, читатель не представляет. К счастью, существует способ, спасающих нас от обеих этих проблем.</p></div><div><h2 data-heading="Метки" id="Метки" style="display: flex;"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>Метки</h2></div><div><p>Мы можем снабдить наши поля метками (англ. label). Вот как это выглядит:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token keyword">data</span> <span class="token constant">Arguments</span> <span class="token operator">=</span> <span class="token constant">Arguments</span> <span class="token punctuation">{</span> <span class="token hvariable">runWDServer</span>    <span class="token operator">::</span> <span class="token constant">Port</span>
                           <span class="token punctuation">,</span> <span class="token hvariable">withWDServer</span>   <span class="token operator">::</span> <span class="token constant">Endpoint</span>
                           <span class="token punctuation">,</span> <span class="token hvariable">redirect</span>       <span class="token operator">::</span> <span class="token constant">RedirectData</span>
                           <span class="token punctuation">,</span> <span class="token hvariable">redirectLib</span>    <span class="token operator">::</span> <span class="token constant">FilePath</span>
                           <span class="token punctuation">,</span> <span class="token hvariable">screenshotsDir</span> <span class="token operator">::</span> <span class="token constant">FilePath</span>
                           <span class="token punctuation">,</span> <span class="token hvariable">noScreenshots</span>  <span class="token operator">::</span> <span class="token constant">Bool</span>
                           <span class="token punctuation">,</span> <span class="token hvariable">harWithXPI</span>     <span class="token operator">::</span> <span class="token constant">FilePath</span>
                           <span class="token punctuation">}</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Теперь назначение меток куда понятнее. Схема определения такова:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token keyword">data</span> <span class="token constant">Arguments</span> <span class="token operator">=</span> <span class="token constant">Arguments</span>   <span class="token punctuation">{</span> <span class="token hvariable">runWDServer</span> <span class="token operator">::</span> <span class="token constant">Port</span> <span class="token punctuation">}</span>

тип  такой<span class="token operator">-</span>то    конструктор   метка поля     тип
                                              поля
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Теперь поле имеет не только тип, но и название, что и делает наше определение значительно более читабельным. Поля в этом случае разделены запятыми и заключены в фигурные скобки.</p></div><div><p>Если подряд идут два или более поля одного типа, его можно указать лишь для последней из меток. Так, если у нас есть вот такой тип:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token keyword">data</span> <span class="token constant">Patient</span> <span class="token operator">=</span> <span class="token constant">Patient</span> <span class="token punctuation">{</span> <span class="token hvariable">firstName</span> <span class="token operator">::</span> <span class="token constant">String</span>
                       <span class="token punctuation">,</span> <span class="token hvariable">lastName</span>  <span class="token operator">::</span> <span class="token constant">String</span>
                       <span class="token punctuation">,</span> <span class="token hvariable">email</span>     <span class="token operator">::</span> <span class="token constant">String</span>
                       <span class="token punctuation">}</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>его определение можно чуток упростить и написать так:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token keyword">data</span> <span class="token constant">Patient</span> <span class="token operator">=</span> <span class="token constant">Patient</span> <span class="token punctuation">{</span> <span class="token hvariable">firstName</span>
                       <span class="token punctuation">,</span> <span class="token hvariable">lastName</span>
                       <span class="token punctuation">,</span> <span class="token hvariable">email</span>     <span class="token operator">::</span> <span class="token constant">String</span>
                       <span class="token punctuation">}</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Раз тип всех трёх полей одинаков, мы указываем его лишь для последней из меток. Ещё пример полной формы:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token keyword">data</span> <span class="token constant">Patient</span> <span class="token operator">=</span> <span class="token constant">Patient</span> <span class="token punctuation">{</span> <span class="token hvariable">firstName</span>    <span class="token operator">::</span> <span class="token constant">String</span>
                       <span class="token punctuation">,</span> <span class="token hvariable">lastName</span>     <span class="token operator">::</span> <span class="token constant">String</span>
                       <span class="token punctuation">,</span> <span class="token hvariable">email</span>        <span class="token operator">::</span> <span class="token constant">String</span>
                       <span class="token punctuation">,</span> <span class="token hvariable">age</span>          <span class="token operator">::</span> <span class="token constant">Int</span>
                       <span class="token punctuation">,</span> <span class="token hvariable">diseaseId</span>    <span class="token operator">::</span> <span class="token constant">Int</span>
                       <span class="token punctuation">,</span> <span class="token hvariable">isIndoor</span>     <span class="token operator">::</span> <span class="token constant">Bool</span>
                       <span class="token punctuation">,</span> <span class="token hvariable">hasInsurance</span> <span class="token operator">::</span> <span class="token constant">Bool</span>
                       <span class="token punctuation">}</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>и тут же упрощаем:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token keyword">data</span> <span class="token constant">Patient</span> <span class="token operator">=</span> <span class="token constant">Patient</span> <span class="token punctuation">{</span> <span class="token hvariable">firstName</span>
                       <span class="token punctuation">,</span> <span class="token hvariable">lastName</span>
                       <span class="token punctuation">,</span> <span class="token hvariable">email</span>        <span class="token operator">::</span> <span class="token constant">String</span>
                       <span class="token punctuation">,</span> <span class="token hvariable">age</span>
                       <span class="token punctuation">,</span> <span class="token hvariable">diseaseId</span>    <span class="token operator">::</span> <span class="token constant">Int</span>
                       <span class="token punctuation">,</span> <span class="token hvariable">isIndoor</span>
                       <span class="token punctuation">,</span> <span class="token hvariable">hasInsurance</span> <span class="token operator">::</span> <span class="token constant">Bool</span>
                       <span class="token punctuation">}</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Поля&nbsp;<code>firstName</code>,&nbsp;<code>lastName</code>&nbsp;и&nbsp;<code>email</code>&nbsp;имеют тип&nbsp;<code>String</code>, поля&nbsp;<code>age</code>&nbsp;и&nbsp;<code>diseaseId</code>&nbsp;— тип&nbsp;<code>Int</code>, и оставшиеся два поля — тип&nbsp;<code>Bool</code>.</p></div><div><h2 data-heading="Getter и Setter?" id="Getter_и_Setter?" style="display: flex;"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>Getter и Setter?</h2></div><div><p>Что же представляют собой метки? Фактически, это особые функции, сгенерированные автоматически. Эти функции имеют три предназначения: создавать, извлекать и изменять. Да, я не оговорился, изменять. Но об этом чуть позже, пусть будет маленькая интрига.</p></div><div><p>Вот как мы создаём значение типа&nbsp;<code>Patient</code></p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">main</span> <span class="token operator">::</span> <span class="token constant">IO</span> <span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token hvariable">main</span> <span class="token operator">=</span> <span class="token builtin">print</span> <span class="token operator">$</span> <span class="token hvariable">diseaseId</span> <span class="token hvariable">patient</span>
  <span class="token keyword">where</span>
    <span class="token hvariable">patient</span> <span class="token operator">=</span> <span class="token constant">Patient</span> <span class="token punctuation">{</span>
        <span class="token hvariable">firstName</span>    <span class="token operator">=</span> <span class="token string">"John"</span>
      <span class="token punctuation">,</span> <span class="token hvariable">lastName</span>     <span class="token operator">=</span> <span class="token string">"Doe"</span>
      <span class="token punctuation">,</span> <span class="token hvariable">email</span>        <span class="token operator">=</span> <span class="token string">"john.doe@gmail.com"</span>
      <span class="token punctuation">,</span> <span class="token hvariable">age</span>          <span class="token operator">=</span> <span class="token number">24</span>
      <span class="token punctuation">,</span> <span class="token hvariable">diseaseId</span>    <span class="token operator">=</span> <span class="token number">431</span>
      <span class="token punctuation">,</span> <span class="token hvariable">isIndoor</span>     <span class="token operator">=</span> <span class="token constant">True</span>
      <span class="token punctuation">,</span> <span class="token hvariable">hasInsurance</span> <span class="token operator">=</span> <span class="token constant">True</span>
    <span class="token punctuation">}</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Метки полей используются как своего рода setter (от англ. set, «устанавливать»):</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">patient</span> <span class="token operator">=</span> <span class="token constant">Patient</span> <span class="token punctuation">{</span> <span class="token hvariable">firstName</span>    <span class="token operator">=</span>      <span class="token string">"John"</span>
в этом    типа      поле с
значении  <span class="token constant">Patient</span>   этой меткой  равно  этой строке
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Кроме того, метку можно использовать и как getter (от англ. get, «получать»):</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">main</span> <span class="token operator">=</span> <span class="token builtin">print</span> <span class="token operator">$</span> <span class="token hvariable">diseaseId</span>  <span class="token hvariable">patient</span>

               метка как  аргумент
               функции
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Мы применяем метку к значению типа&nbsp;<code>Patient</code>&nbsp;и получаем значение соответствующего данной метке поля. Поэтому для получения значений полей нам уже не нужен паттерн матчинг.</p></div><div><p>Но что же за интригу я приготовил под конец? Выше я упомянул, что метки используются не только для задания значений полей и для их извлечения, но и для изменения. Вот что я имел в виду:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">main</span> <span class="token operator">::</span> <span class="token constant">IO</span> <span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token hvariable">main</span> <span class="token operator">=</span> <span class="token builtin">print</span> <span class="token operator">$</span> <span class="token hvariable">email</span> <span class="token hvariable">patientWithChangedEmail</span>
  <span class="token keyword">where</span>
    <span class="token hvariable">patientWithChangedEmail</span> <span class="token operator">=</span> <span class="token hvariable">patient</span> <span class="token punctuation">{</span>
      <span class="token hvariable">email</span> <span class="token operator">=</span> <span class="token string">"j.d@gmail.com"</span>  <span class="token comment">-- Изменяем???</span>
    <span class="token punctuation">}</span>

    <span class="token hvariable">patient</span> <span class="token operator">=</span> <span class="token constant">Patient</span> <span class="token punctuation">{</span>
        <span class="token hvariable">firstName</span>    <span class="token operator">=</span> <span class="token string">"John"</span>
      <span class="token punctuation">,</span> <span class="token hvariable">lastName</span>     <span class="token operator">=</span> <span class="token string">"Doe"</span>
      <span class="token punctuation">,</span> <span class="token hvariable">email</span>        <span class="token operator">=</span> <span class="token string">"john.doe@gmail.com"</span>
      <span class="token punctuation">,</span> <span class="token hvariable">age</span>          <span class="token operator">=</span> <span class="token number">24</span>
      <span class="token punctuation">,</span> <span class="token hvariable">diseaseId</span>    <span class="token operator">=</span> <span class="token number">431</span>
      <span class="token punctuation">,</span> <span class="token hvariable">isIndoor</span>     <span class="token operator">=</span> <span class="token constant">True</span>
      <span class="token punctuation">,</span> <span class="token hvariable">hasInsurance</span> <span class="token operator">=</span> <span class="token constant">True</span>
    <span class="token punctuation">}</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>При запуске программы получим:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">j</span><span class="token punctuation">.</span><span class="token hvariable">d</span><span class="token operator">@</span><span class="token hvariable">gmail</span><span class="token punctuation">.</span><span class="token hvariable">com</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Но постойте, что же тут произошло? Ведь в Haskell, как мы знаем, нет оператора присваивания, однако значение поля с меткой&nbsp;<code>email</code>&nbsp;поменялось. Помню, когда я впервые увидел подобный пример, то очень удивился, мол, уж не ввели ли меня в заблуждение по поводу неизменности значений в Haskell?!</p></div><div><p>Нет, не ввели. Подобная запись:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">patientWithChangedEmail</span> <span class="token operator">=</span> <span class="token hvariable">patient</span> <span class="token punctuation">{</span>
  <span class="token hvariable">email</span> <span class="token operator">=</span> <span class="token string">"j.d@gmail.com"</span>
<span class="token punctuation">}</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>действительно похожа на изменение поля через присваивание ему нового значения, но в действительности никакого изменения не произошло. Когда я назвал метку setter-ом, я немного слукавил, ведь классический setter из мира ООП был бы невозможен в Haskell. Посмотрим ещё раз внимательнее:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token operator">...</span>
  <span class="token keyword">where</span>
    <span class="token hvariable">patientWithChangedEmail</span> <span class="token operator">=</span> <span class="token hvariable">patient</span> <span class="token punctuation">{</span>
      <span class="token hvariable">email</span> <span class="token operator">=</span> <span class="token string">"j.d@gmail.com"</span>  <span class="token comment">-- Изменяем???</span>
    <span class="token punctuation">}</span>

    <span class="token hvariable">patient</span> <span class="token operator">=</span> <span class="token constant">Patient</span> <span class="token punctuation">{</span>
        <span class="token hvariable">firstName</span>    <span class="token operator">=</span> <span class="token string">"John"</span>
      <span class="token punctuation">,</span> <span class="token hvariable">lastName</span>     <span class="token operator">=</span> <span class="token string">"Doe"</span>
      <span class="token punctuation">,</span> <span class="token hvariable">email</span>        <span class="token operator">=</span> <span class="token string">"john.doe@gmail.com"</span>
      <span class="token punctuation">,</span> <span class="token hvariable">age</span>          <span class="token operator">=</span> <span class="token number">24</span>
      <span class="token punctuation">,</span> <span class="token hvariable">diseaseId</span>    <span class="token operator">=</span> <span class="token number">431</span>
      <span class="token punctuation">,</span> <span class="token hvariable">isIndoor</span>     <span class="token operator">=</span> <span class="token constant">True</span>
      <span class="token punctuation">,</span> <span class="token hvariable">hasInsurance</span> <span class="token operator">=</span> <span class="token constant">True</span>
    <span class="token punctuation">}</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Взгляните, ведь у нас теперь два значения типа&nbsp;<code>Patient</code>,&nbsp;<code>patient</code>&nbsp;и&nbsp;<code>patientWithChangedEmail</code>. Эти значения не имеют друг ко другу ни малейшего отношения. Вспомните, как я говорил, что в Haskell нельзя изменить имеющееся значение, а можно лишь создать на основе имеющегося новое значение. Это именно то, что здесь произошло: мы взяли имеющееся значение&nbsp;<code>patient</code>&nbsp;и на его основе создали уже новое значение&nbsp;<code>patientWithChangedEmail</code>, значение поля&nbsp;<code>email</code>&nbsp;в котором теперь другое. Понятно, что поле&nbsp;<code>email</code>&nbsp;в значении&nbsp;<code>patient</code>&nbsp;осталось неизменным.</p></div><div><p>Будьте внимательны при инициализации значения с полями: вы обязаны предоставить значения для всех полей. Если вы напишете так:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">main</span> <span class="token operator">::</span> <span class="token constant">IO</span> <span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token hvariable">main</span> <span class="token operator">=</span> <span class="token builtin">print</span> <span class="token operator">$</span> <span class="token hvariable">email</span> <span class="token hvariable">patientWithChangedEmail</span>
  <span class="token keyword">where</span>
    <span class="token hvariable">patientWithChangedEmail</span> <span class="token operator">=</span> <span class="token hvariable">patient</span> <span class="token punctuation">{</span>
      <span class="token hvariable">email</span> <span class="token operator">=</span> <span class="token string">"j.d@gmail.com"</span>  <span class="token comment">-- Изменяем???</span>
    <span class="token punctuation">}</span>

    <span class="token hvariable">patient</span> <span class="token operator">=</span> <span class="token constant">Patient</span> <span class="token punctuation">{</span>
        <span class="token hvariable">firstName</span>    <span class="token operator">=</span> <span class="token string">"John"</span>
      <span class="token punctuation">,</span> <span class="token hvariable">lastName</span>     <span class="token operator">=</span> <span class="token string">"Doe"</span>
      <span class="token punctuation">,</span> <span class="token hvariable">email</span>        <span class="token operator">=</span> <span class="token string">"john.doe@gmail.com"</span>
      <span class="token punctuation">,</span> <span class="token hvariable">age</span>          <span class="token operator">=</span> <span class="token number">24</span>
      <span class="token punctuation">,</span> <span class="token hvariable">diseaseId</span>    <span class="token operator">=</span> <span class="token number">431</span>
      <span class="token punctuation">,</span> <span class="token hvariable">isIndoor</span>     <span class="token operator">=</span> <span class="token constant">True</span>
    <span class="token punctuation">}</span>

    <span class="token comment">-- Поле hasInsurance забыли!</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>код скомпилируется, но внимательный компилятор предупредит вас о проблеме:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token constant">Fields</span> <span class="token keyword">of</span> ‘<span class="token constant">Patient</span>’ <span class="token builtin">not</span> <span class="token hvariable">initialised</span><span class="token operator">:</span> <span class="token hvariable">hasInsurance</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Пожалуйста, не пренебрегайте подобным предупреждением, ведь если вы проигнорируете его и затем попытаетесь обратиться к неинициализированному полю:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">main</span> <span class="token operator">=</span> <span class="token builtin">print</span> <span class="token operator">$</span> <span class="token hvariable">hasInsurance</span> <span class="token hvariable">patient</span>
  <span class="token operator">...</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>ваша программа аварийно завершится на этапе выполнения с ожидаемой ошибкой:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token constant">Missing</span> <span class="token hvariable">field</span> <span class="token keyword">in</span> <span class="token hvariable">record</span> <span class="token hvariable">construction</span> <span class="token hvariable">hasInsurance</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Не забывайте: компилятор — ваш добрый друг.</p></div><div><h2 data-heading="Без меток" id="Без_меток" style="display: flex;"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>Без меток</h2></div><div><p>Помните, что метки полей — это синтаксический сахар, без которого мы вполне можем обойтись. Даже если тип был определён с метками, как наш&nbsp;<code>Patient</code>, мы можем работать с ним по-старинке:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token keyword">data</span> <span class="token constant">Patient</span> <span class="token operator">=</span> <span class="token constant">Patient</span> <span class="token punctuation">{</span> <span class="token hvariable">firstName</span>    <span class="token operator">::</span> <span class="token constant">String</span>
                       <span class="token punctuation">,</span> <span class="token hvariable">lastName</span>     <span class="token operator">::</span> <span class="token constant">String</span>
                       <span class="token punctuation">,</span> <span class="token hvariable">email</span>        <span class="token operator">::</span> <span class="token constant">String</span>
                       <span class="token punctuation">,</span> <span class="token hvariable">age</span>          <span class="token operator">::</span> <span class="token constant">Int</span>
                       <span class="token punctuation">,</span> <span class="token hvariable">diseaseId</span>    <span class="token operator">::</span> <span class="token constant">Int</span>
                       <span class="token punctuation">,</span> <span class="token hvariable">isIndoor</span>     <span class="token operator">::</span> <span class="token constant">Bool</span>
                       <span class="token punctuation">,</span> <span class="token hvariable">hasInsurance</span> <span class="token operator">::</span> <span class="token constant">Bool</span>
                       <span class="token punctuation">}</span>

<span class="token hvariable">main</span> <span class="token operator">::</span> <span class="token constant">IO</span> <span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token hvariable">main</span> <span class="token operator">=</span> <span class="token builtin">print</span> <span class="token operator">$</span> <span class="token hvariable">hasInsurance</span> <span class="token hvariable">patient</span>
  <span class="token keyword">where</span>
    <span class="token comment">-- Создаём по-старинке...</span>
    <span class="token hvariable">patient</span> <span class="token operator">=</span> <span class="token constant">Patient</span> <span class="token string">"John"</span>
                      <span class="token string">"Doe"</span>
                      <span class="token string">"john.doe@gmail.com"</span>
                      <span class="token number">24</span>
                      <span class="token number">431</span>
                      <span class="token constant">True</span>
                      <span class="token constant">True</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Соответственно, извлекать значения полей тоже можно по-старинке, через паттерн матчинг:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">main</span> <span class="token operator">::</span> <span class="token constant">IO</span> <span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token hvariable">main</span> <span class="token operator">=</span> <span class="token builtin">print</span> <span class="token hvariable">insurance</span>
  <span class="token keyword">where</span>
    <span class="token comment">-- Жутко неудобно, но если желаете...</span>
    <span class="token constant">Patient</span> <span class="token hvariable">_</span> <span class="token hvariable">_</span> <span class="token hvariable">_</span> <span class="token hvariable">_</span> <span class="token hvariable">_</span> <span class="token hvariable">_</span> <span class="token hvariable">insurance</span> <span class="token operator">=</span> <span class="token hvariable">patient</span>
    <span class="token hvariable">patient</span> <span class="token operator">=</span> <span class="token constant">Patient</span> <span class="token string">"John"</span>
                      <span class="token string">"Doe"</span>
                      <span class="token string">"john.doe@gmail.com"</span>
                      <span class="token number">24</span>
                      <span class="token number">431</span>
                      <span class="token constant">True</span>
                      <span class="token constant">True</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>С другими видами синтаксического сахара мы встретимся ещё не раз, на куда более продвинутых примерах.</p></div><div><p>Итого:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token keyword">data</span> <span class="token constant">Patient</span> <span class="token operator">=</span> <span class="token constant">Patient</span> <span class="token punctuation">{</span> <span class="token hvariable">firstName</span>
                       <span class="token punctuation">,</span> <span class="token hvariable">lastName</span>
                       <span class="token punctuation">,</span> <span class="token hvariable">email</span>        <span class="token operator">::</span> <span class="token constant">String</span>
                       <span class="token punctuation">,</span> <span class="token hvariable">age</span>
                       <span class="token punctuation">,</span> <span class="token hvariable">diseaseId</span>    <span class="token operator">::</span> <span class="token constant">Int</span>
                       <span class="token punctuation">,</span> <span class="token hvariable">isIndoor</span>
                       <span class="token punctuation">,</span> <span class="token hvariable">hasInsurance</span> <span class="token operator">::</span> <span class="token constant">Bool</span>
                       <span class="token punctuation">}</span>

<span class="token comment">-- По старинке</span>
<span class="token comment">{-
main :: IO ()
main = print insurance
  where
    -- Жутко неудобно, но если желаете...
    Patient _ _ _ _ _ _ insurance = patient
    patient = Patient "John"
                      "Doe"
                      "john.doe@gmail.com"
                      24
                      431
                      True
                      True
-}</span>

<span class="token comment">-- С сахарком :3</span>
<span class="token hvariable">main</span> <span class="token operator">::</span> <span class="token constant">IO</span> <span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token hvariable">main</span> <span class="token operator">=</span> <span class="token builtin">print</span> <span class="token operator">$</span> <span class="token hvariable">email</span> <span class="token hvariable">patientWithChangedEmail</span>
  <span class="token keyword">where</span>
    <span class="token hvariable">patientWithChangedEmail</span> <span class="token operator">=</span> <span class="token hvariable">patient</span> <span class="token punctuation">{</span>
      <span class="token hvariable">email</span> <span class="token operator">=</span> <span class="token string">"j.d@gmail.com"</span>  <span class="token comment">-- Изменяем???</span>
    <span class="token punctuation">}</span>

    <span class="token hvariable">patient</span> <span class="token operator">=</span> <span class="token constant">Patient</span> <span class="token punctuation">{</span>
        <span class="token hvariable">firstName</span>    <span class="token operator">=</span> <span class="token string">"John"</span>
      <span class="token punctuation">,</span> <span class="token hvariable">lastName</span>     <span class="token operator">=</span> <span class="token string">"Doe"</span>
      <span class="token punctuation">,</span> <span class="token hvariable">email</span>        <span class="token operator">=</span> <span class="token string">"john.doe@gmail.com"</span>
      <span class="token punctuation">,</span> <span class="token hvariable">age</span>          <span class="token operator">=</span> <span class="token number">24</span>
      <span class="token punctuation">,</span> <span class="token hvariable">diseaseId</span>    <span class="token operator">=</span> <span class="token number">431</span>
      <span class="token punctuation">,</span> <span class="token hvariable">isIndoor</span>     <span class="token operator">=</span> <span class="token constant">True</span>
      <span class="token punctuation">,</span> <span class="token hvariable">hasInsurance</span> <span class="token operator">=</span> <span class="token constant">True</span>
    <span class="token punctuation">}</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><h1 data-heading="Новый тип" id="Новый_тип">Новый тип</h1></div><div><p>Помимо&nbsp;<code>data</code>&nbsp;существует ещё одно ключевое слово, предназначенное для определения нового типа. Оно так и называется —&nbsp;<code>newtype</code>. Эти слова похожи друг на друга «в одну сторону»: вы можете поставить&nbsp;<code>data</code>&nbsp;на место&nbsp;<code>newtype</code>, но не наоборот.</p></div><div><h2 data-heading="Различия" id="Различия" style="display: flex;"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>Различия</h2></div><div><p>Тип, определяемый с помощью слова&nbsp;<code>newtype</code>, обязан иметь один и только один конструктор значения. Мы можем написать так: &nbsp;</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token keyword">newtype</span> <span class="token constant">IPAddress</span> <span class="token operator">=</span> <span class="token constant">IP</span> <span class="token constant">String</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>А вот так не можем:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token keyword">newtype</span> <span class="token constant">IPAddress</span> <span class="token operator">=</span> <span class="token constant">IP</span> <span class="token constant">String</span> <span class="token operator">|</span> <span class="token constant">Localhost</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Компилятор заупрямится:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token constant">A</span> <span class="token keyword">newtype</span> <span class="token hvariable">must</span> <span class="token hvariable">have</span> <span class="token hvariable">exactly</span> <span class="token hvariable">one</span> <span class="token hvariable">constructor</span><span class="token punctuation">,</span>
  <span class="token hvariable">but</span> ‘<span class="token constant">IPAddress</span>’ <span class="token hvariable">has</span> <span class="token hvariable">two</span>
<span class="token constant">In</span> <span class="token hvariable">the</span> <span class="token keyword">newtype</span> <span class="token hvariable">declaration</span> <span class="token hvariable">for</span> ‘<span class="token constant">IPAddress</span>’
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Кроме того, в таком типе должно быть одно и лишь одно поле. То есть можно так:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token keyword">newtype</span> <span class="token constant">IPAddress</span> <span class="token operator">=</span> <span class="token constant">IP</span> <span class="token constant">String</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Или же так, с меткой:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token keyword">newtype</span> <span class="token constant">IPAddress</span> <span class="token operator">=</span> <span class="token constant">IP</span> <span class="token punctuation">{</span> <span class="token hvariable">value</span> <span class="token operator">::</span> <span class="token constant">String</span> <span class="token punctuation">}</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>А вот два или более полей запихнуть не удастся:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token keyword">newtype</span> <span class="token constant">EndPoint</span> <span class="token operator">=</span> <span class="token constant">EndPoint</span> <span class="token constant">String</span> <span class="token constant">Int</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Компилятор вновь обратит наше внимание на проблему:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token constant">The</span> <span class="token hvariable">constructor</span> <span class="token keyword">of</span> <span class="token hvariable">a</span> <span class="token keyword">newtype</span> <span class="token hvariable">must</span> <span class="token hvariable">have</span> <span class="token hvariable">exactly</span> <span class="token hvariable">one</span> <span class="token hvariable">field</span>
  <span class="token hvariable">but</span> ‘<span class="token constant">EndPoint</span>’ <span class="token hvariable">has</span> <span class="token hvariable">two</span>
<span class="token constant">In</span> <span class="token hvariable">the</span> <span class="token hvariable">definition</span> <span class="token keyword">of</span> <span class="token keyword">data</span> <span class="token hvariable">constructor</span> ‘<span class="token constant">EndPoint</span>’
<span class="token constant">In</span> <span class="token hvariable">the</span> <span class="token keyword">newtype</span> <span class="token hvariable">declaration</span> <span class="token hvariable">for</span> ‘<span class="token constant">EndPoint</span>’
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Более того, нульарный конструктор тоже не подойдёт:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token keyword">newtype</span> <span class="token constant">HardDay</span> <span class="token operator">=</span> <span class="token constant">Monday</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>И вновь ошибка:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token constant">The</span> <span class="token hvariable">constructor</span> <span class="token keyword">of</span> <span class="token hvariable">a</span> <span class="token keyword">newtype</span> <span class="token hvariable">must</span> <span class="token hvariable">have</span> <span class="token hvariable">exactly</span> <span class="token hvariable">one</span> <span class="token hvariable">field</span>
  <span class="token hvariable">but</span> ‘<span class="token constant">Monday</span>’ <span class="token hvariable">has</span> <span class="token hvariable">none</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><h2 data-heading="Зачем он нужен?" id="Зачем_он_нужен?" style="display: flex;"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>Зачем он нужен?</h2></div><div><p>В самом деле, зачем нам нужно такое хозяйство? Это нельзя, то нельзя. Какой смысл?</p></div><div><p>Смысл в оптимизации. Обратите внимание на модель&nbsp;<code>newtype</code>:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token keyword">newtype</span> <span class="token constant">IPAddress</span> <span class="token operator">=</span> <span class="token constant">IP</span>           <span class="token constant">String</span>

новый   название    конструктор  Поле
тип                 значения
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Фактически,&nbsp;<code>newtype</code>&nbsp;берёт одно-единственное значение некоторого существующего типа и всего лишь оборачивает его в свой конструктор. Именно поэтому тип, введённый с помощью&nbsp;<code>newtype</code>, не относится к АТД, и с точки зрения компилятора он является лишь переименованием типа (англ. type renaming). Это делает такой тип более простым и эффективным с точки зрения представления в памяти, нежели тип, определяемый с&nbsp;<code>data</code>.</p></div><div><p>Когда мы пишем так:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token keyword">data</span> <span class="token constant">IPAddress</span> <span class="token operator">=</span> <span class="token constant">IP</span> <span class="token constant">String</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>мы говорим компилятору: «<code>IPAddress</code>&nbsp;— это абсолютно новый и самобытный тип, которого никогда не было ранее». А когда пишем так:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token keyword">newtype</span> <span class="token constant">IPAddress</span> <span class="token operator">=</span> <span class="token constant">IP</span> <span class="token constant">String</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>мы говорим: «<code>IPAddress</code>&nbsp;— это всего лишь обёртка для значения уже существующего типа&nbsp;<code>String</code>».</p></div><div><h2 data-heading="type vs newtype" id="type_vs_newtype" style="display: flex;"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>type vs newtype</h2></div><div><p>Внимательный читатель спросит, в чём же фундаментальное отличие типов, вводимых с помощью&nbsp;<code>newtype</code>, от типов, вводимых с помощью&nbsp;<code>type</code>? Там синоним, тут — обёртка. Отличие вот в чём.</p></div><div><p>Когда мы пишем так:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token keyword">type</span> <span class="token constant">String</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token constant">Char</span><span class="token punctuation">]</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>мы объявляем: «Тип&nbsp;<code>String</code>&nbsp;— это эквивалентная замена типу&nbsp;<code>[Char]</code>». И поэтому везде, где в коде стоит&nbsp;<code>[Char]</code>, мы можем поставить&nbsp;<code>String</code>, и везде, где стоит&nbsp;<code>String</code>, мы можем поставить&nbsp;<code>[Char]</code>. Например, если функция объявлена так:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">replace</span> <span class="token operator">::</span> <span class="token constant">String</span>
        <span class="token operator">-&gt;</span> <span class="token constant">String</span>
        <span class="token operator">-&gt;</span> <span class="token constant">String</span>
        <span class="token operator">-&gt;</span> <span class="token constant">String</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>мы можем спокойно переписать объявление:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">replace</span> <span class="token operator">::</span> <span class="token punctuation">[</span><span class="token constant">Char</span><span class="token punctuation">]</span>
        <span class="token operator">-&gt;</span> <span class="token punctuation">[</span><span class="token constant">Char</span><span class="token punctuation">]</span>
        <span class="token operator">-&gt;</span> <span class="token punctuation">[</span><span class="token constant">Char</span><span class="token punctuation">]</span>
        <span class="token operator">-&gt;</span> <span class="token punctuation">[</span><span class="token constant">Char</span><span class="token punctuation">]</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>и ничего не изменится.</p></div><div><p>Когда же мы пишем так:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token keyword">newtype</span> <span class="token constant">MyInt</span> <span class="token operator">=</span> <span class="token constant">MyInt</span> <span class="token constant">Int</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>мы объявляем: «Тип&nbsp;<code>MyInt</code>&nbsp;— это новый тип, представление которого такое же, как у типа&nbsp;<code>Int</code>». Мы не можем просто взять и поставить&nbsp;<code>MyInt</code>&nbsp;на место&nbsp;<code>Int</code>, потому что эти типы равны лишь с точки зрения представления в памяти, с точки зрения системы типов они абсолютно различны.</p></div><div><p>А зачем же нам нужно это? Для простоты и надёжности кода. Допустим, есть такая функция:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">getBuildsInfo</span> <span class="token operator">::</span> <span class="token constant">String</span> <span class="token operator">-&gt;</span> <span class="token constant">Int</span> <span class="token operator">-&gt;</span> <span class="token constant">BuildsInfo</span>
<span class="token hvariable">getBuildsInfo</span> <span class="token hvariable">projectName</span> <span class="token hvariable">limit</span> <span class="token operator">=</span> <span class="token operator">...</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Эта функция запрашивает у CI-сервиса (через REST API) информацию о сборках проекта. Из определения мы видим, что первым аргументом выступает имя проекта, а вторым — количество сборок. Однако в месте применения функции это может быть не столь очевидным:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded">  <span class="token keyword">let</span> <span class="token hvariable">info</span> <span class="token operator">=</span> <span class="token hvariable">getBuildsInfo</span> <span class="token string">"ohaskell.guide"</span> <span class="token number">4</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Что такое первая строка? Что такое второе число? Неясно, нужно глядеть в определение, ведь даже объявление не расскажет нам правду:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">getBuildsInfo</span> <span class="token operator">::</span> <span class="token constant">String</span>  <span class="token operator">-&gt;</span> <span class="token constant">Int</span>    <span class="token operator">-&gt;</span> <span class="token constant">BuildsInfo</span>

                 что за     что за
                 строка<span class="token operator">?</span>    число<span class="token operator">?</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Вот тут нам и помогают наши типы, ведь стандартные&nbsp;<code>String</code>&nbsp;и&nbsp;<code>Int</code>&nbsp;сами по себе не несут никакой полезной информации о своём содержимом. Конечно, мы могли бы обойтись и без типов, просто введя промежуточные выражения:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded">  <span class="token keyword">let</span> <span class="token hvariable">project</span> <span class="token operator">=</span> <span class="token string">"ohaskell.guide"</span>
      <span class="token hvariable">limit</span>   <span class="token operator">=</span> <span class="token number">4</span>
      <span class="token hvariable">info</span>    <span class="token operator">=</span> <span class="token hvariable">getBuildsInfo</span> <span class="token hvariable">project</span> <span class="token hvariable">limit</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Однако программист может этого и не сделать, и тогда мы получим «магические значения», смысл которых нам неизвестен. Куда лучше ввести собственные типы:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token keyword">newtype</span> <span class="token constant">Project</span> <span class="token operator">=</span> <span class="token constant">Project</span> <span class="token constant">String</span>
<span class="token keyword">newtype</span> <span class="token constant">Limit</span> <span class="token operator">=</span> <span class="token constant">Limit</span> <span class="token constant">Int</span>

<span class="token hvariable">getBuildsInfo</span> <span class="token operator">::</span> <span class="token constant">Project</span> <span class="token operator">-&gt;</span> <span class="token constant">Limit</span>  <span class="token operator">-&gt;</span> <span class="token constant">BuildsInfo</span>

                 уже не     уже не
                 просто     просто
                 строка     число
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Это заставит нас писать явно:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded">  <span class="token keyword">let</span> <span class="token hvariable">info</span> <span class="token operator">=</span> <span class="token hvariable">getBuildsInfo</span> <span class="token punctuation">(</span><span class="token constant">Project</span> <span class="token string">"ohaskell.guide"</span><span class="token punctuation">)</span>
                           <span class="token punctuation">(</span><span class="token constant">Limit</span> <span class="token number">4</span><span class="token punctuation">)</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Теперь, даже без промежуточных выражений, смысл строки и числа вполне очевиден. Это важный принцип в Haskell: безликие типы наподобие&nbsp;<code>String</code>&nbsp;или&nbsp;<code>Int</code>&nbsp;заменять на типы, имеющие конкретный смысл для нас.</p></div><div><p>Кроме того,&nbsp;<code>newtype</code>-типы помогают нам не допускать глупых ошибок. Например, есть другая функция:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">getArtifacts</span> <span class="token operator">::</span> <span class="token constant">String</span> <span class="token operator">-&gt;</span> <span class="token constant">Int</span> <span class="token operator">-&gt;</span> <span class="token constant">Int</span> <span class="token operator">-&gt;</span> <span class="token punctuation">[</span><span class="token constant">Project</span><span class="token punctuation">]</span>
<span class="token hvariable">getArtifacts</span> <span class="token hvariable">projectName</span> <span class="token hvariable">limit</span> <span class="token hvariable">offset</span> <span class="token operator">=</span> <span class="token operator">...</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Мало того, что перед нами вновь безликие&nbsp;<code>Int</code>, так их ещё и два. И вот какая нелепая ошибка может нас поджидать:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded">  <span class="token keyword">let</span> <span class="token hvariable">project</span> <span class="token operator">=</span> <span class="token string">"ohaskell.guide"</span>
      <span class="token hvariable">limit</span>   <span class="token operator">=</span> <span class="token number">4</span>
      <span class="token hvariable">offset</span>  <span class="token operator">=</span> <span class="token number">1</span>
      <span class="token hvariable">info</span>    <span class="token operator">=</span> <span class="token hvariable">getArtifacts</span> <span class="token hvariable">project</span> <span class="token hvariable">offset</span> <span class="token hvariable">limit</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Заметили? Мы случайно перепутали аргументы местами, поставив&nbsp;<code>offset</code>&nbsp;на место&nbsp;<code>limit</code>. Работа функции при этом нарушится, однако компилятор останется нем как рыба, ведь с точки зрения системы типов ошибки не произошло: и там&nbsp;<code>Int</code>, и тут&nbsp;<code>Int</code>. Синонимы для&nbsp;<code>Int</code>&nbsp;также не помогли бы. Однако если у нас будут&nbsp;<code>newtype</code>-типы:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token keyword">newtype</span> <span class="token constant">Limit</span> <span class="token operator">=</span> <span class="token constant">Limit</span> <span class="token constant">Int</span>
<span class="token keyword">newtype</span> <span class="token constant">Offset</span> <span class="token operator">=</span> <span class="token constant">Offset</span> <span class="token constant">Int</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>тогда подобная ошибка не пройдёт незамеченной:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded">  <span class="token keyword">let</span> <span class="token hvariable">project</span> <span class="token operator">=</span> <span class="token string">"ohaskell.guide"</span>
      <span class="token hvariable">limit</span>   <span class="token operator">=</span> <span class="token constant">Limit</span> <span class="token number">4</span>
      <span class="token hvariable">offset</span>  <span class="token operator">=</span> <span class="token constant">Offset</span> <span class="token number">1</span>
      <span class="token hvariable">info</span>    <span class="token operator">=</span> <span class="token hvariable">getArtifacts</span> <span class="token hvariable">offset</span> <span class="token hvariable">limit</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Типы аргументов теперь разные, а значит, путаница между ними гарантированно прервёт компиляцию.</p></div><div><p>Вот такие они,&nbsp;<code>newtype</code>-типы. В последующих главах мы увидим ещё большую мощь системы типов Haskell.</p></div><div><h1 data-heading="Конструктор типа" id="Конструктор_типа">Конструктор типа</h1></div><div><p>В предыдущих главах мы познакомились с АТД, которые сами по себе уже весьма полезны. И всё же есть в них одно ограничение: они напрочь лишены гибкости. Вот тебе конкретные поля, а вот тебе конкретные типы, будь счастлив. Но существует способ наделить наши тип куда большей силой. Эта глава станет для нас переломной, ведь с неё начнётся наш путь в мир действительно мощных типов.</p></div><div><h2 data-heading="Опциональный тип" id="Опциональный_тип" style="display: flex;"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>Опциональный тип</h2></div><div><p>Допустим, у нас есть список пар следующего вида:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token keyword">type</span> <span class="token constant">Chapters</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">(</span><span class="token constant">FilePath</span><span class="token punctuation">,</span> <span class="token constant">String</span><span class="token punctuation">)</span><span class="token punctuation">]</span>

<span class="token hvariable">chapters</span> <span class="token operator">::</span> <span class="token constant">Chapters</span>
<span class="token hvariable">chapters</span> <span class="token operator">=</span> <span class="token punctuation">[</span> <span class="token punctuation">(</span><span class="token string">"/list.html"</span><span class="token punctuation">,</span>  <span class="token string">"Список"</span><span class="token punctuation">)</span>
           <span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token string">"/tuple.html"</span><span class="token punctuation">,</span> <span class="token string">"Кортеж"</span><span class="token punctuation">)</span>
           <span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token string">"/hof.html"</span><span class="token punctuation">,</span>   <span class="token string">"ФВП"</span><span class="token punctuation">)</span>
           <span class="token punctuation">]</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Тип&nbsp;<code>FilePath</code>&nbsp;есть не более чем стандартный синоним для типа&nbsp;<code>String</code>, но он более информативен. Итак, этот список содержит названия трёх глав данной книги и пути к ним. И вот понадобилась нам функция, которая извлекает название главы по её пути:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">lookupChapterNameBy</span> <span class="token operator">::</span> <span class="token constant">FilePath</span> <span class="token operator">-&gt;</span> <span class="token constant">Chapters</span> <span class="token operator">-&gt;</span> <span class="token constant">String</span>
<span class="token hvariable">lookupChapterNameBy</span> <span class="token hvariable">_</span> <span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">""</span>  <span class="token comment">-- Так ничего и не нашли...</span>
<span class="token hvariable">lookupChapterNameBy</span> <span class="token hvariable">path</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token hvariable">realPath</span><span class="token punctuation">,</span> <span class="token hvariable">name</span><span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token hvariable">others</span><span class="token punctuation">)</span>
  <span class="token operator">|</span> <span class="token hvariable">path</span> <span class="token operator">==</span> <span class="token hvariable">realPath</span> <span class="token operator">=</span> <span class="token hvariable">name</span> <span class="token comment">-- Пути совпадают, вот вам имя.</span>
  <span class="token operator">|</span> <span class="token builtin">otherwise</span>        <span class="token operator">=</span> <span class="token hvariable">lookupChapterNameBy</span> <span class="token hvariable">path</span> <span class="token hvariable">others</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Всё предельно просто: рекурсивно бежим по списку пар&nbsp;<code>chapters</code>, на каждом шаге извлекая через паттерн матчинг путь ко главе и её имя. Сравниваем пути и, ежели совпадают — на выходе получается имя, соответствующее заданному пути. Если же, пройдя весь список, мы так и не нашли соответствующего пути, на выходе будет пустая строка.</p></div><div><p>Используем так:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">main</span> <span class="token operator">::</span> <span class="token constant">IO</span> <span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token hvariable">main</span> <span class="token operator">=</span> <span class="token builtin">putStrLn</span> <span class="token operator">$</span>
  <span class="token keyword">if</span> <span class="token operator">|</span> <span class="token builtin">null</span> <span class="token hvariable">name</span> <span class="token operator">-&gt;</span> <span class="token string">"No such chapter, sorry..."</span>
     <span class="token operator">|</span> <span class="token builtin">otherwise</span> <span class="token operator">-&gt;</span> <span class="token string">"This is chapter name: "</span> <span class="token operator">++</span> <span class="token hvariable">name</span>
  <span class="token keyword">where</span>
    <span class="token hvariable">name</span> <span class="token operator">=</span> <span class="token hvariable">lookupChapterNameBy</span> <span class="token string">"/tuple.html"</span> <span class="token hvariable">chapters</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Если на выходе функции&nbsp;<code>lookupChapterNameBy</code>&nbsp;пустая строка, значит мы ничего не нашли, в противном же случае показываем найденное имя.</p></div><div><p>Ну и как вам такое решение? Вроде бы красивое, но почему, собственно, пустая строка? Я вполне мог написать заготовку для очередной главы и ещё не дать ей имя:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">chapters</span> <span class="token operator">::</span> <span class="token constant">Chapters</span>
<span class="token hvariable">chapters</span> <span class="token operator">=</span> <span class="token punctuation">[</span> <span class="token punctuation">(</span><span class="token string">"/list.html"</span><span class="token punctuation">,</span>  <span class="token string">"Список"</span><span class="token punctuation">)</span>
           <span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token string">"/tuple.html"</span><span class="token punctuation">,</span> <span class="token string">"Кортеж"</span><span class="token punctuation">)</span>
           <span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token string">"/hof.html"</span><span class="token punctuation">,</span>   <span class="token string">"ФВП"</span><span class="token punctuation">)</span>
           <span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token string">"/monad.html"</span><span class="token punctuation">,</span> <span class="token string">""</span><span class="token punctuation">)</span>  <span class="token comment">-- Заготовка</span>
           <span class="token punctuation">]</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>В этом случае наше решение ломается: пустая строка на выходе функции&nbsp;<code>lookupChapterNameBy</code>&nbsp;может означать теперь как то, что мы не нашли главы с таким путём, так и то, что глава-то существует, просто её имя пока не задано. Следовательно, нам нужен другой механизм проверки результата поиска, более однозначный.</p></div><div><p>Определим опциональный тип. Опциональным (англ. optional) называют такой тип, внутри которого либо есть нечто полезное, либо нет. Выглядеть он будет так:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token keyword">data</span> <span class="token constant">Optional</span> <span class="token operator">=</span> <span class="token constant">NoSuchChapter</span>
              <span class="token operator">|</span> <span class="token constant">Chapter</span> <span class="token constant">String</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Если значение типа&nbsp;<code>Optional</code>&nbsp;создано с помощью нульарного конструктора&nbsp;<code>NoSuchChapter</code>, это означает, что внутри ничего нет, перед нами значение-пустышка. Это и будет соответствовать тому случаю, когда нужную главу мы не нашли. А вот если значение было создано с помощью унарного конструктора&nbsp;<code>Chapter</code>, это несомненно будет означать то, что мы нашли интересующую нас главу. Перепишем функцию&nbsp;<code>lookupChapterNameBy</code>:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">lookupChapterNameBy</span> <span class="token operator">::</span> <span class="token constant">FilePath</span> <span class="token operator">-&gt;</span> <span class="token constant">Chapters</span> <span class="token operator">-&gt;</span> <span class="token constant">Optional</span>
<span class="token hvariable">lookupChapterNameBy</span> <span class="token hvariable">_</span> <span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token constant">NoSuchChapter</span> <span class="token comment">-- Пустышка</span>
<span class="token hvariable">lookupChapterNameBy</span> <span class="token hvariable">path</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token hvariable">realPath</span><span class="token punctuation">,</span> <span class="token hvariable">name</span><span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token hvariable">others</span><span class="token punctuation">)</span>
  <span class="token operator">|</span> <span class="token hvariable">path</span> <span class="token operator">==</span> <span class="token hvariable">realPath</span> <span class="token operator">=</span> <span class="token constant">Chapter</span> <span class="token hvariable">name</span>      <span class="token comment">-- Реальное имя</span>
  <span class="token operator">|</span> <span class="token builtin">otherwise</span>        <span class="token operator">=</span> <span class="token hvariable">lookupChapterNameBy</span> <span class="token hvariable">path</span> <span class="token hvariable">others</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Код стал более понятным. И вот как мы будем работать с этой функцией:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">main</span> <span class="token operator">::</span> <span class="token constant">IO</span> <span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token hvariable">main</span> <span class="token operator">=</span> <span class="token builtin">putStrLn</span> <span class="token operator">$</span>
  <span class="token keyword">case</span> <span class="token hvariable">result</span> <span class="token keyword">of</span>
    <span class="token constant">NoSuchChapter</span> <span class="token operator">-&gt;</span> <span class="token string">"No such chapter, sorry..."</span>
    <span class="token constant">Chapter</span> <span class="token hvariable">name</span>  <span class="token operator">-&gt;</span> <span class="token string">"This is chapter name: "</span> <span class="token operator">++</span> <span class="token hvariable">name</span>
  <span class="token keyword">where</span>
    <span class="token hvariable">result</span> <span class="token operator">=</span> <span class="token hvariable">lookupChapterNameBy</span> <span class="token string">"/tuple.html"</span> <span class="token hvariable">chapters</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Отныне функция&nbsp;<code>lookupChapterNameBy</code>&nbsp;сигнализирует о неудачном поиске не посредством пустой строки, а посредством нульарного конструктора. Это и надёжнее, и читабельнее.</p></div><div><p>Красиво, но в этом элегантном решении всё-таки остаётся один изъян: оно намертво привязано к типу&nbsp;<code>String</code>:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token keyword">data</span> <span class="token constant">Optional</span> <span class="token operator">=</span> <span class="token constant">NoSuchChapter</span>
              <span class="token operator">|</span> <span class="token constant">Chapter</span> <span class="token constant">String</span>

                        Почему
                        именно
                        <span class="token constant">String</span><span class="token operator">?</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>В самом деле, почему? Например, в Haskell широкое применение получил тип&nbsp;<code>Text</code>&nbsp;из одноимённого пакета. Этот тип, кстати, значительно мощнее и эффективнее стандартной&nbsp;<code>String</code>. Значит, если мы захотим определить опциональный тип и для&nbsp;<code>Text</code>, придётся дублировать:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token keyword">data</span> <span class="token constant">Optional</span> <span class="token operator">=</span> <span class="token constant">NoSuchChapter</span> <span class="token operator">|</span> <span class="token constant">Chapter</span> <span class="token constant">String</span>

<span class="token keyword">data</span> <span class="token constant">Optional</span> <span class="token operator">=</span> <span class="token constant">NoSuchChapter</span> <span class="token operator">|</span> <span class="token constant">Chapter</span> <span class="token constant">Text</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Однако компилятор наотрез откажется принимать такой код:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token constant">Multiple</span> <span class="token hvariable">declarations</span> <span class="token keyword">of</span> ‘<span class="token constant">Optional</span>’
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Имена-то типов одинаковые! Хорошо, уточним:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token keyword">data</span> <span class="token constant">OptionalString</span> <span class="token operator">=</span> <span class="token constant">NoSuchChapter</span> <span class="token operator">|</span> <span class="token constant">Chapter</span> <span class="token constant">String</span>

<span class="token keyword">data</span> <span class="token constant">OptionalText</span>   <span class="token operator">=</span> <span class="token constant">NoSuchChapter</span> <span class="token operator">|</span> <span class="token constant">Chapter</span> <span class="token constant">Text</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Но и в этом случае компиляция не пройдёт:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token constant">Multiple</span> <span class="token hvariable">declarations</span> <span class="token keyword">of</span> ‘<span class="token constant">NoSuchChapter</span>’

<span class="token operator">...</span>

<span class="token constant">Multiple</span> <span class="token hvariable">declarations</span> <span class="token keyword">of</span> ‘<span class="token constant">Chapter</span>’
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Конструкторы значений тоже одноимённые, опять уточняем:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token keyword">data</span> <span class="token constant">OptionalString</span> <span class="token operator">=</span> <span class="token constant">NoSuchChapterString</span>
                    <span class="token operator">|</span> <span class="token constant">ChapterString</span> <span class="token constant">String</span>

<span class="token keyword">data</span> <span class="token constant">OptionalText</span>   <span class="token operator">=</span> <span class="token constant">NoSuchChapterText</span>
                    <span class="token operator">|</span> <span class="token constant">ChapterText</span> <span class="token constant">Text</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Вот теперь это работает, но код стал избыточным. А вдруг мы пожелаем добавить к двум строковым типам ещё и третий? Или четвёртый? Что ж нам, для каждого типа вот так вот уточнять? Нет, умный в гору не пойдёт — есть лучший путь.</p></div><div><h2 data-heading="Может быть" id="Может_быть" style="display: flex;"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>Может быть</h2></div><div><p>В стандартной библиотеке живёт тип по имени&nbsp;<code>Maybe</code>:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token keyword">data</span> <span class="token constant">Maybe</span> <span class="token hvariable">a</span> <span class="token operator">=</span> <span class="token constant">Nothing</span> <span class="token operator">|</span> <span class="token constant">Just</span> <span class="token hvariable">a</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Тип&nbsp;<code>Maybe</code>&nbsp;(от англ. maybe, «может быть») нужен для создания тех самых опциональных значений. Впрочем, я выразился неточно, ведь, несмотря на ключевое слово&nbsp;<code>data</code>,&nbsp;<code>Maybe</code>&nbsp;— это не совсем тип, это конструктор типа (англ. type constructor). Данная концепция используется в Haskell чрезвычайно часто, и, как и большинство концепций в этом языке, она столь полезна потому, что очень проста.</p></div><div><p>Конструктор типа — это то, что создаёт новый тип (потенциально, бесконечное множество типов). Когда мы явно определяем тип, он прямолинеен и однозначен:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token keyword">data</span> <span class="token constant">Optional</span> <span class="token operator">=</span> <span class="token constant">NoSuchChapter</span> <span class="token operator">|</span> <span class="token constant">Chapter</span>      <span class="token constant">String</span>

     имя типа   нульарный       унарный      поле
                конструктор     конструктор  типа
                значения        значения     <span class="token constant">String</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Когда же мы определяем конструктор типа, мы создаём концептуальный скелет для будущих типов. Взглянем ещё раз (к-тор — это конструктор, для краткости):</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded">              <span class="token hvariable">______________________________</span>
             <span class="token operator">/</span>                              `<span class="token hvariable">v</span>

<span class="token keyword">data</span> <span class="token constant">Maybe</span>  <span class="token hvariable">a</span>        <span class="token operator">=</span> <span class="token constant">Nothing</span>   <span class="token operator">|</span> <span class="token constant">Just</span>      <span class="token hvariable">a</span>

     к<span class="token operator">-</span>тор  типовая    нульарный   унарный   поле
     типа   заглушка   к<span class="token operator">-</span>тор       к<span class="token operator">-</span>тор     типа
                       значения    значения  <span class="token hvariable">a</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Здесь присутствует уже знакомая нам типовая заглушка&nbsp;<code>a</code>, она-то и делает&nbsp;<code>Maybe</code>&nbsp;конструктором типа. Как мы помним, на место типовой заглушки всегда встаёт какой-то тип. Перепишем функцию&nbsp;<code>lookupChapterNameBy</code>&nbsp;для работы с&nbsp;<code>Maybe</code>:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">lookupChapterNameBy</span> <span class="token operator">::</span> <span class="token constant">FilePath</span> <span class="token operator">-&gt;</span> <span class="token constant">Chapters</span> <span class="token operator">-&gt;</span> <span class="token constant">Maybe</span> <span class="token constant">String</span>
<span class="token hvariable">lookupChapterNameBy</span> <span class="token hvariable">_</span> <span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token constant">Nothing</span>  <span class="token comment">-- Пустышка</span>
<span class="token hvariable">lookupChapterNameBy</span> <span class="token hvariable">path</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token hvariable">realPath</span><span class="token punctuation">,</span> <span class="token hvariable">name</span><span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token hvariable">others</span><span class="token punctuation">)</span>
  <span class="token operator">|</span> <span class="token hvariable">path</span> <span class="token operator">==</span> <span class="token hvariable">realPath</span> <span class="token operator">=</span> <span class="token constant">Just</span> <span class="token hvariable">name</span>    <span class="token comment">-- Реальное имя</span>
  <span class="token operator">|</span> <span class="token builtin">otherwise</span>        <span class="token operator">=</span> <span class="token hvariable">lookupChapterNameBy</span> <span class="token hvariable">path</span> <span class="token hvariable">others</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Рассмотрим обновлённое объявление:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">lookupChapterNameBy</span> <span class="token operator">::</span> <span class="token constant">FilePath</span>
                    <span class="token operator">-&gt;</span> <span class="token constant">Chapters</span> <span class="token operator">-&gt;</span> <span class="token constant">Maybe</span> <span class="token constant">String</span>

                                   это тип такой<span class="token punctuation">,</span>
                                   называется
                                   <span class="token constant">Maybe</span> <span class="token constant">String</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>На выходе видим значение типа&nbsp;<code>Maybe String</code>. Этот тип был порождён конструктором&nbsp;<code>Maybe</code>, применённым к типу&nbsp;<code>String</code>. Стоп, я сказал «применённым»? Да, именно так: вы можете воспринимать конструктор типа как особую «функцию», назовём её «типовая функция». Нет, это не официальный термин из Haskell, это просто аналогия: обычная функция работает с данными, а типовая функция работает с типами. Сравните это:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token builtin">length</span>   <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token number">3</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">3</span>

функция  данное    <span class="token operator">=</span> другое данное
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>и это:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token constant">Maybe</span>    <span class="token constant">String</span>    <span class="token operator">=</span> <span class="token constant">Maybe</span> <span class="token constant">String</span>

типовая  тип       <span class="token operator">=</span> другой тип
функция
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Применение конструктора типа к существующему типу порождает некий новый тип, и это очень мощная техника, используемая в Haskell почти на каждом шагу. Например, если нам нужно завернуть в опциональное значение уже не&nbsp;<code>String</code>, а ранее упомянутый&nbsp;<code>Text</code>, мы ничего не должны менять в конструкторе&nbsp;<code>Maybe</code>:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token constant">Maybe</span>    <span class="token constant">Text</span> <span class="token operator">=</span> <span class="token constant">Maybe</span> <span class="token constant">Text</span>

типовая  тип  <span class="token operator">=</span> другой тип
функция
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Какой тип подставляем на место&nbsp;<code>a</code>, такой тип и станет опциональным. В этом и заключается красота конструкторов типов, ведь они дают нам колоссальный простор для творчества.</p></div><div><p>А теперь мы подошли к очень важной теме.</p></div><div><h2 data-heading="Этажи" id="Этажи" style="display: flex;"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>Этажи</h2></div><div><p>Что такое тип&nbsp;<code>Maybe String</code>? Да, мы уже знаем, это АТД. Но что это такое по сути? Зачем мы конструируем сложные типы из простых? Я предлагаю вам аналогию, которая поможет нам взглянуть на этот вопрос несколько иначе. Эта аналогия отнюдь не аксиома, просто я нашёл её полезной для себя самого. Думаю, вам она тоже будет полезна. Конечно, предлагать аналогии — дело неблагодарное, ведь любая из них несовершенна и может быть так или иначе подвергнута критике. Поэтому не воспринимайте мою аналогию как единственно верную.</p></div><div><p>С точки зрения типов любую Haskell-программу можно сравнить с многоэтажным домом. И вот представьте, мы смотрим на этот дом со стороны.</p></div><div><p>На самом нижнем этаже расположены простейшие стандартные типы, такие как&nbsp;<code>Int</code>,&nbsp;<code>Double</code>,&nbsp;<code>Char</code>&nbsp;или список. Возьмём, например, тип&nbsp;<code>Int</code>. Что это такое? Целое число. Оно не несёт в себе никакого смысла, это всего лишь число в вакууме. Или вот строка — что она такое? Это просто набор каких-то символов в том же вакууме, и ничего более. И если бы мы были ограничены лишь этими типами, наша программистская жизнь была бы весьма грустной.</p></div><div><p>А вот на втором и последующих этажах живут типы куда более интересные. Например, на одном из этажей живёт тип&nbsp;<code>Maybe String</code>. При создании типа&nbsp;<code>Maybe String</code>&nbsp;происходит важное событие: мы поднимаемся с первого на более высокий этаж. Считайте эти этажи уровнями абстракции. Если тип&nbsp;<code>String</code>&nbsp;— это всего лишь безликая строка, то тип&nbsp;<code>Maybe String</code>&nbsp;— это уже не просто строка, это опциональная строка, или, если хотите, строка, наделённая опциональностью. Подняться на тот или иной этаж в нашем типовом небоскрёбе — это значит взять более простой тип и наделить его новым смыслом, новыми возможностями.</p></div><div><p>Или вот вспомним тип&nbsp;<code>IPAddress</code>:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token keyword">data</span> <span class="token constant">IPAddress</span> <span class="token operator">=</span> <span class="token constant">IPAddress</span> <span class="token constant">String</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Мы опять-таки взяли ничего не значащую строку и подняли её на этаж под названием&nbsp;<code>IPAddress</code>, и теперь это уже не просто какая-то строка, это IP-адрес. Новый тип наделил бессмысленную строку вполне определённым смыслом. А когда мы вытаскиваем внутреннюю строку из&nbsp;<code>IPAddress</code>&nbsp;с помощью паттерн матчинга, мы вновь оказываемся на первом этаже.</p></div><div><p>А вот ещё наш тип,&nbsp;<code>EndPoint</code>:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token keyword">data</span> <span class="token constant">EndPoint</span> <span class="token operator">=</span> <span class="token constant">EndPoint</span> <span class="token constant">IPAddress</span> <span class="token constant">Int</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Тут мы поднялись ещё чуток: сначала подняли строку на этаж IP-адреса, а затем взяли его и тип&nbsp;<code>Int</code>&nbsp;и подняли их на следующий этаж под названием&nbsp;<code>EndPoint</code>, и на этом этаже перед нами уже не просто какой-то IP-адрес и какое-то число, перед нами уже связанные друг с другом адрес и порт.</p></div><div><p>А вот ещё один пример, знакомство с которым я откладывал до сих пор. Вспомним определение главной функции&nbsp;<code>main</code>:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">main</span> <span class="token operator">::</span> <span class="token constant">IO</span> <span class="token punctuation">(</span><span class="token punctuation">)</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Я обещал рассказать о том, что такое&nbsp;<code>IO</code>, и вот теперь рассказываю:&nbsp;<code>IO</code>&nbsp;— это тоже конструктор типа. Правда, конструктор особенный, непохожий на наши&nbsp;<code>IPAddress</code>&nbsp;или&nbsp;<code>EndPoint</code>, но об этом подробнее в следующих главах. Так вот поднявшись на этаж под названием&nbsp;<code>IO</code>, мы получаем очень важную способность — способность взаимодействовать с внешним миром: файл прочесть, на консоль текст вывести, и в том же духе. И потому тип&nbsp;<code>IO String</code>&nbsp;— это уже не просто невесть откуда взявшаяся строка, но строка, полученная из внешнего мира (например, из файла). И единственная возможность наделить наши функции способностью взаимодействовать с внешним миром — поднять (ну или опустить) их на&nbsp;<code>IO</code>-этаж. Вот так и получается: в процессе работы программы мы постоянно прыгаем в лифт и переезжаем с одного типового этажа на другой.</p></div><div><p>Но запомните: не все этажи одинаковы! Не со всякого этажа можно напрямую попасть на любой другой. Более того, есть такие этажи, оказавшись на котором, мы в конечном итоге обязаны на него и вернуться. Понимаю, сейчас это порождает больше вопросов, нежели ответов, но не беспокойтесь: ответы ждут нас в последующих главах.</p></div><div><p>Итого:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token keyword">type</span> <span class="token constant">Chapters</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">(</span><span class="token constant">FilePath</span><span class="token punctuation">,</span> <span class="token constant">String</span><span class="token punctuation">)</span><span class="token punctuation">]</span>

<span class="token hvariable">chapters</span> <span class="token operator">::</span> <span class="token constant">Chapters</span>
<span class="token hvariable">chapters</span> <span class="token operator">=</span> <span class="token punctuation">[</span> <span class="token punctuation">(</span><span class="token string">"/list.html"</span><span class="token punctuation">,</span>  <span class="token string">"Список"</span><span class="token punctuation">)</span>
           <span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token string">"/tuple.html"</span><span class="token punctuation">,</span> <span class="token string">"Кортеж"</span><span class="token punctuation">)</span>
           <span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token string">"/hof.html"</span><span class="token punctuation">,</span>   <span class="token string">"ФВП"</span><span class="token punctuation">)</span>
           <span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token string">"/monad.html"</span><span class="token punctuation">,</span> <span class="token string">""</span><span class="token punctuation">)</span>  <span class="token comment">-- Заготовка</span>
           <span class="token punctuation">]</span>

<span class="token hvariable">lookupChapterNameBy</span> <span class="token operator">::</span> <span class="token constant">FilePath</span> <span class="token operator">-&gt;</span> <span class="token constant">Chapters</span> <span class="token operator">-&gt;</span> <span class="token constant">Maybe</span> <span class="token constant">String</span>
<span class="token hvariable">lookupChapterNameBy</span> <span class="token hvariable">_</span> <span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token constant">Nothing</span>  <span class="token comment">-- Пустышка</span>
<span class="token hvariable">lookupChapterNameBy</span> <span class="token hvariable">path</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token hvariable">realPath</span><span class="token punctuation">,</span> <span class="token hvariable">name</span><span class="token punctuation">)</span> <span class="token operator">:</span> <span class="token hvariable">others</span><span class="token punctuation">)</span>
  <span class="token operator">|</span> <span class="token hvariable">path</span> <span class="token operator">==</span> <span class="token hvariable">realPath</span> <span class="token operator">=</span> <span class="token constant">Just</span> <span class="token hvariable">name</span>    <span class="token comment">-- Реальное имя</span>
  <span class="token operator">|</span> <span class="token builtin">otherwise</span>        <span class="token operator">=</span> <span class="token hvariable">lookupChapterNameBy</span> <span class="token hvariable">path</span> <span class="token hvariable">others</span>


<span class="token hvariable">main</span> <span class="token operator">::</span> <span class="token constant">IO</span> <span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token hvariable">main</span> <span class="token operator">=</span> <span class="token builtin">putStrLn</span> <span class="token operator">$</span>
  <span class="token keyword">case</span> <span class="token hvariable">result</span> <span class="token keyword">of</span>
    <span class="token constant">Nothing</span>   <span class="token operator">-&gt;</span> <span class="token string">"No such chapter, sorry..."</span>
    <span class="token constant">Just</span> <span class="token hvariable">name</span> <span class="token operator">-&gt;</span> <span class="token string">"This is chapter name: "</span> <span class="token operator">++</span> <span class="token hvariable">name</span>
  <span class="token keyword">where</span>
    <span class="token hvariable">result</span> <span class="token operator">=</span> <span class="token hvariable">lookupChapterNameBy</span> <span class="token string">"/tuple.html"</span> <span class="token hvariable">chapters</span>

</code><button class="copy-code-button">Копировать</button></pre></div><div class="mod-footer"><div class="embedded-backlinks" style="display: none;"></div></div></div></div></div><div class="sidebar-right sidebar"><div class="sidebar-content"><span class="sidebar-section-header">Interactive Graph</span><div class="graph-view-placeholder">
		<div class="graph-view-container">
			<div class="graph-icon graph-expand" role="button" aria-label="Expand" data-tooltip-position="top"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon lucide-arrow-up-right"><line x1="7" y1="17" x2="17" y2="7"></line><polyline points="7 7 17 7 17 17"></polyline></svg></div>
			<canvas id="graph-canvas" width="512px" height="512px"></canvas>
		</div>
		</div><div class="tree-container outline-tree" data-depth="0"><div class="tree-header"><span class="sidebar-section-header">Table Of Contents</span><button class="clickable-icon collapse-tree-button"><iconify-icon icon="ph:arrows-in-line-horizontal-bold" width="18px" height="18px" rotate="90deg" color="currentColor"></iconify-icon></button></div><div class="tree-scroll-area"><div class="tree-item mod-tree-heading" data-depth="1"><div class="tree-item-contents"><a class="tree-item-link" href="#Приветствие"><span class="tree-item-title">Приветствие</span></a></div><div class="tree-item-children"></div></div><div class="tree-item mod-tree-heading" data-depth="1"><div class="tree-item-contents"><a class="tree-item-link" href="#Первые_вопросы"><span class="tree-item-title">Первые вопросы</span></a></div><div class="tree-item-children"></div></div><div class="tree-item mod-tree-heading" data-depth="1"><div class="tree-item-contents"><a class="tree-item-link" href="#Об_этой_книге"><span class="tree-item-title">Об этой книге</span></a></div><div class="tree-item-children"></div></div><div class="tree-item mod-tree-heading" data-depth="1"><div class="tree-item-contents"><a class="tree-item-link" href="#Приготовимся"><span class="tree-item-title">Приготовимся</span></a></div><div class="tree-item-children"></div></div><div class="tree-item mod-tree-heading" data-depth="1"><div class="tree-item-contents"><a class="tree-item-link" href="#Киты_и_Черепаха"><span class="tree-item-title">Киты и Черепаха</span></a></div><div class="tree-item-children"><div class="tree-item mod-tree-heading" data-depth="2"><div class="tree-item-contents"><a class="tree-item-link" href="#Черепаха"><span class="tree-item-title">Черепаха</span></a></div><div class="tree-item-children"></div></div><div class="tree-item mod-tree-heading" data-depth="2"><div class="tree-item-contents"><a class="tree-item-link" href="#Первый_Кит"><span class="tree-item-title">Первый Кит</span></a></div><div class="tree-item-children"></div></div><div class="tree-item mod-tree-heading" data-depth="2"><div class="tree-item-contents"><a class="tree-item-link" href="#Второй_Кит"><span class="tree-item-title">Второй Кит</span></a></div><div class="tree-item-children"></div></div><div class="tree-item mod-tree-heading" data-depth="2"><div class="tree-item-contents"><a class="tree-item-link" href="#Третий_Кит"><span class="tree-item-title">Третий Кит</span></a></div><div class="tree-item-children"></div></div></div></div><div class="tree-item mod-tree-heading" data-depth="1"><div class="tree-item-contents"><a class="tree-item-link" href="#Неизменность_и_чистота"><span class="tree-item-title">Неизменность и чистота</span></a></div><div class="tree-item-children"></div></div><div class="tree-item mod-tree-heading" data-depth="1"><div class="tree-item-contents"><a class="tree-item-link" href="#Выбираем_и_возвращаемся"><span class="tree-item-title">Выбираем и возвращаемся</span></a></div><div class="tree-item-children"></div></div><div class="tree-item mod-tree-heading" data-depth="1"><div class="tree-item-contents"><a class="tree-item-link" href="#Выбор_и_образцы"><span class="tree-item-title">Выбор и образцы</span></a></div><div class="tree-item-children"><div class="tree-item mod-tree-heading" data-depth="2"><div class="tree-item-contents"><a class="tree-item-link" href="#Не_только_из_двух"><span class="tree-item-title">Не только из двух</span></a></div><div class="tree-item-children"></div></div><div class="tree-item mod-tree-heading" data-depth="2"><div class="tree-item-contents"><a class="tree-item-link" href="#Без_Если"><span class="tree-item-title">Без Если</span></a></div><div class="tree-item-children"></div></div><div class="tree-item mod-tree-heading" data-depth="2"><div class="tree-item-contents"><a class="tree-item-link" href="#Сравнение_с_образцом"><span class="tree-item-title">Сравнение с образцом</span></a></div><div class="tree-item-children"></div></div></div></div><div class="tree-item mod-tree-heading" data-depth="1"><div class="tree-item-contents"><a class="tree-item-link" href="#Пусть_будет_там,_Где…"><span class="tree-item-title">Пусть будет там, Где…</span></a></div><div class="tree-item-children"><div class="tree-item mod-tree-heading" data-depth="2"><div class="tree-item-contents"><a class="tree-item-link" href="#Пусть"><span class="tree-item-title">Пусть</span></a></div><div class="tree-item-children"></div></div><div class="tree-item mod-tree-heading" data-depth="2"><div class="tree-item-contents"><a class="tree-item-link" href="#Где"><span class="tree-item-title">Где</span></a></div><div class="tree-item-children"></div></div><div class="tree-item mod-tree-heading" data-depth="2"><div class="tree-item-contents"><a class="tree-item-link" href="#Вместе"><span class="tree-item-title">Вместе</span></a></div><div class="tree-item-children"></div></div></div></div><div class="tree-item mod-tree-heading" data-depth="1"><div class="tree-item-contents"><a class="tree-item-link" href="#Мир_операторов"><span class="tree-item-title">Мир операторов</span></a></div><div class="tree-item-children"><div class="tree-item mod-tree-heading" data-depth="2"><div class="tree-item-contents"><a class="tree-item-link" href="#Зачем_это_нужно?"><span class="tree-item-title">Зачем это нужно?</span></a></div><div class="tree-item-children"></div></div></div></div><div class="tree-item mod-tree-heading" data-depth="1"><div class="tree-item-contents"><a class="tree-item-link" href="#Список"><span class="tree-item-title">Список</span></a></div><div class="tree-item-children"><div class="tree-item mod-tree-heading" data-depth="2"><div class="tree-item-contents"><a class="tree-item-link" href="#Тип_списка"><span class="tree-item-title">Тип списка</span></a></div><div class="tree-item-children"></div></div><div class="tree-item mod-tree-heading" data-depth="2"><div class="tree-item-contents"><a class="tree-item-link" href="#Действия_над_списками"><span class="tree-item-title">Действия над списками</span></a></div><div class="tree-item-children"></div></div><div class="tree-item mod-tree-heading" data-depth="2"><div class="tree-item-contents"><a class="tree-item-link" href="#Неизменность_списка"><span class="tree-item-title">Неизменность списка</span></a></div><div class="tree-item-children"></div></div><div class="tree-item mod-tree-heading" data-depth="2"><div class="tree-item-contents"><a class="tree-item-link" href="#Перечисление"><span class="tree-item-title">Перечисление</span></a></div><div class="tree-item-children"></div></div></div></div><div class="tree-item mod-tree-heading" data-depth="1"><div class="tree-item-contents"><a class="tree-item-link" href="#Кортеж"><span class="tree-item-title">Кортеж</span></a></div><div class="tree-item-children"><div class="tree-item mod-tree-heading" data-depth="2"><div class="tree-item-contents"><a class="tree-item-link" href="#Тип_кортежа"><span class="tree-item-title">Тип кортежа</span></a></div><div class="tree-item-children"></div></div><div class="tree-item mod-tree-heading" data-depth="2"><div class="tree-item-contents"><a class="tree-item-link" href="#Действия_над_кортежами"><span class="tree-item-title">Действия над кортежами</span></a></div><div class="tree-item-children"></div></div><div class="tree-item mod-tree-heading" data-depth="2"><div class="tree-item-contents"><a class="tree-item-link" href="#Дополнение"><span class="tree-item-title">Дополнение</span></a></div><div class="tree-item-children"></div></div></div></div><div class="tree-item mod-tree-heading" data-depth="1"><div class="tree-item-contents"><a class="tree-item-link" href="#Лямбда-функция"><span class="tree-item-title">Лямбда-функция</span></a></div><div class="tree-item-children"><div class="tree-item mod-tree-heading" data-depth="2"><div class="tree-item-contents"><a class="tree-item-link" href="#Локальные_функции"><span class="tree-item-title">Локальные функции</span></a></div><div class="tree-item-children"></div></div></div></div><div class="tree-item mod-tree-heading" data-depth="1"><div class="tree-item-contents"><a class="tree-item-link" href="#Композиция_функций"><span class="tree-item-title">Композиция функций</span></a></div><div class="tree-item-children"><div class="tree-item mod-tree-heading" data-depth="2"><div class="tree-item-contents"><a class="tree-item-link" href="#Композиция_и_применение"><span class="tree-item-title">Композиция и применение</span></a></div><div class="tree-item-children"></div></div><div class="tree-item mod-tree-heading" data-depth="2"><div class="tree-item-contents"><a class="tree-item-link" href="#Длинные_цепочки"><span class="tree-item-title">Длинные цепочки</span></a></div><div class="tree-item-children"></div></div></div></div><div class="tree-item mod-tree-heading" data-depth="1"><div class="tree-item-contents"><a class="tree-item-link" href="#ФВП"><span class="tree-item-title">ФВП</span></a></div><div class="tree-item-children"><div class="tree-item mod-tree-heading" data-depth="2"><div class="tree-item-contents"><a class="tree-item-link" href="#Отображение"><span class="tree-item-title">Отображение</span></a></div><div class="tree-item-children"></div></div><div class="tree-item mod-tree-heading" data-depth="2"><div class="tree-item-contents"><a class="tree-item-link" href="#Частичное_применение"><span class="tree-item-title">Частичное применение</span></a></div><div class="tree-item-children"></div></div><div class="tree-item mod-tree-heading" data-depth="2"><div class="tree-item-contents"><a class="tree-item-link" href="#Композиция_для_отображения"><span class="tree-item-title">Композиция для отображения</span></a></div><div class="tree-item-children"></div></div></div></div><div class="tree-item mod-tree-heading" data-depth="1"><div class="tree-item-contents"><a class="tree-item-link" href="#Hackage_и_библиотеки"><span class="tree-item-title">Hackage и библиотеки</span></a></div><div class="tree-item-children"><div class="tree-item mod-tree-heading" data-depth="2"><div class="tree-item-contents"><a class="tree-item-link" href="#Библиотеки_большие_и_маленькие"><span class="tree-item-title">Библиотеки большие и маленькие</span></a></div><div class="tree-item-children"></div></div><div class="tree-item mod-tree-heading" data-depth="2"><div class="tree-item-contents"><a class="tree-item-link" href="#Hackage"><span class="tree-item-title">Hackage</span></a></div><div class="tree-item-children"></div></div></div></div><div class="tree-item mod-tree-heading" data-depth="1"><div class="tree-item-contents"><a class="tree-item-link" href="#Рекурсия"><span class="tree-item-title">Рекурсия</span></a></div><div class="tree-item-children"><div class="tree-item mod-tree-heading" data-depth="2"><div class="tree-item-contents"><a class="tree-item-link" href="#Правда_о_списке"><span class="tree-item-title">Правда о списке</span></a></div><div class="tree-item-children"></div></div><div class="tree-item mod-tree-heading" data-depth="2"><div class="tree-item-contents"><a class="tree-item-link" href="#Туда_и_обратно"><span class="tree-item-title">Туда и обратно</span></a></div><div class="tree-item-children"></div></div><div class="tree-item mod-tree-heading" data-depth="2"><div class="tree-item-contents"><a class="tree-item-link" href="#Для_любопытных"><span class="tree-item-title">Для любопытных</span></a></div><div class="tree-item-children"></div></div></div></div><div class="tree-item mod-tree-heading" data-depth="1"><div class="tree-item-contents"><a class="tree-item-link" href="#Лень"><span class="tree-item-title">Лень</span></a></div><div class="tree-item-children"><div class="tree-item mod-tree-heading" data-depth="2"><div class="tree-item-contents"><a class="tree-item-link" href="#Рациональность"><span class="tree-item-title">Рациональность</span></a></div><div class="tree-item-children"></div></div><div class="tree-item mod-tree-heading" data-depth="2"><div class="tree-item-contents"><a class="tree-item-link" href="#Бесконечность"><span class="tree-item-title">Бесконечность</span></a></div><div class="tree-item-children"></div></div><div class="tree-item mod-tree-heading" data-depth="2"><div class="tree-item-contents"><a class="tree-item-link" href="#Space_leak"><span class="tree-item-title">Space leak</span></a></div><div class="tree-item-children"></div></div><div class="tree-item mod-tree-heading mod-collapsible" data-depth="2"><div class="tree-item-contents"><div class="tree-item-icon collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div><a class="tree-item-link" href="#Борьба"><span class="tree-item-title">Борьба</span></a></div><div class="tree-item-children"><div class="tree-item mod-tree-heading" data-depth="3"><div class="tree-item-contents"><a class="tree-item-link" href="#Оптимизация"><span class="tree-item-title">Оптимизация</span></a></div><div class="tree-item-children"></div></div><div class="tree-item mod-tree-heading" data-depth="3"><div class="tree-item-contents"><a class="tree-item-link" href="#Вручную"><span class="tree-item-title">Вручную</span></a></div><div class="tree-item-children"></div></div></div></div><div class="tree-item mod-tree-heading" data-depth="2"><div class="tree-item-contents"><a class="tree-item-link" href="#Лень_и_строгость_вместе"><span class="tree-item-title">Лень и строгость вместе</span></a></div><div class="tree-item-children"></div></div><div class="tree-item mod-tree-heading" data-depth="2"><div class="tree-item-contents"><a class="tree-item-link" href="#Для_любопытных"><span class="tree-item-title">Для любопытных</span></a></div><div class="tree-item-children"></div></div></div></div><div class="tree-item mod-tree-heading" data-depth="1"><div class="tree-item-contents"><a class="tree-item-link" href="#Наши_типы"><span class="tree-item-title">Наши типы</span></a></div><div class="tree-item-children"><div class="tree-item mod-tree-heading" data-depth="2"><div class="tree-item-contents"><a class="tree-item-link" href="#Значение-пустышка"><span class="tree-item-title">Значение-пустышка</span></a></div><div class="tree-item-children"></div></div></div></div><div class="tree-item mod-tree-heading" data-depth="1"><div class="tree-item-contents"><a class="tree-item-link" href="#АТД"><span class="tree-item-title">АТД</span></a></div><div class="tree-item-children"><div class="tree-item mod-tree-heading" data-depth="2"><div class="tree-item-contents"><a class="tree-item-link" href="#Извлекаем_значение"><span class="tree-item-title">Извлекаем значение</span></a></div><div class="tree-item-children"></div></div><div class="tree-item mod-tree-heading" data-depth="2"><div class="tree-item-contents"><a class="tree-item-link" href="#Строим"><span class="tree-item-title">Строим</span></a></div><div class="tree-item-children"></div></div></div></div><div class="tree-item mod-tree-heading" data-depth="1"><div class="tree-item-contents"><a class="tree-item-link" href="#АТД:_поля_с_метками"><span class="tree-item-title">АТД: поля с метками</span></a></div><div class="tree-item-children"><div class="tree-item mod-tree-heading" data-depth="2"><div class="tree-item-contents"><a class="tree-item-link" href="#Метки"><span class="tree-item-title">Метки</span></a></div><div class="tree-item-children"></div></div><div class="tree-item mod-tree-heading" data-depth="2"><div class="tree-item-contents"><a class="tree-item-link" href="#Getter_и_Setter?"><span class="tree-item-title">Getter и Setter?</span></a></div><div class="tree-item-children"></div></div><div class="tree-item mod-tree-heading" data-depth="2"><div class="tree-item-contents"><a class="tree-item-link" href="#Без_меток"><span class="tree-item-title">Без меток</span></a></div><div class="tree-item-children"></div></div></div></div><div class="tree-item mod-tree-heading" data-depth="1"><div class="tree-item-contents"><a class="tree-item-link" href="#Новый_тип"><span class="tree-item-title">Новый тип</span></a></div><div class="tree-item-children"><div class="tree-item mod-tree-heading" data-depth="2"><div class="tree-item-contents"><a class="tree-item-link" href="#Различия"><span class="tree-item-title">Различия</span></a></div><div class="tree-item-children"></div></div><div class="tree-item mod-tree-heading" data-depth="2"><div class="tree-item-contents"><a class="tree-item-link" href="#Зачем_он_нужен?"><span class="tree-item-title">Зачем он нужен?</span></a></div><div class="tree-item-children"></div></div><div class="tree-item mod-tree-heading" data-depth="2"><div class="tree-item-contents"><a class="tree-item-link" href="#type_vs_newtype"><span class="tree-item-title">type vs newtype</span></a></div><div class="tree-item-children"></div></div></div></div><div class="tree-item mod-tree-heading" data-depth="1"><div class="tree-item-contents"><a class="tree-item-link" href="#Конструктор_типа"><span class="tree-item-title">Конструктор типа</span></a></div><div class="tree-item-children"><div class="tree-item mod-tree-heading" data-depth="2"><div class="tree-item-contents"><a class="tree-item-link" href="#Опциональный_тип"><span class="tree-item-title">Опциональный тип</span></a></div><div class="tree-item-children"></div></div><div class="tree-item mod-tree-heading" data-depth="2"><div class="tree-item-contents"><a class="tree-item-link" href="#Может_быть"><span class="tree-item-title">Может быть</span></a></div><div class="tree-item-children"></div></div><div class="tree-item mod-tree-heading" data-depth="2"><div class="tree-item-contents"><a class="tree-item-link" href="#Этажи"><span class="tree-item-title">Этажи</span></a></div><div class="tree-item-children"></div></div></div></div></div></div></div></div></div></body></html>