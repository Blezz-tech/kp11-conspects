<!DOCTYPE html>
<html><head>
			
		<title>Chapter 13 For a Few Monads More</title>
		<base href="../../../">
		<meta id="root-path" root-path="../../../">

		<link rel="icon" sizes="96x96" href="https://publish-01.obsidian.md/access/f786db9fac45774fa4f0d8112e232d67/favicon-96x96.png">
		<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes, minimum-scale=1.0, maximum-scale=5.0">
		<meta charset="UTF-8">
		<script src="https://code.iconify.design/iconify-icon/1.0.3/iconify-icon.min.js"></script>

			<link rel="stylesheet" href="lib/styles/obsidian-styles.css">
			<link rel="stylesheet" href="lib/styles/theme.css">
			<link rel="stylesheet" href="lib/styles/plugin-styles.css">
			<link rel="stylesheet" href="lib/styles/snippets.css">
			<style>  </style>

			
			<!-- Graph View Data -->
			<script>
			let nodes=
{"nodeCount":22,"linkCount":21,"radii":[7,5.346938775510203,4.855867346938775,4.301020408163265,3.6823979591836737,3.6823979591836737,3.6823979591836737,3.6823979591836737,3.6823979591836737,3.6823979591836737,3.6823979591836737,3.6823979591836737,3.6823979591836737,3.6823979591836737,3.6823979591836737,3.6823979591836737,3.6823979591836737,3.6823979591836737,3.6823979591836737,3.6823979591836737,3.6823979591836737,3.6823979591836737],"labels":["Table Of Content","Отчеты","README","README","О Haskell по-человечески (Итого)","Полезные ресурсы","О Haskell по-человечески (Оригинал)","Оглавление","Chapter 13 For a Few Monads More","Chapter 12 A Fistful of Monads","Chapter 11 Functors, Applicative Functors and Monoids","Chapter 10 Functionally Solving Problems","Chapter 9 Input and Output","Chapter 8 Making Our Own Types and Typeclasses","Chapter 7 Modules","Chapter 6 Higher order functions","Chapter 5 Recursion","Chapter 4 Syntax in Functions","Chapter 14 Zippers","Chapter 1 Introduction","Chapter 2 Starting Out","Chapter 3 Types and Typeclasses"],"paths":["курсы/learn-you-a-haskell-for-great-good!/en/table-of-content.html","отчеты.html","курсы/learn-you-a-haskell-for-great-good!/readme.html","readme.html","мои-решения/о-haskell-по-человечески/о-haskell-по-человечески-(итого).html","полезные-ресурсы.html","курсы/о-haskell-по-человечески/о-haskell-по-человечески-(оригинал).html","курсы/learn-you-a-haskell-for-great-good!/ru/оглавление.html","курсы/learn-you-a-haskell-for-great-good!/en/chapter-13-for-a-few-monads-more.html","курсы/learn-you-a-haskell-for-great-good!/en/chapter-12-a-fistful-of-monads.html","курсы/learn-you-a-haskell-for-great-good!/en/chapter-11-functors,-applicative-functors-and-monoids.html","курсы/learn-you-a-haskell-for-great-good!/en/chapter-10-functionally-solving-problems.html","курсы/learn-you-a-haskell-for-great-good!/en/chapter-9-input-and-output.html","курсы/learn-you-a-haskell-for-great-good!/en/chapter-8-making-our-own-types-and-typeclasses.html","курсы/learn-you-a-haskell-for-great-good!/en/chapter-7-modules.html","курсы/learn-you-a-haskell-for-great-good!/en/chapter-6-higher-order-functions.html","курсы/learn-you-a-haskell-for-great-good!/en/chapter-5-recursion.html","курсы/learn-you-a-haskell-for-great-good!/en/chapter-4-syntax-in-functions.html","курсы/learn-you-a-haskell-for-great-good!/en/chapter-14-zippers.html","курсы/learn-you-a-haskell-for-great-good!/en/chapter-1-introduction.html","курсы/learn-you-a-haskell-for-great-good!/en/chapter-2-starting-out.html","курсы/learn-you-a-haskell-for-great-good!/en/chapter-3-types-and-typeclasses.html"],"linkSources":[3,3,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,2],"linkTargets":[5,1,6,4,2,19,20,21,17,16,15,14,13,12,11,10,9,8,18,0,7]};
			let attractionForce = 1;
			let linkLength = 10;
			let repulsionForce = 150;
			let centralForce = 3;
			let edgePruning = 100;
			</script>
			
<script type="module" src="lib/scripts/graph_view.js"></script>

<script src="lib/scripts/graph_wasm.js"></script>

<script src="lib/scripts/tinycolor.js"></script>

<script src="https://cdnjs.cloudflare.com/ajax/libs/pixi.js/7.2.4/pixi.min.js" integrity="sha512-Ch/O6kL8BqUwAfCF7Ie5SX1Hin+BJgYH4pNjRqXdTEqMsis1TUYg+j6nnI9uduPjGaj7DN4UKCZgpvoExt6dkw==" crossorigin="anonymous" referrerpolicy="no-referrer"></script>

<script src="lib/scripts/webpage.js"></script>

			</head><body class="theme-dark mod-windows is-frameless is-maximized is-hidden-frameless obsidian-app show-inline-title show-view-header is-focused" style="--zoom-factor:1; --font-text-size:16px; --line-width:100%; --line-width-adaptive:100%; --file-line-width:100%; --content-width:500em; --sidebar-width:25em; --collapse-arrow-size:0.4em; --tree-horizontal-spacing:1em; --tree-vertical-spacing:0.5em; --sidebar-margin:12px;"><div class="webpage-container"><div class="sidebar-left sidebar"><div class="sidebar-content"><div><label class="theme-toggle-container" for="theme_toggle"><input class="theme-toggle-input" type="checkbox" id="theme_toggle"><div class="toggle-background"></div></label></div><div class="tree-container file-tree mod-nav-indicator" data-depth="0"><div class="tree-header"><span class="sidebar-section-header">learn-haskell-valut</span><button class="clickable-icon collapse-tree-button is-collapsed"><iconify-icon icon="ph:arrows-in-line-horizontal-bold" width="18px" height="18px" rotate="90deg" color="currentColor"></iconify-icon></button></div><div class="tree-scroll-area"><div class="tree-item mod-tree-folder mod-collapsible is-collapsed" data-depth="1"><div class="tree-item-contents"><div class="tree-item-icon collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div><a class="tree-item-link" href="курсы"><span class="tree-item-title">Курсы</span></a></div><div class="tree-item-children"><div class="tree-item mod-tree-folder mod-collapsible is-collapsed" data-depth="2"><div class="tree-item-contents"><div class="tree-item-icon collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div><a class="tree-item-link" href="курсы/о-haskell-по-человечески"><span class="tree-item-title">О Haskell по-человечески</span></a></div><div class="tree-item-children"><div class="tree-item mod-tree-file" data-depth="3"><div class="tree-item-contents"><a class="tree-item-link" href="курсы/о-haskell-по-человечески/о-haskell-по-человечески-(оригинал).html"><span class="tree-item-title">О Haskell по-человечески (Оригинал)</span></a></div><div class="tree-item-children"></div></div></div></div><div class="tree-item mod-tree-folder mod-collapsible is-collapsed" data-depth="2"><div class="tree-item-contents"><div class="tree-item-icon collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div><a class="tree-item-link" href="курсы/learn-you-a-haskell-for-great-good!"><span class="tree-item-title">Learn You a Haskell for Great Good!</span></a></div><div class="tree-item-children"><div class="tree-item mod-tree-folder mod-collapsible is-collapsed" data-depth="3"><div class="tree-item-contents"><div class="tree-item-icon collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div><a class="tree-item-link" href="курсы/learn-you-a-haskell-for-great-good!/en"><span class="tree-item-title">en</span></a></div><div class="tree-item-children"><div class="tree-item mod-tree-file" data-depth="4"><div class="tree-item-contents"><a class="tree-item-link" href="курсы/learn-you-a-haskell-for-great-good!/en/chapter-1-introduction.html"><span class="tree-item-title">Chapter 1 Introduction</span></a></div><div class="tree-item-children"></div></div><div class="tree-item mod-tree-file" data-depth="4"><div class="tree-item-contents"><a class="tree-item-link" href="курсы/learn-you-a-haskell-for-great-good!/en/chapter-10-functionally-solving-problems.html"><span class="tree-item-title">Chapter 10 Functionally Solving Problems</span></a></div><div class="tree-item-children"></div></div><div class="tree-item mod-tree-file" data-depth="4"><div class="tree-item-contents"><a class="tree-item-link" href="курсы/learn-you-a-haskell-for-great-good!/en/chapter-11-functors,-applicative-functors-and-monoids.html"><span class="tree-item-title">Chapter 11 Functors, Applicative Functors and Monoids</span></a></div><div class="tree-item-children"></div></div><div class="tree-item mod-tree-file" data-depth="4"><div class="tree-item-contents"><a class="tree-item-link" href="курсы/learn-you-a-haskell-for-great-good!/en/chapter-12-a-fistful-of-monads.html"><span class="tree-item-title">Chapter 12 A Fistful of Monads</span></a></div><div class="tree-item-children"></div></div><div class="tree-item mod-tree-file" data-depth="4"><div class="tree-item-contents"><a class="tree-item-link" href="курсы/learn-you-a-haskell-for-great-good!/en/chapter-13-for-a-few-monads-more.html"><span class="tree-item-title">Chapter 13 For a Few Monads More</span></a></div><div class="tree-item-children"></div></div><div class="tree-item mod-tree-file" data-depth="4"><div class="tree-item-contents"><a class="tree-item-link" href="курсы/learn-you-a-haskell-for-great-good!/en/chapter-14-zippers.html"><span class="tree-item-title">Chapter 14 Zippers</span></a></div><div class="tree-item-children"></div></div><div class="tree-item mod-tree-file" data-depth="4"><div class="tree-item-contents"><a class="tree-item-link" href="курсы/learn-you-a-haskell-for-great-good!/en/chapter-2-starting-out.html"><span class="tree-item-title">Chapter 2 Starting Out</span></a></div><div class="tree-item-children"></div></div><div class="tree-item mod-tree-file" data-depth="4"><div class="tree-item-contents"><a class="tree-item-link" href="курсы/learn-you-a-haskell-for-great-good!/en/chapter-3-types-and-typeclasses.html"><span class="tree-item-title">Chapter 3 Types and Typeclasses</span></a></div><div class="tree-item-children"></div></div><div class="tree-item mod-tree-file" data-depth="4"><div class="tree-item-contents"><a class="tree-item-link" href="курсы/learn-you-a-haskell-for-great-good!/en/chapter-4-syntax-in-functions.html"><span class="tree-item-title">Chapter 4 Syntax in Functions</span></a></div><div class="tree-item-children"></div></div><div class="tree-item mod-tree-file" data-depth="4"><div class="tree-item-contents"><a class="tree-item-link" href="курсы/learn-you-a-haskell-for-great-good!/en/chapter-5-recursion.html"><span class="tree-item-title">Chapter 5 Recursion</span></a></div><div class="tree-item-children"></div></div><div class="tree-item mod-tree-file" data-depth="4"><div class="tree-item-contents"><a class="tree-item-link" href="курсы/learn-you-a-haskell-for-great-good!/en/chapter-6-higher-order-functions.html"><span class="tree-item-title">Chapter 6 Higher order functions</span></a></div><div class="tree-item-children"></div></div><div class="tree-item mod-tree-file" data-depth="4"><div class="tree-item-contents"><a class="tree-item-link" href="курсы/learn-you-a-haskell-for-great-good!/en/chapter-7-modules.html"><span class="tree-item-title">Chapter 7 Modules</span></a></div><div class="tree-item-children"></div></div><div class="tree-item mod-tree-file" data-depth="4"><div class="tree-item-contents"><a class="tree-item-link" href="курсы/learn-you-a-haskell-for-great-good!/en/chapter-8-making-our-own-types-and-typeclasses.html"><span class="tree-item-title">Chapter 8 Making Our Own Types and Typeclasses</span></a></div><div class="tree-item-children"></div></div><div class="tree-item mod-tree-file" data-depth="4"><div class="tree-item-contents"><a class="tree-item-link" href="курсы/learn-you-a-haskell-for-great-good!/en/chapter-9-input-and-output.html"><span class="tree-item-title">Chapter 9 Input and Output</span></a></div><div class="tree-item-children"></div></div><div class="tree-item mod-tree-file" data-depth="4"><div class="tree-item-contents"><a class="tree-item-link" href="курсы/learn-you-a-haskell-for-great-good!/en/table-of-content.html"><span class="tree-item-title">Table Of Content</span></a></div><div class="tree-item-children"></div></div></div></div><div class="tree-item mod-tree-folder mod-collapsible is-collapsed" data-depth="3"><div class="tree-item-contents"><div class="tree-item-icon collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div><a class="tree-item-link" href="курсы/learn-you-a-haskell-for-great-good!/ru"><span class="tree-item-title">ru</span></a></div><div class="tree-item-children"><div class="tree-item mod-tree-file" data-depth="4"><div class="tree-item-contents"><a class="tree-item-link" href="курсы/learn-you-a-haskell-for-great-good!/ru/оглавление.html"><span class="tree-item-title">Оглавление</span></a></div><div class="tree-item-children"></div></div></div></div><div class="tree-item mod-tree-file" data-depth="3"><div class="tree-item-contents"><a class="tree-item-link" href="курсы/learn-you-a-haskell-for-great-good!/readme.html"><span class="tree-item-title">README</span></a></div><div class="tree-item-children"></div></div></div></div></div></div><div class="tree-item mod-tree-folder mod-collapsible is-collapsed" data-depth="1"><div class="tree-item-contents"><div class="tree-item-icon collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div><a class="tree-item-link" href="мои-решения"><span class="tree-item-title">Мои решения</span></a></div><div class="tree-item-children"><div class="tree-item mod-tree-folder mod-collapsible is-collapsed" data-depth="2"><div class="tree-item-contents"><div class="tree-item-icon collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div><a class="tree-item-link" href="мои-решения/о-haskell-по-человечески"><span class="tree-item-title">О Haskell по-человечески</span></a></div><div class="tree-item-children"><div class="tree-item mod-tree-file" data-depth="3"><div class="tree-item-contents"><a class="tree-item-link" href="мои-решения/о-haskell-по-человечески/о-haskell-по-человечески-(итого).html"><span class="tree-item-title">О Haskell по-человечески (Итого)</span></a></div><div class="tree-item-children"></div></div></div></div></div></div><div class="tree-item mod-tree-file" data-depth="1"><div class="tree-item-contents"><a class="tree-item-link" href="отчеты.html"><span class="tree-item-title">Отчеты</span></a></div><div class="tree-item-children"></div></div><div class="tree-item mod-tree-file" data-depth="1"><div class="tree-item-contents"><a class="tree-item-link" href="полезные-ресурсы.html"><span class="tree-item-title">Полезные ресурсы</span></a></div><div class="tree-item-children"></div></div><div class="tree-item mod-tree-file" data-depth="1"><div class="tree-item-contents"><a class="tree-item-link" href="readme.html"><span class="tree-item-title">README</span></a></div><div class="tree-item-children"></div></div></div></div></div></div><div class="document-container"><div class="markdown-preview-view markdown-rendered node-insert-event allow-fold-headings show-indentation-guide allow-fold-lists show-frontmatter" style="tab-size: 4;"><style id="MJX-CHTML-styles"></style><div class="markdown-preview-sizer markdown-preview-section" style="padding-bottom: ; padding-top: var(--file-margins); padding-right: var(--file-margins); padding-left: var(--file-margins); width: 100%; position: absolute;"><div class="markdown-preview-pusher" style="width: 1px; height: 0.1px; margin-bottom: 0px;"></div><div class="mod-header"></div><div><h1 data-heading="For a Few Monads More" id="For_a_Few_Monads_More">For a Few Monads More</h1></div><div><p><img alt="there are two kinds of people in the world, my friend. those who learn them a haskell and those who have the job of coding java" src="http://s3.amazonaws.com/lyah/clint.png" referrerpolicy="no-referrer"></p></div><div><p>We've seen how monads can be used to take values with contexts and apply them to functions and how using&nbsp;<code>&gt;&gt;=</code>&nbsp;or&nbsp;<code>do</code>&nbsp;notation allows us to focus on the values themselves while the context gets handled for us.</p></div><div><p>We've met the&nbsp;<code>Maybe</code>&nbsp;monad and seen how it adds a context of possible failure to values. We've learned about the list monad and saw how it lets us easily introduce non-determinism into our programs. We've also learned how to work in the&nbsp;<code>IO</code>&nbsp;monad, even before we knew what a monad was!</p></div><div><p>In this chapter, we're going to learn about a few other monads. We'll see how they can make our programs clearer by letting us treat all sorts of values as monadic ones. Exploring a few monads more will also solidify our intuition for monads.</p></div><div><p>The monads that we'll be exploring are all part of the&nbsp;<code>mtl</code>&nbsp;package. A Haskell package is a collection of modules. The&nbsp;<code>mtl</code>&nbsp;package comes with the Haskell Platform, so you probably already have it. To check if you do, type&nbsp;<code>ghc-pkg list</code>&nbsp;in the command-line. This will show which Haskell packages you have installed and one of them should be&nbsp;<code>mtl</code>, followed by a version number.</p></div><div><h2 data-heading="Writer? I hardly know her!" id="Writer?_I_hardly_know_her!" style="display: flex;"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>Writer? I hardly know her!</h2></div><div><p>We've loaded our gun with the&nbsp;<code>Maybe</code>&nbsp;monad, the list monad and the&nbsp;<code>IO</code>&nbsp;monad. Now let's put the&nbsp;<code>Writer</code>&nbsp;monad in the chamber and see what happens when we fire it!</p></div><div><p>Whereas&nbsp;<code>Maybe</code>&nbsp;is for values with an added context of failure and the list is for non-deterministic values, the&nbsp;<code>Writer</code>&nbsp;monad is for values that have another value attached that acts as a sort of log value.&nbsp;<code>Writer</code>&nbsp;allows us to do computations while making sure that all the log values are combined into one log value that then gets attached to the result.</p></div><div><p>For instance, we might want to equip our values with strings that explain what's going on, probably for debugging purposes. Consider a function that takes a number of bandits in a gang and tells us if that's a big gang or not. That's a very simple function:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">isBigGang</span> <span class="token operator">::</span> <span class="token constant">Int</span> <span class="token operator">-&gt;</span> <span class="token constant">Bool</span>
<span class="token hvariable">isBigGang</span> <span class="token hvariable">x</span> <span class="token operator">=</span> <span class="token hvariable">x</span> <span class="token operator">&gt;</span> <span class="token number">9</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Now, what if instead of just giving us a&nbsp;<code>True</code>&nbsp;or&nbsp;<code>False</code>&nbsp;value, we want it to also return a log string that says what it did? Well, we just make that string and return it along side our&nbsp;<code>Bool</code>:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">isBigGang</span> <span class="token operator">::</span> <span class="token constant">Int</span> <span class="token operator">-&gt;</span> <span class="token punctuation">(</span><span class="token constant">Bool</span><span class="token punctuation">,</span> <span class="token constant">String</span><span class="token punctuation">)</span>
<span class="token hvariable">isBigGang</span> <span class="token hvariable">x</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token hvariable">x</span> <span class="token operator">&gt;</span> <span class="token number">9</span><span class="token punctuation">,</span> <span class="token string">"Compared gang size to 9."</span><span class="token punctuation">)</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>So now instead of just returning a&nbsp;<code>Bool</code>, we return a tuple where the first component of the tuple is the actual value and the second component is the string that accompanies that value. There's some added context to our value now. Let's give this a go:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token hvariable">isBigGang</span> <span class="token number">3</span>
<span class="token punctuation">(</span><span class="token constant">False</span><span class="token punctuation">,</span><span class="token string">"Compared gang size to 9."</span><span class="token punctuation">)</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token hvariable">isBigGang</span> <span class="token number">30</span>
<span class="token punctuation">(</span><span class="token constant">True</span><span class="token punctuation">,</span><span class="token string">"Compared gang size to 9."</span><span class="token punctuation">)</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p><img alt="when you have to poop, poop, don't talk" src="http://s3.amazonaws.com/lyah/tuco.png" referrerpolicy="no-referrer"></p></div><div><p>So far so good.&nbsp;<code>isBigGang</code>&nbsp;takes a normal value and returns a value with a context. As we've just seen, feeding it a normal value is not a problem. Now what if we already have a value that has a log string attached to it, such as&nbsp;<code>(3, "Smallish gang.")</code>, and we want to feed it to&nbsp;<code>isBigGang</code>? It seems like once again, we're faced with this question: if we have a function that takes a normal value and returns a value with a context, how do we take a value with a context and feed it to the function?</p></div><div><p>When we were exploring the&nbsp;<code>Maybe</code>&nbsp;monad, we made a function&nbsp;<code>applyMaybe</code>, which took a&nbsp;<code>Maybe a</code>&nbsp;value and a function of type&nbsp;<code>a -&gt; Maybe b</code>&nbsp;and fed that&nbsp;<code>Maybe a</code>&nbsp;value into the function, even though the function takes a normal&nbsp;<code>a</code>&nbsp;instead of a&nbsp;<code>Maybe a</code>. It did this by minding the context that comes with&nbsp;<code>Maybe a</code>&nbsp;values, which is that they are values with possible failure. But inside the&nbsp;<code>a -&gt; Maybe b</code>&nbsp;function, we were able to treat that value as just a normal value, because&nbsp;<code>applyMaybe</code>&nbsp;(which later became&nbsp;<code>&gt;&gt;=</code>) took care of checking if it was a&nbsp;<code>Nothing</code>&nbsp;or a&nbsp;<code>Just</code>&nbsp;value.</p></div><div><p>In the same vein, let's make a function that takes a value with an attached log, that is, an&nbsp;<code>(a,String)</code>&nbsp;value and a function of type&nbsp;<code>a -&gt; (b,String)</code>&nbsp;and feeds that value into the function. We'll call it&nbsp;<code>applyLog</code>. But because an&nbsp;<code>(a,String)</code>&nbsp;value doesn't carry with it a context of possible failure, but rather a context of an additional log value,&nbsp;<code>applyLog</code>&nbsp;is going to make sure that the log of the original value isn't lost, but is joined together with the log of the value that results from the function. Here's the implementation of&nbsp;<code>applyLog</code>:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">applyLog</span> <span class="token operator">::</span> <span class="token punctuation">(</span><span class="token hvariable">a</span><span class="token punctuation">,</span><span class="token constant">String</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token punctuation">(</span><span class="token hvariable">a</span> <span class="token operator">-&gt;</span> <span class="token punctuation">(</span><span class="token hvariable">b</span><span class="token punctuation">,</span><span class="token constant">String</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token punctuation">(</span><span class="token hvariable">b</span><span class="token punctuation">,</span><span class="token constant">String</span><span class="token punctuation">)</span>
<span class="token hvariable">applyLog</span> <span class="token punctuation">(</span><span class="token hvariable">x</span><span class="token punctuation">,</span><span class="token builtin">log</span><span class="token punctuation">)</span> <span class="token hvariable">f</span> <span class="token operator">=</span> <span class="token keyword">let</span> <span class="token punctuation">(</span><span class="token hvariable">y</span><span class="token punctuation">,</span><span class="token hvariable">newLog</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token hvariable">f</span> <span class="token hvariable">x</span> <span class="token keyword">in</span> <span class="token punctuation">(</span><span class="token hvariable">y</span><span class="token punctuation">,</span><span class="token builtin">log</span> <span class="token operator">++</span> <span class="token hvariable">newLog</span><span class="token punctuation">)</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>When we have a value with a context and we want to feed it to a function, we usually try to separate the actual value from the context and then try to apply the function to the value and then see that the context is taken care of. In the&nbsp;<code>Maybe</code>&nbsp;monad, we checked if the value was a&nbsp;<code>Just x</code>&nbsp;and if it was, we took that&nbsp;<code>x</code>&nbsp;and applied the function to it. In this case, it's very easy to find the actual value, because we're dealing with a pair where one component is the value and the other a log. So first we just take the value, which is&nbsp;<code>x</code>&nbsp;and we apply the function&nbsp;<code>f</code>&nbsp;to it. We get a pair of&nbsp;<code>(y,newLog)</code>, where&nbsp;<code>y</code>&nbsp;is the new result and&nbsp;<code>newLog</code>&nbsp;the new log. But if we returned that as the result, the old log value wouldn't be included in the result, so we return a pair of&nbsp;<code>(y,log ++ newLog)</code>. We use&nbsp;<code>++</code>&nbsp;to append the new log to the old one.</p></div><div><p>Here's&nbsp;<code>applyLog</code>&nbsp;in action:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token string">"Smallish gang."</span><span class="token punctuation">)</span> <span class="token operator">`applyLog`</span> <span class="token hvariable">isBigGang</span>
<span class="token punctuation">(</span><span class="token constant">False</span><span class="token punctuation">,</span><span class="token string">"Smallish gang.Compared gang size to 9"</span><span class="token punctuation">)</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token punctuation">(</span><span class="token number">30</span><span class="token punctuation">,</span> <span class="token string">"A freaking platoon."</span><span class="token punctuation">)</span> <span class="token operator">`applyLog`</span> <span class="token hvariable">isBigGang</span>
<span class="token punctuation">(</span><span class="token constant">True</span><span class="token punctuation">,</span><span class="token string">"A freaking platoon.Compared gang size to 9"</span><span class="token punctuation">)</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>The results are similar to before, only now the number of people in the gang had its accompanying log and it got included in the result log. Here are a few more examples of using&nbsp;<code>applyLog</code>:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token punctuation">(</span><span class="token string">"Tobin"</span><span class="token punctuation">,</span><span class="token string">"Got outlaw name."</span><span class="token punctuation">)</span> <span class="token operator">`applyLog`</span> <span class="token punctuation">(</span><span class="token operator">\</span><span class="token hvariable">x</span> <span class="token operator">-&gt;</span> <span class="token punctuation">(</span><span class="token builtin">length</span> <span class="token hvariable">x</span><span class="token punctuation">,</span> <span class="token string">"Applied length."</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token string">"Got outlaw name.Applied length."</span><span class="token punctuation">)</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token punctuation">(</span><span class="token string">"Bathcat"</span><span class="token punctuation">,</span><span class="token string">"Got outlaw name."</span><span class="token punctuation">)</span> <span class="token operator">`applyLog`</span> <span class="token punctuation">(</span><span class="token operator">\</span><span class="token hvariable">x</span> <span class="token operator">-&gt;</span> <span class="token punctuation">(</span><span class="token builtin">length</span> <span class="token hvariable">x</span><span class="token punctuation">,</span> <span class="token string">"Applied length"</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token punctuation">(</span><span class="token number">7</span><span class="token punctuation">,</span><span class="token string">"Got outlaw name.Applied length"</span><span class="token punctuation">)</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>See how inside the lambda,&nbsp;<code>x</code>&nbsp;is just a normal string and not a tuple and how&nbsp;<code>applyLog</code>&nbsp;takes care of appending the logs.</p></div><div><h3 data-heading="Monoids to the rescue" id="Monoids_to_the_rescue" style="display: flex;"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>Monoids to the rescue</h3></div><div><p>Be sure you know what&nbsp;<a data-tooltip-position="top" aria-label="http://learnyouahaskell.com/functors-applicative-functors-and-monoids#monoids" rel="noopener" class="external-link" href="http://learnyouahaskell.com/functors-applicative-functors-and-monoids#monoids" target="_blank">monoids</a>&nbsp;are at this point! Cheers.</p></div><div><p>Right now,&nbsp;<code>applyLog</code>&nbsp;takes values of type&nbsp;<code>(a,String)</code>, but is there a reason that the log has to be a&nbsp;<code>String</code>? It uses&nbsp;<code>++</code>&nbsp;to append the logs, so wouldn't this work on any kind of list, not just a list of characters? Sure it would. We can go ahead and change its type to this:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">applyLog</span> <span class="token operator">::</span> <span class="token punctuation">(</span><span class="token hvariable">a</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token hvariable">c</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token punctuation">(</span><span class="token hvariable">a</span> <span class="token operator">-&gt;</span> <span class="token punctuation">(</span><span class="token hvariable">b</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token hvariable">c</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token punctuation">(</span><span class="token hvariable">b</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token hvariable">c</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Now, the log is a list. The type of values contained in the list has to be the same for the original list as well as for the list that the function returns, otherwise we wouldn't be able to use&nbsp;<code>++</code>&nbsp;to stick them together.</p></div><div><p>Would this work for bytestrings? There's no reason it shouldn't. However, the type we have now only works for lists. It seems like we'd have to make a separate&nbsp;<code>applyLog</code>&nbsp;for bytestrings. But wait! Both lists and bytestrings are monoids. As such, they are both instances of the&nbsp;<code>Monoid</code>&nbsp;type class, which means that they implement the&nbsp;<code>mappend</code>&nbsp;function. And for both lists and bytestrings,&nbsp;<code>mappend</code>&nbsp;is for appending. Watch:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">]</span> <span class="token operator">`mappend`</span> <span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">]</span>
<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">]</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token constant">B</span><span class="token punctuation">.</span><span class="token builtin">pack</span> <span class="token punctuation">[</span><span class="token number">99</span><span class="token punctuation">,</span><span class="token number">104</span><span class="token punctuation">,</span><span class="token number">105</span><span class="token punctuation">]</span> <span class="token operator">`mappend`</span> <span class="token constant">B</span><span class="token punctuation">.</span><span class="token builtin">pack</span> <span class="token punctuation">[</span><span class="token number">104</span><span class="token punctuation">,</span><span class="token number">117</span><span class="token punctuation">,</span><span class="token number">97</span><span class="token punctuation">,</span><span class="token number">104</span><span class="token punctuation">,</span><span class="token number">117</span><span class="token punctuation">,</span><span class="token number">97</span><span class="token punctuation">]</span>
<span class="token constant">Chunk</span> <span class="token string">"chi"</span> <span class="token punctuation">(</span><span class="token constant">Chunk</span> <span class="token string">"huahua"</span> <span class="token constant">Empty</span><span class="token punctuation">)</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Cool! Now our&nbsp;<code>applyLog</code>&nbsp;can work for any monoid. We have to change the type to reflect this, as well as the implementation, because we have to change&nbsp;<code>++</code>&nbsp;to&nbsp;<code>mappend</code>:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">applyLog</span> <span class="token operator">::</span> <span class="token punctuation">(</span><span class="token constant">Monoid</span> <span class="token hvariable">m</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">(</span><span class="token hvariable">a</span><span class="token punctuation">,</span><span class="token hvariable">m</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token punctuation">(</span><span class="token hvariable">a</span> <span class="token operator">-&gt;</span> <span class="token punctuation">(</span><span class="token hvariable">b</span><span class="token punctuation">,</span><span class="token hvariable">m</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token punctuation">(</span><span class="token hvariable">b</span><span class="token punctuation">,</span><span class="token hvariable">m</span><span class="token punctuation">)</span>
<span class="token hvariable">applyLog</span> <span class="token punctuation">(</span><span class="token hvariable">x</span><span class="token punctuation">,</span><span class="token builtin">log</span><span class="token punctuation">)</span> <span class="token hvariable">f</span> <span class="token operator">=</span> <span class="token keyword">let</span> <span class="token punctuation">(</span><span class="token hvariable">y</span><span class="token punctuation">,</span><span class="token hvariable">newLog</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token hvariable">f</span> <span class="token hvariable">x</span> <span class="token keyword">in</span> <span class="token punctuation">(</span><span class="token hvariable">y</span><span class="token punctuation">,</span><span class="token builtin">log</span> <span class="token operator">`mappend`</span> <span class="token hvariable">newLog</span><span class="token punctuation">)</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Because the accompanying value can now be any monoid value, we no longer have to think of the tuple as a value and a log, but now we can think of it as a value with an accompanying monoid value. For instance, we can have a tuple that has an item name and an item price as the monoid value. We just use the&nbsp;<code>Sum</code>&nbsp;newtype to make sure that the prices get added as we operate with the items. Here's a function that adds drink to some cowboy food:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token import-statement"><span class="token keyword">import</span> Data<span class="token punctuation">.</span>Monoid</span>

<span class="token keyword">type</span> <span class="token constant">Food</span> <span class="token operator">=</span> <span class="token constant">String</span>
<span class="token keyword">type</span> <span class="token constant">Price</span> <span class="token operator">=</span> <span class="token constant">Sum</span> <span class="token constant">Int</span>

<span class="token hvariable">addDrink</span> <span class="token operator">::</span> <span class="token constant">Food</span> <span class="token operator">-&gt;</span> <span class="token punctuation">(</span><span class="token constant">Food</span><span class="token punctuation">,</span><span class="token constant">Price</span><span class="token punctuation">)</span>
<span class="token hvariable">addDrink</span> <span class="token string">"beans"</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token string">"milk"</span><span class="token punctuation">,</span> <span class="token constant">Sum</span> <span class="token number">25</span><span class="token punctuation">)</span>
<span class="token hvariable">addDrink</span> <span class="token string">"jerky"</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token string">"whiskey"</span><span class="token punctuation">,</span> <span class="token constant">Sum</span> <span class="token number">99</span><span class="token punctuation">)</span>
<span class="token hvariable">addDrink</span> <span class="token hvariable">_</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token string">"beer"</span><span class="token punctuation">,</span> <span class="token constant">Sum</span> <span class="token number">30</span><span class="token punctuation">)</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>We use strings to represent foods and an&nbsp;<code>Int</code>&nbsp;in a&nbsp;<code>Sum</code>&nbsp;<code>newtype</code>&nbsp;wrapper to keep track of how many cents something costs. Just a reminder, doing&nbsp;<code>mappend</code>&nbsp;with&nbsp;<code>Sum</code>&nbsp;results in the wrapped values getting added together:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token constant">Sum</span> <span class="token number">3</span> <span class="token operator">`mappend`</span> <span class="token constant">Sum</span> <span class="token number">9</span>
<span class="token constant">Sum</span> <span class="token punctuation">{</span><span class="token hvariable">getSum</span> <span class="token operator">=</span> <span class="token number">12</span><span class="token punctuation">}</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>The&nbsp;<code>addDrink</code>&nbsp;function is pretty simple. If we're eating beans, it returns&nbsp;<code>"milk"</code>&nbsp;along with&nbsp;<code>Sum 25</code>, so 25 cents wrapped in&nbsp;<code>Sum</code>. If we're eating jerky we drink whiskey and if we're eating anything else we drink beer. Just normally applying this function to a food wouldn't be terribly interesting right now, but using&nbsp;<code>applyLog</code>&nbsp;to feed a food that comes with a price itself into this function is interesting:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token punctuation">(</span><span class="token string">"beans"</span><span class="token punctuation">,</span> <span class="token constant">Sum</span> <span class="token number">10</span><span class="token punctuation">)</span> <span class="token operator">`applyLog`</span> <span class="token hvariable">addDrink</span>
<span class="token punctuation">(</span><span class="token string">"milk"</span><span class="token punctuation">,</span><span class="token constant">Sum</span> <span class="token punctuation">{</span><span class="token hvariable">getSum</span> <span class="token operator">=</span> <span class="token number">35</span><span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token punctuation">(</span><span class="token string">"jerky"</span><span class="token punctuation">,</span> <span class="token constant">Sum</span> <span class="token number">25</span><span class="token punctuation">)</span> <span class="token operator">`applyLog`</span> <span class="token hvariable">addDrink</span>
<span class="token punctuation">(</span><span class="token string">"whiskey"</span><span class="token punctuation">,</span><span class="token constant">Sum</span> <span class="token punctuation">{</span><span class="token hvariable">getSum</span> <span class="token operator">=</span> <span class="token number">124</span><span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token punctuation">(</span><span class="token string">"dogmeat"</span><span class="token punctuation">,</span> <span class="token constant">Sum</span> <span class="token number">5</span><span class="token punctuation">)</span> <span class="token operator">`applyLog`</span> <span class="token hvariable">addDrink</span>
<span class="token punctuation">(</span><span class="token string">"beer"</span><span class="token punctuation">,</span><span class="token constant">Sum</span> <span class="token punctuation">{</span><span class="token hvariable">getSum</span> <span class="token operator">=</span> <span class="token number">35</span><span class="token punctuation">}</span><span class="token punctuation">)</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Milk costs&nbsp;<code>25</code>&nbsp;cents, but if we eat it with beans that cost&nbsp;<code>10</code>&nbsp;cents, we'll end up paying&nbsp;<code>35</code>&nbsp;cents. Now it's clear how the attached value doesn't always have to be a log, it can be any monoid value and how two such values are combined into one depends on the monoid. When we were doing logs, they got appended, but now, the numbers are being added up.</p></div><div><p>Because the value that&nbsp;<code>addDrink</code>&nbsp;returns is a tuple of type&nbsp;<code>(Food,Price)</code>, we can feed that result to&nbsp;<code>addDrink</code>&nbsp;again, so that it tells us what we should drink along with our drink and how much that will cost us. Let's give it a shot:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token punctuation">(</span><span class="token string">"dogmeat"</span><span class="token punctuation">,</span> <span class="token constant">Sum</span> <span class="token number">5</span><span class="token punctuation">)</span> <span class="token operator">`applyLog`</span> <span class="token hvariable">addDrink</span> <span class="token operator">`applyLog`</span> <span class="token hvariable">addDrink</span>
<span class="token punctuation">(</span><span class="token string">"beer"</span><span class="token punctuation">,</span><span class="token constant">Sum</span> <span class="token punctuation">{</span><span class="token hvariable">getSum</span> <span class="token operator">=</span> <span class="token number">65</span><span class="token punctuation">}</span><span class="token punctuation">)</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Adding a drink to some dog meat results in a beer and an additional&nbsp;<code>30</code>&nbsp;cents, so&nbsp;<code>("beer", Sum 35)</code>. And if we use&nbsp;<code>applyLog</code>&nbsp;to feed that to&nbsp;<code>addDrink</code>, we get another beer and the result is&nbsp;<code>("beer", Sum 65)</code>.</p></div><div><h3 data-heading="The Writer type" id="The_Writer_type" style="display: flex;"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>The Writer type</h3></div><div><p>Now that we've seen that a value with an attached monoid acts like a monadic value, let's examine the&nbsp;<code>Monad</code>&nbsp;instance for types of such values. The&nbsp;<code>Control.Monad.Writer</code>&nbsp;module exports the&nbsp;<code>Writer w a</code>&nbsp;type along with its&nbsp;<code>Monad</code>&nbsp;instance and some useful functions for dealing with values of this type.</p></div><div><p>First, let's examine the type itself. To attach a monoid to a value, we just need to put them together in a tuple. The&nbsp;<code>Writer w a</code>&nbsp;type is just a&nbsp;<code>newtype</code>&nbsp;wrapper for this. Its definition is very simple:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token keyword">newtype</span> <span class="token constant">Writer</span> <span class="token hvariable">w</span> <span class="token hvariable">a</span> <span class="token operator">=</span> <span class="token constant">Writer</span> <span class="token punctuation">{</span> <span class="token hvariable">runWriter</span> <span class="token operator">::</span> <span class="token punctuation">(</span><span class="token hvariable">a</span><span class="token punctuation">,</span> <span class="token hvariable">w</span><span class="token punctuation">)</span> <span class="token punctuation">}</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>It's wrapped in a&nbsp;<code>newtype</code>&nbsp;so that it can be made an instance of&nbsp;<code>Monad</code>&nbsp;and that its type is separate from a normal tuple. The&nbsp;<code>a</code>&nbsp;type parameter represents the type of the value and the&nbsp;<code>w</code>&nbsp;type parameter the type of the attached monoid value.</p></div><div><p>Its&nbsp;<code>Monad</code>&nbsp;instance is defined like so:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token keyword">instance</span> <span class="token punctuation">(</span><span class="token constant">Monoid</span> <span class="token hvariable">w</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token constant">Monad</span> <span class="token punctuation">(</span><span class="token constant">Writer</span> <span class="token hvariable">w</span><span class="token punctuation">)</span> <span class="token keyword">where</span>
    <span class="token builtin">return</span> <span class="token hvariable">x</span> <span class="token operator">=</span> <span class="token constant">Writer</span> <span class="token punctuation">(</span><span class="token hvariable">x</span><span class="token punctuation">,</span> <span class="token hvariable">mempty</span><span class="token punctuation">)</span>
    <span class="token punctuation">(</span><span class="token constant">Writer</span> <span class="token punctuation">(</span><span class="token hvariable">x</span><span class="token punctuation">,</span><span class="token hvariable">v</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&gt;&gt;=</span> <span class="token hvariable">f</span> <span class="token operator">=</span> <span class="token keyword">let</span> <span class="token punctuation">(</span><span class="token constant">Writer</span> <span class="token punctuation">(</span><span class="token hvariable">y</span><span class="token punctuation">,</span> <span class="token hvariable">v'</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token hvariable">f</span> <span class="token hvariable">x</span> <span class="token keyword">in</span> <span class="token constant">Writer</span> <span class="token punctuation">(</span><span class="token hvariable">y</span><span class="token punctuation">,</span> <span class="token hvariable">v</span> <span class="token operator">`mappend`</span> <span class="token hvariable">v'</span><span class="token punctuation">)</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p><img alt="when you have to poop, poop, don't talk" src="http://s3.amazonaws.com/lyah/angeleyes.png" referrerpolicy="no-referrer"></p></div><div><p>First off, let's examine&nbsp;<code>&gt;&gt;=</code>. Its implementation is essentially the same as&nbsp;<code>applyLog</code>, only now that our tuple is wrapped in the&nbsp;<code>Writer</code>&nbsp;<code>newtype</code>, we have to unwrap it when pattern matching. We take the value&nbsp;<code>x</code>&nbsp;and apply the function&nbsp;<code>f</code>&nbsp;to it. This gives us a&nbsp;<code>Writer w a</code>&nbsp;value and we use a&nbsp;<code>let</code>&nbsp;expression to pattern match on it. We present&nbsp;<code>y</code>&nbsp;as the new result and use&nbsp;<code>mappend</code>&nbsp;to combine the old monoid value with the new one. We pack that up with the result value in a tuple and then wrap that with the&nbsp;<code>Writer</code>&nbsp;constructor so that our result is a&nbsp;<code>Writer</code>&nbsp;value instead of just an unwrapped tuple.</p></div><div><p>So, what about&nbsp;<code>return</code>? It has to take a value and put it in a default minimal context that still presents that value as the result. So what would such a context be for&nbsp;<code>Writer</code>&nbsp;values? If we want the accompanying monoid value to affect other monoid values as little as possible, it makes sense to use&nbsp;<code>mempty</code>.&nbsp;<code>mempty</code>&nbsp;is used to present identity monoid values, such as&nbsp;<code>""</code>&nbsp;and&nbsp;<code>Sum 0</code>&nbsp;and empty bytestrings. Whenever we use&nbsp;<code>mappend</code>&nbsp;between&nbsp;<code>mempty</code>&nbsp;and some other monoid value, the result is that other monoid value. So if we use&nbsp;<code>return</code>&nbsp;to make a&nbsp;<code>Writer</code>&nbsp;value and then use&nbsp;<code>&gt;&gt;=</code>&nbsp;to feed that value to a function, the resulting monoid value will be only what the function returns. Let's use&nbsp;<code>return</code>&nbsp;on the number&nbsp;<code>3</code>&nbsp;a bunch of times, only we'll pair it with a different monoid every time:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token hvariable">runWriter</span> <span class="token punctuation">(</span><span class="token builtin">return</span> <span class="token number">3</span> <span class="token operator">::</span> <span class="token constant">Writer</span> <span class="token constant">String</span> <span class="token constant">Int</span><span class="token punctuation">)</span>
<span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token string">""</span><span class="token punctuation">)</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token hvariable">runWriter</span> <span class="token punctuation">(</span><span class="token builtin">return</span> <span class="token number">3</span> <span class="token operator">::</span> <span class="token constant">Writer</span> <span class="token punctuation">(</span><span class="token constant">Sum</span> <span class="token constant">Int</span><span class="token punctuation">)</span> <span class="token constant">Int</span><span class="token punctuation">)</span>
<span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token constant">Sum</span> <span class="token punctuation">{</span><span class="token hvariable">getSum</span> <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token hvariable">runWriter</span> <span class="token punctuation">(</span><span class="token builtin">return</span> <span class="token number">3</span> <span class="token operator">::</span> <span class="token constant">Writer</span> <span class="token punctuation">(</span><span class="token constant">Product</span> <span class="token constant">Int</span><span class="token punctuation">)</span> <span class="token constant">Int</span><span class="token punctuation">)</span>
<span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token constant">Product</span> <span class="token punctuation">{</span><span class="token hvariable">getProduct</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">}</span><span class="token punctuation">)</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Because&nbsp;<code>Writer</code>&nbsp;doesn't have a&nbsp;<code>Show</code>&nbsp;instance, we had to use&nbsp;<code>runWriter</code>&nbsp;to convert our&nbsp;<code>Writer</code>&nbsp;values to normal tuples that can be shown. For&nbsp;<code>String</code>, the monoid value is the empty string. With&nbsp;<code>Sum</code>, it's&nbsp;<code>0</code>, because if we add 0 to something, that something stays the same. For&nbsp;<code>Product</code>, the identity is&nbsp;<code>1</code>.</p></div><div><p>The&nbsp;<code>Writer</code>&nbsp;instance doesn't feature an implementation for&nbsp;<code>fail</code>, so if a pattern match fails in&nbsp;<code>do</code>&nbsp;notation,&nbsp;<code>error</code>&nbsp;is called.</p></div><div><h3 data-heading="Using do notation with Writer" id="Using_do_notation_with_Writer" style="display: flex;"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>Using do notation with Writer</h3></div><div><p>Now that we have a&nbsp;<code>Monad</code>&nbsp;instance, we're free to use&nbsp;<code>do</code>&nbsp;notation for&nbsp;<code>Writer</code>&nbsp;values. It's handy for when we have a several&nbsp;<code>Writer</code>&nbsp;values and we want to do stuff with them. Like with other monads, we can treat them as normal values and the context gets taken for us. In this case, all the monoid values that come attached get&nbsp;<code>mappend</code>ed and so are reflected in the final result. Here's a simple example of using&nbsp;<code>do</code>&nbsp;notation with&nbsp;<code>Writer</code>&nbsp;to multiply two numbers:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token import-statement"><span class="token keyword">import</span> Control<span class="token punctuation">.</span>Monad<span class="token punctuation">.</span>Writer</span>

<span class="token hvariable">logNumber</span> <span class="token operator">::</span> <span class="token constant">Int</span> <span class="token operator">-&gt;</span> <span class="token constant">Writer</span> <span class="token punctuation">[</span><span class="token constant">String</span><span class="token punctuation">]</span> <span class="token constant">Int</span>
<span class="token hvariable">logNumber</span> <span class="token hvariable">x</span> <span class="token operator">=</span> <span class="token constant">Writer</span> <span class="token punctuation">(</span><span class="token hvariable">x</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token string">"Got number: "</span> <span class="token operator">++</span> <span class="token builtin">show</span> <span class="token hvariable">x</span><span class="token punctuation">]</span><span class="token punctuation">)</span>

<span class="token hvariable">multWithLog</span> <span class="token operator">::</span> <span class="token constant">Writer</span> <span class="token punctuation">[</span><span class="token constant">String</span><span class="token punctuation">]</span> <span class="token constant">Int</span>
<span class="token hvariable">multWithLog</span> <span class="token operator">=</span> <span class="token keyword">do</span>
    <span class="token hvariable">a</span> <span class="token operator">&lt;-</span> <span class="token hvariable">logNumber</span> <span class="token number">3</span>
    <span class="token hvariable">b</span> <span class="token operator">&lt;-</span> <span class="token hvariable">logNumber</span> <span class="token number">5</span>
    <span class="token builtin">return</span> <span class="token punctuation">(</span><span class="token hvariable">a</span><span class="token operator">*</span><span class="token hvariable">b</span><span class="token punctuation">)</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p><code>logNumber</code>&nbsp;takes a number and makes a&nbsp;<code>Writer</code>&nbsp;value out of it. For the monoid, we use a list of strings and we equip the number with a singleton list that just says that we have that number.&nbsp;<code>multWithLog</code>&nbsp;is a&nbsp;<code>Writer</code>&nbsp;value which multiplies&nbsp;<code>3</code>&nbsp;and&nbsp;<code>5</code>&nbsp;and makes sure that their attached logs get included in the final log. We use&nbsp;<code>return</code>&nbsp;to present&nbsp;<code>a*b</code>&nbsp;as the result. Because&nbsp;<code>return</code>&nbsp;just takes something and puts it in a minimal context, we can be sure that it won't add anything to the log. Here's what we see if we run this:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token hvariable">runWriter</span> <span class="token hvariable">multWithLog</span>
<span class="token punctuation">(</span><span class="token number">15</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token string">"Got number: 3"</span><span class="token punctuation">,</span><span class="token string">"Got number: 5"</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Sometimes we just want some monoid value to be included at some particular point. For this, the&nbsp;<code>tell</code>&nbsp;function is useful. It's part of the&nbsp;<code>MonadWriter</code>&nbsp;type class and in the case of&nbsp;<code>Writer</code>&nbsp;it takes a monoid value, like&nbsp;<code>["This is going on"]</code>&nbsp;and creates a&nbsp;<code>Writer</code>&nbsp;value that presents the dummy value&nbsp;<code>()</code>&nbsp;as its result but has our desired monoid value attached. When we have a monadic value that has&nbsp;<code>()</code>&nbsp;as its result, we don't bind it to a variable. Here's&nbsp;<code>multWithLog</code>&nbsp;but with some extra reporting included:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">multWithLog</span> <span class="token operator">::</span> <span class="token constant">Writer</span> <span class="token punctuation">[</span><span class="token constant">String</span><span class="token punctuation">]</span> <span class="token constant">Int</span>
<span class="token hvariable">multWithLog</span> <span class="token operator">=</span> <span class="token keyword">do</span>
    <span class="token hvariable">a</span> <span class="token operator">&lt;-</span> <span class="token hvariable">logNumber</span> <span class="token number">3</span>
    <span class="token hvariable">b</span> <span class="token operator">&lt;-</span> <span class="token hvariable">logNumber</span> <span class="token number">5</span>
    <span class="token hvariable">tell</span> <span class="token punctuation">[</span><span class="token string">"Gonna multiply these two"</span><span class="token punctuation">]</span>
    <span class="token builtin">return</span> <span class="token punctuation">(</span><span class="token hvariable">a</span><span class="token operator">*</span><span class="token hvariable">b</span><span class="token punctuation">)</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>It's important that&nbsp;<code>return (a*b)</code>&nbsp;is the last line, because the result of the last line in a&nbsp;<code>do</code>&nbsp;expression is the result of the whole&nbsp;<code>do</code>&nbsp;expression. Had we put&nbsp;<code>tell</code>&nbsp;as the last line,&nbsp;<code>()</code>&nbsp;would have been the result of this&nbsp;<code>do</code>&nbsp;expression. We'd lose the result of the multiplication. However, the log would be the same. Here is this in action:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token hvariable">runWriter</span> <span class="token hvariable">multWithLog</span>
<span class="token punctuation">(</span><span class="token number">15</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token string">"Got number: 3"</span><span class="token punctuation">,</span><span class="token string">"Got number: 5"</span><span class="token punctuation">,</span><span class="token string">"Gonna multiply these two"</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><h3 data-heading="Adding logging to programs" id="Adding_logging_to_programs" style="display: flex;"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>Adding logging to programs</h3></div><div><p>Euclid's algorithm is an algorithm that takes two numbers and computes their greatest common divisor. That is, the biggest number that still divides both of them. Haskell already features the&nbsp;<code>gcd</code>&nbsp;function, which does exactly this, but let's implement our own and then equip it with logging capabilities. Here's the normal algorithm:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token builtin">gcd</span>' <span class="token operator">::</span> <span class="token constant">Int</span> <span class="token operator">-&gt;</span> <span class="token constant">Int</span> <span class="token operator">-&gt;</span> <span class="token constant">Int</span>
<span class="token builtin">gcd</span>' <span class="token hvariable">a</span> <span class="token hvariable">b</span> 
    <span class="token operator">|</span> <span class="token hvariable">b</span> <span class="token operator">==</span> <span class="token number">0</span>    <span class="token operator">=</span> <span class="token hvariable">a</span>
    <span class="token operator">|</span> <span class="token builtin">otherwise</span> <span class="token operator">=</span> <span class="token builtin">gcd</span>' <span class="token hvariable">b</span> <span class="token punctuation">(</span><span class="token hvariable">a</span> <span class="token operator">`mod`</span> <span class="token hvariable">b</span><span class="token punctuation">)</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>The algorithm is very simple. First, it checks if the second number is 0. If it is, then the result is the first number. If it isn't, then the result is the greatest common divisor of the second number and the remainder of dividing the first number with the second one. For instance, if we want to know what the greatest common divisor of 8 and 3 is, we just follow the algorithm outlined. Because 3 isn't 0, we have to find the greatest common divisor of 3 and 2 (if we divide 8 by 3, the remainder is 2). Next, we find the greatest common divisor of 3 and 2. 2 still isn't 0, so now we have have 2 and 1. The second number isn't 0, so we run the algorithm again for 1 and 0, as dividing 2 by 1 gives us a remainder of 0. And finally, because the second number is now 0, the final result is 1. Let's see if our code agrees:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token builtin">gcd</span>' <span class="token number">8</span> <span class="token number">3</span>
<span class="token number">1</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>It does. Very good! Now, we want to equip our result with a context, and the context will be a monoid value that acts as a log. Like before, we'll use a list of strings as our monoid. So the type of our new&nbsp;<code>gcd'</code>&nbsp;function should be:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token builtin">gcd</span>' <span class="token operator">::</span> <span class="token constant">Int</span> <span class="token operator">-&gt;</span> <span class="token constant">Int</span> <span class="token operator">-&gt;</span> <span class="token constant">Writer</span> <span class="token punctuation">[</span><span class="token constant">String</span><span class="token punctuation">]</span> <span class="token constant">Int</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>All that's left now is to equip our function with log values. Here's the code:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token import-statement"><span class="token keyword">import</span> Control<span class="token punctuation">.</span>Monad<span class="token punctuation">.</span>Writer</span>

<span class="token builtin">gcd</span>' <span class="token operator">::</span> <span class="token constant">Int</span> <span class="token operator">-&gt;</span> <span class="token constant">Int</span> <span class="token operator">-&gt;</span> <span class="token constant">Writer</span> <span class="token punctuation">[</span><span class="token constant">String</span><span class="token punctuation">]</span> <span class="token constant">Int</span>
<span class="token builtin">gcd</span>' <span class="token hvariable">a</span> <span class="token hvariable">b</span>
    <span class="token operator">|</span> <span class="token hvariable">b</span> <span class="token operator">==</span> <span class="token number">0</span> <span class="token operator">=</span> <span class="token keyword">do</span>
        <span class="token hvariable">tell</span> <span class="token punctuation">[</span><span class="token string">"Finished with "</span> <span class="token operator">++</span> <span class="token builtin">show</span> <span class="token hvariable">a</span><span class="token punctuation">]</span>
        <span class="token builtin">return</span> <span class="token hvariable">a</span>
    <span class="token operator">|</span> <span class="token builtin">otherwise</span> <span class="token operator">=</span> <span class="token keyword">do</span>
        <span class="token hvariable">tell</span> <span class="token punctuation">[</span><span class="token builtin">show</span> <span class="token hvariable">a</span> <span class="token operator">++</span> <span class="token string">" mod "</span> <span class="token operator">++</span> <span class="token builtin">show</span> <span class="token hvariable">b</span> <span class="token operator">++</span> <span class="token string">" = "</span> <span class="token operator">++</span> <span class="token builtin">show</span> <span class="token punctuation">(</span><span class="token hvariable">a</span> <span class="token operator">`mod`</span> <span class="token hvariable">b</span><span class="token punctuation">)</span><span class="token punctuation">]</span>
        <span class="token builtin">gcd</span>' <span class="token hvariable">b</span> <span class="token punctuation">(</span><span class="token hvariable">a</span> <span class="token operator">`mod`</span> <span class="token hvariable">b</span><span class="token punctuation">)</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>This function takes two normal&nbsp;<code>Int</code>&nbsp;values and returns a&nbsp;<code>Writer [String] Int</code>, that is, an&nbsp;<code>Int</code>&nbsp;that has a log context. In the case where&nbsp;<code>b</code>&nbsp;is&nbsp;<code>0</code>, instead of just giving&nbsp;<code>a</code>&nbsp;as the result, we use a&nbsp;<code>do</code>&nbsp;expression to put together a&nbsp;<code>Writer</code>&nbsp;value as a result. First we use&nbsp;<code>tell</code>&nbsp;to report that we're finished and then we use&nbsp;<code>return</code>&nbsp;to present&nbsp;<code>a</code>&nbsp;as the result of the&nbsp;<code>do</code>&nbsp;expression. Instead of this&nbsp;<code>do</code>&nbsp;expression, we could have also written this:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token constant">Writer</span> <span class="token punctuation">(</span><span class="token hvariable">a</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token string">"Finished with "</span> <span class="token operator">++</span> <span class="token builtin">show</span> <span class="token hvariable">a</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>However, I think the&nbsp;<code>do</code>&nbsp;expression is easier to read. Next, we have the case when&nbsp;<code>b</code>&nbsp;isn't&nbsp;<code>0</code>. In this case, we log that we're using&nbsp;<code>mod</code>&nbsp;to figure out the remainder of dividing&nbsp;<code>a</code>&nbsp;and&nbsp;<code>b</code>. Then, the second line of the&nbsp;<code>do</code>&nbsp;expression just recursively calls&nbsp;<code>gcd'</code>. Remember,&nbsp;<code>gcd'</code>&nbsp;now ultimately returns a&nbsp;<code>Writer</code>&nbsp;value, so it's perfectly valid that&nbsp;<code>gcd' b (a `mod` b)</code>&nbsp;is a line in a&nbsp;<code>do</code>&nbsp;expression.</p></div><div><p>While it may be kind of useful to trace the execution of this new&nbsp;<code>gcd'</code>&nbsp;by hand to see how the logs get appended, I think it's more insightful to just look at the big picture and view these as values with a context and from that gain insight as to what the final result will be.</p></div><div><p>Let's try our new&nbsp;<code>gcd'</code>&nbsp;out. Its result is a&nbsp;<code>Writer [String] Int</code>&nbsp;value and if we unwrap that from its&nbsp;<code>newtype</code>, we get a tuple. The first part of the tuple is the result. Let's see if it's okay:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token builtin">fst</span> <span class="token operator">$</span> <span class="token hvariable">runWriter</span> <span class="token punctuation">(</span><span class="token builtin">gcd</span>' <span class="token number">8</span> <span class="token number">3</span><span class="token punctuation">)</span>
<span class="token number">1</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Good! Now what about the log? Because the log is a list of strings, let's use&nbsp;<code>mapM_ putStrLn</code>&nbsp;to print those strings to the screen:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token builtin">mapM_</span> <span class="token builtin">putStrLn</span> <span class="token operator">$</span> <span class="token builtin">snd</span> <span class="token operator">$</span> <span class="token hvariable">runWriter</span> <span class="token punctuation">(</span><span class="token builtin">gcd</span>' <span class="token number">8</span> <span class="token number">3</span><span class="token punctuation">)</span>
<span class="token number">8</span> <span class="token builtin">mod</span> <span class="token number">3</span> <span class="token operator">=</span> <span class="token number">2</span>
<span class="token number">3</span> <span class="token builtin">mod</span> <span class="token number">2</span> <span class="token operator">=</span> <span class="token number">1</span>
<span class="token number">2</span> <span class="token builtin">mod</span> <span class="token number">1</span> <span class="token operator">=</span> <span class="token number">0</span>
<span class="token constant">Finished</span> <span class="token hvariable">with</span> <span class="token number">1</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>I think it's awesome how we were able to change our ordinary algorithm to one that reports what it does as it goes along just by changing normal values to monadic values and letting the implementation of&nbsp;<code>&gt;&gt;=</code>&nbsp;for&nbsp;<code>Writer</code>&nbsp;take care of the logs for us. We can add a logging mechanism to pretty much any function. We just replace normal values with&nbsp;<code>Writer</code>&nbsp;values where we want and change normal function application to&nbsp;<code>&gt;&gt;=</code>&nbsp;(or&nbsp;<code>do</code>&nbsp;expressions if it increases readability).</p></div><div><h3 data-heading="Inefficient list construction" id="Inefficient_list_construction" style="display: flex;"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>Inefficient list construction</h3></div><div><p>When using the&nbsp;<code>Writer</code>&nbsp;monad, you have to be careful which monoid to use, because using lists can sometimes turn out to be very slow. That's because lists use&nbsp;<code>++</code>&nbsp;for&nbsp;<code>mappend</code>&nbsp;and using&nbsp;<code>++</code>&nbsp;to add something to the end of a list is slow if that list is really long.</p></div><div><p>In our&nbsp;<code>gcd'</code>&nbsp;function, the logging is fast because the list appending ends up looking like this:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">a</span> <span class="token operator">++</span> <span class="token punctuation">(</span><span class="token hvariable">b</span> <span class="token operator">++</span> <span class="token punctuation">(</span><span class="token hvariable">c</span> <span class="token operator">++</span> <span class="token punctuation">(</span><span class="token hvariable">d</span> <span class="token operator">++</span> <span class="token punctuation">(</span><span class="token hvariable">e</span> <span class="token operator">++</span> <span class="token hvariable">f</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Lists are a data structure that's constructed from left to right, and this is efficient because we first fully construct the left part of a list and only then add a longer list on the right. But if we're not careful, using the&nbsp;<code>Writer</code>&nbsp;monad can produce list appending that looks like this:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token hvariable">a</span> <span class="token operator">++</span> <span class="token hvariable">b</span><span class="token punctuation">)</span> <span class="token operator">++</span> <span class="token hvariable">c</span><span class="token punctuation">)</span> <span class="token operator">++</span> <span class="token hvariable">d</span><span class="token punctuation">)</span> <span class="token operator">++</span> <span class="token hvariable">e</span><span class="token punctuation">)</span> <span class="token operator">++</span> <span class="token hvariable">f</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>This associates to the left instead of to the right. This is inefficient because every time it wants to add the right part to the left part, it has to construct the left part all the way from the beginning!</p></div><div><p>The following function works like&nbsp;<code>gcd'</code>, only it logs stuff in reverse. First it produces the log for the rest of the procedure and then adds the current step to the end of the log.</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token import-statement"><span class="token keyword">import</span> Control<span class="token punctuation">.</span>Monad<span class="token punctuation">.</span>Writer</span>

<span class="token hvariable">gcdReverse</span> <span class="token operator">::</span> <span class="token constant">Int</span> <span class="token operator">-&gt;</span> <span class="token constant">Int</span> <span class="token operator">-&gt;</span> <span class="token constant">Writer</span> <span class="token punctuation">[</span><span class="token constant">String</span><span class="token punctuation">]</span> <span class="token constant">Int</span>
<span class="token hvariable">gcdReverse</span> <span class="token hvariable">a</span> <span class="token hvariable">b</span>
    <span class="token operator">|</span> <span class="token hvariable">b</span> <span class="token operator">==</span> <span class="token number">0</span> <span class="token operator">=</span> <span class="token keyword">do</span>
        <span class="token hvariable">tell</span> <span class="token punctuation">[</span><span class="token string">"Finished with "</span> <span class="token operator">++</span> <span class="token builtin">show</span> <span class="token hvariable">a</span><span class="token punctuation">]</span>
        <span class="token builtin">return</span> <span class="token hvariable">a</span>
    <span class="token operator">|</span> <span class="token builtin">otherwise</span> <span class="token operator">=</span> <span class="token keyword">do</span>
        <span class="token hvariable">result</span> <span class="token operator">&lt;-</span> <span class="token hvariable">gcdReverse</span> <span class="token hvariable">b</span> <span class="token punctuation">(</span><span class="token hvariable">a</span> <span class="token operator">`mod`</span> <span class="token hvariable">b</span><span class="token punctuation">)</span>
        <span class="token hvariable">tell</span> <span class="token punctuation">[</span><span class="token builtin">show</span> <span class="token hvariable">a</span> <span class="token operator">++</span> <span class="token string">" mod "</span> <span class="token operator">++</span> <span class="token builtin">show</span> <span class="token hvariable">b</span> <span class="token operator">++</span> <span class="token string">" = "</span> <span class="token operator">++</span> <span class="token builtin">show</span> <span class="token punctuation">(</span><span class="token hvariable">a</span> <span class="token operator">`mod`</span> <span class="token hvariable">b</span><span class="token punctuation">)</span><span class="token punctuation">]</span>
        <span class="token builtin">return</span> <span class="token hvariable">result</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>It does the recursion first, and binds its result value to&nbsp;<code>result</code>. Then it adds the current step to the log, but the current step goes at the end of the log that was produced by the recursion. Finally, it presents the result of the recursion as the final result. Here it is in action:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token builtin">mapM_</span> <span class="token builtin">putStrLn</span> <span class="token operator">$</span> <span class="token builtin">snd</span> <span class="token operator">$</span> <span class="token hvariable">runWriter</span> <span class="token punctuation">(</span><span class="token hvariable">gcdReverse</span> <span class="token number">8</span> <span class="token number">3</span><span class="token punctuation">)</span>
<span class="token constant">Finished</span> <span class="token hvariable">with</span> <span class="token number">1</span>
<span class="token number">2</span> <span class="token builtin">mod</span> <span class="token number">1</span> <span class="token operator">=</span> <span class="token number">0</span>
<span class="token number">3</span> <span class="token builtin">mod</span> <span class="token number">2</span> <span class="token operator">=</span> <span class="token number">1</span>
<span class="token number">8</span> <span class="token builtin">mod</span> <span class="token number">3</span> <span class="token operator">=</span> <span class="token number">2</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>It's inefficient because it ends up associating the use of&nbsp;<code>++</code>&nbsp;to the left instead of to the right.</p></div><div><h3 data-heading="Difference lists" id="Difference_lists" style="display: flex;"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>Difference lists</h3></div><div><p><img alt="cactuses" src="http://s3.amazonaws.com/lyah/cactus.png" referrerpolicy="no-referrer"></p></div><div><p>Because lists can sometimes be inefficient when repeatedly appended in this manner, it's best to use a data structure that always supports efficient appending. One such data structure is the difference list. A difference list is similar to a list, only instead of being a normal list, it's a function that takes a list and prepends another list to it. The difference list equivalent of a list like&nbsp;<code>[1,2,3]</code>&nbsp;would be the function&nbsp;<code>\xs -&gt; [1,2,3] ++ xs</code>. A normal empty list is&nbsp;<code>[]</code>, whereas an empty difference list is the function&nbsp;<code>\xs -&gt; [] ++ xs</code>.</p></div><div><p>The cool thing about difference lists is that they support efficient appending. When we append two normal lists with&nbsp;<code>++</code>, it has to walk all the way to the end of the list on the left of&nbsp;<code>++</code>&nbsp;and then stick the other one there. But what if we take the difference list approach and represent our lists as functions? Well then, appending two difference lists can be done like so:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">f</span> <span class="token operator">`append`</span> <span class="token hvariable">g</span> <span class="token operator">=</span> <span class="token operator">\</span><span class="token hvariable">xs</span> <span class="token operator">-&gt;</span> <span class="token hvariable">f</span> <span class="token punctuation">(</span><span class="token hvariable">g</span> <span class="token hvariable">xs</span><span class="token punctuation">)</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Remember,&nbsp;<code>f</code>&nbsp;and&nbsp;<code>g</code>&nbsp;are functions that take lists and prepend something to them. So, for instance, if&nbsp;<code>f</code>&nbsp;is the function&nbsp;<code>("dog"++)</code>&nbsp;(just another way of writing&nbsp;<code>\xs -&gt; "dog" ++ xs</code>) and&nbsp;<code>g</code>&nbsp;the function&nbsp;<code>("meat"++)</code>, then&nbsp;<code>f `append` g</code>&nbsp;makes a new function that's equivalent to the following:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token operator">\</span><span class="token hvariable">xs</span> <span class="token operator">-&gt;</span> <span class="token string">"dog"</span> <span class="token operator">++</span> <span class="token punctuation">(</span><span class="token string">"meat"</span> <span class="token operator">++</span> <span class="token hvariable">xs</span><span class="token punctuation">)</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>We've appended two difference lists just by making a new function that first applies one difference list some list and then the other.</p></div><div><p>Let's make a&nbsp;<code>newtype</code>&nbsp;wrapper for difference lists so that we can easily give them monoid instances:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token keyword">newtype</span> <span class="token constant">DiffList</span> <span class="token hvariable">a</span> <span class="token operator">=</span> <span class="token constant">DiffList</span> <span class="token punctuation">{</span> <span class="token hvariable">getDiffList</span> <span class="token operator">::</span> <span class="token punctuation">[</span><span class="token hvariable">a</span><span class="token punctuation">]</span> <span class="token operator">-&gt;</span> <span class="token punctuation">[</span><span class="token hvariable">a</span><span class="token punctuation">]</span> <span class="token punctuation">}</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>The type that we wrap is&nbsp;<code>[a] -&gt; [a]</code>&nbsp;because a difference list is just a function that takes a list and returns another. Converting normal lists to difference lists and vice versa is easy:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">toDiffList</span> <span class="token operator">::</span> <span class="token punctuation">[</span><span class="token hvariable">a</span><span class="token punctuation">]</span> <span class="token operator">-&gt;</span> <span class="token constant">DiffList</span> <span class="token hvariable">a</span>
<span class="token hvariable">toDiffList</span> <span class="token hvariable">xs</span> <span class="token operator">=</span> <span class="token constant">DiffList</span> <span class="token punctuation">(</span><span class="token hvariable">xs</span><span class="token operator">++</span><span class="token punctuation">)</span>

<span class="token hvariable">fromDiffList</span> <span class="token operator">::</span> <span class="token constant">DiffList</span> <span class="token hvariable">a</span> <span class="token operator">-&gt;</span> <span class="token punctuation">[</span><span class="token hvariable">a</span><span class="token punctuation">]</span>
<span class="token hvariable">fromDiffList</span> <span class="token punctuation">(</span><span class="token constant">DiffList</span> <span class="token hvariable">f</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token hvariable">f</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>To make a normal list into a difference list we just do what we did before and make it a function that prepends it to another list. Because a difference list is a function that prepends something to another list, if we just want that something, we apply the function to an empty list!</p></div><div><p>Here's the&nbsp;<code>Monoid</code>&nbsp;instance:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token keyword">instance</span> <span class="token constant">Monoid</span> <span class="token punctuation">(</span><span class="token constant">DiffList</span> <span class="token hvariable">a</span><span class="token punctuation">)</span> <span class="token keyword">where</span>
    <span class="token hvariable">mempty</span> <span class="token operator">=</span> <span class="token constant">DiffList</span> <span class="token punctuation">(</span><span class="token operator">\</span><span class="token hvariable">xs</span> <span class="token operator">-&gt;</span> <span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">++</span> <span class="token hvariable">xs</span><span class="token punctuation">)</span>
    <span class="token punctuation">(</span><span class="token constant">DiffList</span> <span class="token hvariable">f</span><span class="token punctuation">)</span> <span class="token operator">`mappend`</span> <span class="token punctuation">(</span><span class="token constant">DiffList</span> <span class="token hvariable">g</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token constant">DiffList</span> <span class="token punctuation">(</span><span class="token operator">\</span><span class="token hvariable">xs</span> <span class="token operator">-&gt;</span> <span class="token hvariable">f</span> <span class="token punctuation">(</span><span class="token hvariable">g</span> <span class="token hvariable">xs</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Notice how for lists,&nbsp;<code>mempty</code>&nbsp;is just the&nbsp;<code>id</code>&nbsp;function and&nbsp;<code>mappend</code>&nbsp;is actually just function composition. Let's see if this works:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token hvariable">fromDiffList</span> <span class="token punctuation">(</span><span class="token hvariable">toDiffList</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">]</span> <span class="token operator">`mappend`</span> <span class="token hvariable">toDiffList</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">]</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Tip top! Now we can increase the efficiency of our&nbsp;<code>gcdReverse</code>&nbsp;function by making it use difference lists instead of normal lists:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token import-statement"><span class="token keyword">import</span> Control<span class="token punctuation">.</span>Monad<span class="token punctuation">.</span>Writer</span>

<span class="token builtin">gcd</span>' <span class="token operator">::</span> <span class="token constant">Int</span> <span class="token operator">-&gt;</span> <span class="token constant">Int</span> <span class="token operator">-&gt;</span> <span class="token constant">Writer</span> <span class="token punctuation">(</span><span class="token constant">DiffList</span> <span class="token constant">String</span><span class="token punctuation">)</span> <span class="token constant">Int</span>
<span class="token builtin">gcd</span>' <span class="token hvariable">a</span> <span class="token hvariable">b</span>
    <span class="token operator">|</span> <span class="token hvariable">b</span> <span class="token operator">==</span> <span class="token number">0</span> <span class="token operator">=</span> <span class="token keyword">do</span>
        <span class="token hvariable">tell</span> <span class="token punctuation">(</span><span class="token hvariable">toDiffList</span> <span class="token punctuation">[</span><span class="token string">"Finished with "</span> <span class="token operator">++</span> <span class="token builtin">show</span> <span class="token hvariable">a</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
        <span class="token builtin">return</span> <span class="token hvariable">a</span>
    <span class="token operator">|</span> <span class="token builtin">otherwise</span> <span class="token operator">=</span> <span class="token keyword">do</span>
        <span class="token hvariable">result</span> <span class="token operator">&lt;-</span> <span class="token builtin">gcd</span>' <span class="token hvariable">b</span> <span class="token punctuation">(</span><span class="token hvariable">a</span> <span class="token operator">`mod`</span> <span class="token hvariable">b</span><span class="token punctuation">)</span>
        <span class="token hvariable">tell</span> <span class="token punctuation">(</span><span class="token hvariable">toDiffList</span> <span class="token punctuation">[</span><span class="token builtin">show</span> <span class="token hvariable">a</span> <span class="token operator">++</span> <span class="token string">" mod "</span> <span class="token operator">++</span> <span class="token builtin">show</span> <span class="token hvariable">b</span> <span class="token operator">++</span> <span class="token string">" = "</span> <span class="token operator">++</span> <span class="token builtin">show</span> <span class="token punctuation">(</span><span class="token hvariable">a</span> <span class="token operator">`mod`</span> <span class="token hvariable">b</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
        <span class="token builtin">return</span> <span class="token hvariable">result</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>We only had to change the type of the monoid from&nbsp;<code>[String]</code>&nbsp;to&nbsp;<code>DiffList String</code>&nbsp;and then when using&nbsp;<code>tell</code>, convert our normal lists into difference lists with&nbsp;<code>toDiffList</code>. Let's see if the log gets assembled properly:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token builtin">mapM_</span> <span class="token builtin">putStrLn</span> <span class="token operator">.</span> <span class="token hvariable">fromDiffList</span> <span class="token operator">.</span> <span class="token builtin">snd</span> <span class="token operator">.</span> <span class="token hvariable">runWriter</span> <span class="token operator">$</span> <span class="token hvariable">gcdReverse</span> <span class="token number">110</span> <span class="token number">34</span>
<span class="token constant">Finished</span> <span class="token hvariable">with</span> <span class="token number">2</span>
<span class="token number">8</span> <span class="token builtin">mod</span> <span class="token number">2</span> <span class="token operator">=</span> <span class="token number">0</span>
<span class="token number">34</span> <span class="token builtin">mod</span> <span class="token number">8</span> <span class="token operator">=</span> <span class="token number">2</span>
<span class="token number">110</span> <span class="token builtin">mod</span> <span class="token number">34</span> <span class="token operator">=</span> <span class="token number">8</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>We do&nbsp;<code>gcdReverse 110 34</code>, then use&nbsp;<code>runWriter</code>&nbsp;to unwrap it from the&nbsp;<code>newtype</code>, then apply&nbsp;<code>snd</code>&nbsp;to that to just get the log, then apply&nbsp;<code>fromDiffList</code>&nbsp;to convert it to a normal list and then finally print its entries to the screen.</p></div><div><h3 data-heading="Comparing Performance" id="Comparing_Performance" style="display: flex;"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>Comparing Performance</h3></div><div><p>To get a feel for just how much difference lists may improve your performance, consider this function that just counts down from some number to zero, but produces its log in reverse, like&nbsp;<code>gcdReverse</code>, so that the numbers in the log will actually be counted up:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">finalCountDown</span> <span class="token operator">::</span> <span class="token constant">Int</span> <span class="token operator">-&gt;</span> <span class="token constant">Writer</span> <span class="token punctuation">(</span><span class="token constant">DiffList</span> <span class="token constant">String</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token hvariable">finalCountDown</span> <span class="token number">0</span> <span class="token operator">=</span> <span class="token keyword">do</span>
    <span class="token hvariable">tell</span> <span class="token punctuation">(</span><span class="token hvariable">toDiffList</span> <span class="token punctuation">[</span><span class="token string">"0"</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
<span class="token hvariable">finalCountDown</span> <span class="token hvariable">x</span> <span class="token operator">=</span> <span class="token keyword">do</span>
    <span class="token hvariable">finalCountDown</span> <span class="token punctuation">(</span><span class="token hvariable">x</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span>
    <span class="token hvariable">tell</span> <span class="token punctuation">(</span><span class="token hvariable">toDiffList</span> <span class="token punctuation">[</span><span class="token builtin">show</span> <span class="token hvariable">x</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>If we give it&nbsp;<code>0</code>, it just logs it. For any other number, it first counts down its predecessor to&nbsp;<code>0</code>&nbsp;and then appends that number to the log. So if we apply&nbsp;<code>finalCountDown</code>&nbsp;to&nbsp;<code>100</code>, the string&nbsp;<code>"100"</code>&nbsp;will come last in the log.</p></div><div><p>Anyway, if you load this function in GHCi and apply it to a big number, like&nbsp;<code>500000</code>, you'll see that it quickly starts counting from&nbsp;<code>0</code>&nbsp;onwards:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token builtin">mapM_</span> <span class="token builtin">putStrLn</span> <span class="token operator">.</span> <span class="token hvariable">fromDiffList</span> <span class="token operator">.</span> <span class="token builtin">snd</span> <span class="token operator">.</span> <span class="token hvariable">runWriter</span> <span class="token operator">$</span> <span class="token hvariable">finalCountDown</span> <span class="token number">500000</span>
<span class="token number">0</span>
<span class="token number">1</span>
<span class="token number">2</span>
<span class="token operator">...</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>However, if we change it to use normal lists instead of difference lists, like so:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">finalCountDown</span> <span class="token operator">::</span> <span class="token constant">Int</span> <span class="token operator">-&gt;</span> <span class="token constant">Writer</span> <span class="token punctuation">[</span><span class="token constant">String</span><span class="token punctuation">]</span> <span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token hvariable">finalCountDown</span> <span class="token number">0</span> <span class="token operator">=</span> <span class="token keyword">do</span>
    <span class="token hvariable">tell</span> <span class="token punctuation">[</span><span class="token string">"0"</span><span class="token punctuation">]</span>
<span class="token hvariable">finalCountDown</span> <span class="token hvariable">x</span> <span class="token operator">=</span> <span class="token keyword">do</span>
    <span class="token hvariable">finalCountDown</span> <span class="token punctuation">(</span><span class="token hvariable">x</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span>
    <span class="token hvariable">tell</span> <span class="token punctuation">[</span><span class="token builtin">show</span> <span class="token hvariable">x</span><span class="token punctuation">]</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>And then tell GHCi to start counting:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token builtin">mapM_</span> <span class="token builtin">putStrLn</span> <span class="token operator">.</span> <span class="token builtin">snd</span> <span class="token operator">.</span> <span class="token hvariable">runWriter</span> <span class="token operator">$</span> <span class="token hvariable">finalCountDown</span> <span class="token number">500000</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>We'll see that the counting is really slow.</p></div><div><p>Of course, this is not the proper and scientific way to test how fast our programs are, but we were able to see that in this case, using difference lists starts producing results right away whereas normal lists take forever.</p></div><div><p>Oh, by the way, the song Final Countdown by Europe is now stuck in your head. Enjoy!</p></div><div><h2 data-heading="Reader? Ugh, not this joke again." id="Reader?_Ugh,_not_this_joke_again." style="display: flex;"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>Reader? Ugh, not this joke again.</h2></div><div><p><img alt="bang youre dead" src="http://s3.amazonaws.com/lyah/revolver.png" referrerpolicy="no-referrer"></p></div><div><p>In the&nbsp;<a data-tooltip-position="top" aria-label="http://learnyouahaskell.com/functors-applicative-functors-and-monoids" rel="noopener" class="external-link" href="http://learnyouahaskell.com/functors-applicative-functors-and-monoids" target="_blank">chapter about applicatives</a>, we saw that the function type,&nbsp;<code>(-&gt;) r</code>&nbsp;is an instance of&nbsp;<code>Functor</code>. Mapping a function&nbsp;<code>f</code>&nbsp;over a function&nbsp;<code>g</code>&nbsp;will make a function that takes the same thing as&nbsp;<code>g</code>, applies&nbsp;<code>g</code>&nbsp;to it and then applies&nbsp;<code>f</code>&nbsp;to that result. So basically, we're making a new function that's like&nbsp;<code>g</code>, only before returning its result,&nbsp;<code>f</code>&nbsp;gets applied to that result as well. For instance:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token keyword">let</span> <span class="token hvariable">f</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token operator">*</span><span class="token number">5</span><span class="token punctuation">)</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token keyword">let</span> <span class="token hvariable">g</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token operator">+</span><span class="token number">3</span><span class="token punctuation">)</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token punctuation">(</span><span class="token builtin">fmap</span> <span class="token hvariable">f</span> <span class="token hvariable">g</span><span class="token punctuation">)</span> <span class="token number">8</span>
<span class="token number">55</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>We've also seen that functions are applicative functors. They allow us to operate on the eventual results of functions as if we already had their results. Here's an example:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token keyword">let</span> <span class="token hvariable">f</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token operator">+</span><span class="token punctuation">)</span> <span class="token operator">&lt;$&gt;</span> <span class="token punctuation">(</span><span class="token operator">*</span><span class="token number">2</span><span class="token punctuation">)</span> <span class="token operator">&lt;*&gt;</span> <span class="token punctuation">(</span><span class="token operator">+</span><span class="token number">10</span><span class="token punctuation">)</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token hvariable">f</span> <span class="token number">3</span>
<span class="token number">19</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>The expression&nbsp;<code>(+) &lt;$&gt; (*2) &lt;*&gt; (+10)</code>&nbsp;makes a function that takes a number, gives that number to&nbsp;<code>(*2)</code>&nbsp;and&nbsp;<code>(+10)</code>&nbsp;and then adds together the results. For instance, if we apply this function to&nbsp;<code>3</code>, it applies both&nbsp;<code>(*2)</code>&nbsp;and&nbsp;<code>(+10)</code>&nbsp;to&nbsp;<code>3</code>, giving&nbsp;<code>6</code>&nbsp;and&nbsp;<code>13</code>. Then, it calls&nbsp;<code>(+)</code>&nbsp;with&nbsp;<code>6</code>&nbsp;and&nbsp;<code>13</code>&nbsp;and the result is&nbsp;<code>19</code>.</p></div><div><p>Not only is the function type&nbsp;<code>(-&gt;) r</code>&nbsp;a functor and an applicative functor, but it's also a monad. Just like other monadic values that we've met so far, a function can also be considered a value with a context. The context for functions is that that value is not present yet and that we have to apply that function to something in order to get its result value.</p></div><div><p>Because we're already acquainted with how functions work as functors and applicative functors, let's dive right in and see what their&nbsp;<code>Monad</code>&nbsp;instance looks like. It's located in&nbsp;<code>Control.Monad.Instances</code>&nbsp;and it goes a little something like this:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token keyword">instance</span> <span class="token constant">Monad</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token operator">-&gt;</span><span class="token punctuation">)</span> <span class="token hvariable">r</span><span class="token punctuation">)</span> <span class="token keyword">where</span>
    <span class="token builtin">return</span> <span class="token hvariable">x</span> <span class="token operator">=</span> <span class="token operator">\</span><span class="token hvariable">_</span> <span class="token operator">-&gt;</span> <span class="token hvariable">x</span>
    <span class="token hvariable">h</span> <span class="token operator">&gt;&gt;=</span> <span class="token hvariable">f</span> <span class="token operator">=</span> <span class="token operator">\</span><span class="token hvariable">w</span> <span class="token operator">-&gt;</span> <span class="token hvariable">f</span> <span class="token punctuation">(</span><span class="token hvariable">h</span> <span class="token hvariable">w</span><span class="token punctuation">)</span> <span class="token hvariable">w</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>We've already seen how&nbsp;<code>pure</code>&nbsp;is implemented for functions, and&nbsp;<code>return</code>&nbsp;is pretty much the same thing as&nbsp;<code>pure</code>. It takes a value and puts it in a minimal context that always has that value as its result. And the only way to make a function that always has a certain value as its result is to make it completely ignore its parameter.</p></div><div><p>The implementation for&nbsp;<code>&gt;&gt;=</code>&nbsp;seems a bit cryptic, but it's really not all that. When we use&nbsp;<code>&gt;&gt;=</code>&nbsp;to feed a monadic value to a function, the result is always a monadic value. So in this case, when we feed a function to another function, the result is a function as well. That's why the result starts off as a lambda. All of the implementations of&nbsp;<code>&gt;&gt;=</code>&nbsp;so far always somehow isolated the result from the monadic value and then applied the function&nbsp;<code>f</code>&nbsp;to that result. The same thing happens here. To get the result from a function, we have to apply it to something, which is why we do&nbsp;<code>(h w)</code>&nbsp;here to get the result from the function and then we apply&nbsp;<code>f</code>&nbsp;to that.&nbsp;<code>f</code>&nbsp;returns a monadic value, which is a function in our case, so we apply it to&nbsp;<code>w</code>&nbsp;as well.</p></div><div><p>If don't get how&nbsp;<code>&gt;&gt;=</code>&nbsp;works at this point, don't worry, because with examples we'll see how this is a really simple monad. Here's a&nbsp;<code>do</code>&nbsp;expression that utilizes this monad:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token import-statement"><span class="token keyword">import</span> Control<span class="token punctuation">.</span>Monad<span class="token punctuation">.</span>Instances</span>

<span class="token hvariable">addStuff</span> <span class="token operator">::</span> <span class="token constant">Int</span> <span class="token operator">-&gt;</span> <span class="token constant">Int</span>
<span class="token hvariable">addStuff</span> <span class="token operator">=</span> <span class="token keyword">do</span>
    <span class="token hvariable">a</span> <span class="token operator">&lt;-</span> <span class="token punctuation">(</span><span class="token operator">*</span><span class="token number">2</span><span class="token punctuation">)</span>
    <span class="token hvariable">b</span> <span class="token operator">&lt;-</span> <span class="token punctuation">(</span><span class="token operator">+</span><span class="token number">10</span><span class="token punctuation">)</span>
    <span class="token builtin">return</span> <span class="token punctuation">(</span><span class="token hvariable">a</span><span class="token operator">+</span><span class="token hvariable">b</span><span class="token punctuation">)</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>This is the same thing as the applicative expression that we wrote earlier, only now it relies on functions being monads. A&nbsp;<code>do</code>&nbsp;expression always results in a monadic value and this one is no different. The result of this monadic value is a function. What happens here is that it takes a number and then&nbsp;<code>(*2)</code>&nbsp;gets applied to that number and the result becomes&nbsp;<code>a</code>.&nbsp;<code>(+10)</code>&nbsp;is applied to the same number that&nbsp;<code>(*2)</code>&nbsp;got applied to and the result becomes&nbsp;<code>b</code>.&nbsp;<code>return</code>, like in other monads, doesn't have any other effect but to make a monadic value that presents some result. This presents&nbsp;<code>a+b</code>&nbsp;as the result of this function. If we test it out, we get the same result as before:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token hvariable">addStuff</span> <span class="token number">3</span>
<span class="token number">19</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Both&nbsp;<code>(*2)</code>&nbsp;and&nbsp;<code>(+10)</code>&nbsp;get applied to the number&nbsp;<code>3</code>&nbsp;in this case.&nbsp;<code>return (a+b)</code>&nbsp;does as well, but it ignores it and always presents&nbsp;<code>a+b</code>&nbsp;as the result. For this reason, the function monad is also called the reader monad. All the functions read from a common source. To illustrate this even better, we can rewrite&nbsp;<code>addStuff</code>&nbsp;like so:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">addStuff</span> <span class="token operator">::</span> <span class="token constant">Int</span> <span class="token operator">-&gt;</span> <span class="token constant">Int</span>
<span class="token hvariable">addStuff</span> <span class="token hvariable">x</span> <span class="token operator">=</span> <span class="token keyword">let</span>
    <span class="token hvariable">a</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token operator">*</span><span class="token number">2</span><span class="token punctuation">)</span> <span class="token hvariable">x</span>
    <span class="token hvariable">b</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token operator">+</span><span class="token number">10</span><span class="token punctuation">)</span> <span class="token hvariable">x</span>
    <span class="token keyword">in</span> <span class="token hvariable">a</span><span class="token operator">+</span><span class="token hvariable">b</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>We see that the reader monad allows us to treat functions as values with a context. We can act as if we already know what the functions will return. It does this by gluing functions together into one function and then giving that function's parameter to all of the functions that it was glued from. So if we have a lot of functions that are all just missing one parameter and they'd eventually be applied to the same thing, we can use the reader monad to sort of extract their future results and the&nbsp;<code>&gt;&gt;=</code>&nbsp;implementation will make sure that it all works out.</p></div><div><h2 data-heading="Tasteful stateful computations" id="Tasteful_stateful_computations" style="display: flex;"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>Tasteful stateful computations</h2></div><div><p><img alt="don't jest with texas" src="http://s3.amazonaws.com/lyah/texas.png" referrerpolicy="no-referrer"></p></div><div><p>Haskell is a pure language and because of that, our programs are made of functions that can't change any global state or variables, they can only do some computations and return them results. This restriction actually makes it easier to think about our programs, as it frees us from worrying what every variable's value is at some point in time. However, some problems are inherently stateful in that they rely on some state that changes over time. While such problems aren't a problem for Haskell, they can be a bit tedious to model sometimes. That's why Haskell features a thing called the state monad, which makes dealing with stateful problems a breeze while still keeping everything nice and pure.</p></div><div><p><a data-tooltip-position="top" aria-label="http://learnyouahaskell.com/input-and-output#randomness" rel="noopener" class="external-link" href="http://learnyouahaskell.com/input-and-output#randomness" target="_blank">When we were dealing with random numbers</a>, we dealt with functions that took a random generator as a parameter and returned a random number and a new random generator. If we wanted to generate several random numbers, we always had to use the random generator that a previous function returned along with its result. When making a function that takes a&nbsp;<code>StdGen</code>&nbsp;and tosses a coin three times based on that generator, we had to do this:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">threeCoins</span> <span class="token operator">::</span> <span class="token constant">StdGen</span> <span class="token operator">-&gt;</span> <span class="token punctuation">(</span><span class="token constant">Bool</span><span class="token punctuation">,</span> <span class="token constant">Bool</span><span class="token punctuation">,</span> <span class="token constant">Bool</span><span class="token punctuation">)</span>
<span class="token hvariable">threeCoins</span> <span class="token hvariable">gen</span> <span class="token operator">=</span> 
    <span class="token keyword">let</span> <span class="token punctuation">(</span><span class="token hvariable">firstCoin</span><span class="token punctuation">,</span> <span class="token hvariable">newGen</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token hvariable">random</span> <span class="token hvariable">gen</span>
        <span class="token punctuation">(</span><span class="token hvariable">secondCoin</span><span class="token punctuation">,</span> <span class="token hvariable">newGen'</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token hvariable">random</span> <span class="token hvariable">newGen</span>
        <span class="token punctuation">(</span><span class="token hvariable">thirdCoin</span><span class="token punctuation">,</span> <span class="token hvariable">newGen''</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token hvariable">random</span> <span class="token hvariable">newGen'</span>
    <span class="token keyword">in</span>  <span class="token punctuation">(</span><span class="token hvariable">firstCoin</span><span class="token punctuation">,</span> <span class="token hvariable">secondCoin</span><span class="token punctuation">,</span> <span class="token hvariable">thirdCoin</span><span class="token punctuation">)</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>It took a generator&nbsp;<code>gen</code>&nbsp;and then&nbsp;<code>random gen</code>&nbsp;returned a&nbsp;<code>Bool</code>&nbsp;value along with a new generator. To throw the second coin, we used the new generator, and so on. In most other languages, we wouldn't have to return a new generator along with a random number. We could just modify the existing one! But since Haskell is pure, we can't do that, so we had to take some state, make a result from it and a new state and then use that new state to generate new results.</p></div><div><p>You'd think that to avoid manually dealing with stateful computations in this way, we'd have to give up the purity of Haskell. Well, we don't have to, since there exist a special little monad called the state monad which handles all this state business for us and without giving up any of the purity that makes Haskell programming so cool.</p></div><div><p>So, to help us understand this concept of stateful computations better, let's go ahead and give them a type. We'll say that a stateful computation is a function that takes some state and returns a value along with some new state. That function would have the following type:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">s</span> <span class="token operator">-&gt;</span> <span class="token punctuation">(</span><span class="token hvariable">a</span><span class="token punctuation">,</span><span class="token hvariable">s</span><span class="token punctuation">)</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p><code>s</code>&nbsp;is the type of the state and&nbsp;<code>a</code>&nbsp;the result of the stateful computations.</p></div><div><p>Assignment in most other languages could be thought of as a stateful computation. For instance, when we do&nbsp;x = 5&nbsp;in an imperative language, it will usually assign the value&nbsp;5&nbsp;to the variable&nbsp;x&nbsp;and it will also have the value&nbsp;5&nbsp;as an expression. If you look at that functionally, you could look at it as a function that takes a state (that is, all the variables that have been assigned previously) and returns a result (in this case&nbsp;5) and a new state, which would be all the previous variable mappings plus the newly assigned variable.</p></div><div><p>This stateful computation, a function that takes a state and returns a result and a new state, can be thought of as a value with a context as well. The actual value is the result, whereas the context is that we have to provide some initial state to actually get that result and that apart from getting a result we also get a new state.</p></div><div><h3 data-heading="Stacks and stones" id="Stacks_and_stones" style="display: flex;"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>Stacks and stones</h3></div><div><p>Say we want to model operating a stack. You have a stack of things one on top of another and you can either push stuff on top of that stack or you can take stuff off the top of the stack. When you're putting an item on top of the stack we say that you're pushing it to the stack and when you're taking stuff off the top we say that you're popping it. If you want to something that's at the bottom of the stack, you have to pop everything that's above it.</p></div><div><p>We'll use a list to represent our stack and the head of the list will be the top of the stack. To help us with our task, we'll make two functions:&nbsp;<code>pop</code>&nbsp;and&nbsp;<code>push</code>.&nbsp;<code>pop</code>&nbsp;will take a stack, pop one item and return that item as the result and also return a new stack, without that item.&nbsp;<code>push</code>&nbsp;will take an item and a stack and then push that item onto the stack. It will return&nbsp;<code>()</code>&nbsp;as its result, along with a new stack. Here goes:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token keyword">type</span> <span class="token constant">Stack</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token constant">Int</span><span class="token punctuation">]</span>

<span class="token hvariable">pop</span> <span class="token operator">::</span> <span class="token constant">Stack</span> <span class="token operator">-&gt;</span> <span class="token punctuation">(</span><span class="token constant">Int</span><span class="token punctuation">,</span><span class="token constant">Stack</span><span class="token punctuation">)</span>
<span class="token hvariable">pop</span> <span class="token punctuation">(</span><span class="token hvariable">x</span><span class="token operator">:</span><span class="token hvariable">xs</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token hvariable">x</span><span class="token punctuation">,</span><span class="token hvariable">xs</span><span class="token punctuation">)</span>

<span class="token hvariable">push</span> <span class="token operator">::</span> <span class="token constant">Int</span> <span class="token operator">-&gt;</span> <span class="token constant">Stack</span> <span class="token operator">-&gt;</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token constant">Stack</span><span class="token punctuation">)</span>
<span class="token hvariable">push</span> <span class="token hvariable">a</span> <span class="token hvariable">xs</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token hvariable">a</span><span class="token operator">:</span><span class="token hvariable">xs</span><span class="token punctuation">)</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>We used&nbsp;<code>()</code>&nbsp;as the result when pushing to the stack because pushing an item onto the stack doesn't have any important result value, its main job is to change the stack. Notice how we just apply the first parameter of&nbsp;<code>push</code>, we get a stateful computation.&nbsp;<code>pop</code>&nbsp;is already a stateful computation because of its type.</p></div><div><p>Let's write a small piece of code to simulate a stack using these functions. We'll take a stack, push&nbsp;<code>3</code>&nbsp;to it and then pop two items, just for kicks. Here it is:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">stackManip</span> <span class="token operator">::</span> <span class="token constant">Stack</span> <span class="token operator">-&gt;</span> <span class="token punctuation">(</span><span class="token constant">Int</span><span class="token punctuation">,</span> <span class="token constant">Stack</span><span class="token punctuation">)</span>
<span class="token hvariable">stackManip</span> <span class="token hvariable">stack</span> <span class="token operator">=</span> <span class="token keyword">let</span>
    <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token hvariable">newStack1</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token hvariable">push</span> <span class="token number">3</span> <span class="token hvariable">stack</span>
    <span class="token punctuation">(</span><span class="token hvariable">a</span> <span class="token punctuation">,</span><span class="token hvariable">newStack2</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token hvariable">pop</span> <span class="token hvariable">newStack1</span>
    <span class="token keyword">in</span> <span class="token hvariable">pop</span> <span class="token hvariable">newStack2</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>We take a&nbsp;<code>stack</code>&nbsp;and then we do&nbsp;<code>push 3 stack</code>, which results in a tuple. The first part of the tuple is a&nbsp;<code>()</code>&nbsp;and the second is a new stack and we call it&nbsp;<code>newStack1</code>. Then, we pop a number from&nbsp;<code>newStack1</code>, which results in a number&nbsp;<code>a</code>&nbsp;(which is the&nbsp;<code>3</code>) that we pushed and a new stack which we call&nbsp;<code>newStack2</code>. Then, we pop a number off&nbsp;<code>newStack2</code>&nbsp;and we get a number that's&nbsp;<code>b</code>&nbsp;and a&nbsp;<code>newStack3</code>. We return a tuple with that number and that stack. Let's try it out:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token hvariable">stackManip</span> <span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">8</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">]</span>
<span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token number">8</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Cool, the result is&nbsp;<code>5</code>&nbsp;and the new stack is&nbsp;<code>[8,2,1]</code>. Notice how&nbsp;<code>stackManip</code>&nbsp;is itself a stateful computation. We've taken a bunch of stateful computations and we've sort of glued them together. Hmm, sounds familiar.</p></div><div><p>The above code for&nbsp;<code>stackManip</code>&nbsp;is kind of tedious since we're manually giving the state to every stateful computation and storing it and then giving it to the next one. Wouldn't it be cooler if, instead of giving the stack manually to each function, we could write something like this:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">stackManip</span> <span class="token operator">=</span> <span class="token keyword">do</span>
    <span class="token hvariable">push</span> <span class="token number">3</span>
    <span class="token hvariable">a</span> <span class="token operator">&lt;-</span> <span class="token hvariable">pop</span>
    <span class="token hvariable">pop</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Well, using the state monad will allow us to do exactly this. With it, we will be able to take stateful computations like these and use them without having to manage the state manually.</p></div><div><h3 data-heading="The State monad" id="The_State_monad" style="display: flex;"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>The State monad</h3></div><div><p>The&nbsp;<code>Control.Monad.State</code>&nbsp;module provides a&nbsp;<code>newtype</code>&nbsp;that wraps stateful computations. Here's its definition:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token keyword">newtype</span> <span class="token constant">State</span> <span class="token hvariable">s</span> <span class="token hvariable">a</span> <span class="token operator">=</span> <span class="token constant">State</span> <span class="token punctuation">{</span> <span class="token hvariable">runState</span> <span class="token operator">::</span> <span class="token hvariable">s</span> <span class="token operator">-&gt;</span> <span class="token punctuation">(</span><span class="token hvariable">a</span><span class="token punctuation">,</span><span class="token hvariable">s</span><span class="token punctuation">)</span> <span class="token punctuation">}</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>A&nbsp;<code>State s a</code>&nbsp;is a stateful computation that manipulates a state of type&nbsp;<code>s</code>&nbsp;and has a result of type&nbsp;<code>a</code>.</p></div><div><p>Now that we've seen what stateful computations are about and how they can even be thought of as values with contexts, let's check out their&nbsp;<code>Monad</code>&nbsp;instance:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token keyword">instance</span> <span class="token constant">Monad</span> <span class="token punctuation">(</span><span class="token constant">State</span> <span class="token hvariable">s</span><span class="token punctuation">)</span> <span class="token keyword">where</span>
    <span class="token builtin">return</span> <span class="token hvariable">x</span> <span class="token operator">=</span> <span class="token constant">State</span> <span class="token operator">$</span> <span class="token operator">\</span><span class="token hvariable">s</span> <span class="token operator">-&gt;</span> <span class="token punctuation">(</span><span class="token hvariable">x</span><span class="token punctuation">,</span><span class="token hvariable">s</span><span class="token punctuation">)</span>
    <span class="token punctuation">(</span><span class="token constant">State</span> <span class="token hvariable">h</span><span class="token punctuation">)</span> <span class="token operator">&gt;&gt;=</span> <span class="token hvariable">f</span> <span class="token operator">=</span> <span class="token constant">State</span> <span class="token operator">$</span> <span class="token operator">\</span><span class="token hvariable">s</span> <span class="token operator">-&gt;</span> <span class="token keyword">let</span> <span class="token punctuation">(</span><span class="token hvariable">a</span><span class="token punctuation">,</span> <span class="token hvariable">newState</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token hvariable">h</span> <span class="token hvariable">s</span>
                                        <span class="token punctuation">(</span><span class="token constant">State</span> <span class="token hvariable">g</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token hvariable">f</span> <span class="token hvariable">a</span>
                                    <span class="token keyword">in</span>  <span class="token hvariable">g</span> <span class="token hvariable">newState</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Let's take a gander at&nbsp;<code>return</code>&nbsp;first. Our aim with&nbsp;<code>return</code>&nbsp;is to take a value and make a stateful computation that always has that value as its result. That's why we just make a lambda&nbsp;<code>\s -&gt; (x,s)</code>. We always present&nbsp;<code>x</code>&nbsp;as the result of the stateful computation and the state is kept unchanged, because&nbsp;<code>return</code>&nbsp;has to put a value in a minimal context. So&nbsp;<code>return</code>&nbsp;will make a stateful computation that presents a certain value as the result and keeps the state unchanged.</p></div><div><p><img alt="im a cop" src="http://s3.amazonaws.com/lyah/badge.png" referrerpolicy="no-referrer"></p></div><div><p>What about&nbsp;<code>&gt;&gt;=</code>? Well, the result of feeding a stateful computation to a function with&nbsp;<code>&gt;&gt;=</code>&nbsp;has to be a stateful computation, right? So we start off with the&nbsp;<code>State</code>&nbsp;<code>newtype</code>&nbsp;wrapper and then we type out a lambda. This lambda will be our new stateful computation. But what goes on in it? Well, we somehow have to extract the result value from the first stateful computation. Because we're in a stateful computation right now, we can give the stateful computation&nbsp;<code>h</code>&nbsp;our current state&nbsp;<code>s</code>, which results in a pair of result and a new state:&nbsp;<code>(a, newState)</code>. Every time so far when we were implementing&nbsp;<code>&gt;&gt;=</code>, once we had the extracted the result from the monadic value, we applied the function&nbsp;<code>f</code>&nbsp;to it to get the new monadic value. In&nbsp;<code>Writer</code>, after doing that and getting the new monadic value, we still had to make sure that the context was taken care of by&nbsp;<code>mappend</code>ing the old monoid value with the new one. Here, we do&nbsp;<code>f a</code>&nbsp;and we get a new stateful computation&nbsp;<code>g</code>. Now that we have a new stateful computation and a new state (goes by the name of&nbsp;<code>newState</code>) we just apply that stateful computation&nbsp;<code>g</code>&nbsp;to the&nbsp;<code>newState</code>. The result is a tuple of final result and final state!</p></div><div><p>So with&nbsp;<code>&gt;&gt;=</code>, we kind of glue two stateful computations together, only the second one is hidden inside a function that takes the previous one's result. Because&nbsp;<code>pop</code>&nbsp;and&nbsp;<code>push</code>&nbsp;are already stateful computations, it's easy to wrap them into a&nbsp;<code>State</code>&nbsp;wrapper. Watch:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token import-statement"><span class="token keyword">import</span> Control<span class="token punctuation">.</span>Monad<span class="token punctuation">.</span>State</span>

<span class="token hvariable">pop</span> <span class="token operator">::</span> <span class="token constant">State</span> <span class="token constant">Stack</span> <span class="token constant">Int</span>
<span class="token hvariable">pop</span> <span class="token operator">=</span> <span class="token constant">State</span> <span class="token operator">$</span> <span class="token operator">\</span><span class="token punctuation">(</span><span class="token hvariable">x</span><span class="token operator">:</span><span class="token hvariable">xs</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token punctuation">(</span><span class="token hvariable">x</span><span class="token punctuation">,</span><span class="token hvariable">xs</span><span class="token punctuation">)</span>

<span class="token hvariable">push</span> <span class="token operator">::</span> <span class="token constant">Int</span> <span class="token operator">-&gt;</span> <span class="token constant">State</span> <span class="token constant">Stack</span> <span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token hvariable">push</span> <span class="token hvariable">a</span> <span class="token operator">=</span> <span class="token constant">State</span> <span class="token operator">$</span> <span class="token operator">\</span><span class="token hvariable">xs</span> <span class="token operator">-&gt;</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token hvariable">a</span><span class="token operator">:</span><span class="token hvariable">xs</span><span class="token punctuation">)</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p><code>pop</code>&nbsp;is already a stateful computation and&nbsp;<code>push</code>&nbsp;takes an&nbsp;<code>Int</code>&nbsp;and returns a stateful computation. Now we can rewrite our previous example of pushing&nbsp;<code>3</code>&nbsp;onto the stack and then popping two numbers off like this:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token import-statement"><span class="token keyword">import</span> Control<span class="token punctuation">.</span>Monad<span class="token punctuation">.</span>State</span>

<span class="token hvariable">stackManip</span> <span class="token operator">::</span> <span class="token constant">State</span> <span class="token constant">Stack</span> <span class="token constant">Int</span>
<span class="token hvariable">stackManip</span> <span class="token operator">=</span> <span class="token keyword">do</span>
    <span class="token hvariable">push</span> <span class="token number">3</span>
    <span class="token hvariable">a</span> <span class="token operator">&lt;-</span> <span class="token hvariable">pop</span>
    <span class="token hvariable">pop</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>See how we've glued a push and two pops into one stateful computation? When we unwrap it from its&nbsp;<code>newtype</code>&nbsp;wrapper we get a function to which we can provide some initial state:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token hvariable">runState</span> <span class="token hvariable">stackManip</span> <span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">8</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">]</span>
<span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token number">8</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>We didn't have to bind the second&nbsp;<code>pop</code>&nbsp;to&nbsp;<code>a</code>&nbsp;because we didn't use that&nbsp;<code>a</code>&nbsp;at all. So we could have written it like this:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">stackManip</span> <span class="token operator">::</span> <span class="token constant">State</span> <span class="token constant">Stack</span> <span class="token constant">Int</span>
<span class="token hvariable">stackManip</span> <span class="token operator">=</span> <span class="token keyword">do</span>
    <span class="token hvariable">push</span> <span class="token number">3</span>
    <span class="token hvariable">pop</span>
    <span class="token hvariable">pop</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Pretty cool. But what if we want to do this: pop one number off the stack and then if that number is&nbsp;<code>5</code>&nbsp;we just put it back onto the stack and stop but if it isn't&nbsp;<code>5</code>, we push&nbsp;<code>3</code>&nbsp;and&nbsp;<code>8</code>&nbsp;back on? Well, here's the code:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">stackStuff</span> <span class="token operator">::</span> <span class="token constant">State</span> <span class="token constant">Stack</span> <span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token hvariable">stackStuff</span> <span class="token operator">=</span> <span class="token keyword">do</span>
    <span class="token hvariable">a</span> <span class="token operator">&lt;-</span> <span class="token hvariable">pop</span>
    <span class="token keyword">if</span> <span class="token hvariable">a</span> <span class="token operator">==</span> <span class="token number">5</span>
        <span class="token keyword">then</span> <span class="token hvariable">push</span> <span class="token number">5</span>
        <span class="token keyword">else</span> <span class="token keyword">do</span>
            <span class="token hvariable">push</span> <span class="token number">3</span>
            <span class="token hvariable">push</span> <span class="token number">8</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>This is quite straightforward. Let's run it with an initial stack.</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token hvariable">runState</span> <span class="token hvariable">stackStuff</span> <span class="token punctuation">[</span><span class="token number">9</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">]</span>
<span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token number">8</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Remember,&nbsp;<code>do</code>&nbsp;expressions result in monadic values and with the&nbsp;<code>State</code>&nbsp;monad, a single&nbsp;<code>do</code>&nbsp;expression is also a stateful function. Because&nbsp;<code>stackManip</code>&nbsp;and&nbsp;<code>stackStuff</code>&nbsp;are ordinary stateful computations, we can glue them together to produce further stateful computations.</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">moreStack</span> <span class="token operator">::</span> <span class="token constant">State</span> <span class="token constant">Stack</span> <span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token hvariable">moreStack</span> <span class="token operator">=</span> <span class="token keyword">do</span>
    <span class="token hvariable">a</span> <span class="token operator">&lt;-</span> <span class="token hvariable">stackManip</span>
    <span class="token keyword">if</span> <span class="token hvariable">a</span> <span class="token operator">==</span> <span class="token number">100</span>
        <span class="token keyword">then</span> <span class="token hvariable">stackStuff</span>
        <span class="token keyword">else</span> <span class="token builtin">return</span> <span class="token punctuation">(</span><span class="token punctuation">)</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>If the result of&nbsp;<code>stackManip</code>&nbsp;on the current stack is&nbsp;<code>100</code>, we run&nbsp;<code>stackStuff</code>, otherwise we do nothing.&nbsp;<code>return ()</code>&nbsp;just keeps the state as it is and does nothing.</p></div><div><p>The&nbsp;<code>Control.Monad.State</code>&nbsp;module provides a type class that's called&nbsp;<code>MonadState</code>&nbsp;and it features two pretty useful functions, namely&nbsp;<code>get</code>&nbsp;and&nbsp;<code>put</code>. For&nbsp;<code>State</code>, the&nbsp;<code>get</code>&nbsp;function is implemented like this:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">get</span> <span class="token operator">=</span> <span class="token constant">State</span> <span class="token operator">$</span> <span class="token operator">\</span><span class="token hvariable">s</span> <span class="token operator">-&gt;</span> <span class="token punctuation">(</span><span class="token hvariable">s</span><span class="token punctuation">,</span><span class="token hvariable">s</span><span class="token punctuation">)</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>So it just takes the current state and presents it as the result. The&nbsp;<code>put</code>&nbsp;function takes some state and makes a stateful function that replaces the current state with it:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">put</span> <span class="token hvariable">newState</span> <span class="token operator">=</span> <span class="token constant">State</span> <span class="token operator">$</span> <span class="token operator">\</span><span class="token hvariable">s</span> <span class="token operator">-&gt;</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token hvariable">newState</span><span class="token punctuation">)</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>So with these, we can see what the current stack is or we can replace it with a whole other stack. Like so:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">stackyStack</span> <span class="token operator">::</span> <span class="token constant">State</span> <span class="token constant">Stack</span> <span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token hvariable">stackyStack</span> <span class="token operator">=</span> <span class="token keyword">do</span>
    <span class="token hvariable">stackNow</span> <span class="token operator">&lt;-</span> <span class="token hvariable">get</span>
    <span class="token keyword">if</span> <span class="token hvariable">stackNow</span> <span class="token operator">==</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">]</span>
        <span class="token keyword">then</span> <span class="token hvariable">put</span> <span class="token punctuation">[</span><span class="token number">8</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">]</span>
        <span class="token keyword">else</span> <span class="token hvariable">put</span> <span class="token punctuation">[</span><span class="token number">9</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">]</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>It's worth examining what the type of&nbsp;<code>&gt;&gt;=</code>&nbsp;would be if it only worked for&nbsp;<code>State</code>&nbsp;values:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token punctuation">(</span><span class="token operator">&gt;&gt;=</span><span class="token punctuation">)</span> <span class="token operator">::</span> <span class="token constant">State</span> <span class="token hvariable">s</span> <span class="token hvariable">a</span> <span class="token operator">-&gt;</span> <span class="token punctuation">(</span><span class="token hvariable">a</span> <span class="token operator">-&gt;</span> <span class="token constant">State</span> <span class="token hvariable">s</span> <span class="token hvariable">b</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token constant">State</span> <span class="token hvariable">s</span> <span class="token hvariable">b</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>See how the type of the state&nbsp;<code>s</code>&nbsp;stays the same but the type of the result can change from&nbsp;<code>a</code>&nbsp;to&nbsp;<code>b</code>? This means that we can glue together several stateful computations whose results are of different types but the type of the state has to stay the same. Now why is that? Well, for instance, for&nbsp;<code>Maybe</code>,&nbsp;<code>&gt;&gt;=</code>&nbsp;has this type:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token punctuation">(</span><span class="token operator">&gt;&gt;=</span><span class="token punctuation">)</span> <span class="token operator">::</span> <span class="token constant">Maybe</span> <span class="token hvariable">a</span> <span class="token operator">-&gt;</span> <span class="token punctuation">(</span><span class="token hvariable">a</span> <span class="token operator">-&gt;</span> <span class="token constant">Maybe</span> <span class="token hvariable">b</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token constant">Maybe</span> <span class="token hvariable">b</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>It makes sense that the monad itself,&nbsp;<code>Maybe</code>, doesn't change. It wouldn't make sense to use&nbsp;<code>&gt;&gt;=</code>&nbsp;between two different monads. Well, for the state monad, the monad is actually&nbsp;<code>State s</code>, so if that&nbsp;<code>s</code>&nbsp;was different, we'd be using&nbsp;<code>&gt;&gt;=</code>&nbsp;between two different monads.</p></div><div><h3 data-heading="Randomness and the state monad" id="Randomness_and_the_state_monad" style="display: flex;"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>Randomness and the state monad</h3></div><div><p>At the beginning of this section, we saw how generating numbers can sometimes be awkward because every random function takes a generator and returns a random number along with a new generator, which must then be used instead of the old one if we want to generate another random number. The state monad makes dealing with this a lot easier.</p></div><div><p>The&nbsp;<code>random</code>&nbsp;function from&nbsp;<code>System.Random</code>&nbsp;has the following type:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">random</span> <span class="token operator">::</span> <span class="token punctuation">(</span><span class="token constant">RandomGen</span> <span class="token hvariable">g</span><span class="token punctuation">,</span> <span class="token constant">Random</span> <span class="token hvariable">a</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token hvariable">g</span> <span class="token operator">-&gt;</span> <span class="token punctuation">(</span><span class="token hvariable">a</span><span class="token punctuation">,</span> <span class="token hvariable">g</span><span class="token punctuation">)</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Meaning it takes a random generator and produces a random number along with a new generator. We can see that it's a stateful computation, so we can wrap it in the&nbsp;<code>State</code>&nbsp;<code>newtype</code>&nbsp;constructor and then use it as a monadic value so that passing of the state gets handled for us:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token import-statement"><span class="token keyword">import</span> System<span class="token punctuation">.</span>Random</span>
<span class="token import-statement"><span class="token keyword">import</span> Control<span class="token punctuation">.</span>Monad<span class="token punctuation">.</span>State</span>

<span class="token hvariable">randomSt</span> <span class="token operator">::</span> <span class="token punctuation">(</span><span class="token constant">RandomGen</span> <span class="token hvariable">g</span><span class="token punctuation">,</span> <span class="token constant">Random</span> <span class="token hvariable">a</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token constant">State</span> <span class="token hvariable">g</span> <span class="token hvariable">a</span>
<span class="token hvariable">randomSt</span> <span class="token operator">=</span> <span class="token constant">State</span> <span class="token hvariable">random</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>So now if we want to throw three coins (<code>True</code>&nbsp;is tails,&nbsp;<code>False</code>&nbsp;is heads) we just do the following:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token import-statement"><span class="token keyword">import</span> System<span class="token punctuation">.</span>Random</span>
<span class="token import-statement"><span class="token keyword">import</span> Control<span class="token punctuation">.</span>Monad<span class="token punctuation">.</span>State</span>

<span class="token hvariable">threeCoins</span> <span class="token operator">::</span> <span class="token constant">State</span> <span class="token constant">StdGen</span> <span class="token punctuation">(</span><span class="token constant">Bool</span><span class="token punctuation">,</span><span class="token constant">Bool</span><span class="token punctuation">,</span><span class="token constant">Bool</span><span class="token punctuation">)</span>
<span class="token hvariable">threeCoins</span> <span class="token operator">=</span> <span class="token keyword">do</span>
    <span class="token hvariable">a</span> <span class="token operator">&lt;-</span> <span class="token hvariable">randomSt</span>
    <span class="token hvariable">b</span> <span class="token operator">&lt;-</span> <span class="token hvariable">randomSt</span>
    <span class="token hvariable">c</span> <span class="token operator">&lt;-</span> <span class="token hvariable">randomSt</span>
    <span class="token builtin">return</span> <span class="token punctuation">(</span><span class="token hvariable">a</span><span class="token punctuation">,</span><span class="token hvariable">b</span><span class="token punctuation">,</span><span class="token hvariable">c</span><span class="token punctuation">)</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p><code>threeCoins</code>&nbsp;is now a stateful computations and after taking an initial random generator, it passes it to the first&nbsp;<code>randomSt</code>, which produces a number and a new generator, which gets passed to the next one and so on. We use&nbsp;<code>return (a,b,c)</code>&nbsp;to present&nbsp;<code>(a,b,c)</code>&nbsp;as the result without changing the most recent generator. Let's give this a go:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token hvariable">runState</span> <span class="token hvariable">threeCoins</span> <span class="token punctuation">(</span><span class="token hvariable">mkStdGen</span> <span class="token number">33</span><span class="token punctuation">)</span>
<span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token constant">True</span><span class="token punctuation">,</span><span class="token constant">False</span><span class="token punctuation">,</span><span class="token constant">True</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token number">680029187</span> <span class="token number">2103410263</span><span class="token punctuation">)</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Nice. Doing these sort of things that require some state to be kept in between steps just became much less of a hassle!</p></div><div><h2 data-heading="Error error on the wall" id="Error_error_on_the_wall" style="display: flex;"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>Error error on the wall</h2></div><div><p>We know by now that&nbsp;<code>Maybe</code>&nbsp;is used to add a context of possible failure to values. A value can be a&nbsp;<code>Just something</code>&nbsp;or a&nbsp;<code>Nothing</code>. However useful it may be, when we have a&nbsp;<code>Nothing</code>, all we know is that there was some sort of failure, but there's no way to cram some more info in there telling us what kind of failure it was or why it failed.</p></div><div><p>The&nbsp;<code>Either e a</code>&nbsp;type on the other hand, allows us to incorporate a context of possible failure to our values while also being able to attach values to the failure, so that they can describe what went wrong or provide some other useful info regarding the failure. An&nbsp;<code>Either e a</code>&nbsp;value can either be a&nbsp;<code>Right</code>&nbsp;value, signifying the right answer and a success, or it can be a&nbsp;<code>Left</code>&nbsp;value, signifying failure. For instance:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token operator">:</span><span class="token hvariable">t</span> <span class="token constant">Right</span> <span class="token number">4</span>
<span class="token constant">Right</span> <span class="token number">4</span> <span class="token operator">::</span> <span class="token punctuation">(</span><span class="token constant">Num</span> <span class="token hvariable">t</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token constant">Either</span> <span class="token hvariable">a</span> <span class="token hvariable">t</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token operator">:</span><span class="token hvariable">t</span> <span class="token constant">Left</span> <span class="token string">"out of cheese error"</span>
<span class="token constant">Left</span> <span class="token string">"out of cheese error"</span> <span class="token operator">::</span> <span class="token constant">Either</span> <span class="token punctuation">[</span><span class="token constant">Char</span><span class="token punctuation">]</span> <span class="token hvariable">b</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>This is pretty much just an enhanced&nbsp;<code>Maybe</code>, so it makes sense for it to be a monad, because it can also be viewed as a value with an added context of possible failure, only now there's a value attached when there's an error as well.</p></div><div><p>Its&nbsp;<code>Monad</code>&nbsp;instance is similar to that of&nbsp;<code>Maybe</code>&nbsp;and it can be found in&nbsp;<code>Control.Monad.Error</code>:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token keyword">instance</span> <span class="token punctuation">(</span><span class="token constant">Error</span> <span class="token hvariable">e</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token constant">Monad</span> <span class="token punctuation">(</span><span class="token constant">Either</span> <span class="token hvariable">e</span><span class="token punctuation">)</span> <span class="token keyword">where</span>
    <span class="token builtin">return</span> <span class="token hvariable">x</span> <span class="token operator">=</span> <span class="token constant">Right</span> <span class="token hvariable">x</span> 
    <span class="token constant">Right</span> <span class="token hvariable">x</span> <span class="token operator">&gt;&gt;=</span> <span class="token hvariable">f</span> <span class="token operator">=</span> <span class="token hvariable">f</span> <span class="token hvariable">x</span>
    <span class="token constant">Left</span> <span class="token hvariable">err</span> <span class="token operator">&gt;&gt;=</span> <span class="token hvariable">f</span> <span class="token operator">=</span> <span class="token constant">Left</span> <span class="token hvariable">err</span>
    <span class="token builtin">fail</span> <span class="token hvariable">msg</span> <span class="token operator">=</span> <span class="token constant">Left</span> <span class="token punctuation">(</span><span class="token hvariable">strMsg</span> <span class="token hvariable">msg</span><span class="token punctuation">)</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p><code>return</code>, as always, takes a value and puts it in a default minimal context. It wraps our value in the&nbsp;<code>Right</code>&nbsp;constructor because we're using&nbsp;<code>Right</code>&nbsp;to represent a successful computation where a result is present. This is a lot like&nbsp;<code>return</code>&nbsp;for&nbsp;<code>Maybe</code>.</p></div><div><p>The&nbsp;<code>&gt;&gt;=</code>&nbsp;examines two possible cases: a&nbsp;<code>Left</code>&nbsp;and a&nbsp;<code>Right</code>. In the case of a&nbsp;<code>Right</code>, the function&nbsp;<code>f</code>&nbsp;is applied to the value inside it, similar to how in the case of a&nbsp;<code>Just</code>, the function is just applied to its contents. In the case of an error, the&nbsp;<code>Left</code>&nbsp;value is kept, along with its contents, which describe the failure.</p></div><div><p>The&nbsp;<code>Monad</code>&nbsp;instance for&nbsp;<code>Either e</code>&nbsp;makes an additional requirement, and that is that the type of the value contained in a&nbsp;<code>Left</code>, the one that's indexed by the&nbsp;<code>e</code>&nbsp;type parameter, has to be an instance of the&nbsp;<code>Error</code>&nbsp;type class. The&nbsp;<code>Error</code>&nbsp;type class is for types whose values can act like error messages. It defines the&nbsp;<code>strMsg</code>&nbsp;function, which takes an error in the form of a string and returns such a value. A good example of an&nbsp;<code>Error</code>&nbsp;instance is, well, the&nbsp;<code>String</code>&nbsp;type! In the case of&nbsp;<code>String</code>, the&nbsp;<code>strMsg</code>&nbsp;function just returns the string that it got:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token operator">:</span><span class="token hvariable">t</span> <span class="token hvariable">strMsg</span>
<span class="token hvariable">strMsg</span> <span class="token operator">::</span> <span class="token punctuation">(</span><span class="token constant">Error</span> <span class="token hvariable">a</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token constant">String</span> <span class="token operator">-&gt;</span> <span class="token hvariable">a</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token hvariable">strMsg</span> <span class="token string">"boom!"</span> <span class="token operator">::</span> <span class="token constant">String</span>
<span class="token string">"boom!"</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>But since we usually use&nbsp;<code>String</code>&nbsp;to describe the error when using&nbsp;<code>Either</code>, we don't have to worry about this too much. When a pattern match fails in&nbsp;<code>do</code>&nbsp;notation, a&nbsp;<code>Left</code>&nbsp;value is used to signify this failure.</p></div><div><p>Anyway, here are a few examples of usage:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token constant">Left</span> <span class="token string">"boom"</span> <span class="token operator">&gt;&gt;=</span> <span class="token operator">\</span><span class="token hvariable">x</span> <span class="token operator">-&gt;</span> <span class="token builtin">return</span> <span class="token punctuation">(</span><span class="token hvariable">x</span><span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span>
<span class="token constant">Left</span> <span class="token string">"boom"</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token constant">Right</span> <span class="token number">100</span> <span class="token operator">&gt;&gt;=</span> <span class="token operator">\</span><span class="token hvariable">x</span> <span class="token operator">-&gt;</span> <span class="token constant">Left</span> <span class="token string">"no way!"</span>
<span class="token constant">Left</span> <span class="token string">"no way!"</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>When we use&nbsp;<code>&gt;&gt;=</code>&nbsp;to feed a&nbsp;<code>Left</code>&nbsp;value to a function, the function is ignored and an identical&nbsp;<code>Left</code>&nbsp;value is returned. When we feed a&nbsp;<code>Right</code>&nbsp;value to a function, the function gets applied to what's on the inside, but in this case that function produced a&nbsp;<code>Left</code>&nbsp;value anyway!</p></div><div><p>When we try to feed a&nbsp;<code>Right</code>&nbsp;value to a function that also succeeds, we're tripped up by a peculiar type error! Hmmm.</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token constant">Right</span> <span class="token number">3</span> <span class="token operator">&gt;&gt;=</span> <span class="token operator">\</span><span class="token hvariable">x</span> <span class="token operator">-&gt;</span> <span class="token builtin">return</span> <span class="token punctuation">(</span><span class="token hvariable">x</span> <span class="token operator">+</span> <span class="token number">100</span><span class="token punctuation">)</span>

<span class="token operator">&lt;</span><span class="token hvariable">interactive</span><span class="token operator">&gt;:</span><span class="token number">1</span><span class="token operator">:</span><span class="token number">0</span><span class="token operator">:</span>
    <span class="token constant">Ambiguous</span> <span class="token keyword">type</span> <span class="token hvariable">variable</span> `<span class="token hvariable">a'</span> <span class="token keyword">in</span> <span class="token hvariable">the</span> <span class="token hvariable">constraints</span><span class="token operator">:</span>
      `<span class="token constant">Error</span> <span class="token hvariable">a'</span> <span class="token hvariable">arising</span> <span class="token hvariable">from</span> <span class="token hvariable">a</span> <span class="token hvariable">use</span> <span class="token keyword">of</span> `<span class="token hvariable">it'</span> <span class="token hvariable">at</span> <span class="token operator">&lt;</span><span class="token hvariable">interactive</span><span class="token operator">&gt;:</span><span class="token number">1</span><span class="token operator">:</span><span class="token number">0</span><span class="token operator">-</span><span class="token number">33</span>
      `<span class="token constant">Show</span> <span class="token hvariable">a'</span> <span class="token hvariable">arising</span> <span class="token hvariable">from</span> <span class="token hvariable">a</span> <span class="token hvariable">use</span> <span class="token keyword">of</span> `<span class="token builtin">print</span>' <span class="token hvariable">at</span> <span class="token operator">&lt;</span><span class="token hvariable">interactive</span><span class="token operator">&gt;:</span><span class="token number">1</span><span class="token operator">:</span><span class="token number">0</span><span class="token operator">-</span><span class="token number">33</span>
    <span class="token constant">Probable</span> <span class="token hvariable">fix</span><span class="token operator">:</span> <span class="token hvariable">add</span> <span class="token hvariable">a</span> <span class="token keyword">type</span> <span class="token hvariable">signature</span> <span class="token hvariable">that</span> <span class="token hvariable">fixes</span> <span class="token hvariable">these</span> <span class="token keyword">type</span> <span class="token hvariable">variable</span><span class="token punctuation">(</span><span class="token hvariable">s</span><span class="token punctuation">)</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Haskell says that it doesn't know which type to choose for the&nbsp;<code>e</code>&nbsp;part of our&nbsp;<code>Either e a</code>&nbsp;typed value, even though we're just printing the&nbsp;<code>Right</code>&nbsp;part. This is due to the&nbsp;<code>Error e</code>&nbsp;constraint on the&nbsp;<code>Monad</code>&nbsp;instance. So if you get type errors like this one when using&nbsp;<code>Either</code>&nbsp;as a monad, just add an explicit type signature:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token constant">Right</span> <span class="token number">3</span> <span class="token operator">&gt;&gt;=</span> <span class="token operator">\</span><span class="token hvariable">x</span> <span class="token operator">-&gt;</span> <span class="token builtin">return</span> <span class="token punctuation">(</span><span class="token hvariable">x</span> <span class="token operator">+</span> <span class="token number">100</span><span class="token punctuation">)</span> <span class="token operator">::</span> <span class="token constant">Either</span> <span class="token constant">String</span> <span class="token constant">Int</span>
<span class="token constant">Right</span> <span class="token number">103</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Alright, now it works!</p></div><div><p>Other than this little hangup, using this monad is very similar to using&nbsp;<code>Maybe</code>&nbsp;as a monad. In the previous chapter, we used the monadic aspects of&nbsp;<code>Maybe</code>&nbsp;to simulate birds landing on the balancing pole of a tightrope walker. As an exercise, you can rewrite that with the error monad so that when the tightrope walker slips and falls, we remember how many birds were on each side of the pole when he fell.</p></div><div><h2 data-heading="Some useful monadic functions" id="Some_useful_monadic_functions" style="display: flex;"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>Some useful monadic functions</h2></div><div><p>In this section, we're going to explore a few functions that either operate on monadic values or return monadic values as their results (or both!). Such functions are usually referred to as monadic functions. While some of them will be brand new, others will be monadic counterparts of functions that we already know, like&nbsp;<code>filter</code>&nbsp;and&nbsp;<code>foldl</code>. Let's see what they are then!</p></div><div><h3 data-heading="liftM and friends" id="liftM_and_friends" style="display: flex;"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>liftM and friends</h3></div><div><p><img alt="im a cop too" src="http://s3.amazonaws.com/lyah/wolf.png" referrerpolicy="no-referrer"></p></div><div><p>When we started our journey to the top of Monad Mountain, we first looked at functors, which are for things that can be mapped over. Then, we learned about improved functors called applicative functors, which allowed us to apply normal functions between several applicative values as well as to take a normal value and put it in some default context. Finally, we introduced monads as improved applicative functors, which added the ability for these values with context to somehow be fed into normal functions.</p></div><div><p>So every monad is an applicative functor and every applicative functor is a functor. The&nbsp;<code>Applicative</code>&nbsp;type class has a class constraint such that our type has to be an instance of&nbsp;<code>Functor</code>&nbsp;before we can make it an instance of&nbsp;<code>Applicative</code>. But even though&nbsp;<code>Monad</code>&nbsp;should have the same constraint for&nbsp;<code>Applicative</code>, as every monad is an applicative functor, it doesn't, because the&nbsp;<code>Monad</code>&nbsp;type class was introduced to Haskell way before&nbsp;<code>Applicative</code>.</p></div><div><p>But even though every monad is a functor, we don't have to rely on it having a&nbsp;<code>Functor</code>&nbsp;instance because of the&nbsp;<code>liftM</code>&nbsp;function.&nbsp;<code>liftM</code>&nbsp;takes a function and a monadic value and maps it over the monadic value. So it's pretty much the same thing as&nbsp;<code>fmap</code>! This is&nbsp;<code>liftM</code>'s type:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">liftM</span> <span class="token operator">::</span> <span class="token punctuation">(</span><span class="token constant">Monad</span> <span class="token hvariable">m</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">(</span><span class="token hvariable">a</span> <span class="token operator">-&gt;</span> <span class="token hvariable">b</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token hvariable">m</span> <span class="token hvariable">a</span> <span class="token operator">-&gt;</span> <span class="token hvariable">m</span> <span class="token hvariable">b</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>And this is the type of&nbsp;<code>fmap</code>:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token builtin">fmap</span> <span class="token operator">::</span> <span class="token punctuation">(</span><span class="token constant">Functor</span> <span class="token hvariable">f</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">(</span><span class="token hvariable">a</span> <span class="token operator">-&gt;</span> <span class="token hvariable">b</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token hvariable">f</span> <span class="token hvariable">a</span> <span class="token operator">-&gt;</span> <span class="token hvariable">f</span> <span class="token hvariable">b</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>If the&nbsp;<code>Functor</code>&nbsp;and&nbsp;<code>Monad</code>&nbsp;instances for a type obey the functor and monad laws, these two amount to the same thing (and all the monads that we've met so far obey both). This is kind of like&nbsp;<code>pure</code>&nbsp;and&nbsp;<code>return</code>&nbsp;do the same thing, only one has an&nbsp;<code>Applicative</code>&nbsp;class constraint whereas the other has a&nbsp;<code>Monad</code>&nbsp;one. Let's try&nbsp;<code>liftM</code>&nbsp;out:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token hvariable">liftM</span> <span class="token punctuation">(</span><span class="token operator">*</span><span class="token number">3</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token constant">Just</span> <span class="token number">8</span><span class="token punctuation">)</span>
<span class="token constant">Just</span> <span class="token number">24</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token builtin">fmap</span> <span class="token punctuation">(</span><span class="token operator">*</span><span class="token number">3</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token constant">Just</span> <span class="token number">8</span><span class="token punctuation">)</span>
<span class="token constant">Just</span> <span class="token number">24</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token hvariable">runWriter</span> <span class="token operator">$</span> <span class="token hvariable">liftM</span> <span class="token builtin">not</span> <span class="token operator">$</span> <span class="token constant">Writer</span> <span class="token punctuation">(</span><span class="token constant">True</span><span class="token punctuation">,</span> <span class="token string">"chickpeas"</span><span class="token punctuation">)</span>
<span class="token punctuation">(</span><span class="token constant">False</span><span class="token punctuation">,</span><span class="token string">"chickpeas"</span><span class="token punctuation">)</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token hvariable">runWriter</span> <span class="token operator">$</span> <span class="token builtin">fmap</span> <span class="token builtin">not</span> <span class="token operator">$</span> <span class="token constant">Writer</span> <span class="token punctuation">(</span><span class="token constant">True</span><span class="token punctuation">,</span> <span class="token string">"chickpeas"</span><span class="token punctuation">)</span>
<span class="token punctuation">(</span><span class="token constant">False</span><span class="token punctuation">,</span><span class="token string">"chickpeas"</span><span class="token punctuation">)</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token hvariable">runState</span> <span class="token punctuation">(</span><span class="token hvariable">liftM</span> <span class="token punctuation">(</span><span class="token operator">+</span><span class="token number">100</span><span class="token punctuation">)</span> <span class="token hvariable">pop</span><span class="token punctuation">)</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">]</span>
<span class="token punctuation">(</span><span class="token number">101</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token hvariable">runState</span> <span class="token punctuation">(</span><span class="token builtin">fmap</span> <span class="token punctuation">(</span><span class="token operator">+</span><span class="token number">100</span><span class="token punctuation">)</span> <span class="token hvariable">pop</span><span class="token punctuation">)</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">]</span>
<span class="token punctuation">(</span><span class="token number">101</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>We already know quite well how&nbsp;<code>fmap</code>&nbsp;works with&nbsp;<code>Maybe</code>&nbsp;values. And&nbsp;<code>liftM</code>&nbsp;does the same thing. For&nbsp;<code>Writer</code>&nbsp;values, the function is mapped over the first component of the tuple, which is the result. Doing&nbsp;<code>fmap</code>&nbsp;or&nbsp;<code>liftM</code>&nbsp;over a stateful computation results in another stateful computation, only its eventual result is modified by the supplied function. Had we not mapped&nbsp;<code>(+100)</code>&nbsp;over&nbsp;<code>pop</code>&nbsp;in this case before running it, it would have returned&nbsp;<code>(1,[2,3,4])</code>.</p></div><div><p>This is how&nbsp;<code>liftM</code>&nbsp;is implemented:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">liftM</span> <span class="token operator">::</span> <span class="token punctuation">(</span><span class="token constant">Monad</span> <span class="token hvariable">m</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">(</span><span class="token hvariable">a</span> <span class="token operator">-&gt;</span> <span class="token hvariable">b</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token hvariable">m</span> <span class="token hvariable">a</span> <span class="token operator">-&gt;</span> <span class="token hvariable">m</span> <span class="token hvariable">b</span>
<span class="token hvariable">liftM</span> <span class="token hvariable">f</span> <span class="token hvariable">m</span> <span class="token operator">=</span> <span class="token hvariable">m</span> <span class="token operator">&gt;&gt;=</span> <span class="token punctuation">(</span><span class="token operator">\</span><span class="token hvariable">x</span> <span class="token operator">-&gt;</span> <span class="token builtin">return</span> <span class="token punctuation">(</span><span class="token hvariable">f</span> <span class="token hvariable">x</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Or with&nbsp;<code>do</code>&nbsp;notation:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">liftM</span> <span class="token operator">::</span> <span class="token punctuation">(</span><span class="token constant">Monad</span> <span class="token hvariable">m</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">(</span><span class="token hvariable">a</span> <span class="token operator">-&gt;</span> <span class="token hvariable">b</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token hvariable">m</span> <span class="token hvariable">a</span> <span class="token operator">-&gt;</span> <span class="token hvariable">m</span> <span class="token hvariable">b</span>
<span class="token hvariable">liftM</span> <span class="token hvariable">f</span> <span class="token hvariable">m</span> <span class="token operator">=</span> <span class="token keyword">do</span>
    <span class="token hvariable">x</span> <span class="token operator">&lt;-</span> <span class="token hvariable">m</span>
    <span class="token builtin">return</span> <span class="token punctuation">(</span><span class="token hvariable">f</span> <span class="token hvariable">x</span><span class="token punctuation">)</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>We feed the monadic value&nbsp;<code>m</code>&nbsp;into the function and then we apply the function&nbsp;<code>f</code>&nbsp;to its result before putting it back into a default context. Because of the monad laws, this is guaranteed not to change the context, only the result that the monadic value presents. We see that&nbsp;<code>liftM</code>&nbsp;is implemented without referencing the&nbsp;<code>Functor</code>&nbsp;type class at all. This means that we can implement&nbsp;<code>fmap</code>&nbsp;(or&nbsp;<code>liftM</code>, whatever you want to call it) just by using the goodies that monads offer us. Because of this, we can conclude that monads are stronger than just regular old functors.</p></div><div><p>The&nbsp;<code>Applicative</code>&nbsp;type class allows us to apply functions between values with contexts as if they were normal values. Like this:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token punctuation">(</span><span class="token operator">+</span><span class="token punctuation">)</span> <span class="token operator">&lt;$&gt;</span> <span class="token constant">Just</span> <span class="token number">3</span> <span class="token operator">&lt;*&gt;</span> <span class="token constant">Just</span> <span class="token number">5</span>
<span class="token constant">Just</span> <span class="token number">8</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token punctuation">(</span><span class="token operator">+</span><span class="token punctuation">)</span> <span class="token operator">&lt;$&gt;</span> <span class="token constant">Just</span> <span class="token number">3</span> <span class="token operator">&lt;*&gt;</span> <span class="token constant">Nothing</span>
<span class="token constant">Nothing</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Using this applicative style makes things pretty easy.&nbsp;<code>&lt;$&gt;</code>&nbsp;is just&nbsp;<code>fmap</code>&nbsp;and&nbsp;<code>&lt;*&gt;</code>&nbsp;is a function from the&nbsp;<code>Applicative</code>&nbsp;type class that has the following type:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token punctuation">(</span><span class="token operator">&lt;*&gt;</span><span class="token punctuation">)</span> <span class="token operator">::</span> <span class="token punctuation">(</span><span class="token constant">Applicative</span> <span class="token hvariable">f</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token hvariable">f</span> <span class="token punctuation">(</span><span class="token hvariable">a</span> <span class="token operator">-&gt;</span> <span class="token hvariable">b</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token hvariable">f</span> <span class="token hvariable">a</span> <span class="token operator">-&gt;</span> <span class="token hvariable">f</span> <span class="token hvariable">b</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>So it's kind of like&nbsp;<code>fmap</code>, only the function itself is in a context. We have to somehow extract it from the context and map it over the&nbsp;<code>f a</code>&nbsp;value and then assemble the context back together. Because all functions are curried in Haskell by default, we can use the combination of&nbsp;<code>&lt;$&gt;</code>&nbsp;and&nbsp;<code>&lt;*&gt;</code>&nbsp;to apply functions that take several parameters between applicative values.</p></div><div><p>Anyway, it turns out that just like&nbsp;<code>fmap</code>,&nbsp;<code>&lt;*&gt;</code>&nbsp;can also be implemented by using only what the&nbsp;<code>Monad</code>&nbsp;type class give us. The&nbsp;<code>ap</code>&nbsp;function is basically&nbsp;<code>&lt;*&gt;</code>, only it has a&nbsp;<code>Monad</code>&nbsp;constraint instead of an&nbsp;<code>Applicative</code>&nbsp;one. Here's its definition:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">ap</span> <span class="token operator">::</span> <span class="token punctuation">(</span><span class="token constant">Monad</span> <span class="token hvariable">m</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token hvariable">m</span> <span class="token punctuation">(</span><span class="token hvariable">a</span> <span class="token operator">-&gt;</span> <span class="token hvariable">b</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token hvariable">m</span> <span class="token hvariable">a</span> <span class="token operator">-&gt;</span> <span class="token hvariable">m</span> <span class="token hvariable">b</span>
<span class="token hvariable">ap</span> <span class="token hvariable">mf</span> <span class="token hvariable">m</span> <span class="token operator">=</span> <span class="token keyword">do</span>
    <span class="token hvariable">f</span> <span class="token operator">&lt;-</span> <span class="token hvariable">mf</span>
    <span class="token hvariable">x</span> <span class="token operator">&lt;-</span> <span class="token hvariable">m</span>
    <span class="token builtin">return</span> <span class="token punctuation">(</span><span class="token hvariable">f</span> <span class="token hvariable">x</span><span class="token punctuation">)</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p><code>mf</code>&nbsp;is a monadic value whose result is a function. Because the function is in a context as well as the value, we get the function from the context and call it&nbsp;<code>f</code>, then get the value and call that&nbsp;<code>x</code>&nbsp;and then finally apply the function to the value and present that as a result. Here's a quick demonstration:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token constant">Just</span> <span class="token punctuation">(</span><span class="token operator">+</span><span class="token number">3</span><span class="token punctuation">)</span> <span class="token operator">&lt;*&gt;</span> <span class="token constant">Just</span> <span class="token number">4</span>
<span class="token constant">Just</span> <span class="token number">7</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token constant">Just</span> <span class="token punctuation">(</span><span class="token operator">+</span><span class="token number">3</span><span class="token punctuation">)</span> <span class="token operator">`ap`</span> <span class="token constant">Just</span> <span class="token number">4</span>
<span class="token constant">Just</span> <span class="token number">7</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token punctuation">[</span><span class="token punctuation">(</span><span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token operator">+</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token operator">+</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token operator">&lt;*&gt;</span> <span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">,</span><span class="token number">11</span><span class="token punctuation">]</span>
<span class="token punctuation">[</span><span class="token number">11</span><span class="token punctuation">,</span><span class="token number">12</span><span class="token punctuation">,</span><span class="token number">12</span><span class="token punctuation">,</span><span class="token number">13</span><span class="token punctuation">,</span><span class="token number">13</span><span class="token punctuation">,</span><span class="token number">14</span><span class="token punctuation">]</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token punctuation">[</span><span class="token punctuation">(</span><span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token operator">+</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token operator">+</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token operator">`ap`</span> <span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">,</span><span class="token number">11</span><span class="token punctuation">]</span>
<span class="token punctuation">[</span><span class="token number">11</span><span class="token punctuation">,</span><span class="token number">12</span><span class="token punctuation">,</span><span class="token number">12</span><span class="token punctuation">,</span><span class="token number">13</span><span class="token punctuation">,</span><span class="token number">13</span><span class="token punctuation">,</span><span class="token number">14</span><span class="token punctuation">]</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Now we see that monads are stronger than applicatives as well, because we can use the functions from&nbsp;<code>Monad</code>&nbsp;to implement the ones for&nbsp;<code>Applicative</code>. In fact, many times when a type is found to be a monad, people first write up a&nbsp;<code>Monad</code>&nbsp;instance and then make an&nbsp;<code>Applicative</code>&nbsp;instance by just saying that&nbsp;<code>pure</code>&nbsp;is&nbsp;<code>return</code>&nbsp;and&nbsp;<code>&lt;*&gt;</code>&nbsp;is&nbsp;<code>ap</code>. Similarly, if you already have a&nbsp;<code>Monad</code>&nbsp;instance for something, you can give it a&nbsp;<code>Functor</code>&nbsp;instance just saying that&nbsp;<code>fmap</code>&nbsp;is&nbsp;<code>liftM</code>.</p></div><div><p>The&nbsp;<code>liftA2</code>&nbsp;function is a convenience function for applying a function between two applicative values. It's defined simply like so:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">liftA2</span> <span class="token operator">::</span> <span class="token punctuation">(</span><span class="token constant">Applicative</span> <span class="token hvariable">f</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">(</span><span class="token hvariable">a</span> <span class="token operator">-&gt;</span> <span class="token hvariable">b</span> <span class="token operator">-&gt;</span> <span class="token hvariable">c</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token hvariable">f</span> <span class="token hvariable">a</span> <span class="token operator">-&gt;</span> <span class="token hvariable">f</span> <span class="token hvariable">b</span> <span class="token operator">-&gt;</span> <span class="token hvariable">f</span> <span class="token hvariable">c</span>
<span class="token hvariable">liftA2</span> <span class="token hvariable">f</span> <span class="token hvariable">x</span> <span class="token hvariable">y</span> <span class="token operator">=</span> <span class="token hvariable">f</span> <span class="token operator">&lt;$&gt;</span> <span class="token hvariable">x</span> <span class="token operator">&lt;*&gt;</span> <span class="token hvariable">y</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>The&nbsp;<code>liftM2</code>&nbsp;function does the same thing, only it has a&nbsp;<code>Monad</code>&nbsp;constraint. There also exist&nbsp;<code>liftM3</code>&nbsp;and&nbsp;<code>liftM4</code>&nbsp;and&nbsp;<code>liftM5</code>.</p></div><div><p>We saw how monads are stronger than applicatives and functors and how even though all monads are functors and applicative functors, they don't necessarily have&nbsp;<code>Functor</code>&nbsp;and&nbsp;<code>Applicative</code>&nbsp;instances, so we examined the monadic equivalents of the functions that functors and applicative functors use.</p></div><div><h3 data-heading="The join function" id="The_join_function" style="display: flex;"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>The join function</h3></div><div><p>Here's some food for thought: if the result of one monadic value is another monadic value i.e. if one monadic value is nested inside the other, can you flatten them to just a single normal monadic value? Like, if we have&nbsp;<code>Just (Just 9)</code>, can we make that into&nbsp;<code>Just 9</code>? It turns out that any nested monadic value can be flattened and that this is actually a property unique to monads. For this, the&nbsp;<code>join</code>&nbsp;function exists. Its type is this:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">join</span> <span class="token operator">::</span> <span class="token punctuation">(</span><span class="token constant">Monad</span> <span class="token hvariable">m</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token hvariable">m</span> <span class="token punctuation">(</span><span class="token hvariable">m</span> <span class="token hvariable">a</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token hvariable">m</span> <span class="token hvariable">a</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>So it takes a monadic value within a monadic value and gives us just a monadic value, so it sort of flattens it. Here it is with some&nbsp;<code>Maybe</code>&nbsp;values:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token hvariable">join</span> <span class="token punctuation">(</span><span class="token constant">Just</span> <span class="token punctuation">(</span><span class="token constant">Just</span> <span class="token number">9</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token constant">Just</span> <span class="token number">9</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token hvariable">join</span> <span class="token punctuation">(</span><span class="token constant">Just</span> <span class="token constant">Nothing</span><span class="token punctuation">)</span>
<span class="token constant">Nothing</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token hvariable">join</span> <span class="token constant">Nothing</span>
<span class="token constant">Nothing</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>The first line has a successful computation as a result of a successful computation, so they're both just joined into one big successful computation. The second line features a&nbsp;<code>Nothing</code>&nbsp;as a result of a&nbsp;<code>Just</code>&nbsp;value. Whenever we were dealing with&nbsp;<code>Maybe</code>&nbsp;values before and we wanted to combine several of them into one, be it with&nbsp;<code>&lt;*&gt;</code>&nbsp;or&nbsp;<code>&gt;&gt;=</code>, they all had to be&nbsp;<code>Just</code>&nbsp;values for the result to be a&nbsp;<code>Just</code>&nbsp;value. If there was any failure along the way, the result was a failure and the same thing happens here. In the third line, we try to flatten what is from the onset a failure, so the result is a failure as well.</p></div><div><p>Flattening lists is pretty intuitive:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token hvariable">join</span> <span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">]</span><span class="token punctuation">]</span>
<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">]</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>As you can see, for lists,&nbsp;<code>join</code>&nbsp;is just&nbsp;<code>concat</code>. To flatten a&nbsp;<code>Writer</code>&nbsp;value whose result is a&nbsp;<code>Writer</code>&nbsp;value itself, we have to&nbsp;<code>mappend</code>&nbsp;the monoid value.</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token hvariable">runWriter</span> <span class="token operator">$</span> <span class="token hvariable">join</span> <span class="token punctuation">(</span><span class="token constant">Writer</span> <span class="token punctuation">(</span><span class="token constant">Writer</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token string">"aaa"</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token string">"bbb"</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token string">"bbbaaa"</span><span class="token punctuation">)</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>The outer monoid value&nbsp;<code>"bbb"</code>&nbsp;comes first and then to it&nbsp;<code>"aaa"</code>&nbsp;is appended. Intuitively speaking, when you want to examine what the result of a&nbsp;<code>Writer</code>&nbsp;value is, you have to write its monoid value to the log first and only then can you examine what it has inside.</p></div><div><p>Flattening&nbsp;<code>Either</code>&nbsp;values is very similar to flattening&nbsp;<code>Maybe</code>&nbsp;values:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token hvariable">join</span> <span class="token punctuation">(</span><span class="token constant">Right</span> <span class="token punctuation">(</span><span class="token constant">Right</span> <span class="token number">9</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">::</span> <span class="token constant">Either</span> <span class="token constant">String</span> <span class="token constant">Int</span>
<span class="token constant">Right</span> <span class="token number">9</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token hvariable">join</span> <span class="token punctuation">(</span><span class="token constant">Right</span> <span class="token punctuation">(</span><span class="token constant">Left</span> <span class="token string">"error"</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">::</span> <span class="token constant">Either</span> <span class="token constant">String</span> <span class="token constant">Int</span>
<span class="token constant">Left</span> <span class="token string">"error"</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token hvariable">join</span> <span class="token punctuation">(</span><span class="token constant">Left</span> <span class="token string">"error"</span><span class="token punctuation">)</span> <span class="token operator">::</span> <span class="token constant">Either</span> <span class="token constant">String</span> <span class="token constant">Int</span>
<span class="token constant">Left</span> <span class="token string">"error"</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>If we apply&nbsp;<code>join</code>&nbsp;to a stateful computation whose result is a stateful computation, the result is a stateful computation that first runs the outer stateful computation and then the resulting one. Watch:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token hvariable">runState</span> <span class="token punctuation">(</span><span class="token hvariable">join</span> <span class="token punctuation">(</span><span class="token constant">State</span> <span class="token operator">$</span> <span class="token operator">\</span><span class="token hvariable">s</span> <span class="token operator">-&gt;</span> <span class="token punctuation">(</span><span class="token hvariable">push</span> <span class="token number">10</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token operator">:</span><span class="token number">2</span><span class="token operator">:</span><span class="token hvariable">s</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">]</span>
<span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>The lambda here takes a state and puts&nbsp;<code>2</code>&nbsp;and&nbsp;<code>1</code>&nbsp;onto the stack and presents&nbsp;<code>push 10</code>&nbsp;as its result. So when this whole thing is flattened with&nbsp;<code>join</code>&nbsp;and then run, it first puts&nbsp;<code>2</code>&nbsp;and&nbsp;<code>1</code>&nbsp;onto the stack and then&nbsp;<code>push 10</code>&nbsp;gets carried out, pushing a&nbsp;<code>10</code>&nbsp;on to the top.</p></div><div><p>The implementation for&nbsp;<code>join</code>&nbsp;is as follows:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">join</span> <span class="token operator">::</span> <span class="token punctuation">(</span><span class="token constant">Monad</span> <span class="token hvariable">m</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token hvariable">m</span> <span class="token punctuation">(</span><span class="token hvariable">m</span> <span class="token hvariable">a</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token hvariable">m</span> <span class="token hvariable">a</span>
<span class="token hvariable">join</span> <span class="token hvariable">mm</span> <span class="token operator">=</span> <span class="token keyword">do</span>
    <span class="token hvariable">m</span> <span class="token operator">&lt;-</span> <span class="token hvariable">mm</span>
    <span class="token hvariable">m</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Because the result of&nbsp;<code>mm</code>&nbsp;is a monadic value, we get that result and then just put it on a line of its own because it's a monadic value. The trick here is that when we do&nbsp;<code>m &lt;- mm</code>, the context of the monad in which we are in gets taken care of. That's why, for instance,&nbsp;<code>Maybe</code>&nbsp;values result in&nbsp;<code>Just</code>&nbsp;values only if the outer and inner values are both&nbsp;<code>Just</code>&nbsp;values. Here's what this would look like if the&nbsp;<code>mm</code>&nbsp;value was set in advance to&nbsp;<code>Just (Just 8)</code>:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">joinedMaybes</span> <span class="token operator">::</span> <span class="token constant">Maybe</span> <span class="token constant">Int</span>
<span class="token hvariable">joinedMaybes</span> <span class="token operator">=</span> <span class="token keyword">do</span>
    <span class="token hvariable">m</span> <span class="token operator">&lt;-</span> <span class="token constant">Just</span> <span class="token punctuation">(</span><span class="token constant">Just</span> <span class="token number">8</span><span class="token punctuation">)</span>
    <span class="token hvariable">m</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p><img alt="im a cop too as well also" src="http://s3.amazonaws.com/lyah/tipi.png" referrerpolicy="no-referrer"></p></div><div><p>Perhaps the most interesting thing about&nbsp;<code>join</code>&nbsp;is that for every monad, feeding a monadic value to a function with&nbsp;<code>&gt;&gt;=</code>&nbsp;is the same thing as just mapping that function over the value and then using&nbsp;<code>join</code>&nbsp;to flatten the resulting nested monadic value! In other words,&nbsp;<code>m &gt;&gt;= f</code>&nbsp;is always the same thing as&nbsp;<code>join (fmap f m)</code>! It makes sense when you think about it. With&nbsp;<code>&gt;&gt;=</code>, we're always thinking about how to feed a monadic value to a function that takes a normal value but returns a monadic value. If we just map that function over the monadic value, we have a monadic value inside a monadic value. For instance, say we have&nbsp;<code>Just 9</code>&nbsp;and the function&nbsp;<code>\x -&gt; Just (x+1)</code>. If we map this function over&nbsp;<code>Just 9</code>, we're left with&nbsp;<code>Just (Just 10)</code>.</p></div><div><p>The fact that&nbsp;<code>m &gt;&gt;= f</code>&nbsp;always equals&nbsp;<code>join (fmap f m)</code>&nbsp;is very useful if we're making our own&nbsp;<code>Monad</code>&nbsp;instance for some type because it's often easier to figure out how we would flatten a nested monadic value than figuring out how to implement&nbsp;<code>&gt;&gt;=</code>.</p></div><div><h3 data-heading="filterM" id="filterM" style="display: flex;"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>filterM</h3></div><div><p>The&nbsp;<code>filter</code>&nbsp;function is pretty much the bread of Haskell programming (<code>map</code>&nbsp;being the butter). It takes a predicate and a list to filter out and then returns a new list where only the elements that satisfy the predicate are kept. Its type is this:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token builtin">filter</span> <span class="token operator">::</span> <span class="token punctuation">(</span><span class="token hvariable">a</span> <span class="token operator">-&gt;</span> <span class="token constant">Bool</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token punctuation">[</span><span class="token hvariable">a</span><span class="token punctuation">]</span> <span class="token operator">-&gt;</span> <span class="token punctuation">[</span><span class="token hvariable">a</span><span class="token punctuation">]</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>The predicate takes an element of the list and returns a&nbsp;<code>Bool</code>&nbsp;value. Now, what if the&nbsp;<code>Bool</code>&nbsp;value that it returned was actually a monadic value? Whoa! That is, what if it came with a context? Could that work? For instance, what if every&nbsp;<code>True</code>&nbsp;or a&nbsp;<code>False</code>&nbsp;value that the predicate produced also had an accompanying monoid value, like&nbsp;<code>["Accepted the number 5"]</code>&nbsp;or&nbsp;<code>["3 is too small"]</code>? That sounds like it could work. If that were the case, we'd expect the resulting list to also come with a log of all the log values that were produced along the way. So if the&nbsp;<code>Bool</code>&nbsp;that the predicate returned came with a context, we'd expect the final resulting list to have some context attached as well, otherwise the context that each&nbsp;<code>Bool</code>&nbsp;came with would be lost.</p></div><div><p>The&nbsp;<code>filterM</code>&nbsp;function from&nbsp;<code>Control.Monad</code>&nbsp;does just what we want! Its type is this:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">filterM</span> <span class="token operator">::</span> <span class="token punctuation">(</span><span class="token constant">Monad</span> <span class="token hvariable">m</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">(</span><span class="token hvariable">a</span> <span class="token operator">-&gt;</span> <span class="token hvariable">m</span> <span class="token constant">Bool</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token punctuation">[</span><span class="token hvariable">a</span><span class="token punctuation">]</span> <span class="token operator">-&gt;</span> <span class="token hvariable">m</span> <span class="token punctuation">[</span><span class="token hvariable">a</span><span class="token punctuation">]</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>The predicate returns a monadic value whose result is a&nbsp;<code>Bool</code>, but because it's a monadic value, its context can be anything from a possible failure to non-determinism and more! To ensure that the context is reflected in the final result, the result is also a monadic value.</p></div><div><p>Let's take a list and only keep those values that are smaller than 4. To start, we'll just use the regular&nbsp;<code>filter</code>&nbsp;function:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token builtin">filter</span> <span class="token punctuation">(</span><span class="token operator">\</span><span class="token hvariable">x</span> <span class="token operator">-&gt;</span> <span class="token hvariable">x</span> <span class="token operator">&lt;</span> <span class="token number">4</span><span class="token punctuation">)</span> <span class="token punctuation">[</span><span class="token number">9</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">10</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">]</span>
<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">]</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>That's pretty easy. Now, let's make a predicate that, aside from presenting a&nbsp;<code>True</code>&nbsp;or&nbsp;<code>False</code>&nbsp;result, also provides a log of what it did. Of course, we'll be using the&nbsp;<code>Writer</code>&nbsp;monad for this:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">keepSmall</span> <span class="token operator">::</span> <span class="token constant">Int</span> <span class="token operator">-&gt;</span> <span class="token constant">Writer</span> <span class="token punctuation">[</span><span class="token constant">String</span><span class="token punctuation">]</span> <span class="token constant">Bool</span>
<span class="token hvariable">keepSmall</span> <span class="token hvariable">x</span>
    <span class="token operator">|</span> <span class="token hvariable">x</span> <span class="token operator">&lt;</span> <span class="token number">4</span> <span class="token operator">=</span> <span class="token keyword">do</span>
        <span class="token hvariable">tell</span> <span class="token punctuation">[</span><span class="token string">"Keeping "</span> <span class="token operator">++</span> <span class="token builtin">show</span> <span class="token hvariable">x</span><span class="token punctuation">]</span>
        <span class="token builtin">return</span> <span class="token constant">True</span>
    <span class="token operator">|</span> <span class="token builtin">otherwise</span> <span class="token operator">=</span> <span class="token keyword">do</span>
        <span class="token hvariable">tell</span> <span class="token punctuation">[</span><span class="token builtin">show</span> <span class="token hvariable">x</span> <span class="token operator">++</span> <span class="token string">" is too large, throwing it away"</span><span class="token punctuation">]</span>
        <span class="token builtin">return</span> <span class="token constant">False</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Instead of just and returning a&nbsp;<code>Bool</code>, this function returns a&nbsp;<code>Writer [String] Bool</code>. It's a monadic predicate. Sounds fancy, doesn't it? If the number is smaller than&nbsp;<code>4</code>&nbsp;we report that we're keeping it and then&nbsp;<code>return True</code>.</p></div><div><p>Now, let's give it to&nbsp;<code>filterM</code>&nbsp;along with a list. Because the predicate returns a&nbsp;<code>Writer</code>&nbsp;value, the resulting list will also be a&nbsp;<code>Writer</code>&nbsp;value.</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token builtin">fst</span> <span class="token operator">$</span> <span class="token hvariable">runWriter</span> <span class="token operator">$</span> <span class="token hvariable">filterM</span> <span class="token hvariable">keepSmall</span> <span class="token punctuation">[</span><span class="token number">9</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">10</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">]</span>
<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">]</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Examining the result of the resulting&nbsp;<code>Writer</code>&nbsp;value, we see that everything is in order. Now, let's print the log and see what we got:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token builtin">mapM_</span> <span class="token builtin">putStrLn</span> <span class="token operator">$</span> <span class="token builtin">snd</span> <span class="token operator">$</span> <span class="token hvariable">runWriter</span> <span class="token operator">$</span> <span class="token hvariable">filterM</span> <span class="token hvariable">keepSmall</span> <span class="token punctuation">[</span><span class="token number">9</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">10</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">]</span>
<span class="token number">9</span> <span class="token hvariable">is</span> <span class="token hvariable">too</span> <span class="token hvariable">large</span><span class="token punctuation">,</span> <span class="token hvariable">throwing</span> <span class="token hvariable">it</span> <span class="token hvariable">away</span>
<span class="token constant">Keeping</span> <span class="token number">1</span>
<span class="token number">5</span> <span class="token hvariable">is</span> <span class="token hvariable">too</span> <span class="token hvariable">large</span><span class="token punctuation">,</span> <span class="token hvariable">throwing</span> <span class="token hvariable">it</span> <span class="token hvariable">away</span>
<span class="token constant">Keeping</span> <span class="token number">2</span>
<span class="token number">10</span> <span class="token hvariable">is</span> <span class="token hvariable">too</span> <span class="token hvariable">large</span><span class="token punctuation">,</span> <span class="token hvariable">throwing</span> <span class="token hvariable">it</span> <span class="token hvariable">away</span>
<span class="token constant">Keeping</span> <span class="token number">3</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Awesome. So just by providing a monadic predicate to&nbsp;<code>filterM</code>, we were able to filter a list while taking advantage of the monadic context that we used.</p></div><div><p>A very cool Haskell trick is using&nbsp;<code>filterM</code>&nbsp;to get the powerset of a list (if we think of them as sets for now). The powerset of some set is a set of all subsets of that set. So if we have a set like&nbsp;<code>[1,2,3]</code>, its powerset would include the following sets:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">]</span>
<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">]</span>
<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">]</span>
<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span>
<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">]</span>
<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span>
<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span>
<span class="token punctuation">[</span><span class="token punctuation">]</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>In other words, getting a powerset is like getting all the combinations of keeping and throwing out elements from a set.&nbsp;<code>[2,3]</code>&nbsp;is like the original set, only we excluded the number&nbsp;<code>1</code>.</p></div><div><p>To make a function that returns a powerset of some list, we're going to rely on non-determinism. We take the list&nbsp;<code>[1,2,3]</code>&nbsp;and then look at the first element, which is&nbsp;<code>1</code>&nbsp;and we ask ourselves: should we keep it or drop it? Well, we'd like to do both actually. So we are going to filter a list and we'll use a predicate that non-deterministically both keeps and drops every element from the list. Here's our&nbsp;<code>powerset</code>&nbsp;function:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">powerset</span> <span class="token operator">::</span> <span class="token punctuation">[</span><span class="token hvariable">a</span><span class="token punctuation">]</span> <span class="token operator">-&gt;</span> <span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token hvariable">a</span><span class="token punctuation">]</span><span class="token punctuation">]</span>
<span class="token hvariable">powerset</span> <span class="token hvariable">xs</span> <span class="token operator">=</span> <span class="token hvariable">filterM</span> <span class="token punctuation">(</span><span class="token operator">\</span><span class="token hvariable">x</span> <span class="token operator">-&gt;</span> <span class="token punctuation">[</span><span class="token constant">True</span><span class="token punctuation">,</span> <span class="token constant">False</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token hvariable">xs</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Wait, that's it? Yup. We choose to drop and keep every element, regardless of what that element is. We have a non-deterministic predicate, so the resulting list will also be a non-deterministic value and will thus be a list of lists. Let's give this a go:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token hvariable">powerset</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">]</span>
<span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">]</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>This takes a bit of thinking to wrap your head around, but if you just consider lists as non-deterministic values that don't know what to be so they just decide to be everything at once, it's a bit easier.</p></div><div><h3 data-heading="foldM" id="foldM" style="display: flex;"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>foldM</h3></div><div><p>The monadic counterpart to&nbsp;<code>foldl</code>&nbsp;is&nbsp;<code>foldM</code>. If you remember your folds from the&nbsp;<a data-tooltip-position="top" aria-label="http://learnyouahaskell.com/folds" rel="noopener" class="external-link" href="http://learnyouahaskell.com/folds" target="_blank">folds section</a>, you know that&nbsp;<code>foldl</code>&nbsp;takes a binary function, a starting accumulator and a list to fold up and then folds it from the left into a single value by using the binary function.&nbsp;<code>foldM</code>&nbsp;does the same thing, except it takes a binary function that produces a monadic value and folds the list up with that. Unsurprisingly, the resulting value is also monadic. The type of&nbsp;<code>foldl</code>&nbsp;is this:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token builtin">foldl</span> <span class="token operator">::</span> <span class="token punctuation">(</span><span class="token hvariable">a</span> <span class="token operator">-&gt;</span> <span class="token hvariable">b</span> <span class="token operator">-&gt;</span> <span class="token hvariable">a</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token hvariable">a</span> <span class="token operator">-&gt;</span> <span class="token punctuation">[</span><span class="token hvariable">b</span><span class="token punctuation">]</span> <span class="token operator">-&gt;</span> <span class="token hvariable">a</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Whereas&nbsp;<code>foldM</code>&nbsp;has the following type:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">foldM</span> <span class="token operator">::</span> <span class="token punctuation">(</span><span class="token constant">Monad</span> <span class="token hvariable">m</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">(</span><span class="token hvariable">a</span> <span class="token operator">-&gt;</span> <span class="token hvariable">b</span> <span class="token operator">-&gt;</span> <span class="token hvariable">m</span> <span class="token hvariable">a</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token hvariable">a</span> <span class="token operator">-&gt;</span> <span class="token punctuation">[</span><span class="token hvariable">b</span><span class="token punctuation">]</span> <span class="token operator">-&gt;</span> <span class="token hvariable">m</span> <span class="token hvariable">a</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>The value that the binary function returns is monadic and so the result of the whole fold is monadic as well. Let's sum a list of numbers with a fold:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token builtin">foldl</span> <span class="token punctuation">(</span><span class="token operator">\</span><span class="token hvariable">acc</span> <span class="token hvariable">x</span> <span class="token operator">-&gt;</span> <span class="token hvariable">acc</span> <span class="token operator">+</span> <span class="token hvariable">x</span><span class="token punctuation">)</span> <span class="token number">0</span> <span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">8</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">]</span>
<span class="token number">14</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>The starting accumulator is&nbsp;<code>0</code>&nbsp;and then&nbsp;<code>2</code>&nbsp;gets added to the accumulator, resulting in a new accumulator that has a value of&nbsp;<code>2</code>.&nbsp;<code>8</code>&nbsp;gets added to this accumulator resulting in an accumulator of&nbsp;<code>10</code>&nbsp;and so on and when we reach the end, the final accumulator is the result.</p></div><div><p>Now what if we wanted to sum a list of numbers but with the added condition that if any number is greater than&nbsp;<code>9</code>&nbsp;in the list, the whole thing fails? It would make sense to use a binary function that checks if the current number is greater than&nbsp;<code>9</code>&nbsp;and if it is, fails, and if it isn't, continues on its merry way. Because of this added possibility of failure, let's make our binary function return a&nbsp;<code>Maybe</code>&nbsp;accumulator instead of a normal one. Here's the binary function:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">binSmalls</span> <span class="token operator">::</span> <span class="token constant">Int</span> <span class="token operator">-&gt;</span> <span class="token constant">Int</span> <span class="token operator">-&gt;</span> <span class="token constant">Maybe</span> <span class="token constant">Int</span>
<span class="token hvariable">binSmalls</span> <span class="token hvariable">acc</span> <span class="token hvariable">x</span>
    <span class="token operator">|</span> <span class="token hvariable">x</span> <span class="token operator">&gt;</span> <span class="token number">9</span>     <span class="token operator">=</span> <span class="token constant">Nothing</span>
    <span class="token operator">|</span> <span class="token builtin">otherwise</span> <span class="token operator">=</span> <span class="token constant">Just</span> <span class="token punctuation">(</span><span class="token hvariable">acc</span> <span class="token operator">+</span> <span class="token hvariable">x</span><span class="token punctuation">)</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Because our binary function is now a monadic function, we can't use it with the normal&nbsp;<code>foldl</code>, but we have to use&nbsp;<code>foldM</code>. Here goes:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token hvariable">foldM</span> <span class="token hvariable">binSmalls</span> <span class="token number">0</span> <span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">8</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">]</span>
<span class="token constant">Just</span> <span class="token number">14</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token hvariable">foldM</span> <span class="token hvariable">binSmalls</span> <span class="token number">0</span> <span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">11</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">]</span>
<span class="token constant">Nothing</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Excellent! Because one number in the list was greater than&nbsp;<code>9</code>, the whole thing resulted in a&nbsp;<code>Nothing</code>. Folding with a binary function that returns a&nbsp;<code>Writer</code>&nbsp;value is cool as well because then you log whatever you want as your fold goes along its way.</p></div><div><h3 data-heading="Making a safe RPN calculator" id="Making_a_safe_RPN_calculator" style="display: flex;"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>Making a safe RPN calculator</h3></div><div><p><img alt="i've found yellow!" src="http://s3.amazonaws.com/lyah/miner.png" referrerpolicy="no-referrer"></p></div><div><p>When we were solving the problem of&nbsp;<a data-tooltip-position="top" aria-label="http://learnyouahaskell.com/reverse-polish-notation-calculator" rel="noopener" class="external-link" href="http://learnyouahaskell.com/reverse-polish-notation-calculator" target="_blank">implementing a RPN calculator</a>, we noted that it worked fine as long as the input that it got made sense. But if something went wrong, it caused our whole program to crash. Now that we know how to take some code that we have and make it monadic, let's take our RPN calculator and add error handling to it by taking advantage of the&nbsp;<code>Maybe</code>&nbsp;monad.</p></div><div><p>We implemented our RPN calculator by taking a string like&nbsp;<code>"1 3 + 2 *"</code>, breaking it up into words to get something like&nbsp;<code>["1","3","+","2","*"]</code>&nbsp;and then folding over that list by starting out with an empty stack and then using a binary folding function that adds numbers to the stack or manipulates numbers on the top of the stack to add them together and divide them and such.</p></div><div><p>This was the main body of our function:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token import-statement"><span class="token keyword">import</span> Data<span class="token punctuation">.</span>List</span>

<span class="token hvariable">solveRPN</span> <span class="token operator">::</span> <span class="token constant">String</span> <span class="token operator">-&gt;</span> <span class="token constant">Double</span>
<span class="token hvariable">solveRPN</span> <span class="token operator">=</span> <span class="token builtin">head</span> <span class="token operator">.</span> <span class="token builtin">foldl</span> <span class="token hvariable">foldingFunction</span> <span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">.</span> <span class="token builtin">words</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>We made the expression into a list of strings, folded over it with our folding function and then when we were left with just one item in the stack, we returned that item as the answer. This was the folding function:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">foldingFunction</span> <span class="token operator">::</span> <span class="token punctuation">[</span><span class="token constant">Double</span><span class="token punctuation">]</span> <span class="token operator">-&gt;</span> <span class="token constant">String</span> <span class="token operator">-&gt;</span> <span class="token punctuation">[</span><span class="token constant">Double</span><span class="token punctuation">]</span>
<span class="token hvariable">foldingFunction</span> <span class="token punctuation">(</span><span class="token hvariable">x</span><span class="token operator">:</span><span class="token hvariable">y</span><span class="token operator">:</span><span class="token hvariable">ys</span><span class="token punctuation">)</span> <span class="token string">"*"</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token hvariable">x</span> <span class="token operator">*</span> <span class="token hvariable">y</span><span class="token punctuation">)</span><span class="token operator">:</span><span class="token hvariable">ys</span>
<span class="token hvariable">foldingFunction</span> <span class="token punctuation">(</span><span class="token hvariable">x</span><span class="token operator">:</span><span class="token hvariable">y</span><span class="token operator">:</span><span class="token hvariable">ys</span><span class="token punctuation">)</span> <span class="token string">"+"</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token hvariable">x</span> <span class="token operator">+</span> <span class="token hvariable">y</span><span class="token punctuation">)</span><span class="token operator">:</span><span class="token hvariable">ys</span>
<span class="token hvariable">foldingFunction</span> <span class="token punctuation">(</span><span class="token hvariable">x</span><span class="token operator">:</span><span class="token hvariable">y</span><span class="token operator">:</span><span class="token hvariable">ys</span><span class="token punctuation">)</span> <span class="token string">"-"</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token hvariable">y</span> <span class="token operator">-</span> <span class="token hvariable">x</span><span class="token punctuation">)</span><span class="token operator">:</span><span class="token hvariable">ys</span>
<span class="token hvariable">foldingFunction</span> <span class="token hvariable">xs</span> <span class="token hvariable">numberString</span> <span class="token operator">=</span> <span class="token builtin">read</span> <span class="token hvariable">numberString</span><span class="token operator">:</span><span class="token hvariable">xs</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>The accumulator of the fold was a stack, which we represented with a list of&nbsp;<code>Double</code>&nbsp;values. As the folding function went over the RPN expression, if the current item was an operator, it took two items off the top of the stack, applied the operator between them and then put the result back on the stack. If the current item was a string that represented a number, it converted that string into an actual number and returned a new stack that was like the old one, except with that number pushed to the top.</p></div><div><p>Let's first make our folding function capable of graceful failure. Its type is going to change from what it is now to this:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">foldingFunction</span> <span class="token operator">::</span> <span class="token punctuation">[</span><span class="token constant">Double</span><span class="token punctuation">]</span> <span class="token operator">-&gt;</span> <span class="token constant">String</span> <span class="token operator">-&gt;</span> <span class="token constant">Maybe</span> <span class="token punctuation">[</span><span class="token constant">Double</span><span class="token punctuation">]</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>So it will either return&nbsp;<code>Just</code>&nbsp;a new stack or it will fail with&nbsp;<code>Nothing</code>.</p></div><div><p>The&nbsp;<code>reads</code>&nbsp;function is like&nbsp;<code>read</code>, only it returns a list with a single element in case of a successful read. If it fails to read something, then it returns an empty list. Apart from returning the value that it read, it also returns the part of the string that it didn't consume. We're going to say that it always has to consume the full input to work and make it into a&nbsp;<code>readMaybe</code>&nbsp;function for convenience. Here it is:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">readMaybe</span> <span class="token operator">::</span> <span class="token punctuation">(</span><span class="token constant">Read</span> <span class="token hvariable">a</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token constant">String</span> <span class="token operator">-&gt;</span> <span class="token constant">Maybe</span> <span class="token hvariable">a</span>
<span class="token hvariable">readMaybe</span> <span class="token hvariable">st</span> <span class="token operator">=</span> <span class="token keyword">case</span> <span class="token builtin">reads</span> <span class="token hvariable">st</span> <span class="token keyword">of</span> <span class="token punctuation">[</span><span class="token punctuation">(</span><span class="token hvariable">x</span><span class="token punctuation">,</span><span class="token string">""</span><span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token operator">-&gt;</span> <span class="token constant">Just</span> <span class="token hvariable">x</span>
                                <span class="token hvariable">_</span> <span class="token operator">-&gt;</span> <span class="token constant">Nothing</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Testing it out:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token hvariable">readMaybe</span> <span class="token string">"1"</span> <span class="token operator">::</span> <span class="token constant">Maybe</span> <span class="token constant">Int</span>
<span class="token constant">Just</span> <span class="token number">1</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token hvariable">readMaybe</span> <span class="token string">"GO TO HELL"</span> <span class="token operator">::</span> <span class="token constant">Maybe</span> <span class="token constant">Int</span>
<span class="token constant">Nothing</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Okay, it seems to work. So, let's make our folding function into a monadic function that can fail:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">foldingFunction</span> <span class="token operator">::</span> <span class="token punctuation">[</span><span class="token constant">Double</span><span class="token punctuation">]</span> <span class="token operator">-&gt;</span> <span class="token constant">String</span> <span class="token operator">-&gt;</span> <span class="token constant">Maybe</span> <span class="token punctuation">[</span><span class="token constant">Double</span><span class="token punctuation">]</span>
<span class="token hvariable">foldingFunction</span> <span class="token punctuation">(</span><span class="token hvariable">x</span><span class="token operator">:</span><span class="token hvariable">y</span><span class="token operator">:</span><span class="token hvariable">ys</span><span class="token punctuation">)</span> <span class="token string">"*"</span> <span class="token operator">=</span> <span class="token builtin">return</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token hvariable">x</span> <span class="token operator">*</span> <span class="token hvariable">y</span><span class="token punctuation">)</span><span class="token operator">:</span><span class="token hvariable">ys</span><span class="token punctuation">)</span>
<span class="token hvariable">foldingFunction</span> <span class="token punctuation">(</span><span class="token hvariable">x</span><span class="token operator">:</span><span class="token hvariable">y</span><span class="token operator">:</span><span class="token hvariable">ys</span><span class="token punctuation">)</span> <span class="token string">"+"</span> <span class="token operator">=</span> <span class="token builtin">return</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token hvariable">x</span> <span class="token operator">+</span> <span class="token hvariable">y</span><span class="token punctuation">)</span><span class="token operator">:</span><span class="token hvariable">ys</span><span class="token punctuation">)</span>
<span class="token hvariable">foldingFunction</span> <span class="token punctuation">(</span><span class="token hvariable">x</span><span class="token operator">:</span><span class="token hvariable">y</span><span class="token operator">:</span><span class="token hvariable">ys</span><span class="token punctuation">)</span> <span class="token string">"-"</span> <span class="token operator">=</span> <span class="token builtin">return</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token hvariable">y</span> <span class="token operator">-</span> <span class="token hvariable">x</span><span class="token punctuation">)</span><span class="token operator">:</span><span class="token hvariable">ys</span><span class="token punctuation">)</span>
<span class="token hvariable">foldingFunction</span> <span class="token hvariable">xs</span> <span class="token hvariable">numberString</span> <span class="token operator">=</span> <span class="token hvariable">liftM</span> <span class="token punctuation">(</span><span class="token operator">:</span><span class="token hvariable">xs</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token hvariable">readMaybe</span> <span class="token hvariable">numberString</span><span class="token punctuation">)</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>The first three cases are like the old ones, except the new stack gets wrapped in a&nbsp;<code>Just</code>&nbsp;(we used&nbsp;<code>return</code>&nbsp;here to do this, but we could have written&nbsp;<code>Just</code>&nbsp;just as well). In the last case, we do&nbsp;<code>readMaybe numberString</code>&nbsp;and then we map&nbsp;<code>(:xs)</code>&nbsp;over it. So if the stack&nbsp;<code>xs</code>&nbsp;is&nbsp;<code>[1.0,2.0]</code>&nbsp;and&nbsp;<code>readMaybe numberString</code>&nbsp;results in a&nbsp;<code>Just 3.0</code>, the result is&nbsp;<code>Just [3.0,1.0,2.0]</code>. If&nbsp;<code>readMaybe numberString</code>&nbsp;results in a&nbsp;<code>Nothing</code>&nbsp;then the result is&nbsp;<code>Nothing</code>. Let's try out the folding function by itself:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token hvariable">foldingFunction</span> <span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">]</span> <span class="token string">"*"</span>
<span class="token constant">Just</span> <span class="token punctuation">[</span><span class="token number">6.0</span><span class="token punctuation">]</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token hvariable">foldingFunction</span> <span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">]</span> <span class="token string">"-"</span>
<span class="token constant">Just</span> <span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">1.0</span><span class="token punctuation">]</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token hvariable">foldingFunction</span> <span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token string">"*"</span>
<span class="token constant">Nothing</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token hvariable">foldingFunction</span> <span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token string">"1"</span>
<span class="token constant">Just</span> <span class="token punctuation">[</span><span class="token number">1.0</span><span class="token punctuation">]</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token hvariable">foldingFunction</span> <span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token string">"1 wawawawa"</span>
<span class="token constant">Nothing</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>It looks like it's working! And now it's time for the new and improved&nbsp;<code>solveRPN</code>. Here it is ladies and gents!</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token import-statement"><span class="token keyword">import</span> Data<span class="token punctuation">.</span>List</span>

<span class="token hvariable">solveRPN</span> <span class="token operator">::</span> <span class="token constant">String</span> <span class="token operator">-&gt;</span> <span class="token constant">Maybe</span> <span class="token constant">Double</span>
<span class="token hvariable">solveRPN</span> <span class="token hvariable">st</span> <span class="token operator">=</span> <span class="token keyword">do</span>
    <span class="token punctuation">[</span><span class="token hvariable">result</span><span class="token punctuation">]</span> <span class="token operator">&lt;-</span> <span class="token hvariable">foldM</span> <span class="token hvariable">foldingFunction</span> <span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token punctuation">(</span><span class="token builtin">words</span> <span class="token hvariable">st</span><span class="token punctuation">)</span>
    <span class="token builtin">return</span> <span class="token hvariable">result</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Just like before, we take the string and make it into a list of words. Then, we do a fold, starting with the empty stack, only instead of doing a normal&nbsp;<code>foldl</code>, we do a&nbsp;<code>foldM</code>. The result of that&nbsp;<code>foldM</code>&nbsp;should be a&nbsp;<code>Maybe</code>&nbsp;value that contains a list (that's our final stack) and that list should have only one value. We use a&nbsp;<code>do</code>&nbsp;expression to get that value and we call it&nbsp;<code>result</code>. In case the&nbsp;<code>foldM</code>&nbsp;returns a&nbsp;<code>Nothing</code>, the whole thing will be a&nbsp;<code>Nothing</code>, because that's how&nbsp;<code>Maybe</code>&nbsp;works. Also notice that we pattern match in the&nbsp;<code>do</code>&nbsp;expression, so if the list has more than one value or none at all, the pattern match fails and a&nbsp;<code>Nothing</code>&nbsp;is produced. In the last line we just do&nbsp;<code>return result</code>&nbsp;to present the result of the RPN calculation as the result of the final&nbsp;<code>Maybe</code>&nbsp;value.</p></div><div><p>Let's give it a shot:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token hvariable">solveRPN</span> <span class="token string">"1 2 * 4 +"</span>
<span class="token constant">Just</span> <span class="token number">6.0</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token hvariable">solveRPN</span> <span class="token string">"1 2 * 4 + 5 *"</span>
<span class="token constant">Just</span> <span class="token number">30.0</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token hvariable">solveRPN</span> <span class="token string">"1 2 * 4"</span>
<span class="token constant">Nothing</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token hvariable">solveRPN</span> <span class="token string">"1 8 wharglbllargh"</span>
<span class="token constant">Nothing</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>The first failure happens because the final stack isn't a list with one element in it and so the pattern matching in the&nbsp;<code>do</code>&nbsp;expression fails. The second failure happens because&nbsp;<code>readMaybe</code>&nbsp;returns a&nbsp;<code>Nothing</code>.</p></div><div><h3 data-heading="Composing monadic functions" id="Composing_monadic_functions" style="display: flex;"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>Composing monadic functions</h3></div><div><p>When we were learning about the monad laws, we said that the&nbsp;<code>&lt;=&lt;</code>&nbsp;function is just like composition, only instead of working for normal functions like&nbsp;<code>a -&gt; b</code>, it works for monadic functions like&nbsp;<code>a -&gt; m b</code>. For instance:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token keyword">let</span> <span class="token hvariable">f</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">.</span> <span class="token punctuation">(</span><span class="token operator">*</span><span class="token number">100</span><span class="token punctuation">)</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token hvariable">f</span> <span class="token number">4</span>
<span class="token number">401</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token keyword">let</span> <span class="token hvariable">g</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token operator">\</span><span class="token hvariable">x</span> <span class="token operator">-&gt;</span> <span class="token builtin">return</span> <span class="token punctuation">(</span><span class="token hvariable">x</span><span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&lt;=&lt;</span> <span class="token punctuation">(</span><span class="token operator">\</span><span class="token hvariable">x</span> <span class="token operator">-&gt;</span> <span class="token builtin">return</span> <span class="token punctuation">(</span><span class="token hvariable">x</span><span class="token operator">*</span><span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token constant">Just</span> <span class="token number">4</span> <span class="token operator">&gt;&gt;=</span> <span class="token hvariable">g</span>
<span class="token constant">Just</span> <span class="token number">401</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>In this example we first composed two normal functions, applied the resulting function to&nbsp;<code>4</code>&nbsp;and then we composed two monadic functions and fed&nbsp;<code>Just 4</code>&nbsp;to the resulting function with&nbsp;<code>&gt;&gt;=</code>.</p></div><div><p>If we have a bunch of functions in a list, we can compose them one all into one big function by just using&nbsp;<code>id</code>&nbsp;as the starting accumulator and the&nbsp;<code>.</code>&nbsp;function as the binary function. Here's an example:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token keyword">let</span> <span class="token hvariable">f</span> <span class="token operator">=</span> <span class="token builtin">foldr</span> <span class="token punctuation">(</span><span class="token punctuation">.</span><span class="token punctuation">)</span> <span class="token builtin">id</span> <span class="token punctuation">[</span><span class="token punctuation">(</span><span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token operator">*</span><span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">]</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token hvariable">f</span> <span class="token number">1</span>
<span class="token number">201</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>The function&nbsp;<code>f</code>&nbsp;takes a number and then adds&nbsp;<code>1</code>&nbsp;to it, multiplies the result by&nbsp;<code>100</code>&nbsp;and then adds&nbsp;<code>1</code>&nbsp;to that. Anyway, we can compose monadic functions in the same way, only instead normal composition we use&nbsp;<code>&lt;=&lt;</code>&nbsp;and instead of&nbsp;<code>id</code>&nbsp;we use&nbsp;<code>return</code>. We don't have to use a&nbsp;<code>foldM</code>&nbsp;over a&nbsp;<code>foldr</code>&nbsp;or anything because the&nbsp;<code>&lt;=&lt;</code>&nbsp;function makes sure that composition happens in a monadic fashion.</p></div><div><p>When we were getting to know the list monad in the&nbsp;<a data-tooltip-position="top" aria-label="http://learnyouahaskell.com/a-fistful-of-monads#the-list-monad" rel="noopener" class="external-link" href="http://learnyouahaskell.com/a-fistful-of-monads#the-list-monad" target="_blank">previous chapter</a>, we used it to figure out if a knight can go from one position on a chessboard to another in exactly three moves. We had a function called&nbsp;<code>moveKnight</code>&nbsp;which took the knight's position on the board and returned all the possible moves that he can make next. Then, to generate all the possible positions that he can have after taking three moves, we made the following function:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">in3</span> <span class="token hvariable">start</span> <span class="token operator">=</span> <span class="token builtin">return</span> <span class="token hvariable">start</span> <span class="token operator">&gt;&gt;=</span> <span class="token hvariable">moveKnight</span> <span class="token operator">&gt;&gt;=</span> <span class="token hvariable">moveKnight</span> <span class="token operator">&gt;&gt;=</span> <span class="token hvariable">moveKnight</span> 
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>And to check if he can go from&nbsp;<code>start</code>&nbsp;to&nbsp;<code>end</code>&nbsp;in three moves, we did the following:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">canReachIn3</span> <span class="token operator">::</span> <span class="token constant">KnightPos</span> <span class="token operator">-&gt;</span> <span class="token constant">KnightPos</span> <span class="token operator">-&gt;</span> <span class="token constant">Bool</span>
<span class="token hvariable">canReachIn3</span> <span class="token hvariable">start</span> <span class="token hvariable">end</span> <span class="token operator">=</span> <span class="token hvariable">end</span> <span class="token operator">`elem`</span> <span class="token hvariable">in3</span> <span class="token hvariable">start</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Using monadic function composition, we can make a function like&nbsp;<code>in3</code>, only instead of generating all the positions that the knight can have after making three moves, we can do it for an arbitrary number of moves. If you look at&nbsp;<code>in3</code>, we see that we used&nbsp;<code>moveKnight</code>&nbsp;three times and each time we used&nbsp;<code>&gt;&gt;=</code>&nbsp;to feed it all the possible previous positions. So now, let's make it more general. Here's how to do it:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token import-statement"><span class="token keyword">import</span> Data<span class="token punctuation">.</span>List</span>

<span class="token hvariable">inMany</span> <span class="token operator">::</span> <span class="token constant">Int</span> <span class="token operator">-&gt;</span> <span class="token constant">KnightPos</span> <span class="token operator">-&gt;</span> <span class="token punctuation">[</span><span class="token constant">KnightPos</span><span class="token punctuation">]</span>
<span class="token hvariable">inMany</span> <span class="token hvariable">x</span> <span class="token hvariable">start</span> <span class="token operator">=</span> <span class="token builtin">return</span> <span class="token hvariable">start</span> <span class="token operator">&gt;&gt;=</span> <span class="token builtin">foldr</span> <span class="token punctuation">(</span><span class="token operator">&lt;=&lt;</span><span class="token punctuation">)</span> <span class="token builtin">return</span> <span class="token punctuation">(</span><span class="token builtin">replicate</span> <span class="token hvariable">x</span> <span class="token hvariable">moveKnight</span><span class="token punctuation">)</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>First we use&nbsp;<code>replicate</code>&nbsp;to make a list that contains&nbsp;<code>x</code>&nbsp;copies of the function&nbsp;<code>moveKnight</code>. Then, we monadically compose all those functions into one, which gives us a function that takes a starting position and non-deterministically moves the knight&nbsp;<code>x</code>&nbsp;times. Then, we just make the starting position into a singleton list with&nbsp;<code>return</code>&nbsp;and feed it to the function.</p></div><div><p>Now, we can change our&nbsp;<code>canReachIn3</code>&nbsp;function to be more general as well:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">canReachIn</span> <span class="token operator">::</span> <span class="token constant">Int</span> <span class="token operator">-&gt;</span> <span class="token constant">KnightPos</span> <span class="token operator">-&gt;</span> <span class="token constant">KnightPos</span> <span class="token operator">-&gt;</span> <span class="token constant">Bool</span>
<span class="token hvariable">canReachIn</span> <span class="token hvariable">x</span> <span class="token hvariable">start</span> <span class="token hvariable">end</span> <span class="token operator">=</span> <span class="token hvariable">end</span> <span class="token operator">`elem`</span> <span class="token hvariable">inMany</span> <span class="token hvariable">x</span> <span class="token hvariable">start</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><h2 data-heading="Making monads" id="Making_monads" style="display: flex;"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>Making monads</h2></div><div><p><img alt="kewl" src="http://s3.amazonaws.com/lyah/spearhead.png" referrerpolicy="no-referrer"></p></div><div><p>In this section, we're going to look at an example of how a type gets made, identified as a monad and then given the appropriate&nbsp;<code>Monad</code>&nbsp;instance. We don't usually set out to make a monad with the sole purpose of making a monad. Instead, we usually make a type that whose purpose is to model an aspect of some problem and then later on if we see that the type represents a value with a context and can act like a monad, we give it a&nbsp;<code>Monad</code>&nbsp;instance.</p></div><div><p>As we've seen, lists are used to represent non-deterministic values. A list like&nbsp;<code>[3,5,9]</code>&nbsp;can be viewed as a single non-deterministic value that just can't decide what it's going to be. When we feed a list into a function with&nbsp;<code>&gt;&gt;=</code>, it just makes all the possible choices of taking an element from the list and applying the function to it and then presents those results in a list as well.</p></div><div><p>If we look at the list&nbsp;<code>[3,5,9]</code>&nbsp;as the numbers&nbsp;<code>3</code>,&nbsp;<code>5</code>&nbsp;and&nbsp;<code>9</code>&nbsp;occurring at once, we might notice that there's no info regarding the probability that each of those numbers occurs. What if we wanted to model a non-deterministic value like&nbsp;<code>[3,5,9]</code>, but we wanted to express that&nbsp;<code>3</code>&nbsp;has a 50% chance of happening and&nbsp;<code>5</code>&nbsp;and&nbsp;<code>9</code>&nbsp;both have a 25% chance of happening? Let's try and make this happen!</p></div><div><p>Let's say that every item in the list comes with another value, a probability of it happening. It might make sense to present this like this then:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token punctuation">[</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">0.5</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">0.25</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token number">9</span><span class="token punctuation">,</span><span class="token number">0.25</span><span class="token punctuation">)</span><span class="token punctuation">]</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>In mathematics, probabilities aren't usually expressed in percentages, but rather in real numbers between a 0 and 1. A 0 means that there's no chance in hell for something to happen and a 1 means that it's happening for sure. Floating point numbers can get real messy real fast because they tend to lose precision, so Haskell offers us a data type for rational numbers that doesn't lose precision. That type is called&nbsp;<code>Rational</code>&nbsp;and it lives in&nbsp;<code>Data.Ratio</code>. To make a&nbsp;<code>Rational</code>, we write it as if it were a fraction. The numerator and the denominator are separated by a&nbsp;<code>%</code>. Here are a few examples:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token number">1</span><span class="token operator">%</span><span class="token number">4</span>
<span class="token number">1</span> <span class="token operator">%</span> <span class="token number">4</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token number">1</span><span class="token operator">%</span><span class="token number">2</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token operator">%</span><span class="token number">2</span>
<span class="token number">1</span> <span class="token operator">%</span> <span class="token number">1</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token number">1</span><span class="token operator">%</span><span class="token number">3</span> <span class="token operator">+</span> <span class="token number">5</span><span class="token operator">%</span><span class="token number">4</span>
<span class="token number">19</span> <span class="token operator">%</span> <span class="token number">12</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>The first line is just one quarter. In the second line we add two halves to get a whole and in the third line we add one third with five quarters and get nineteen twelfths. So let'use throw out our floating points and use&nbsp;<code>Rational</code>&nbsp;for our probabilities:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token punctuation">[</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token operator">%</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token operator">%</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token number">9</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token operator">%</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">]</span>
<span class="token punctuation">[</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">1</span> <span class="token operator">%</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">1</span> <span class="token operator">%</span> <span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token number">9</span><span class="token punctuation">,</span><span class="token number">1</span> <span class="token operator">%</span> <span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">]</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Okay, so&nbsp;<code>3</code>&nbsp;has a one out of two chance of happening while&nbsp;<code>5</code>&nbsp;and&nbsp;<code>9</code>&nbsp;will happen one time out of four. Pretty neat.</p></div><div><p>We took lists and we added some extra context to them, so this represents values withs contexts too. Before we go any further, let's wrap this into a&nbsp;<code>newtype</code>&nbsp;because something tells me we'll be making some instances.</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token import-statement"><span class="token keyword">import</span> Data<span class="token punctuation">.</span>Ratio</span>

<span class="token keyword">newtype</span> <span class="token constant">Prob</span> <span class="token hvariable">a</span> <span class="token operator">=</span> <span class="token constant">Prob</span> <span class="token punctuation">{</span> <span class="token hvariable">getProb</span> <span class="token operator">::</span> <span class="token punctuation">[</span><span class="token punctuation">(</span><span class="token hvariable">a</span><span class="token punctuation">,</span><span class="token constant">Rational</span><span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token punctuation">}</span> <span class="token keyword">deriving</span> <span class="token constant">Show</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Alright. Is this a functor? Well, the list is a functor, so this should probably be a functor as well, because we just added some stuff to the list. When we map a function over a list, we apply it to each element. Here, we'll apply it to each element as well, only we'll leave the probabilities as they are. Let's make an instance:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token keyword">instance</span> <span class="token constant">Functor</span> <span class="token constant">Prob</span> <span class="token keyword">where</span>
    <span class="token builtin">fmap</span> <span class="token hvariable">f</span> <span class="token punctuation">(</span><span class="token constant">Prob</span> <span class="token hvariable">xs</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token constant">Prob</span> <span class="token operator">$</span> <span class="token builtin">map</span> <span class="token punctuation">(</span><span class="token operator">\</span><span class="token punctuation">(</span><span class="token hvariable">x</span><span class="token punctuation">,</span><span class="token hvariable">p</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token punctuation">(</span><span class="token hvariable">f</span> <span class="token hvariable">x</span><span class="token punctuation">,</span><span class="token hvariable">p</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token hvariable">xs</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>We unwrap it from the&nbsp;<code>newtype</code>&nbsp;with pattern matching, apply the function&nbsp;<code>f</code>&nbsp;to the values while keeping the probabilities as they are and then wrap it back up. Let's see if it works:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token builtin">fmap</span> <span class="token builtin">negate</span> <span class="token punctuation">(</span><span class="token constant">Prob</span> <span class="token punctuation">[</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token operator">%</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token operator">%</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token number">9</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token operator">%</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
<span class="token constant">Prob</span> <span class="token punctuation">{</span><span class="token hvariable">getProb</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">1</span> <span class="token operator">%</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">1</span> <span class="token operator">%</span> <span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">9</span><span class="token punctuation">,</span><span class="token number">1</span> <span class="token operator">%</span> <span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">}</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Another thing to note is that the probabilities should always add up to&nbsp;<code>1</code>. If those are all the things that can happen, it doesn't make sense for the sum of their probabilities to be anything other than&nbsp;<code>1</code>. A coin that lands tails 75% of the time and heads 50% of the time seems like it could only work in some other strange universe.</p></div><div><p>Now the big question, is this a monad? Given how the list is a monad, this looks like it should be a monad as well. First, let's think about&nbsp;<code>return</code>. How does it work for lists? It takes a value and puts it in a singleton list. What about here? Well, since it's supposed to be a default minimal context, it should also make a singleton list. What about the probability? Well,&nbsp;<code>return x</code>&nbsp;is supposed to make a monadic value that always presents&nbsp;<code>x</code>&nbsp;as its result, so it doesn't make sense for the probability to be&nbsp;<code>0</code>. If it always has to present it as its result, the probability should be&nbsp;<code>1</code>!</p></div><div><p>What about&nbsp;<code>&gt;&gt;=</code>? Seems kind of tricky, so let's make use of the fact that&nbsp;<code>m &gt;&gt;= f</code>&nbsp;always equals&nbsp;<code>join (fmap f m)</code>&nbsp;for monads and think about how we would flatten a probability list of probability lists. As an example, let's consider this list where there's a 25% chance that exactly one of&nbsp;<code>'a'</code>&nbsp;or&nbsp;<code>'b'</code>&nbsp;will happen. Both&nbsp;<code>'a'</code>&nbsp;and&nbsp;<code>'b'</code>&nbsp;are equally likely to occur. Also, there's a 75% chance that exactly one of&nbsp;<code>'c'</code>&nbsp;or&nbsp;<code>'d'</code>&nbsp;will happen.&nbsp;<code>'c'</code>&nbsp;and&nbsp;<code>'d'</code>&nbsp;are also equally likely to happen. Here's a picture of a probability list that models this scenario:</p></div><div><p><img alt="probs" src="http://s3.amazonaws.com/lyah/prob.png" referrerpolicy="no-referrer"></p></div><div><p>What are the chances for each of these letters to occur? If we were to draw this as just four boxes, each with a probability, what would those probabilities be? To find out, all we have to do is multiply each probability with all of probabilities that it contains.&nbsp;<code>'a'</code>&nbsp;would occur one time out of eight, as would&nbsp;<code>'b'</code>, because if we multiply one half by one quarter we get one eighth.&nbsp;<code>'c'</code>&nbsp;would happen three times out of eight because three quarters multiplied by one half is three eighths.&nbsp;<code>'d'</code>&nbsp;would also happen three times out of eight. If we sum all the probabilities, they still add up to one.</p></div><div><p>Here's this situation expressed as a probability list:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">thisSituation</span> <span class="token operator">::</span> <span class="token constant">Prob</span> <span class="token punctuation">(</span><span class="token constant">Prob</span> <span class="token constant">Char</span><span class="token punctuation">)</span>
<span class="token hvariable">thisSituation</span> <span class="token operator">=</span> <span class="token constant">Prob</span>
    <span class="token punctuation">[</span><span class="token punctuation">(</span> <span class="token constant">Prob</span> <span class="token punctuation">[</span><span class="token punctuation">(</span><span class="token char string">'a'</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token operator">%</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token char string">'b'</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token operator">%</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token punctuation">,</span> <span class="token number">1</span><span class="token operator">%</span><span class="token number">4</span> <span class="token punctuation">)</span>
    <span class="token punctuation">,</span><span class="token punctuation">(</span> <span class="token constant">Prob</span> <span class="token punctuation">[</span><span class="token punctuation">(</span><span class="token char string">'c'</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token operator">%</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token char string">'d'</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token operator">%</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token punctuation">,</span> <span class="token number">3</span><span class="token operator">%</span><span class="token number">4</span><span class="token punctuation">)</span>
    <span class="token punctuation">]</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Notice that its type is&nbsp;<code>Prob (Prob Char)</code>. So now that we've figure out how to flatten a nested probability list, all we have to do is write the code for this and then we can write&nbsp;<code>&gt;&gt;=</code>&nbsp;simply as&nbsp;<code>join (fmap f m)</code>&nbsp;and we have ourselves a monad! So here's&nbsp;<code>flatten</code>, which we'll use because the name&nbsp;<code>join</code>&nbsp;is already taken:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">flatten</span> <span class="token operator">::</span> <span class="token constant">Prob</span> <span class="token punctuation">(</span><span class="token constant">Prob</span> <span class="token hvariable">a</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token constant">Prob</span> <span class="token hvariable">a</span>
<span class="token hvariable">flatten</span> <span class="token punctuation">(</span><span class="token constant">Prob</span> <span class="token hvariable">xs</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token constant">Prob</span> <span class="token operator">$</span> <span class="token builtin">concat</span> <span class="token operator">$</span> <span class="token builtin">map</span> <span class="token hvariable">multAll</span> <span class="token hvariable">xs</span>
    <span class="token keyword">where</span> <span class="token hvariable">multAll</span> <span class="token punctuation">(</span><span class="token constant">Prob</span> <span class="token hvariable">innerxs</span><span class="token punctuation">,</span><span class="token hvariable">p</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token builtin">map</span> <span class="token punctuation">(</span><span class="token operator">\</span><span class="token punctuation">(</span><span class="token hvariable">x</span><span class="token punctuation">,</span><span class="token hvariable">r</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token punctuation">(</span><span class="token hvariable">x</span><span class="token punctuation">,</span><span class="token hvariable">p</span><span class="token operator">*</span><span class="token hvariable">r</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token hvariable">innerxs</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>The function&nbsp;<code>multAll</code>&nbsp;takes a tuple of probability list and a probability&nbsp;<code>p</code>&nbsp;that comes with it and then multiplies every inner probability with&nbsp;<code>p</code>, returning a list of pairs of items and probabilities. We map&nbsp;<code>multAll</code>&nbsp;over each pair in our nested probability list and then we just flatten the resulting nested list.</p></div><div><p>Now we have all that we need, we can write a&nbsp;<code>Monad</code>&nbsp;instance!</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token keyword">instance</span> <span class="token constant">Monad</span> <span class="token constant">Prob</span> <span class="token keyword">where</span>
    <span class="token builtin">return</span> <span class="token hvariable">x</span> <span class="token operator">=</span> <span class="token constant">Prob</span> <span class="token punctuation">[</span><span class="token punctuation">(</span><span class="token hvariable">x</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token operator">%</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">]</span>
    <span class="token hvariable">m</span> <span class="token operator">&gt;&gt;=</span> <span class="token hvariable">f</span> <span class="token operator">=</span> <span class="token hvariable">flatten</span> <span class="token punctuation">(</span><span class="token builtin">fmap</span> <span class="token hvariable">f</span> <span class="token hvariable">m</span><span class="token punctuation">)</span>
    <span class="token builtin">fail</span> <span class="token hvariable">_</span> <span class="token operator">=</span> <span class="token constant">Prob</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p><img alt="ride em cowboy" src="http://s3.amazonaws.com/lyah/ride.png" referrerpolicy="no-referrer"></p></div><div><p>Because we already did all the hard work, the instance is very simple. We also defined the&nbsp;<code>fail</code>&nbsp;function, which is the same as it is for lists, so if there's a pattern match failure in a&nbsp;<code>do</code>&nbsp;expression, a failure occurs within the context of a probability list.</p></div><div><p>It's also important to check if the monad laws hold for the monad that we just made. The first one says that&nbsp;<code>return x &gt;&gt;= f</code>&nbsp;should be equal to&nbsp;<code>f x</code>. A rigorous proof would be rather tedious, but we can see that if we put a value in a default context with&nbsp;<code>return</code>&nbsp;and then&nbsp;<code>fmap</code>&nbsp;a function over that and flatten the resulting probability list, every probability that results from the function would be multiplied by the&nbsp;<code>1%1</code>&nbsp;probability that we made with&nbsp;<code>return</code>, so it wouldn't affect the context. The reasoning for&nbsp;<code>m &gt;&gt;= return</code>&nbsp;being equal to just&nbsp;<code>m</code>&nbsp;is similar. The third law states that&nbsp;<code>f &lt;=&lt; (g &lt;=&lt; h)</code>&nbsp;should be the same as&nbsp;<code>(f &lt;=&lt; g) &lt;=&lt; h</code>. This one holds as well, because it holds for the list monad which forms the basis of the probability monad and because multiplication is associative.&nbsp;<code>1%2 * (1%3 * 1%5)</code>&nbsp;is equal to&nbsp;<code>(1%2 * 1%3) * 1%5</code>.</p></div><div><p>Now that we have a monad, what can we do with it? Well, it can help us do calculations with probabilities. We can treat probabilistic events as values with contexts and the probability monad will make sure that those probabilities get reflected in the probabilities of the final result.</p></div><div><p>Say we have two normal coins and one loaded coin that gets tails an astounding nine times out of ten and heads only one time out of ten. If we throw all the coins at once, what are the odds of all of them landing tails? First, let's make probability values for a normal coin flip and for a loaded one:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token keyword">data</span> <span class="token constant">Coin</span> <span class="token operator">=</span> <span class="token constant">Heads</span> <span class="token operator">|</span> <span class="token constant">Tails</span> <span class="token keyword">deriving</span> <span class="token punctuation">(</span><span class="token constant">Show</span><span class="token punctuation">,</span> <span class="token constant">Eq</span><span class="token punctuation">)</span>

<span class="token hvariable">coin</span> <span class="token operator">::</span> <span class="token constant">Prob</span> <span class="token constant">Coin</span>
<span class="token hvariable">coin</span> <span class="token operator">=</span> <span class="token constant">Prob</span> <span class="token punctuation">[</span><span class="token punctuation">(</span><span class="token constant">Heads</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token operator">%</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token constant">Tails</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token operator">%</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">]</span>

<span class="token hvariable">loadedCoin</span> <span class="token operator">::</span> <span class="token constant">Prob</span> <span class="token constant">Coin</span>
<span class="token hvariable">loadedCoin</span> <span class="token operator">=</span> <span class="token constant">Prob</span> <span class="token punctuation">[</span><span class="token punctuation">(</span><span class="token constant">Heads</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token operator">%</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token constant">Tails</span><span class="token punctuation">,</span><span class="token number">9</span><span class="token operator">%</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">]</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>And finally, the coin throwing action:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token import-statement"><span class="token keyword">import</span> Data<span class="token punctuation">.</span>List</span> <span class="token punctuation">(</span><span class="token builtin">all</span><span class="token punctuation">)</span>

<span class="token hvariable">flipThree</span> <span class="token operator">::</span> <span class="token constant">Prob</span> <span class="token constant">Bool</span>
<span class="token hvariable">flipThree</span> <span class="token operator">=</span> <span class="token keyword">do</span>
    <span class="token hvariable">a</span> <span class="token operator">&lt;-</span> <span class="token hvariable">coin</span>
    <span class="token hvariable">b</span> <span class="token operator">&lt;-</span> <span class="token hvariable">coin</span>
    <span class="token hvariable">c</span> <span class="token operator">&lt;-</span> <span class="token hvariable">loadedCoin</span>
    <span class="token builtin">return</span> <span class="token punctuation">(</span><span class="token builtin">all</span> <span class="token punctuation">(</span><span class="token operator">==</span><span class="token constant">Tails</span><span class="token punctuation">)</span> <span class="token punctuation">[</span><span class="token hvariable">a</span><span class="token punctuation">,</span><span class="token hvariable">b</span><span class="token punctuation">,</span><span class="token hvariable">c</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Giving it a go, we see that the odds of all three landing tails are not that good, despite cheating with our loaded coin:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token hvariable">getProb</span> <span class="token hvariable">flipThree</span>
<span class="token punctuation">[</span><span class="token punctuation">(</span><span class="token constant">False</span><span class="token punctuation">,</span><span class="token number">1</span> <span class="token operator">%</span> <span class="token number">40</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token constant">False</span><span class="token punctuation">,</span><span class="token number">9</span> <span class="token operator">%</span> <span class="token number">40</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token constant">False</span><span class="token punctuation">,</span><span class="token number">1</span> <span class="token operator">%</span> <span class="token number">40</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token constant">False</span><span class="token punctuation">,</span><span class="token number">9</span> <span class="token operator">%</span> <span class="token number">40</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
 <span class="token punctuation">(</span><span class="token constant">False</span><span class="token punctuation">,</span><span class="token number">1</span> <span class="token operator">%</span> <span class="token number">40</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token constant">False</span><span class="token punctuation">,</span><span class="token number">9</span> <span class="token operator">%</span> <span class="token number">40</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token constant">False</span><span class="token punctuation">,</span><span class="token number">1</span> <span class="token operator">%</span> <span class="token number">40</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token constant">True</span><span class="token punctuation">,</span><span class="token number">9</span> <span class="token operator">%</span> <span class="token number">40</span><span class="token punctuation">)</span><span class="token punctuation">]</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>All three of them will land tails nine times out of forty, which is less than 25%. We see that our monad doesn't know how to join all of the&nbsp;<code>False</code>&nbsp;outcomes where all coins don't land tails into one outcome. That's not a big problem, since writing a function to put all the same outcomes into one outcome is pretty easy and is left as an exercise to the reader (you!)</p></div><div><p>In this section, we went from having a question (what if lists also carried information about probability?) to making a type, recognizing a monad and finally making an instance and doing something with it. I think that's quite fetching! By now, we should have a pretty good grasp on monads and what they're about.</p></div><div class="mod-footer"></div></div></div></div><div class="sidebar-right sidebar"><div class="sidebar-content"><span class="sidebar-section-header">Interactive Graph</span><div class="graph-view-placeholder">
		<div class="graph-view-container">
			<div class="graph-icon graph-expand" role="button" aria-label="Expand" data-tooltip-position="top"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon lucide-arrow-up-right"><line x1="7" y1="17" x2="17" y2="7"></line><polyline points="7 7 17 7 17 17"></polyline></svg></div>
			<canvas id="graph-canvas" width="512px" height="512px"></canvas>
		</div>
		</div><div class="tree-container outline-tree" data-depth="0"><div class="tree-header"><span class="sidebar-section-header">Table Of Contents</span><button class="clickable-icon collapse-tree-button"><iconify-icon icon="ph:arrows-in-line-horizontal-bold" width="18px" height="18px" rotate="90deg" color="currentColor"></iconify-icon></button></div><div class="tree-scroll-area"><div class="tree-item mod-tree-heading" data-depth="1"><div class="tree-item-contents"><a class="tree-item-link" href="#For_a_Few_Monads_More"><span class="tree-item-title">For a Few Monads More</span></a></div><div class="tree-item-children"><div class="tree-item mod-tree-heading mod-collapsible" data-depth="2"><div class="tree-item-contents"><div class="tree-item-icon collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div><a class="tree-item-link" href="#Writer?_I_hardly_know_her!"><span class="tree-item-title">Writer? I hardly know her!</span></a></div><div class="tree-item-children"><div class="tree-item mod-tree-heading" data-depth="3"><div class="tree-item-contents"><a class="tree-item-link" href="#Monoids_to_the_rescue"><span class="tree-item-title">Monoids to the rescue</span></a></div><div class="tree-item-children"></div></div><div class="tree-item mod-tree-heading" data-depth="3"><div class="tree-item-contents"><a class="tree-item-link" href="#The_Writer_type"><span class="tree-item-title">The Writer type</span></a></div><div class="tree-item-children"></div></div><div class="tree-item mod-tree-heading" data-depth="3"><div class="tree-item-contents"><a class="tree-item-link" href="#Using_do_notation_with_Writer"><span class="tree-item-title">Using do notation with Writer</span></a></div><div class="tree-item-children"></div></div><div class="tree-item mod-tree-heading" data-depth="3"><div class="tree-item-contents"><a class="tree-item-link" href="#Adding_logging_to_programs"><span class="tree-item-title">Adding logging to programs</span></a></div><div class="tree-item-children"></div></div><div class="tree-item mod-tree-heading" data-depth="3"><div class="tree-item-contents"><a class="tree-item-link" href="#Inefficient_list_construction"><span class="tree-item-title">Inefficient list construction</span></a></div><div class="tree-item-children"></div></div><div class="tree-item mod-tree-heading" data-depth="3"><div class="tree-item-contents"><a class="tree-item-link" href="#Difference_lists"><span class="tree-item-title">Difference lists</span></a></div><div class="tree-item-children"></div></div><div class="tree-item mod-tree-heading" data-depth="3"><div class="tree-item-contents"><a class="tree-item-link" href="#Comparing_Performance"><span class="tree-item-title">Comparing Performance</span></a></div><div class="tree-item-children"></div></div></div></div><div class="tree-item mod-tree-heading" data-depth="2"><div class="tree-item-contents"><a class="tree-item-link" href="#Reader?_Ugh,_not_this_joke_again."><span class="tree-item-title">Reader? Ugh, not this joke again.</span></a></div><div class="tree-item-children"></div></div><div class="tree-item mod-tree-heading mod-collapsible" data-depth="2"><div class="tree-item-contents"><div class="tree-item-icon collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div><a class="tree-item-link" href="#Tasteful_stateful_computations"><span class="tree-item-title">Tasteful stateful computations</span></a></div><div class="tree-item-children"><div class="tree-item mod-tree-heading" data-depth="3"><div class="tree-item-contents"><a class="tree-item-link" href="#Stacks_and_stones"><span class="tree-item-title">Stacks and stones</span></a></div><div class="tree-item-children"></div></div><div class="tree-item mod-tree-heading" data-depth="3"><div class="tree-item-contents"><a class="tree-item-link" href="#The_State_monad"><span class="tree-item-title">The State monad</span></a></div><div class="tree-item-children"></div></div><div class="tree-item mod-tree-heading" data-depth="3"><div class="tree-item-contents"><a class="tree-item-link" href="#Randomness_and_the_state_monad"><span class="tree-item-title">Randomness and the state monad</span></a></div><div class="tree-item-children"></div></div></div></div><div class="tree-item mod-tree-heading" data-depth="2"><div class="tree-item-contents"><a class="tree-item-link" href="#Error_error_on_the_wall"><span class="tree-item-title">Error error on the wall</span></a></div><div class="tree-item-children"></div></div><div class="tree-item mod-tree-heading mod-collapsible" data-depth="2"><div class="tree-item-contents"><div class="tree-item-icon collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div><a class="tree-item-link" href="#Some_useful_monadic_functions"><span class="tree-item-title">Some useful monadic functions</span></a></div><div class="tree-item-children"><div class="tree-item mod-tree-heading" data-depth="3"><div class="tree-item-contents"><a class="tree-item-link" href="#liftM_and_friends"><span class="tree-item-title">liftM and friends</span></a></div><div class="tree-item-children"></div></div><div class="tree-item mod-tree-heading" data-depth="3"><div class="tree-item-contents"><a class="tree-item-link" href="#The_join_function"><span class="tree-item-title">The join function</span></a></div><div class="tree-item-children"></div></div><div class="tree-item mod-tree-heading" data-depth="3"><div class="tree-item-contents"><a class="tree-item-link" href="#filterM"><span class="tree-item-title">filterM</span></a></div><div class="tree-item-children"></div></div><div class="tree-item mod-tree-heading" data-depth="3"><div class="tree-item-contents"><a class="tree-item-link" href="#foldM"><span class="tree-item-title">foldM</span></a></div><div class="tree-item-children"></div></div><div class="tree-item mod-tree-heading" data-depth="3"><div class="tree-item-contents"><a class="tree-item-link" href="#Making_a_safe_RPN_calculator"><span class="tree-item-title">Making a safe RPN calculator</span></a></div><div class="tree-item-children"></div></div><div class="tree-item mod-tree-heading" data-depth="3"><div class="tree-item-contents"><a class="tree-item-link" href="#Composing_monadic_functions"><span class="tree-item-title">Composing monadic functions</span></a></div><div class="tree-item-children"></div></div></div></div><div class="tree-item mod-tree-heading" data-depth="2"><div class="tree-item-contents"><a class="tree-item-link" href="#Making_monads"><span class="tree-item-title">Making monads</span></a></div><div class="tree-item-children"></div></div></div></div></div></div></div></div></div></body></html>