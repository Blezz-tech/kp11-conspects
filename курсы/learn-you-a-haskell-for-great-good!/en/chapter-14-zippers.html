<!DOCTYPE html>
<html><head>
			
		<title>Chapter 14 Zippers</title>
		<base href="../../../">
		<meta id="root-path" root-path="../../../">

		<link rel="icon" sizes="96x96" href="https://publish-01.obsidian.md/access/f786db9fac45774fa4f0d8112e232d67/favicon-96x96.png">
		<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes, minimum-scale=1.0, maximum-scale=5.0">
		<meta charset="UTF-8">
		<script src="https://code.iconify.design/iconify-icon/1.0.3/iconify-icon.min.js"></script>

			<link rel="stylesheet" href="lib/styles/obsidian-styles.css">
			<link rel="stylesheet" href="lib/styles/theme.css">
			<link rel="stylesheet" href="lib/styles/plugin-styles.css">
			<link rel="stylesheet" href="lib/styles/snippets.css">
			<style>  </style>

			
			<!-- Graph View Data -->
			<script>
			let nodes=
{"nodeCount":22,"linkCount":21,"radii":[7,5.346938775510203,4.855867346938775,4.301020408163265,3.6823979591836737,3.6823979591836737,3.6823979591836737,3.6823979591836737,3.6823979591836737,3.6823979591836737,3.6823979591836737,3.6823979591836737,3.6823979591836737,3.6823979591836737,3.6823979591836737,3.6823979591836737,3.6823979591836737,3.6823979591836737,3.6823979591836737,3.6823979591836737,3.6823979591836737,3.6823979591836737],"labels":["Table Of Content","Отчеты","README","README","О Haskell по-человечески (Итого)","Полезные ресурсы","О Haskell по-человечески (Оригинал)","Оглавление","Chapter 13 For a Few Monads More","Chapter 12 A Fistful of Monads","Chapter 11 Functors, Applicative Functors and Monoids","Chapter 10 Functionally Solving Problems","Chapter 9 Input and Output","Chapter 8 Making Our Own Types and Typeclasses","Chapter 7 Modules","Chapter 6 Higher order functions","Chapter 5 Recursion","Chapter 4 Syntax in Functions","Chapter 14 Zippers","Chapter 1 Introduction","Chapter 2 Starting Out","Chapter 3 Types and Typeclasses"],"paths":["курсы/learn-you-a-haskell-for-great-good!/en/table-of-content.html","отчеты.html","курсы/learn-you-a-haskell-for-great-good!/readme.html","readme.html","мои-решения/о-haskell-по-человечески/о-haskell-по-человечески-(итого).html","полезные-ресурсы.html","курсы/о-haskell-по-человечески/о-haskell-по-человечески-(оригинал).html","курсы/learn-you-a-haskell-for-great-good!/ru/оглавление.html","курсы/learn-you-a-haskell-for-great-good!/en/chapter-13-for-a-few-monads-more.html","курсы/learn-you-a-haskell-for-great-good!/en/chapter-12-a-fistful-of-monads.html","курсы/learn-you-a-haskell-for-great-good!/en/chapter-11-functors,-applicative-functors-and-monoids.html","курсы/learn-you-a-haskell-for-great-good!/en/chapter-10-functionally-solving-problems.html","курсы/learn-you-a-haskell-for-great-good!/en/chapter-9-input-and-output.html","курсы/learn-you-a-haskell-for-great-good!/en/chapter-8-making-our-own-types-and-typeclasses.html","курсы/learn-you-a-haskell-for-great-good!/en/chapter-7-modules.html","курсы/learn-you-a-haskell-for-great-good!/en/chapter-6-higher-order-functions.html","курсы/learn-you-a-haskell-for-great-good!/en/chapter-5-recursion.html","курсы/learn-you-a-haskell-for-great-good!/en/chapter-4-syntax-in-functions.html","курсы/learn-you-a-haskell-for-great-good!/en/chapter-14-zippers.html","курсы/learn-you-a-haskell-for-great-good!/en/chapter-1-introduction.html","курсы/learn-you-a-haskell-for-great-good!/en/chapter-2-starting-out.html","курсы/learn-you-a-haskell-for-great-good!/en/chapter-3-types-and-typeclasses.html"],"linkSources":[3,3,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,2],"linkTargets":[5,1,6,4,2,19,20,21,17,16,15,14,13,12,11,10,9,8,18,0,7]};
			let attractionForce = 1;
			let linkLength = 10;
			let repulsionForce = 150;
			let centralForce = 3;
			let edgePruning = 100;
			</script>
			
<script type="module" src="lib/scripts/graph_view.js"></script>

<script src="lib/scripts/graph_wasm.js"></script>

<script src="lib/scripts/tinycolor.js"></script>

<script src="https://cdnjs.cloudflare.com/ajax/libs/pixi.js/7.2.4/pixi.min.js" integrity="sha512-Ch/O6kL8BqUwAfCF7Ie5SX1Hin+BJgYH4pNjRqXdTEqMsis1TUYg+j6nnI9uduPjGaj7DN4UKCZgpvoExt6dkw==" crossorigin="anonymous" referrerpolicy="no-referrer"></script>

<script src="lib/scripts/webpage.js"></script>

			</head><body class="theme-dark mod-windows is-frameless is-maximized is-hidden-frameless obsidian-app show-inline-title show-view-header" style="--zoom-factor:1; --font-text-size:16px; --line-width:100%; --line-width-adaptive:100%; --file-line-width:100%; --content-width:500em; --sidebar-width:25em; --collapse-arrow-size:0.4em; --tree-horizontal-spacing:1em; --tree-vertical-spacing:0.5em; --sidebar-margin:12px;"><div class="webpage-container"><div class="sidebar-left sidebar"><div class="sidebar-content"><div><label class="theme-toggle-container" for="theme_toggle"><input class="theme-toggle-input" type="checkbox" id="theme_toggle"><div class="toggle-background"></div></label></div><div class="tree-container file-tree mod-nav-indicator" data-depth="0"><div class="tree-header"><span class="sidebar-section-header">learn-haskell-valut</span><button class="clickable-icon collapse-tree-button is-collapsed"><iconify-icon icon="ph:arrows-in-line-horizontal-bold" width="18px" height="18px" rotate="90deg" color="currentColor"></iconify-icon></button></div><div class="tree-scroll-area"><div class="tree-item mod-tree-folder mod-collapsible is-collapsed" data-depth="1"><div class="tree-item-contents"><div class="tree-item-icon collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div><a class="tree-item-link" href="курсы"><span class="tree-item-title">Курсы</span></a></div><div class="tree-item-children"><div class="tree-item mod-tree-folder mod-collapsible is-collapsed" data-depth="2"><div class="tree-item-contents"><div class="tree-item-icon collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div><a class="tree-item-link" href="курсы/о-haskell-по-человечески"><span class="tree-item-title">О Haskell по-человечески</span></a></div><div class="tree-item-children"><div class="tree-item mod-tree-file" data-depth="3"><div class="tree-item-contents"><a class="tree-item-link" href="курсы/о-haskell-по-человечески/о-haskell-по-человечески-(оригинал).html"><span class="tree-item-title">О Haskell по-человечески (Оригинал)</span></a></div><div class="tree-item-children"></div></div></div></div><div class="tree-item mod-tree-folder mod-collapsible is-collapsed" data-depth="2"><div class="tree-item-contents"><div class="tree-item-icon collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div><a class="tree-item-link" href="курсы/learn-you-a-haskell-for-great-good!"><span class="tree-item-title">Learn You a Haskell for Great Good!</span></a></div><div class="tree-item-children"><div class="tree-item mod-tree-folder mod-collapsible is-collapsed" data-depth="3"><div class="tree-item-contents"><div class="tree-item-icon collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div><a class="tree-item-link" href="курсы/learn-you-a-haskell-for-great-good!/en"><span class="tree-item-title">en</span></a></div><div class="tree-item-children"><div class="tree-item mod-tree-file" data-depth="4"><div class="tree-item-contents"><a class="tree-item-link" href="курсы/learn-you-a-haskell-for-great-good!/en/chapter-1-introduction.html"><span class="tree-item-title">Chapter 1 Introduction</span></a></div><div class="tree-item-children"></div></div><div class="tree-item mod-tree-file" data-depth="4"><div class="tree-item-contents"><a class="tree-item-link" href="курсы/learn-you-a-haskell-for-great-good!/en/chapter-10-functionally-solving-problems.html"><span class="tree-item-title">Chapter 10 Functionally Solving Problems</span></a></div><div class="tree-item-children"></div></div><div class="tree-item mod-tree-file" data-depth="4"><div class="tree-item-contents"><a class="tree-item-link" href="курсы/learn-you-a-haskell-for-great-good!/en/chapter-11-functors,-applicative-functors-and-monoids.html"><span class="tree-item-title">Chapter 11 Functors, Applicative Functors and Monoids</span></a></div><div class="tree-item-children"></div></div><div class="tree-item mod-tree-file" data-depth="4"><div class="tree-item-contents"><a class="tree-item-link" href="курсы/learn-you-a-haskell-for-great-good!/en/chapter-12-a-fistful-of-monads.html"><span class="tree-item-title">Chapter 12 A Fistful of Monads</span></a></div><div class="tree-item-children"></div></div><div class="tree-item mod-tree-file" data-depth="4"><div class="tree-item-contents"><a class="tree-item-link" href="курсы/learn-you-a-haskell-for-great-good!/en/chapter-13-for-a-few-monads-more.html"><span class="tree-item-title">Chapter 13 For a Few Monads More</span></a></div><div class="tree-item-children"></div></div><div class="tree-item mod-tree-file" data-depth="4"><div class="tree-item-contents"><a class="tree-item-link" href="курсы/learn-you-a-haskell-for-great-good!/en/chapter-14-zippers.html"><span class="tree-item-title">Chapter 14 Zippers</span></a></div><div class="tree-item-children"></div></div><div class="tree-item mod-tree-file" data-depth="4"><div class="tree-item-contents"><a class="tree-item-link" href="курсы/learn-you-a-haskell-for-great-good!/en/chapter-2-starting-out.html"><span class="tree-item-title">Chapter 2 Starting Out</span></a></div><div class="tree-item-children"></div></div><div class="tree-item mod-tree-file" data-depth="4"><div class="tree-item-contents"><a class="tree-item-link" href="курсы/learn-you-a-haskell-for-great-good!/en/chapter-3-types-and-typeclasses.html"><span class="tree-item-title">Chapter 3 Types and Typeclasses</span></a></div><div class="tree-item-children"></div></div><div class="tree-item mod-tree-file" data-depth="4"><div class="tree-item-contents"><a class="tree-item-link" href="курсы/learn-you-a-haskell-for-great-good!/en/chapter-4-syntax-in-functions.html"><span class="tree-item-title">Chapter 4 Syntax in Functions</span></a></div><div class="tree-item-children"></div></div><div class="tree-item mod-tree-file" data-depth="4"><div class="tree-item-contents"><a class="tree-item-link" href="курсы/learn-you-a-haskell-for-great-good!/en/chapter-5-recursion.html"><span class="tree-item-title">Chapter 5 Recursion</span></a></div><div class="tree-item-children"></div></div><div class="tree-item mod-tree-file" data-depth="4"><div class="tree-item-contents"><a class="tree-item-link" href="курсы/learn-you-a-haskell-for-great-good!/en/chapter-6-higher-order-functions.html"><span class="tree-item-title">Chapter 6 Higher order functions</span></a></div><div class="tree-item-children"></div></div><div class="tree-item mod-tree-file" data-depth="4"><div class="tree-item-contents"><a class="tree-item-link" href="курсы/learn-you-a-haskell-for-great-good!/en/chapter-7-modules.html"><span class="tree-item-title">Chapter 7 Modules</span></a></div><div class="tree-item-children"></div></div><div class="tree-item mod-tree-file" data-depth="4"><div class="tree-item-contents"><a class="tree-item-link" href="курсы/learn-you-a-haskell-for-great-good!/en/chapter-8-making-our-own-types-and-typeclasses.html"><span class="tree-item-title">Chapter 8 Making Our Own Types and Typeclasses</span></a></div><div class="tree-item-children"></div></div><div class="tree-item mod-tree-file" data-depth="4"><div class="tree-item-contents"><a class="tree-item-link" href="курсы/learn-you-a-haskell-for-great-good!/en/chapter-9-input-and-output.html"><span class="tree-item-title">Chapter 9 Input and Output</span></a></div><div class="tree-item-children"></div></div><div class="tree-item mod-tree-file" data-depth="4"><div class="tree-item-contents"><a class="tree-item-link" href="курсы/learn-you-a-haskell-for-great-good!/en/table-of-content.html"><span class="tree-item-title">Table Of Content</span></a></div><div class="tree-item-children"></div></div></div></div><div class="tree-item mod-tree-folder mod-collapsible is-collapsed" data-depth="3"><div class="tree-item-contents"><div class="tree-item-icon collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div><a class="tree-item-link" href="курсы/learn-you-a-haskell-for-great-good!/ru"><span class="tree-item-title">ru</span></a></div><div class="tree-item-children"><div class="tree-item mod-tree-file" data-depth="4"><div class="tree-item-contents"><a class="tree-item-link" href="курсы/learn-you-a-haskell-for-great-good!/ru/оглавление.html"><span class="tree-item-title">Оглавление</span></a></div><div class="tree-item-children"></div></div></div></div><div class="tree-item mod-tree-file" data-depth="3"><div class="tree-item-contents"><a class="tree-item-link" href="курсы/learn-you-a-haskell-for-great-good!/readme.html"><span class="tree-item-title">README</span></a></div><div class="tree-item-children"></div></div></div></div></div></div><div class="tree-item mod-tree-folder mod-collapsible is-collapsed" data-depth="1"><div class="tree-item-contents"><div class="tree-item-icon collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div><a class="tree-item-link" href="мои-решения"><span class="tree-item-title">Мои решения</span></a></div><div class="tree-item-children"><div class="tree-item mod-tree-folder mod-collapsible is-collapsed" data-depth="2"><div class="tree-item-contents"><div class="tree-item-icon collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div><a class="tree-item-link" href="мои-решения/о-haskell-по-человечески"><span class="tree-item-title">О Haskell по-человечески</span></a></div><div class="tree-item-children"><div class="tree-item mod-tree-file" data-depth="3"><div class="tree-item-contents"><a class="tree-item-link" href="мои-решения/о-haskell-по-человечески/о-haskell-по-человечески-(итого).html"><span class="tree-item-title">О Haskell по-человечески (Итого)</span></a></div><div class="tree-item-children"></div></div></div></div></div></div><div class="tree-item mod-tree-file" data-depth="1"><div class="tree-item-contents"><a class="tree-item-link" href="отчеты.html"><span class="tree-item-title">Отчеты</span></a></div><div class="tree-item-children"></div></div><div class="tree-item mod-tree-file" data-depth="1"><div class="tree-item-contents"><a class="tree-item-link" href="полезные-ресурсы.html"><span class="tree-item-title">Полезные ресурсы</span></a></div><div class="tree-item-children"></div></div><div class="tree-item mod-tree-file" data-depth="1"><div class="tree-item-contents"><a class="tree-item-link" href="readme.html"><span class="tree-item-title">README</span></a></div><div class="tree-item-children"></div></div></div></div></div></div><div class="document-container"><div class="markdown-preview-view markdown-rendered node-insert-event allow-fold-headings show-indentation-guide allow-fold-lists show-frontmatter" style="tab-size: 4;" tabindex="-1"><style id="MJX-CHTML-styles"></style><div class="markdown-preview-sizer markdown-preview-section" style="padding-bottom: ; padding-top: var(--file-margins); padding-right: var(--file-margins); padding-left: var(--file-margins); width: 100%; position: absolute;"><div class="markdown-preview-pusher" style="width: 1px; height: 0.1px; margin-bottom: 0px;"></div><div class="mod-header"></div><div><h1 data-heading="Zippers" id="Zippers">Zippers</h1></div><div><p><img alt="hi im chet" src="http://learnyouahaskell.com/60sdude.png" referrerpolicy="no-referrer"></p></div><div><p>While Haskell's purity comes with a whole bunch of benefits, it makes us tackle some problems differently than we would in impure languages. Because of referential transparency, one value is as good as another in Haskell if it represents the same thing.</p></div><div><p>So if we have a tree full of fives (high-fives, maybe?) and we want to change one of them into a six, we have to have some way of knowing exactly which five in our tree we want to change. We have to know where it is in our tree. In impure languages, we could just note where in our memory the five is located and change that. But in Haskell, one five is as good as another, so we can't discriminate based on where in our memory they are. We also can't really&nbsp;<em>change</em>&nbsp;anything; when we say that we change a tree, we actually mean that we take a tree and return a new one that's similar to the original tree, but slightly different.</p></div><div><p>One thing we can do is to remember a path from the root of the tree to the element that we want to change. We could say, take this tree, go left, go right and then left again and change the element that's there. While this works, it can be inefficient. If we want to later change an element that's near the element that we previously changed, we have to walk all the way from the root of the tree to our element again!</p></div><div><p>In this chapter, we'll see how we can take some data structure and focus on a part of it in a way that makes changing its elements easy and walking around it efficient. Nice!</p></div><div><h2 data-heading="Taking a walk" id="Taking_a_walk" style="display: flex;"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>Taking a walk</h2></div><div><p>Like we've learned in biology class, there are many different kinds of trees, so let's pick a seed that we will use to plant ours. Here it is:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token keyword">data</span> <span class="token constant">Tree</span> <span class="token hvariable">a</span> <span class="token operator">=</span> <span class="token constant">Empty</span> <span class="token operator">|</span> <span class="token constant">Node</span> <span class="token hvariable">a</span> <span class="token punctuation">(</span><span class="token constant">Tree</span> <span class="token hvariable">a</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token constant">Tree</span> <span class="token hvariable">a</span><span class="token punctuation">)</span> <span class="token keyword">deriving</span> <span class="token punctuation">(</span><span class="token constant">Show</span><span class="token punctuation">)</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>So our tree is either empty or it's a node that has an element and two sub-trees. Here's a fine example of such a tree, which I give to you, the reader, for free!</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">freeTree</span> <span class="token operator">::</span> <span class="token constant">Tree</span> <span class="token constant">Char</span>
<span class="token hvariable">freeTree</span> <span class="token operator">=</span> 
    <span class="token constant">Node</span> <span class="token char string">'P'</span>
        <span class="token punctuation">(</span><span class="token constant">Node</span> <span class="token char string">'O'</span>
            <span class="token punctuation">(</span><span class="token constant">Node</span> <span class="token char string">'L'</span>
                <span class="token punctuation">(</span><span class="token constant">Node</span> <span class="token char string">'N'</span> <span class="token constant">Empty</span> <span class="token constant">Empty</span><span class="token punctuation">)</span>
                <span class="token punctuation">(</span><span class="token constant">Node</span> <span class="token char string">'T'</span> <span class="token constant">Empty</span> <span class="token constant">Empty</span><span class="token punctuation">)</span>
            <span class="token punctuation">)</span>
            <span class="token punctuation">(</span><span class="token constant">Node</span> <span class="token char string">'Y'</span>
                <span class="token punctuation">(</span><span class="token constant">Node</span> <span class="token char string">'S'</span> <span class="token constant">Empty</span> <span class="token constant">Empty</span><span class="token punctuation">)</span>
                <span class="token punctuation">(</span><span class="token constant">Node</span> <span class="token char string">'A'</span> <span class="token constant">Empty</span> <span class="token constant">Empty</span><span class="token punctuation">)</span>
            <span class="token punctuation">)</span>
        <span class="token punctuation">)</span>
        <span class="token punctuation">(</span><span class="token constant">Node</span> <span class="token char string">'L'</span>
            <span class="token punctuation">(</span><span class="token constant">Node</span> <span class="token char string">'W'</span>
                <span class="token punctuation">(</span><span class="token constant">Node</span> <span class="token char string">'C'</span> <span class="token constant">Empty</span> <span class="token constant">Empty</span><span class="token punctuation">)</span>
                <span class="token punctuation">(</span><span class="token constant">Node</span> <span class="token char string">'R'</span> <span class="token constant">Empty</span> <span class="token constant">Empty</span><span class="token punctuation">)</span>
            <span class="token punctuation">)</span>
            <span class="token punctuation">(</span><span class="token constant">Node</span> <span class="token char string">'A'</span>
                <span class="token punctuation">(</span><span class="token constant">Node</span> <span class="token char string">'A'</span> <span class="token constant">Empty</span> <span class="token constant">Empty</span><span class="token punctuation">)</span>
                <span class="token punctuation">(</span><span class="token constant">Node</span> <span class="token char string">'C'</span> <span class="token constant">Empty</span> <span class="token constant">Empty</span><span class="token punctuation">)</span>
            <span class="token punctuation">)</span>
        <span class="token punctuation">)</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>And here's this tree represented graphically:</p></div><div><p><img alt="polly says her back hurts" src="http://learnyouahaskell.com/pollywantsa.png" referrerpolicy="no-referrer"></p></div><div><p>Notice that&nbsp;<code>W</code>&nbsp;in the tree there? Say we want to change it into a&nbsp;<code>P</code>. How would we go about doing that? Well, one way would be to pattern match on our tree until we find the element that's located by first going right and then left and changing said element. Here's the code for this:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">changeToP</span> <span class="token operator">::</span> <span class="token constant">Tree</span> <span class="token constant">Char</span> <span class="token operator">-&gt;</span> <span class="token constant">Tree</span> <span class="token constant">Char</span>
<span class="token hvariable">changeToP</span> <span class="token punctuation">(</span><span class="token constant">Node</span> <span class="token hvariable">x</span> <span class="token hvariable">l</span> <span class="token punctuation">(</span><span class="token constant">Node</span> <span class="token hvariable">y</span> <span class="token punctuation">(</span><span class="token constant">Node</span> <span class="token hvariable">_</span> <span class="token hvariable">m</span> <span class="token hvariable">n</span><span class="token punctuation">)</span> <span class="token hvariable">r</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token constant">Node</span> <span class="token hvariable">x</span> <span class="token hvariable">l</span> <span class="token punctuation">(</span><span class="token constant">Node</span> <span class="token hvariable">y</span> <span class="token punctuation">(</span><span class="token constant">Node</span> <span class="token char string">'P'</span> <span class="token hvariable">m</span> <span class="token hvariable">n</span><span class="token punctuation">)</span> <span class="token hvariable">r</span><span class="token punctuation">)</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Yuck! Not only is this rather ugly, it's also kind of confusing. What happens here? Well, we pattern match on our tree and name its root element&nbsp;<code>x</code>&nbsp;(that's becomes the&nbsp;<code>'P'</code>&nbsp;in the root) and its left sub-tree&nbsp;<code>l</code>. Instead of giving a name to its right sub-tree, we further pattern match on it. We continue this pattern matching until we reach the sub-tree whose root is our&nbsp;<code>'W'</code>. Once we've done this, we rebuild the tree, only the sub-tree that contained the&nbsp;<code>'W'</code>&nbsp;at its root now has a&nbsp;<code>'P'</code>.</p></div><div><p>Is there a better way of doing this? How about we make our function take a tree along with a list of directions. The directions will be either&nbsp;<code>L</code>&nbsp;or&nbsp;<code>R</code>, representing left and right respectively, and we'll change the element that we arrive at if we follow the supplied directions. Here it is:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token keyword">data</span> <span class="token constant">Direction</span> <span class="token operator">=</span> <span class="token constant">L</span> <span class="token operator">|</span> <span class="token constant">R</span> <span class="token keyword">deriving</span> <span class="token punctuation">(</span><span class="token constant">Show</span><span class="token punctuation">)</span>
<span class="token keyword">type</span> <span class="token constant">Directions</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token constant">Direction</span><span class="token punctuation">]</span>

<span class="token hvariable">changeToP</span> <span class="token operator">::</span> <span class="token constant">Directions</span><span class="token operator">-&gt;</span> <span class="token constant">Tree</span> <span class="token constant">Char</span> <span class="token operator">-&gt;</span> <span class="token constant">Tree</span> <span class="token constant">Char</span>
<span class="token hvariable">changeToP</span> <span class="token punctuation">(</span><span class="token constant">L</span><span class="token operator">:</span><span class="token hvariable">ds</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token constant">Node</span> <span class="token hvariable">x</span> <span class="token hvariable">l</span> <span class="token hvariable">r</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token constant">Node</span> <span class="token hvariable">x</span> <span class="token punctuation">(</span><span class="token hvariable">changeToP</span> <span class="token hvariable">ds</span> <span class="token hvariable">l</span><span class="token punctuation">)</span> <span class="token hvariable">r</span>
<span class="token hvariable">changeToP</span> <span class="token punctuation">(</span><span class="token constant">R</span><span class="token operator">:</span><span class="token hvariable">ds</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token constant">Node</span> <span class="token hvariable">x</span> <span class="token hvariable">l</span> <span class="token hvariable">r</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token constant">Node</span> <span class="token hvariable">x</span> <span class="token hvariable">l</span> <span class="token punctuation">(</span><span class="token hvariable">changeToP</span> <span class="token hvariable">ds</span> <span class="token hvariable">r</span><span class="token punctuation">)</span>
<span class="token hvariable">changeToP</span> <span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token punctuation">(</span><span class="token constant">Node</span> <span class="token hvariable">_</span> <span class="token hvariable">l</span> <span class="token hvariable">r</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token constant">Node</span> <span class="token char string">'P'</span> <span class="token hvariable">l</span> <span class="token hvariable">r</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>If the first element in the our list of directions is&nbsp;<code>L</code>, we construct a new tree that's like the old tree, only its left sub-tree has an element changed to&nbsp;<code>'P'</code>. When we recursively call&nbsp;<code>changeToP</code>, we give it only the tail of the list of directions, because we already took a left. We do the same thing in the case of an&nbsp;<code>R</code>. If the list of directions is empty, that means that we're at our destination, so we return a tree that's like the one supplied, only it has&nbsp;<code>'P'</code>&nbsp;as its root element.</p></div><div><p>To avoid printing out the whole tree, let's make a function that takes a list of directions and tells us what the element at the destination is:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">elemAt</span> <span class="token operator">::</span> <span class="token constant">Directions</span> <span class="token operator">-&gt;</span> <span class="token constant">Tree</span> <span class="token hvariable">a</span> <span class="token operator">-&gt;</span> <span class="token hvariable">a</span>
<span class="token hvariable">elemAt</span> <span class="token punctuation">(</span><span class="token constant">L</span><span class="token operator">:</span><span class="token hvariable">ds</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token constant">Node</span> <span class="token hvariable">_</span> <span class="token hvariable">l</span> <span class="token hvariable">_</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token hvariable">elemAt</span> <span class="token hvariable">ds</span> <span class="token hvariable">l</span>
<span class="token hvariable">elemAt</span> <span class="token punctuation">(</span><span class="token constant">R</span><span class="token operator">:</span><span class="token hvariable">ds</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token constant">Node</span> <span class="token hvariable">_</span> <span class="token hvariable">_</span> <span class="token hvariable">r</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token hvariable">elemAt</span> <span class="token hvariable">ds</span> <span class="token hvariable">r</span>
<span class="token hvariable">elemAt</span> <span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token punctuation">(</span><span class="token constant">Node</span> <span class="token hvariable">x</span> <span class="token hvariable">_</span> <span class="token hvariable">_</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token hvariable">x</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>This function is actually quite similar to&nbsp;<code>changeToP</code>, only instead of remembering stuff along the way and reconstructing the tree, it ignores everything except its destination. Here we change the&nbsp;<code>'W'</code>&nbsp;to a&nbsp;<code>'P'</code>&nbsp;and see if the change in our new tree sticks:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token keyword">let</span> <span class="token hvariable">newTree</span> <span class="token operator">=</span> <span class="token hvariable">changeToP</span> <span class="token punctuation">[</span><span class="token constant">R</span><span class="token punctuation">,</span><span class="token constant">L</span><span class="token punctuation">]</span> <span class="token hvariable">freeTree</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token hvariable">elemAt</span> <span class="token punctuation">[</span><span class="token constant">R</span><span class="token punctuation">,</span><span class="token constant">L</span><span class="token punctuation">]</span> <span class="token hvariable">newTree</span>
<span class="token char string">'P'</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Nice, this seems to work. In these functions, the list of directions acts as a sort of&nbsp;<em>focus</em>, because it pinpoints one exact sub-tree from our tree. A direction list of&nbsp;<code>[R]</code>&nbsp;focuses on the sub-tree that's right of the root, for example. An empty direction list focuses on the main tree itself.</p></div><div><p>While this technique may seem cool, it can be rather inefficient, especially if we want to repeatedly change elements. Say we have a really huge tree and a long direction list that points to some element all the way at the bottom of the tree. We use the direction list to take a walk along the tree and change an element at the bottom. If we want to change another element that's close to the element that we've just changed, we have to start from the root of the tree and walk all the way to the bottom again! What a drag.</p></div><div><p>In the next section, we'll find a better way of focusing on a sub-tree, one that allows us to efficiently switch focus to sub-trees that are nearby.</p></div><div><h2 data-heading="A trail of breadcrumbs" id="A_trail_of_breadcrumbs" style="display: flex;"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>A trail of breadcrumbs</h2></div><div><p><img alt="whoop dee doo" src="http://learnyouahaskell.com/bread.png" referrerpolicy="no-referrer"></p></div><div><p>Okay, so for focusing on a sub-tree, we want something better than just a list of directions that we always follow from the root of our tree. Would it help if we start at the root of the tree and move either left or right one step at a time and sort of leave breadcrumbs? That is, when we go left, we remember that we went left and when we go right, we remember that we went right. Sure, we can try that.</p></div><div><p>To represent our breadcrumbs, we'll also use a list of&nbsp;<code>Direction</code>&nbsp;(which is either&nbsp;<code>L</code>&nbsp;or&nbsp;<code>R</code>), only instead of calling it&nbsp;<code>Directions</code>, we'll call it&nbsp;<code>Breadcrumbs</code>&nbsp;, because our directions will now be reversed since we're leaving them as we go down our tree:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token keyword">type</span> <span class="token constant">Breadcrumbs</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token constant">Direction</span><span class="token punctuation">]</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Here's a function that takes a tree and some breadcrumbs and moves to the left sub-tree while adding&nbsp;<code>L</code>&nbsp;to the head of the list that represents our breadcrumbs:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">goLeft</span> <span class="token operator">::</span> <span class="token punctuation">(</span><span class="token constant">Tree</span> <span class="token hvariable">a</span><span class="token punctuation">,</span> <span class="token constant">Breadcrumbs</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token punctuation">(</span><span class="token constant">Tree</span> <span class="token hvariable">a</span><span class="token punctuation">,</span> <span class="token constant">Breadcrumbs</span><span class="token punctuation">)</span>
<span class="token hvariable">goLeft</span> <span class="token punctuation">(</span><span class="token constant">Node</span> <span class="token hvariable">_</span> <span class="token hvariable">l</span> <span class="token hvariable">_</span><span class="token punctuation">,</span> <span class="token hvariable">bs</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token hvariable">l</span><span class="token punctuation">,</span> <span class="token constant">L</span><span class="token operator">:</span><span class="token hvariable">bs</span><span class="token punctuation">)</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>We ignore the element at the root and the right sub-tree and just return the left sub-tree along with the old breadcrumbs with&nbsp;<code>L</code>&nbsp;as the head. Here's a function to go right:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">goRight</span> <span class="token operator">::</span> <span class="token punctuation">(</span><span class="token constant">Tree</span> <span class="token hvariable">a</span><span class="token punctuation">,</span> <span class="token constant">Breadcrumbs</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token punctuation">(</span><span class="token constant">Tree</span> <span class="token hvariable">a</span><span class="token punctuation">,</span> <span class="token constant">Breadcrumbs</span><span class="token punctuation">)</span>
<span class="token hvariable">goRight</span> <span class="token punctuation">(</span><span class="token constant">Node</span> <span class="token hvariable">_</span> <span class="token hvariable">_</span> <span class="token hvariable">r</span><span class="token punctuation">,</span> <span class="token hvariable">bs</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token hvariable">r</span><span class="token punctuation">,</span> <span class="token constant">R</span><span class="token operator">:</span><span class="token hvariable">bs</span><span class="token punctuation">)</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>It works the same way. Let's use these functions to take our&nbsp;<code>freeTree</code>&nbsp;and go right and then left:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token hvariable">goLeft</span> <span class="token punctuation">(</span><span class="token hvariable">goRight</span> <span class="token punctuation">(</span><span class="token hvariable">freeTree</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token punctuation">(</span><span class="token constant">Node</span> <span class="token char string">'W'</span> <span class="token punctuation">(</span><span class="token constant">Node</span> <span class="token char string">'C'</span> <span class="token constant">Empty</span> <span class="token constant">Empty</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token constant">Node</span> <span class="token char string">'R'</span> <span class="token constant">Empty</span> <span class="token constant">Empty</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token constant">L</span><span class="token punctuation">,</span><span class="token constant">R</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p><img alt="almostthere" src="http://learnyouahaskell.com/almostzipper.png" referrerpolicy="no-referrer"></p></div><div><p>Okay, so now we have a tree that has&nbsp;<code>'W'</code>&nbsp;in its root and&nbsp;<code>'C'</code>&nbsp;in the root of its left sub-tree and&nbsp;<code>'R'</code>&nbsp;in the root of its right sub-tree. The breadcrumbs are&nbsp;<code>[L,R]</code>, because we first went right and then left.</p></div><div><p>To make walking along our tree clearer, we can use the&nbsp;<code>-:</code>&nbsp;function that we defined like so:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">x</span> <span class="token operator">-:</span> <span class="token hvariable">f</span> <span class="token operator">=</span> <span class="token hvariable">f</span> <span class="token hvariable">x</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Which allows us to apply functions to values by first writing the value, then writing a&nbsp;<code>-:</code>&nbsp;and then the function. So instead of&nbsp;<code>goRight (freeTree, [])</code>, we can write&nbsp;<code>(freeTree, []) -: goRight</code>. Using this, we can rewrite the above so that it's more apparent that we're first going right and then left:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token punctuation">(</span><span class="token hvariable">freeTree</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-:</span> <span class="token hvariable">goRight</span> <span class="token operator">-:</span> <span class="token hvariable">goLeft</span>
<span class="token punctuation">(</span><span class="token constant">Node</span> <span class="token char string">'W'</span> <span class="token punctuation">(</span><span class="token constant">Node</span> <span class="token char string">'C'</span> <span class="token constant">Empty</span> <span class="token constant">Empty</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token constant">Node</span> <span class="token char string">'R'</span> <span class="token constant">Empty</span> <span class="token constant">Empty</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token constant">L</span><span class="token punctuation">,</span><span class="token constant">R</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><h3 data-heading="Going back up" id="Going_back_up" style="display: flex;"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>Going back up</h3></div><div><p>What if we now want to go back up in our tree? From our breadcrumbs we know that the current tree is the left sub-tree of its parent and that it is the right sub-tree of its parent, but that's it. They don't tell us enough about the parent of the current sub-tree for us to be able to go up in the tree. It would seem that apart from the direction that we took, a single breadcrumb should also contain all other data that we need to go back up. In this case, that's the element in the parent tree along with its right sub-tree.</p></div><div><p>In general, a single breadcrumb should contain all the data needed to reconstruct the parent node. So it should have the information from all the paths that we didn't take and it should also know the direction that we did take, but it must not contain the sub-tree that we're currently focusing on. That's because we already have that sub-tree in the first component of the tuple, so if we also had it in the breadcrumbs, we'd have duplicate information.</p></div><div><p>Let's modify our breadcrumbs so that they also contain information about everything that we previously ignored when moving left and right. Instead of&nbsp;<code>Direction</code>, we'll make a new data type:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token keyword">data</span> <span class="token constant">Crumb</span> <span class="token hvariable">a</span> <span class="token operator">=</span> <span class="token constant">LeftCrumb</span> <span class="token hvariable">a</span> <span class="token punctuation">(</span><span class="token constant">Tree</span> <span class="token hvariable">a</span><span class="token punctuation">)</span> <span class="token operator">|</span> <span class="token constant">RightCrumb</span> <span class="token hvariable">a</span> <span class="token punctuation">(</span><span class="token constant">Tree</span> <span class="token hvariable">a</span><span class="token punctuation">)</span> <span class="token keyword">deriving</span> <span class="token punctuation">(</span><span class="token constant">Show</span><span class="token punctuation">)</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Now, instead of just&nbsp;<code>L</code>, we have a&nbsp;<code>LeftCrumb</code>&nbsp;that also contains the element in the node that we moved from and the right tree that we didn't visit. Instead of&nbsp;<code>R</code>, we have&nbsp;<code>RightCrumb</code>, which contains the element in the node that we moved from and the left tree that we didn't visit.</p></div><div><p>These breadcrumbs now contain all the data needed to recreate the tree that we walked through. So instead of just being normal bread crumbs, they're now more like floppy disks that we leave as we go along, because they contain a lot more information than just the direction that we took.</p></div><div><p>In essence, every breadcrumb is now like a tree node with a hole in it. When we move deeper into a tree, the breadcrumb carries all the information that the node that we moved away from carried&nbsp;<em>except</em>&nbsp;the sub-tree that we chose to focus on. It also has to note where the hole is. In the case of a&nbsp;<code>LeftCrumb</code>, we know that we moved left, so the sub-tree that's missing is the left one.</p></div><div><p>Let's also change our&nbsp;<code>Breadcrumbs</code>&nbsp;type synonym to reflect this:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token keyword">type</span> <span class="token constant">Breadcrumbs</span> <span class="token hvariable">a</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token constant">Crumb</span> <span class="token hvariable">a</span><span class="token punctuation">]</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Next up, we have to modify the&nbsp;<code>goLeft</code>&nbsp;and&nbsp;<code>goRight</code>&nbsp;functions to store information about the paths that we didn't take in our breadcrumbs, instead of ignoring that information like they did before. Here's&nbsp;<code>goLeft</code>:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">goLeft</span> <span class="token operator">::</span> <span class="token punctuation">(</span><span class="token constant">Tree</span> <span class="token hvariable">a</span><span class="token punctuation">,</span> <span class="token constant">Breadcrumbs</span> <span class="token hvariable">a</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token punctuation">(</span><span class="token constant">Tree</span> <span class="token hvariable">a</span><span class="token punctuation">,</span> <span class="token constant">Breadcrumbs</span> <span class="token hvariable">a</span><span class="token punctuation">)</span>
<span class="token hvariable">goLeft</span> <span class="token punctuation">(</span><span class="token constant">Node</span> <span class="token hvariable">x</span> <span class="token hvariable">l</span> <span class="token hvariable">r</span><span class="token punctuation">,</span> <span class="token hvariable">bs</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token hvariable">l</span><span class="token punctuation">,</span> <span class="token constant">LeftCrumb</span> <span class="token hvariable">x</span> <span class="token hvariable">r</span><span class="token operator">:</span><span class="token hvariable">bs</span><span class="token punctuation">)</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>You can see that it's very similar to our previous&nbsp;<code>goLeft</code>, only instead of just adding a&nbsp;<code>L</code>&nbsp;to the head of our list of breadcrumbs, we add a&nbsp;<code>LeftCrumb</code>&nbsp;to signify that we went left and we equip our&nbsp;<code>LeftCrumb</code>&nbsp;with the element in the node that we moved from (that's the&nbsp;<code>x</code>) and the right sub-tree that we chose not to visit.</p></div><div><p>Note that this function assumes that the current tree that's under focus isn't&nbsp;<code>Empty</code>. An empty tree doesn't have any sub-trees, so if we try to go left from an empty tree, an error will occur because the pattern match on&nbsp;<code>Node</code>&nbsp;won't succeed and there's no pattern that takes care of&nbsp;<code>Empty</code>.</p></div><div><p><code>goRight</code>&nbsp;is similar:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">goRight</span> <span class="token operator">::</span> <span class="token punctuation">(</span><span class="token constant">Tree</span> <span class="token hvariable">a</span><span class="token punctuation">,</span> <span class="token constant">Breadcrumbs</span> <span class="token hvariable">a</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token punctuation">(</span><span class="token constant">Tree</span> <span class="token hvariable">a</span><span class="token punctuation">,</span> <span class="token constant">Breadcrumbs</span> <span class="token hvariable">a</span><span class="token punctuation">)</span>
<span class="token hvariable">goRight</span> <span class="token punctuation">(</span><span class="token constant">Node</span> <span class="token hvariable">x</span> <span class="token hvariable">l</span> <span class="token hvariable">r</span><span class="token punctuation">,</span> <span class="token hvariable">bs</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token hvariable">r</span><span class="token punctuation">,</span> <span class="token constant">RightCrumb</span> <span class="token hvariable">x</span> <span class="token hvariable">l</span><span class="token operator">:</span><span class="token hvariable">bs</span><span class="token punctuation">)</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>We were previously able to go left and right. What we've gotten now is the ability to actualy go back up by remembering stuff about the parent nodes and the paths that we didn't visit. Here's the&nbsp;<code>goUp</code>&nbsp;function:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">goUp</span> <span class="token operator">::</span> <span class="token punctuation">(</span><span class="token constant">Tree</span> <span class="token hvariable">a</span><span class="token punctuation">,</span> <span class="token constant">Breadcrumbs</span> <span class="token hvariable">a</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token punctuation">(</span><span class="token constant">Tree</span> <span class="token hvariable">a</span><span class="token punctuation">,</span> <span class="token constant">Breadcrumbs</span> <span class="token hvariable">a</span><span class="token punctuation">)</span>
<span class="token hvariable">goUp</span> <span class="token punctuation">(</span><span class="token hvariable">t</span><span class="token punctuation">,</span> <span class="token constant">LeftCrumb</span> <span class="token hvariable">x</span> <span class="token hvariable">r</span><span class="token operator">:</span><span class="token hvariable">bs</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token constant">Node</span> <span class="token hvariable">x</span> <span class="token hvariable">t</span> <span class="token hvariable">r</span><span class="token punctuation">,</span> <span class="token hvariable">bs</span><span class="token punctuation">)</span>
<span class="token hvariable">goUp</span> <span class="token punctuation">(</span><span class="token hvariable">t</span><span class="token punctuation">,</span> <span class="token constant">RightCrumb</span> <span class="token hvariable">x</span> <span class="token hvariable">l</span><span class="token operator">:</span><span class="token hvariable">bs</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token constant">Node</span> <span class="token hvariable">x</span> <span class="token hvariable">l</span> <span class="token hvariable">t</span><span class="token punctuation">,</span> <span class="token hvariable">bs</span><span class="token punctuation">)</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p><img alt="asstronaut" src="http://learnyouahaskell.com/asstronaut.png" referrerpolicy="no-referrer"></p></div><div><p>We're focusing on the tree&nbsp;<code>t</code>&nbsp;and we check what the latest&nbsp;<code>Crumb</code>&nbsp;is. If it's a&nbsp;<code>LeftCrumb</code>, then we construct a new tree where our tree&nbsp;<code>t</code>&nbsp;is the left sub-tree and we use the information about the right sub-tree that we didn't visit and the element to fill out the rest of the&nbsp;<code>Node</code>. Because we moved back so to speak and picked up the last breadcrumb to recreate with it the parent tree, the new list of breadcrumbs doesn't contain it.</p></div><div><p>Note that this function causes an error if we're already at the top of a tree and we want to move up. Later on, we'll use the&nbsp;<code>Maybe</code>&nbsp;monad to represent possible failure when moving focus.</p></div><div><p>With a pair of&nbsp;<code>Tree a</code>&nbsp;and&nbsp;<code>Breadcrumbs a</code>, we have all the information to rebuild the whole tree and we also have a focus on a sub-tree. This scheme also enables us to easily move up, left and right. Such a pair that contains a focused part of a data structure and its surroundings is called a zipper, because moving our focus up and down the data structure resembles the operation of a zipper on a regular pair of pants. So it's cool to make a type synonym as such:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token keyword">type</span> <span class="token constant">Zipper</span> <span class="token hvariable">a</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token constant">Tree</span> <span class="token hvariable">a</span><span class="token punctuation">,</span> <span class="token constant">Breadcrumbs</span> <span class="token hvariable">a</span><span class="token punctuation">)</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>I'd prefer naming the type synonym&nbsp;<code>Focus</code>&nbsp;because that makes it clearer that we're focusing on a part of a data structure, but the term zipper is more widely used to describe such a setup, so we'll stick with&nbsp;<code>Zipper</code>.</p></div><div><h3 data-heading="Manipulating trees under focus" id="Manipulating_trees_under_focus" style="display: flex;"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>Manipulating trees under focus</h3></div><div><p>Now that we can move up and down, let's make a function that modifies the element in the root of the sub-tree that the zipper is focusing on:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">modify</span> <span class="token operator">::</span> <span class="token punctuation">(</span><span class="token hvariable">a</span> <span class="token operator">-&gt;</span> <span class="token hvariable">a</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token constant">Zipper</span> <span class="token hvariable">a</span> <span class="token operator">-&gt;</span> <span class="token constant">Zipper</span> <span class="token hvariable">a</span>
<span class="token hvariable">modify</span> <span class="token hvariable">f</span> <span class="token punctuation">(</span><span class="token constant">Node</span> <span class="token hvariable">x</span> <span class="token hvariable">l</span> <span class="token hvariable">r</span><span class="token punctuation">,</span> <span class="token hvariable">bs</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token constant">Node</span> <span class="token punctuation">(</span><span class="token hvariable">f</span> <span class="token hvariable">x</span><span class="token punctuation">)</span> <span class="token hvariable">l</span> <span class="token hvariable">r</span><span class="token punctuation">,</span> <span class="token hvariable">bs</span><span class="token punctuation">)</span>
<span class="token hvariable">modify</span> <span class="token hvariable">f</span> <span class="token punctuation">(</span><span class="token constant">Empty</span><span class="token punctuation">,</span> <span class="token hvariable">bs</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token constant">Empty</span><span class="token punctuation">,</span> <span class="token hvariable">bs</span><span class="token punctuation">)</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>If we're focusing on a node, we modify its root element with the function&nbsp;<code>f</code>. If we're focusing on an empty tree, we leave it as it is. Now we can start off with a tree, move to anywhere we want and modify an element, all while keeping focus on that element so that we can easily move further up or down. An example:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token keyword">let</span> <span class="token hvariable">newFocus</span> <span class="token operator">=</span> <span class="token hvariable">modify</span> <span class="token punctuation">(</span><span class="token operator">\</span><span class="token hvariable">_</span> <span class="token operator">-&gt;</span> <span class="token char string">'P'</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token hvariable">goRight</span> <span class="token punctuation">(</span><span class="token hvariable">goLeft</span> <span class="token punctuation">(</span><span class="token hvariable">freeTree</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>We go left, then right and then modify the root element by replacing it with a&nbsp;<code>'P'</code>. This reads even better if we use&nbsp;<code>-:</code>:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token keyword">let</span> <span class="token hvariable">newFocus</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token hvariable">freeTree</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-:</span> <span class="token hvariable">goLeft</span> <span class="token operator">-:</span> <span class="token hvariable">goRight</span> <span class="token operator">-:</span> <span class="token hvariable">modify</span> <span class="token punctuation">(</span><span class="token operator">\</span><span class="token hvariable">_</span> <span class="token operator">-&gt;</span> <span class="token char string">'P'</span><span class="token punctuation">)</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>We can then move up if we want and replace an element with a mysterious&nbsp;<code>'X'</code>:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token keyword">let</span> <span class="token hvariable">newFocus2</span> <span class="token operator">=</span> <span class="token hvariable">modify</span> <span class="token punctuation">(</span><span class="token operator">\</span><span class="token hvariable">_</span> <span class="token operator">-&gt;</span> <span class="token char string">'X'</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token hvariable">goUp</span> <span class="token hvariable">newFocus</span><span class="token punctuation">)</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Or if we wrote it with&nbsp;<code>-:</code>:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token keyword">let</span> <span class="token hvariable">newFocus2</span> <span class="token operator">=</span> <span class="token hvariable">newFocus</span> <span class="token operator">-:</span> <span class="token hvariable">goUp</span> <span class="token operator">-:</span> <span class="token hvariable">modify</span> <span class="token punctuation">(</span><span class="token operator">\</span><span class="token hvariable">_</span> <span class="token operator">-&gt;</span> <span class="token char string">'X'</span><span class="token punctuation">)</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Moving up is easy because the breadcrumbs that we leave form the part of the data structure that we're not focusing on, but it's inverted, sort of like turning a sock inside out. That's why when we want to move up, we don't have to start from the root and make our way down, but we just take the top of our inverted tree, thereby uninverting a part of it and adding it to our focus.</p></div><div><p>Each node has two sub-trees, even if those sub-trees are empty trees. So if we're focusing on an empty sub-tree, one thing we can do is to replace it with a non-empty subtree, thus attaching a tree to a leaf node. The code for this is simple:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">attach</span> <span class="token operator">::</span> <span class="token constant">Tree</span> <span class="token hvariable">a</span> <span class="token operator">-&gt;</span> <span class="token constant">Zipper</span> <span class="token hvariable">a</span> <span class="token operator">-&gt;</span> <span class="token constant">Zipper</span> <span class="token hvariable">a</span>
<span class="token hvariable">attach</span> <span class="token hvariable">t</span> <span class="token punctuation">(</span><span class="token hvariable">_</span><span class="token punctuation">,</span> <span class="token hvariable">bs</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token hvariable">t</span><span class="token punctuation">,</span> <span class="token hvariable">bs</span><span class="token punctuation">)</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>We take a tree and a zipper and return a new zipper that has its focus replaced with the supplied tree. Not only can we extend trees this way by replacing empty sub-trees with new trees, we can also replace whole existing sub-trees. Let's attach a tree to the far left of our&nbsp;<code>freeTree</code>:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token keyword">let</span> <span class="token hvariable">farLeft</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token hvariable">freeTree</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-:</span> <span class="token hvariable">goLeft</span> <span class="token operator">-:</span> <span class="token hvariable">goLeft</span> <span class="token operator">-:</span> <span class="token hvariable">goLeft</span> <span class="token operator">-:</span> <span class="token hvariable">goLeft</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token keyword">let</span> <span class="token hvariable">newFocus</span> <span class="token operator">=</span> <span class="token hvariable">farLeft</span> <span class="token operator">-:</span> <span class="token hvariable">attach</span> <span class="token punctuation">(</span><span class="token constant">Node</span> <span class="token char string">'Z'</span> <span class="token constant">Empty</span> <span class="token constant">Empty</span><span class="token punctuation">)</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p><code>newFocus</code>&nbsp;is now focused on the tree that we just attached and the rest of the tree lies inverted in the breadcrumbs. If we were to use&nbsp;<code>goUp</code>&nbsp;to walk all the way to the top of the tree, it would be the same tree as&nbsp;<code>freeTree</code>&nbsp;but with an additional&nbsp;<code>'Z'</code>&nbsp;on its far left.</p></div><div><h3 data-heading="I'm going straight to the top, oh yeah, up where the air is fresh and clean!" id="I'm_going_straight_to_the_top,_oh_yeah,_up_where_the_air_is_fresh_and_clean!" style="display: flex;"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>I'm going straight to the top, oh yeah, up where the air is fresh and clean!</h3></div><div><p>Making a function that walks all the way to the top of the tree, regardless of what we're focusing on, is really easy. Here it is:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">topMost</span> <span class="token operator">::</span> <span class="token constant">Zipper</span> <span class="token hvariable">a</span> <span class="token operator">-&gt;</span> <span class="token constant">Zipper</span> <span class="token hvariable">a</span>
<span class="token hvariable">topMost</span> <span class="token punctuation">(</span><span class="token hvariable">t</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token hvariable">t</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
<span class="token hvariable">topMost</span> <span class="token hvariable">z</span> <span class="token operator">=</span> <span class="token hvariable">topMost</span> <span class="token punctuation">(</span><span class="token hvariable">goUp</span> <span class="token hvariable">z</span><span class="token punctuation">)</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>If our trail of beefed up breadcrumbs is empty, this means that we're already at the root of our tree, so we just return the current focus. Otherwise, we go up to get the focus of the parent node and then recursively apply&nbsp;<code>topMost</code>&nbsp;to that. So now we can walk around our tree, going left and right and up, applying&nbsp;<code>modify</code>&nbsp;and&nbsp;<code>attach</code>&nbsp;as we go along and then when we're done with our modifications, we use&nbsp;<code>topMost</code>&nbsp;to focus on the root of our tree and see the changes that we've done in proper perspective.</p></div><div><h2 data-heading="Focusing on lists" id="Focusing_on_lists" style="display: flex;"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>Focusing on lists</h2></div><div><p>Zippers can be used with pretty much any data structure, so it's no surprise that they can be used to focus on sub-lists of lists. After all, lists are pretty much like trees, only where a node in a tree has an element (or not) and several sub-trees, a node in a list has an element and only a single sub-list. When we&nbsp;<a data-tooltip-position="top" aria-label="http://learnyouahaskell.com/making-our-own-types-and-typeclasses#recursive-data-structures" rel="noopener" class="external-link" href="http://learnyouahaskell.com/making-our-own-types-and-typeclasses#recursive-data-structures" target="_blank">implemented our own lists</a>, we defined our data type like so:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token keyword">data</span> <span class="token constant">List</span> <span class="token hvariable">a</span> <span class="token operator">=</span> <span class="token constant">Empty</span> <span class="token operator">|</span> <span class="token constant">Cons</span> <span class="token hvariable">a</span> <span class="token punctuation">(</span><span class="token constant">List</span> <span class="token hvariable">a</span><span class="token punctuation">)</span> <span class="token keyword">deriving</span> <span class="token punctuation">(</span><span class="token constant">Show</span><span class="token punctuation">,</span> <span class="token constant">Read</span><span class="token punctuation">,</span> <span class="token constant">Eq</span><span class="token punctuation">,</span> <span class="token constant">Ord</span><span class="token punctuation">)</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p><img alt="the best damn thing" src="http://learnyouahaskell.com/picard.png" referrerpolicy="no-referrer"></p></div><div><p>Contrast this with our definition of our binary tree and it's easy to see how lists can be viewed as trees where each node has only one sub-tree.</p></div><div><p>A list like&nbsp;<code>[1,2,3]</code>&nbsp;can be written as&nbsp;<code>1:2:3:[]</code>. It consists of the head of the list, which is&nbsp;<code>1</code>&nbsp;and then the list's tail, which is&nbsp;<code>2:3:[]</code>. In turn,&nbsp;<code>2:3:[]</code>&nbsp;also has a head, which is&nbsp;<code>2</code>&nbsp;and a tail, which is&nbsp;<code>3:[]</code>. With&nbsp;<code>3:[]</code>, the&nbsp;<code>3</code>&nbsp;is the head and the tail is the empty list&nbsp;<code>[]</code>.</p></div><div><p>Let's make a zipper for lists. To change the focus on sub-lists of a list, we move either forward or back (whereas with trees we moved either up or left or right). The focused part will be a sub-tree and along with that we'll leave breadcrumbs as we move forward. Now what would a single breadcrumb for a list consist of? When we were dealing with binary trees, we said that a breadcrumb has to hold the element in the root of the parent node along with all the sub-trees that we didn't choose. It also had to remember if we went left or right. So, it had to have all the information that a node has except for the sub-tree that we chose to focus on.</p></div><div><p>Lists are simpler than trees, so we don't have to remember if we went left or right, because there's only one way to go deeper into a list. Because there's only one sub-tree to each node, we don't have to remember the paths that we didn't take either. It seems that all we have to remember is the previous element. If we have a list like&nbsp;<code>[3,4,5]</code>&nbsp;and we know that the previous element was&nbsp;<code>2</code>, we can go back by just putting that element at the head of our list, getting&nbsp;<code>[2,3,4,5]</code>.</p></div><div><p>Because a single breadcrumb here is just the element, we don't really have to put it inside a data type, like we did when we made the&nbsp;<code>Crumb</code>&nbsp;data type for tree zippers:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token keyword">type</span> <span class="token constant">ListZipper</span> <span class="token hvariable">a</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token hvariable">a</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token hvariable">a</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>The first list represents the list that we're focusing on and the second list is the list of breadcrumbs. Let's make functions that go forward and back into lists:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">goForward</span> <span class="token operator">::</span> <span class="token constant">ListZipper</span> <span class="token hvariable">a</span> <span class="token operator">-&gt;</span> <span class="token constant">ListZipper</span> <span class="token hvariable">a</span>
<span class="token hvariable">goForward</span> <span class="token punctuation">(</span><span class="token hvariable">x</span><span class="token operator">:</span><span class="token hvariable">xs</span><span class="token punctuation">,</span> <span class="token hvariable">bs</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token hvariable">xs</span><span class="token punctuation">,</span> <span class="token hvariable">x</span><span class="token operator">:</span><span class="token hvariable">bs</span><span class="token punctuation">)</span>

<span class="token hvariable">goBack</span> <span class="token operator">::</span> <span class="token constant">ListZipper</span> <span class="token hvariable">a</span> <span class="token operator">-&gt;</span> <span class="token constant">ListZipper</span> <span class="token hvariable">a</span>
<span class="token hvariable">goBack</span> <span class="token punctuation">(</span><span class="token hvariable">xs</span><span class="token punctuation">,</span> <span class="token hvariable">b</span><span class="token operator">:</span><span class="token hvariable">bs</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token hvariable">b</span><span class="token operator">:</span><span class="token hvariable">xs</span><span class="token punctuation">,</span> <span class="token hvariable">bs</span><span class="token punctuation">)</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>When we're going forward, we focus on the tail of the current list and leave the head element as a breadcrumb. When we're moving backwards, we take the latest breadcrumb and put it at the beginning of the list.</p></div><div><p>Here are these two functions in action:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token keyword">let</span> <span class="token hvariable">xs</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">]</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token hvariable">goForward</span> <span class="token punctuation">(</span><span class="token hvariable">xs</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token hvariable">goForward</span> <span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token hvariable">goForward</span> <span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token hvariable">goBack</span> <span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>We see that the breadcrumbs in the case of lists are nothing more but a reversed part of our list. The element that we move away from always goes into the head of the breadcrumbs, so it's easy to move back by just taking that element from the head of the breadcrumbs and making it the head of our focus.</p></div><div><p>This also makes it easier to see why we call this a zipper, because this really looks like the slider of a zipper moving up and down.</p></div><div><p>If you were making a text editor, you could use a list of strings to represent the lines of text that are currently opened and you could then use a zipper so that you know which line the cursor is currently focused on. By using a zipper, it would also make it easier to insert new lines anywhere in the text or delete existing ones.</p></div><div><h2 data-heading="A very simple file system" id="A_very_simple_file_system" style="display: flex;"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>A very simple file system</h2></div><div><p>Now that we know how zippers work, let's use trees to represent a very simple file system and then make a zipper for that file system, which will allow us to move between folders, just like we usually do when jumping around our file system.</p></div><div><p>If we take a simplistic view of the average hierarchical file system, we see that it's mostly made up of files and folders. Files are units of data and come with a name, whereas folders are used to organize those files and can contain files or other folders. So let's say that an item in a file system is either a file, which comes with a name and some data, or a folder, which has a name and then a bunch of items that are either files or folders themselves. Here's a data type for this and some type synonyms so we know what's what:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token keyword">type</span> <span class="token constant">Name</span> <span class="token operator">=</span> <span class="token constant">String</span>
<span class="token keyword">type</span> <span class="token constant">Data</span> <span class="token operator">=</span> <span class="token constant">String</span>
<span class="token keyword">data</span> <span class="token constant">FSItem</span> <span class="token operator">=</span> <span class="token constant">File</span> <span class="token constant">Name</span> <span class="token constant">Data</span> <span class="token operator">|</span> <span class="token constant">Folder</span> <span class="token constant">Name</span> <span class="token punctuation">[</span><span class="token constant">FSItem</span><span class="token punctuation">]</span> <span class="token keyword">deriving</span> <span class="token punctuation">(</span><span class="token constant">Show</span><span class="token punctuation">)</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>A file comes with two strings, which represent its name and the data it holds. A folder comes with a string that is its name and a list of items. If that list is empty, then we have an empty folder.</p></div><div><p>Here's a folder with some files and sub-folders:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">myDisk</span> <span class="token operator">::</span> <span class="token constant">FSItem</span>
<span class="token hvariable">myDisk</span> <span class="token operator">=</span>
    <span class="token constant">Folder</span> <span class="token string">"root"</span> 
        <span class="token punctuation">[</span> <span class="token constant">File</span> <span class="token string">"goat_yelling_like_man.wmv"</span> <span class="token string">"baaaaaa"</span>
        <span class="token punctuation">,</span> <span class="token constant">File</span> <span class="token string">"pope_time.avi"</span> <span class="token string">"god bless"</span>
        <span class="token punctuation">,</span> <span class="token constant">Folder</span> <span class="token string">"pics"</span>
            <span class="token punctuation">[</span> <span class="token constant">File</span> <span class="token string">"ape_throwing_up.jpg"</span> <span class="token string">"bleargh"</span>
            <span class="token punctuation">,</span> <span class="token constant">File</span> <span class="token string">"watermelon_smash.gif"</span> <span class="token string">"smash!!"</span>
            <span class="token punctuation">,</span> <span class="token constant">File</span> <span class="token string">"skull_man(scary).bmp"</span> <span class="token string">"Yikes!"</span>
            <span class="token punctuation">]</span>
        <span class="token punctuation">,</span> <span class="token constant">File</span> <span class="token string">"dijon_poupon.doc"</span> <span class="token string">"best mustard"</span>
        <span class="token punctuation">,</span> <span class="token constant">Folder</span> <span class="token string">"programs"</span>
            <span class="token punctuation">[</span> <span class="token constant">File</span> <span class="token string">"fartwizard.exe"</span> <span class="token string">"10gotofart"</span>
            <span class="token punctuation">,</span> <span class="token constant">File</span> <span class="token string">"owl_bandit.dmg"</span> <span class="token string">"mov eax, h00t"</span>
            <span class="token punctuation">,</span> <span class="token constant">File</span> <span class="token string">"not_a_virus.exe"</span> <span class="token string">"really not a virus"</span>
            <span class="token punctuation">,</span> <span class="token constant">Folder</span> <span class="token string">"source code"</span>
                <span class="token punctuation">[</span> <span class="token constant">File</span> <span class="token string">"best_hs_prog.hs"</span> <span class="token string">"main = print (fix error)"</span>
                <span class="token punctuation">,</span> <span class="token constant">File</span> <span class="token string">"random.hs"</span> <span class="token string">"main = print 4"</span>
                <span class="token punctuation">]</span>
            <span class="token punctuation">]</span>
        <span class="token punctuation">]</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>That's actually what my disk contains right now.</p></div><div><h3 data-heading="A zipper for our file system" id="A_zipper_for_our_file_system" style="display: flex;"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>A zipper for our file system</h3></div><div><p><img alt="spongedisk" src="http://learnyouahaskell.com/spongedisk.png" referrerpolicy="no-referrer"></p></div><div><p>Now that we have a file system, all we need is a zipper so we can zip and zoom around it and add, modify and remove files as well as folders. Like with binary trees and lists, we're going to be leaving breadcrumbs that contain info about all the stuff that we chose not to visit. Like we said, a single breadcrumb should be kind of like a node, only it should contain everything except the sub-tree that we're currently focusing on. It should also note where the hole is so that once we move back up, we can plug our previous focus into the hole.</p></div><div><p>In this case, a breadcrumb should be like a folder, only it should be missing the folder that we currently chose. Why not like a file, you ask? Well, because once we're focusing on a file, we can't move deeper into the file system, so it doesn't make sense to leave a breadcrumb that says that we came from a file. A file is sort of like an empty tree.</p></div><div><p>If we're focusing on the folder&nbsp;<code>"root"</code>&nbsp;and we then focus on the file&nbsp;<code>"dijon_poupon.doc"</code>, what should the breadcrumb that we leave look like? Well, it should contain the name of its parent folder along with the items that come before the file that we're focusing on and the items that come after it. So all we need is a&nbsp;<code>Name</code>&nbsp;and two lists of items. By keeping separate lists for the items that come before the item that we're focusing and for the items that come after it, we know exactly where to place it once we move back up. So this way, we know where the hole is.</p></div><div><p>Here's our breadcrumb type for the file system:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token keyword">data</span> <span class="token constant">FSCrumb</span> <span class="token operator">=</span> <span class="token constant">FSCrumb</span> <span class="token constant">Name</span> <span class="token punctuation">[</span><span class="token constant">FSItem</span><span class="token punctuation">]</span> <span class="token punctuation">[</span><span class="token constant">FSItem</span><span class="token punctuation">]</span> <span class="token keyword">deriving</span> <span class="token punctuation">(</span><span class="token constant">Show</span><span class="token punctuation">)</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>And here's a type synonym for our zipper:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token keyword">type</span> <span class="token constant">FSZipper</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token constant">FSItem</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token constant">FSCrumb</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Going back up in the hierarchy is very simple. We just take the latest breadcrumb and assemble a new focus from the current focus and breadcrumb. Like so:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">fsUp</span> <span class="token operator">::</span> <span class="token constant">FSZipper</span> <span class="token operator">-&gt;</span> <span class="token constant">FSZipper</span>
<span class="token hvariable">fsUp</span> <span class="token punctuation">(</span><span class="token hvariable">item</span><span class="token punctuation">,</span> <span class="token constant">FSCrumb</span> <span class="token hvariable">name</span> <span class="token hvariable">ls</span> <span class="token hvariable">rs</span><span class="token operator">:</span><span class="token hvariable">bs</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token constant">Folder</span> <span class="token hvariable">name</span> <span class="token punctuation">(</span><span class="token hvariable">ls</span> <span class="token operator">++</span> <span class="token punctuation">[</span><span class="token hvariable">item</span><span class="token punctuation">]</span> <span class="token operator">++</span> <span class="token hvariable">rs</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token hvariable">bs</span><span class="token punctuation">)</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Because our breadcrumb knew what the parent folder's name was, as well as the items that came before our focused item in the folder (that's&nbsp;<code>ls</code>) and the ones that came after (that's&nbsp;<code>rs</code>), moving up was easy.</p></div><div><p>How about going deeper into the file system? If we're in the&nbsp;<code>"root"</code>&nbsp;and we want to focus on&nbsp;<code>"dijon_poupon.doc"</code>, the breadcrumb that we leave is going to include the name&nbsp;<code>"root"</code>&nbsp;along with the items that precede&nbsp;<code>"dijon_poupon.doc"</code>&nbsp;and the ones that come after it.</p></div><div><p>Here's a function that, given a name, focuses on a file of folder that's located in the current focused folder:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token import-statement"><span class="token keyword">import</span> Data<span class="token punctuation">.</span>List</span> <span class="token punctuation">(</span><span class="token builtin">break</span><span class="token punctuation">)</span>

<span class="token hvariable">fsTo</span> <span class="token operator">::</span> <span class="token constant">Name</span> <span class="token operator">-&gt;</span> <span class="token constant">FSZipper</span> <span class="token operator">-&gt;</span> <span class="token constant">FSZipper</span>
<span class="token hvariable">fsTo</span> <span class="token hvariable">name</span> <span class="token punctuation">(</span><span class="token constant">Folder</span> <span class="token hvariable">folderName</span> <span class="token hvariable">items</span><span class="token punctuation">,</span> <span class="token hvariable">bs</span><span class="token punctuation">)</span> <span class="token operator">=</span> 
    <span class="token keyword">let</span> <span class="token punctuation">(</span><span class="token hvariable">ls</span><span class="token punctuation">,</span> <span class="token hvariable">item</span><span class="token operator">:</span><span class="token hvariable">rs</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token builtin">break</span> <span class="token punctuation">(</span><span class="token hvariable">nameIs</span> <span class="token hvariable">name</span><span class="token punctuation">)</span> <span class="token hvariable">items</span>
    <span class="token keyword">in</span>  <span class="token punctuation">(</span><span class="token hvariable">item</span><span class="token punctuation">,</span> <span class="token constant">FSCrumb</span> <span class="token hvariable">folderName</span> <span class="token hvariable">ls</span> <span class="token hvariable">rs</span><span class="token operator">:</span><span class="token hvariable">bs</span><span class="token punctuation">)</span>

<span class="token hvariable">nameIs</span> <span class="token operator">::</span> <span class="token constant">Name</span> <span class="token operator">-&gt;</span> <span class="token constant">FSItem</span> <span class="token operator">-&gt;</span> <span class="token constant">Bool</span>
<span class="token hvariable">nameIs</span> <span class="token hvariable">name</span> <span class="token punctuation">(</span><span class="token constant">Folder</span> <span class="token hvariable">folderName</span> <span class="token hvariable">_</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token hvariable">name</span> <span class="token operator">==</span> <span class="token hvariable">folderName</span>
<span class="token hvariable">nameIs</span> <span class="token hvariable">name</span> <span class="token punctuation">(</span><span class="token constant">File</span> <span class="token hvariable">fileName</span> <span class="token hvariable">_</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token hvariable">name</span> <span class="token operator">==</span> <span class="token hvariable">fileName</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p><code>fsTo</code>&nbsp;takes a&nbsp;<code>Name</code>&nbsp;and a&nbsp;<code>FSZipper</code>&nbsp;and returns a new&nbsp;<code>FSZipper</code>&nbsp;that focuses on the file with the given name. That file has to be in the current focused folder. This function doesn't search all over the place, it just looks at the current folder.</p></div><div><p><img alt="wow cool great" src="http://learnyouahaskell.com/cool.png" referrerpolicy="no-referrer"></p></div><div><p>First we use&nbsp;<code>break</code>&nbsp;to break the list of items in a folder into those that precede the file that we're searching for and those that come after it. If you remember,&nbsp;<code>break</code>&nbsp;takes a predicate and a list and returns a pair of lists. The first list in the pair holds items for which the predicate returns&nbsp;<code>False</code>. Then, once the predicate returns&nbsp;<code>True</code>&nbsp;for an item, it places that item and the rest of the list in the second item of the pair. We made an auxilliary function called&nbsp;<code>nameIs</code>&nbsp;that takes a name and a file system item and returns&nbsp;<code>True</code>&nbsp;if the names match.</p></div><div><p>So now,&nbsp;<code>ls</code>&nbsp;is a list that contains the items that precede the item that we're searching for,&nbsp;<code>item</code>&nbsp;is that very item and&nbsp;<code>rs</code>&nbsp;is the list of items that come after it in its folder. Now that we have this, we just present the item that we got from&nbsp;<code>break</code>&nbsp;as the focus and build a breadcrumb that has all the data it needs.</p></div><div><p>Note that if the name we're looking for isn't in the folder, the pattern&nbsp;<code>item:rs</code>&nbsp;will try to match on an empty list and we'll get an error. Also, if our current focus isn't a folder at all but a file, we get an error as well and the program crashes.</p></div><div><p>Now we can move up and down our file system. Let's start at the root and walk to the file&nbsp;<code>"skull_man(scary).bmp"</code>:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token keyword">let</span> <span class="token hvariable">newFocus</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token hvariable">myDisk</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-:</span> <span class="token hvariable">fsTo</span> <span class="token string">"pics"</span> <span class="token operator">-:</span> <span class="token hvariable">fsTo</span> <span class="token string">"skull_man(scary).bmp"</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p><code>newFocus</code>&nbsp;is now a zipper that's focused on the&nbsp;<code>"skull_man(scary).bmp"</code>&nbsp;file. Let's get the first component of the zipper (the focus itself) and see if that's really true:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token builtin">fst</span> <span class="token hvariable">newFocus</span>
<span class="token constant">File</span> <span class="token string">"skull_man(scary).bmp"</span> <span class="token string">"Yikes!"</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Let's move up and then focus on its neighboring file&nbsp;<code>"watermelon_smash.gif"</code>:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token keyword">let</span> <span class="token hvariable">newFocus2</span> <span class="token operator">=</span> <span class="token hvariable">newFocus</span> <span class="token operator">-:</span> <span class="token hvariable">fsUp</span> <span class="token operator">-:</span> <span class="token hvariable">fsTo</span> <span class="token string">"watermelon_smash.gif"</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token builtin">fst</span> <span class="token hvariable">newFocus2</span>
<span class="token constant">File</span> <span class="token string">"watermelon_smash.gif"</span> <span class="token string">"smash!!"</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><h3 data-heading="Manipulating our file system" id="Manipulating_our_file_system" style="display: flex;"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>Manipulating our file system</h3></div><div><p>Now that we know how to navigate our file system, manipulating it is easy. Here's a function that renames the currently focused file or folder:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">fsRename</span> <span class="token operator">::</span> <span class="token constant">Name</span> <span class="token operator">-&gt;</span> <span class="token constant">FSZipper</span> <span class="token operator">-&gt;</span> <span class="token constant">FSZipper</span>
<span class="token hvariable">fsRename</span> <span class="token hvariable">newName</span> <span class="token punctuation">(</span><span class="token constant">Folder</span> <span class="token hvariable">name</span> <span class="token hvariable">items</span><span class="token punctuation">,</span> <span class="token hvariable">bs</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token constant">Folder</span> <span class="token hvariable">newName</span> <span class="token hvariable">items</span><span class="token punctuation">,</span> <span class="token hvariable">bs</span><span class="token punctuation">)</span>
<span class="token hvariable">fsRename</span> <span class="token hvariable">newName</span> <span class="token punctuation">(</span><span class="token constant">File</span> <span class="token hvariable">name</span> <span class="token hvariable">dat</span><span class="token punctuation">,</span> <span class="token hvariable">bs</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token constant">File</span> <span class="token hvariable">newName</span> <span class="token hvariable">dat</span><span class="token punctuation">,</span> <span class="token hvariable">bs</span><span class="token punctuation">)</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Now we can rename our&nbsp;<code>"pics"</code>&nbsp;folder to&nbsp;<code>"cspi"</code>:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token keyword">let</span> <span class="token hvariable">newFocus</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token hvariable">myDisk</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-:</span> <span class="token hvariable">fsTo</span> <span class="token string">"pics"</span> <span class="token operator">-:</span> <span class="token hvariable">fsRename</span> <span class="token string">"cspi"</span> <span class="token operator">-:</span> <span class="token hvariable">fsUp</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>We descended to the&nbsp;<code>"pics"</code>&nbsp;folder, renamed it and then moved back up.</p></div><div><p>How about a function that makes a new item in the current folder? Behold:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">fsNewFile</span> <span class="token operator">::</span> <span class="token constant">FSItem</span> <span class="token operator">-&gt;</span> <span class="token constant">FSZipper</span> <span class="token operator">-&gt;</span> <span class="token constant">FSZipper</span>
<span class="token hvariable">fsNewFile</span> <span class="token hvariable">item</span> <span class="token punctuation">(</span><span class="token constant">Folder</span> <span class="token hvariable">folderName</span> <span class="token hvariable">items</span><span class="token punctuation">,</span> <span class="token hvariable">bs</span><span class="token punctuation">)</span> <span class="token operator">=</span> 
    <span class="token punctuation">(</span><span class="token constant">Folder</span> <span class="token hvariable">folderName</span> <span class="token punctuation">(</span><span class="token hvariable">item</span><span class="token operator">:</span><span class="token hvariable">items</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token hvariable">bs</span><span class="token punctuation">)</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Easy as pie. Note that this would crash if we tried to add an item but weren't focusing on a folder, but were focusing on a file instead.</p></div><div><p>Let's add a file to our&nbsp;<code>"pics"</code>&nbsp;folder and then move back up to the root:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token keyword">let</span> <span class="token hvariable">newFocus</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token hvariable">myDisk</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-:</span> <span class="token hvariable">fsTo</span> <span class="token string">"pics"</span> <span class="token operator">-:</span> <span class="token hvariable">fsNewFile</span> <span class="token punctuation">(</span><span class="token constant">File</span> <span class="token string">"heh.jpg"</span> <span class="token string">"lol"</span><span class="token punctuation">)</span> <span class="token operator">-:</span> <span class="token hvariable">fsUp</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>What's really cool about all this is that when we modify our file system, it doesn't actually modify it in place but it returns a whole new file system. That way, we have access to our old file system (in this case,&nbsp;<code>myDisk</code>) as well as the new one (the first component of&nbsp;<code>newFocus</code>). So by using zippers, we get versioning for free, meaning that we can always refer to older versions of data structures even after we've changed them, so to speak. This isn't unique to zippers, but is a property of Haskell because its data structures are immutable. With zippers however, we get the ability to easily and efficiently walk around our data structures, so the persistence of Haskell's data structures really begins to shine.</p></div><div><h2 data-heading="Watch your step" id="Watch_your_step" style="display: flex;"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>Watch your step</h2></div><div><p>So far, while walking through our data structures, whether they were binary trees, lists or file systems, we didn't really care if we took a step too far and fell off. For instance, our&nbsp;<code>goLeft</code>&nbsp;function takes a zipper of a binary tree and moves the focus to its left sub-tree:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">goLeft</span> <span class="token operator">::</span> <span class="token constant">Zipper</span> <span class="token hvariable">a</span> <span class="token operator">-&gt;</span> <span class="token constant">Zipper</span> <span class="token hvariable">a</span>
<span class="token hvariable">goLeft</span> <span class="token punctuation">(</span><span class="token constant">Node</span> <span class="token hvariable">x</span> <span class="token hvariable">l</span> <span class="token hvariable">r</span><span class="token punctuation">,</span> <span class="token hvariable">bs</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token hvariable">l</span><span class="token punctuation">,</span> <span class="token constant">LeftCrumb</span> <span class="token hvariable">x</span> <span class="token hvariable">r</span><span class="token operator">:</span><span class="token hvariable">bs</span><span class="token punctuation">)</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p><img alt="falling for you" src="http://learnyouahaskell.com/bigtree.png" referrerpolicy="no-referrer"></p></div><div><p>But what if the tree we're stepping off from is an empty tree? That is, what if it's not a&nbsp;<code>Node</code>, but an&nbsp;<code>Empty</code>? In this case, we'd get a runtime error because the pattern match would fail and we have made no pattern to handle an empty tree, which doesn't have any sub-trees at all. So far, we just assumed that we'd never try to focus on the left sub-tree of an empty tree as its left sub-tree doesn't exist at all. But going to the left sub-tree of an empty tree doesn't make much sense, and so far we've just conveniently ignored this.</p></div><div><p>Or what if we were already at the root of some tree and didn't have any breadcrumbs but still tried to move up? The same thing would happen. It seems that when using zippers, any step could be our last (cue ominous music). In other words, any move can result in a success, but it can also result in a failure. Does that remind you of something? Of course, monads! More specifically, the&nbsp;<code>Maybe</code>&nbsp;monad which adds a context of possible failure to normal values.</p></div><div><p>So let's use the&nbsp;<code>Maybe</code>&nbsp;monad to add a context of possible failure to our movements. We're going to take the functions that work on our binary tree zipper and we're going to make them into monadic functions. First, let's take care of possible failure in&nbsp;<code>goLeft</code>&nbsp;and&nbsp;<code>goRight</code>. So far, the failure of functions that could fail was always reflected in their result, and this time is no different. So here are&nbsp;<code>goLeft</code>&nbsp;and&nbsp;<code>goRight</code>&nbsp;with an added possibility of failure:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">goLeft</span> <span class="token operator">::</span> <span class="token constant">Zipper</span> <span class="token hvariable">a</span> <span class="token operator">-&gt;</span> <span class="token constant">Maybe</span> <span class="token punctuation">(</span><span class="token constant">Zipper</span> <span class="token hvariable">a</span><span class="token punctuation">)</span>
<span class="token hvariable">goLeft</span> <span class="token punctuation">(</span><span class="token constant">Node</span> <span class="token hvariable">x</span> <span class="token hvariable">l</span> <span class="token hvariable">r</span><span class="token punctuation">,</span> <span class="token hvariable">bs</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token constant">Just</span> <span class="token punctuation">(</span><span class="token hvariable">l</span><span class="token punctuation">,</span> <span class="token constant">LeftCrumb</span> <span class="token hvariable">x</span> <span class="token hvariable">r</span><span class="token operator">:</span><span class="token hvariable">bs</span><span class="token punctuation">)</span>
<span class="token hvariable">goLeft</span> <span class="token punctuation">(</span><span class="token constant">Empty</span><span class="token punctuation">,</span> <span class="token hvariable">_</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token constant">Nothing</span>

<span class="token hvariable">goRight</span> <span class="token operator">::</span> <span class="token constant">Zipper</span> <span class="token hvariable">a</span> <span class="token operator">-&gt;</span> <span class="token constant">Maybe</span> <span class="token punctuation">(</span><span class="token constant">Zipper</span> <span class="token hvariable">a</span><span class="token punctuation">)</span>
<span class="token hvariable">goRight</span> <span class="token punctuation">(</span><span class="token constant">Node</span> <span class="token hvariable">x</span> <span class="token hvariable">l</span> <span class="token hvariable">r</span><span class="token punctuation">,</span> <span class="token hvariable">bs</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token constant">Just</span> <span class="token punctuation">(</span><span class="token hvariable">r</span><span class="token punctuation">,</span> <span class="token constant">RightCrumb</span> <span class="token hvariable">x</span> <span class="token hvariable">l</span><span class="token operator">:</span><span class="token hvariable">bs</span><span class="token punctuation">)</span>
<span class="token hvariable">goRight</span> <span class="token punctuation">(</span><span class="token constant">Empty</span><span class="token punctuation">,</span> <span class="token hvariable">_</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token constant">Nothing</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Cool, now if we try to take a step to the left of an empty tree, we get a&nbsp;<code>Nothing</code>!</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token hvariable">goLeft</span> <span class="token punctuation">(</span><span class="token constant">Empty</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
<span class="token constant">Nothing</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token hvariable">goLeft</span> <span class="token punctuation">(</span><span class="token constant">Node</span> <span class="token char string">'A'</span> <span class="token constant">Empty</span> <span class="token constant">Empty</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
<span class="token constant">Just</span> <span class="token punctuation">(</span><span class="token constant">Empty</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token constant">LeftCrumb</span> <span class="token char string">'A'</span> <span class="token constant">Empty</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Looks good! How about going up? The problem before happened if we tried to go up but we didn't have any more breadcrumbs, which meant that we were already in the root of the tree. This is the&nbsp;<code>goUp</code>&nbsp;function that throws an error if we don't keep within the bounds of our tree:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">goUp</span> <span class="token operator">::</span> <span class="token constant">Zipper</span> <span class="token hvariable">a</span> <span class="token operator">-&gt;</span> <span class="token constant">Zipper</span> <span class="token hvariable">a</span>
<span class="token hvariable">goUp</span> <span class="token punctuation">(</span><span class="token hvariable">t</span><span class="token punctuation">,</span> <span class="token constant">LeftCrumb</span> <span class="token hvariable">x</span> <span class="token hvariable">r</span><span class="token operator">:</span><span class="token hvariable">bs</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token constant">Node</span> <span class="token hvariable">x</span> <span class="token hvariable">t</span> <span class="token hvariable">r</span><span class="token punctuation">,</span> <span class="token hvariable">bs</span><span class="token punctuation">)</span>
<span class="token hvariable">goUp</span> <span class="token punctuation">(</span><span class="token hvariable">t</span><span class="token punctuation">,</span> <span class="token constant">RightCrumb</span> <span class="token hvariable">x</span> <span class="token hvariable">l</span><span class="token operator">:</span><span class="token hvariable">bs</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token constant">Node</span> <span class="token hvariable">x</span> <span class="token hvariable">l</span> <span class="token hvariable">t</span><span class="token punctuation">,</span> <span class="token hvariable">bs</span><span class="token punctuation">)</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Now let's modify it to fail gracefully:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">goUp</span> <span class="token operator">::</span> <span class="token constant">Zipper</span> <span class="token hvariable">a</span> <span class="token operator">-&gt;</span> <span class="token constant">Maybe</span> <span class="token punctuation">(</span><span class="token constant">Zipper</span> <span class="token hvariable">a</span><span class="token punctuation">)</span>
<span class="token hvariable">goUp</span> <span class="token punctuation">(</span><span class="token hvariable">t</span><span class="token punctuation">,</span> <span class="token constant">LeftCrumb</span> <span class="token hvariable">x</span> <span class="token hvariable">r</span><span class="token operator">:</span><span class="token hvariable">bs</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token constant">Just</span> <span class="token punctuation">(</span><span class="token constant">Node</span> <span class="token hvariable">x</span> <span class="token hvariable">t</span> <span class="token hvariable">r</span><span class="token punctuation">,</span> <span class="token hvariable">bs</span><span class="token punctuation">)</span>
<span class="token hvariable">goUp</span> <span class="token punctuation">(</span><span class="token hvariable">t</span><span class="token punctuation">,</span> <span class="token constant">RightCrumb</span> <span class="token hvariable">x</span> <span class="token hvariable">l</span><span class="token operator">:</span><span class="token hvariable">bs</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token constant">Just</span> <span class="token punctuation">(</span><span class="token constant">Node</span> <span class="token hvariable">x</span> <span class="token hvariable">l</span> <span class="token hvariable">t</span><span class="token punctuation">,</span> <span class="token hvariable">bs</span><span class="token punctuation">)</span>
<span class="token hvariable">goUp</span> <span class="token punctuation">(</span><span class="token hvariable">_</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token constant">Nothing</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>If we have breadcrumbs, everything is okay and we return a successful new focus, but if we don't, then we return a failure.</p></div><div><p>Before, these functions took zippers and returned zippers, which meant that we could chain them like this to walk around:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">gchi</span><span class="token operator">&gt;</span> <span class="token keyword">let</span> <span class="token hvariable">newFocus</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token hvariable">freeTree</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">-:</span> <span class="token hvariable">goLeft</span> <span class="token operator">-:</span> <span class="token hvariable">goRight</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>But now, instead of returning&nbsp;<code>Zipper a</code>, they return&nbsp;<code>Maybe (Zipper a)</code>, so chaining functions like this won't work. We had a similar problem when we were&nbsp;<a data-tooltip-position="top" aria-label="http://learnyouahaskell.com/a-fistful-of-monads#walk-the-line" rel="noopener" class="external-link" href="http://learnyouahaskell.com/a-fistful-of-monads#walk-the-line" target="_blank">dealing with our tightrope walker</a>&nbsp;in the chapter about monads. He also walked one step at a time and each of his steps could result in failure because a bunch of birds could land on one side of his balancing pole and make him fall.</p></div><div><p>Now, the joke's on us because we're the ones doing the walking, and we're traversing a labyrinth of our own devising. Luckily, we can learn from the tightrope walker and just do what he did, which is to exchange normal function application for using&nbsp;<code>&gt;&gt;=</code>, which takes a value with a context (in our case, the&nbsp;<code>Maybe (Zipper a)</code>, which has a context of possible failure) and feeds it into a function while making sure that the context is taken care of. So just like our tightrope walker, we're going to trade in all our&nbsp;<code>-:</code>&nbsp;operators for&nbsp;<code>&gt;&gt;=</code>. Alright, we can chain our functions again! Watch:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token keyword">let</span> <span class="token hvariable">coolTree</span> <span class="token operator">=</span> <span class="token constant">Node</span> <span class="token number">1</span> <span class="token constant">Empty</span> <span class="token punctuation">(</span><span class="token constant">Node</span> <span class="token number">3</span> <span class="token constant">Empty</span> <span class="token constant">Empty</span><span class="token punctuation">)</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token builtin">return</span> <span class="token punctuation">(</span><span class="token hvariable">coolTree</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">&gt;&gt;=</span> <span class="token hvariable">goRight</span>
<span class="token constant">Just</span> <span class="token punctuation">(</span><span class="token constant">Node</span> <span class="token number">3</span> <span class="token constant">Empty</span> <span class="token constant">Empty</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token constant">RightCrumb</span> <span class="token number">1</span> <span class="token constant">Empty</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token builtin">return</span> <span class="token punctuation">(</span><span class="token hvariable">coolTree</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">&gt;&gt;=</span> <span class="token hvariable">goRight</span> <span class="token operator">&gt;&gt;=</span> <span class="token hvariable">goRight</span>
<span class="token constant">Just</span> <span class="token punctuation">(</span><span class="token constant">Empty</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token constant">RightCrumb</span> <span class="token number">3</span> <span class="token constant">Empty</span><span class="token punctuation">,</span><span class="token constant">RightCrumb</span> <span class="token number">1</span> <span class="token constant">Empty</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token builtin">return</span> <span class="token punctuation">(</span><span class="token hvariable">coolTree</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">&gt;&gt;=</span> <span class="token hvariable">goRight</span> <span class="token operator">&gt;&gt;=</span> <span class="token hvariable">goRight</span> <span class="token operator">&gt;&gt;=</span> <span class="token hvariable">goRight</span>
<span class="token constant">Nothing</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>We used&nbsp;<code>return</code>&nbsp;to put a zipper in a&nbsp;<code>Just</code>&nbsp;and then used&nbsp;<code>&gt;&gt;=</code>&nbsp;to feed that to our&nbsp;<code>goRight</code>&nbsp;function. First, we made a tree that has on its left an empty sub-tree and on its right a node that has two empty sub-trees. When we try to go right once, the result is a success, because the operation makes sense. Going right twice is okay too; we end up with the focus on an empty sub-tree. But going right three times wouldn't make sense, because we can't go to the right of an empty sub-tree, which is why the result is a&nbsp;<code>Nothing</code>.</p></div><div><p>Now we've equipped our trees with a safety-net that will catch us should we fall off. Wow, I nailed this metaphor.</p></div><div><p>Our file system also has a lot of cases where an operation could fail, such as trying to focus on a file or folder that doesn't exist. As an exercise, you can equip our file system with functions that fail gracefully by using the&nbsp;<code>Maybe</code>&nbsp;monad.</p></div><div class="mod-footer"></div></div></div></div><div class="sidebar-right sidebar"><div class="sidebar-content"><span class="sidebar-section-header">Interactive Graph</span><div class="graph-view-placeholder">
		<div class="graph-view-container">
			<div class="graph-icon graph-expand" role="button" aria-label="Expand" data-tooltip-position="top"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon lucide-arrow-up-right"><line x1="7" y1="17" x2="17" y2="7"></line><polyline points="7 7 17 7 17 17"></polyline></svg></div>
			<canvas id="graph-canvas" width="512px" height="512px"></canvas>
		</div>
		</div><div class="tree-container outline-tree" data-depth="0"><div class="tree-header"><span class="sidebar-section-header">Table Of Contents</span><button class="clickable-icon collapse-tree-button"><iconify-icon icon="ph:arrows-in-line-horizontal-bold" width="18px" height="18px" rotate="90deg" color="currentColor"></iconify-icon></button></div><div class="tree-scroll-area"><div class="tree-item mod-tree-heading" data-depth="1"><div class="tree-item-contents"><a class="tree-item-link" href="#Zippers"><span class="tree-item-title">Zippers</span></a></div><div class="tree-item-children"><div class="tree-item mod-tree-heading" data-depth="2"><div class="tree-item-contents"><a class="tree-item-link" href="#Taking_a_walk"><span class="tree-item-title">Taking a walk</span></a></div><div class="tree-item-children"></div></div><div class="tree-item mod-tree-heading mod-collapsible" data-depth="2"><div class="tree-item-contents"><div class="tree-item-icon collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div><a class="tree-item-link" href="#A_trail_of_breadcrumbs"><span class="tree-item-title">A trail of breadcrumbs</span></a></div><div class="tree-item-children"><div class="tree-item mod-tree-heading" data-depth="3"><div class="tree-item-contents"><a class="tree-item-link" href="#Going_back_up"><span class="tree-item-title">Going back up</span></a></div><div class="tree-item-children"></div></div><div class="tree-item mod-tree-heading" data-depth="3"><div class="tree-item-contents"><a class="tree-item-link" href="#Manipulating_trees_under_focus"><span class="tree-item-title">Manipulating trees under focus</span></a></div><div class="tree-item-children"></div></div><div class="tree-item mod-tree-heading" data-depth="3"><div class="tree-item-contents"><a class="tree-item-link" href="#I'm_going_straight_to_the_top,_oh_yeah,_up_where_the_air_is_fresh_and_clean!"><span class="tree-item-title">I'm going straight to the top, oh yeah, up where the air is fresh and clean!</span></a></div><div class="tree-item-children"></div></div></div></div><div class="tree-item mod-tree-heading" data-depth="2"><div class="tree-item-contents"><a class="tree-item-link" href="#Focusing_on_lists"><span class="tree-item-title">Focusing on lists</span></a></div><div class="tree-item-children"></div></div><div class="tree-item mod-tree-heading mod-collapsible" data-depth="2"><div class="tree-item-contents"><div class="tree-item-icon collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div><a class="tree-item-link" href="#A_very_simple_file_system"><span class="tree-item-title">A very simple file system</span></a></div><div class="tree-item-children"><div class="tree-item mod-tree-heading" data-depth="3"><div class="tree-item-contents"><a class="tree-item-link" href="#A_zipper_for_our_file_system"><span class="tree-item-title">A zipper for our file system</span></a></div><div class="tree-item-children"></div></div><div class="tree-item mod-tree-heading" data-depth="3"><div class="tree-item-contents"><a class="tree-item-link" href="#Manipulating_our_file_system"><span class="tree-item-title">Manipulating our file system</span></a></div><div class="tree-item-children"></div></div></div></div><div class="tree-item mod-tree-heading" data-depth="2"><div class="tree-item-contents"><a class="tree-item-link" href="#Watch_your_step"><span class="tree-item-title">Watch your step</span></a></div><div class="tree-item-children"></div></div></div></div></div></div></div></div></div></body></html>