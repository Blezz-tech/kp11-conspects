<!DOCTYPE html>
<html><head>
			
		<title>Chapter 3 Types and Typeclasses</title>
		<base href="../../../">
		<meta id="root-path" root-path="../../../">

		<link rel="icon" sizes="96x96" href="https://publish-01.obsidian.md/access/f786db9fac45774fa4f0d8112e232d67/favicon-96x96.png">
		<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes, minimum-scale=1.0, maximum-scale=5.0">
		<meta charset="UTF-8">
		<script src="https://code.iconify.design/iconify-icon/1.0.3/iconify-icon.min.js"></script>

			<link rel="stylesheet" href="lib/styles/obsidian-styles.css">
			<link rel="stylesheet" href="lib/styles/theme.css">
			<link rel="stylesheet" href="lib/styles/plugin-styles.css">
			<link rel="stylesheet" href="lib/styles/snippets.css">
			<style>  </style>

			
			<!-- Graph View Data -->
			<script>
			let nodes=
{"nodeCount":22,"linkCount":21,"radii":[7,5.346938775510203,4.855867346938775,4.301020408163265,3.6823979591836737,3.6823979591836737,3.6823979591836737,3.6823979591836737,3.6823979591836737,3.6823979591836737,3.6823979591836737,3.6823979591836737,3.6823979591836737,3.6823979591836737,3.6823979591836737,3.6823979591836737,3.6823979591836737,3.6823979591836737,3.6823979591836737,3.6823979591836737,3.6823979591836737,3.6823979591836737],"labels":["Table Of Content","Отчеты","README","README","О Haskell по-человечески (Итого)","Полезные ресурсы","О Haskell по-человечески (Оригинал)","Оглавление","Chapter 13 For a Few Monads More","Chapter 12 A Fistful of Monads","Chapter 11 Functors, Applicative Functors and Monoids","Chapter 10 Functionally Solving Problems","Chapter 9 Input and Output","Chapter 8 Making Our Own Types and Typeclasses","Chapter 7 Modules","Chapter 6 Higher order functions","Chapter 5 Recursion","Chapter 4 Syntax in Functions","Chapter 14 Zippers","Chapter 1 Introduction","Chapter 2 Starting Out","Chapter 3 Types and Typeclasses"],"paths":["курсы/learn-you-a-haskell-for-great-good!/en/table-of-content.html","отчеты.html","курсы/learn-you-a-haskell-for-great-good!/readme.html","readme.html","мои-решения/о-haskell-по-человечески/о-haskell-по-человечески-(итого).html","полезные-ресурсы.html","курсы/о-haskell-по-человечески/о-haskell-по-человечески-(оригинал).html","курсы/learn-you-a-haskell-for-great-good!/ru/оглавление.html","курсы/learn-you-a-haskell-for-great-good!/en/chapter-13-for-a-few-monads-more.html","курсы/learn-you-a-haskell-for-great-good!/en/chapter-12-a-fistful-of-monads.html","курсы/learn-you-a-haskell-for-great-good!/en/chapter-11-functors,-applicative-functors-and-monoids.html","курсы/learn-you-a-haskell-for-great-good!/en/chapter-10-functionally-solving-problems.html","курсы/learn-you-a-haskell-for-great-good!/en/chapter-9-input-and-output.html","курсы/learn-you-a-haskell-for-great-good!/en/chapter-8-making-our-own-types-and-typeclasses.html","курсы/learn-you-a-haskell-for-great-good!/en/chapter-7-modules.html","курсы/learn-you-a-haskell-for-great-good!/en/chapter-6-higher-order-functions.html","курсы/learn-you-a-haskell-for-great-good!/en/chapter-5-recursion.html","курсы/learn-you-a-haskell-for-great-good!/en/chapter-4-syntax-in-functions.html","курсы/learn-you-a-haskell-for-great-good!/en/chapter-14-zippers.html","курсы/learn-you-a-haskell-for-great-good!/en/chapter-1-introduction.html","курсы/learn-you-a-haskell-for-great-good!/en/chapter-2-starting-out.html","курсы/learn-you-a-haskell-for-great-good!/en/chapter-3-types-and-typeclasses.html"],"linkSources":[3,3,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,2],"linkTargets":[5,1,6,4,2,19,20,21,17,16,15,14,13,12,11,10,9,8,18,0,7]};
			let attractionForce = 1;
			let linkLength = 10;
			let repulsionForce = 150;
			let centralForce = 3;
			let edgePruning = 100;
			</script>
			
<script type="module" src="lib/scripts/graph_view.js"></script>

<script src="lib/scripts/graph_wasm.js"></script>

<script src="lib/scripts/tinycolor.js"></script>

<script src="https://cdnjs.cloudflare.com/ajax/libs/pixi.js/7.2.4/pixi.min.js" integrity="sha512-Ch/O6kL8BqUwAfCF7Ie5SX1Hin+BJgYH4pNjRqXdTEqMsis1TUYg+j6nnI9uduPjGaj7DN4UKCZgpvoExt6dkw==" crossorigin="anonymous" referrerpolicy="no-referrer"></script>

<script src="lib/scripts/webpage.js"></script>

			</head><body class="theme-dark mod-windows is-frameless is-maximized is-hidden-frameless obsidian-app show-inline-title show-view-header" style="--zoom-factor:1; --font-text-size:16px; --line-width:100%; --line-width-adaptive:100%; --file-line-width:100%; --content-width:500em; --sidebar-width:25em; --collapse-arrow-size:0.4em; --tree-horizontal-spacing:1em; --tree-vertical-spacing:0.5em; --sidebar-margin:12px;"><div class="webpage-container"><div class="sidebar-left sidebar"><div class="sidebar-content"><div><label class="theme-toggle-container" for="theme_toggle"><input class="theme-toggle-input" type="checkbox" id="theme_toggle"><div class="toggle-background"></div></label></div><div class="tree-container file-tree mod-nav-indicator" data-depth="0"><div class="tree-header"><span class="sidebar-section-header">learn-haskell-valut</span><button class="clickable-icon collapse-tree-button is-collapsed"><iconify-icon icon="ph:arrows-in-line-horizontal-bold" width="18px" height="18px" rotate="90deg" color="currentColor"></iconify-icon></button></div><div class="tree-scroll-area"><div class="tree-item mod-tree-folder mod-collapsible is-collapsed" data-depth="1"><div class="tree-item-contents"><div class="tree-item-icon collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div><a class="tree-item-link" href="курсы"><span class="tree-item-title">Курсы</span></a></div><div class="tree-item-children"><div class="tree-item mod-tree-folder mod-collapsible is-collapsed" data-depth="2"><div class="tree-item-contents"><div class="tree-item-icon collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div><a class="tree-item-link" href="курсы/о-haskell-по-человечески"><span class="tree-item-title">О Haskell по-человечески</span></a></div><div class="tree-item-children"><div class="tree-item mod-tree-file" data-depth="3"><div class="tree-item-contents"><a class="tree-item-link" href="курсы/о-haskell-по-человечески/о-haskell-по-человечески-(оригинал).html"><span class="tree-item-title">О Haskell по-человечески (Оригинал)</span></a></div><div class="tree-item-children"></div></div></div></div><div class="tree-item mod-tree-folder mod-collapsible is-collapsed" data-depth="2"><div class="tree-item-contents"><div class="tree-item-icon collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div><a class="tree-item-link" href="курсы/learn-you-a-haskell-for-great-good!"><span class="tree-item-title">Learn You a Haskell for Great Good!</span></a></div><div class="tree-item-children"><div class="tree-item mod-tree-folder mod-collapsible is-collapsed" data-depth="3"><div class="tree-item-contents"><div class="tree-item-icon collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div><a class="tree-item-link" href="курсы/learn-you-a-haskell-for-great-good!/en"><span class="tree-item-title">en</span></a></div><div class="tree-item-children"><div class="tree-item mod-tree-file" data-depth="4"><div class="tree-item-contents"><a class="tree-item-link" href="курсы/learn-you-a-haskell-for-great-good!/en/chapter-1-introduction.html"><span class="tree-item-title">Chapter 1 Introduction</span></a></div><div class="tree-item-children"></div></div><div class="tree-item mod-tree-file" data-depth="4"><div class="tree-item-contents"><a class="tree-item-link" href="курсы/learn-you-a-haskell-for-great-good!/en/chapter-10-functionally-solving-problems.html"><span class="tree-item-title">Chapter 10 Functionally Solving Problems</span></a></div><div class="tree-item-children"></div></div><div class="tree-item mod-tree-file" data-depth="4"><div class="tree-item-contents"><a class="tree-item-link" href="курсы/learn-you-a-haskell-for-great-good!/en/chapter-11-functors,-applicative-functors-and-monoids.html"><span class="tree-item-title">Chapter 11 Functors, Applicative Functors and Monoids</span></a></div><div class="tree-item-children"></div></div><div class="tree-item mod-tree-file" data-depth="4"><div class="tree-item-contents"><a class="tree-item-link" href="курсы/learn-you-a-haskell-for-great-good!/en/chapter-12-a-fistful-of-monads.html"><span class="tree-item-title">Chapter 12 A Fistful of Monads</span></a></div><div class="tree-item-children"></div></div><div class="tree-item mod-tree-file" data-depth="4"><div class="tree-item-contents"><a class="tree-item-link" href="курсы/learn-you-a-haskell-for-great-good!/en/chapter-13-for-a-few-monads-more.html"><span class="tree-item-title">Chapter 13 For a Few Monads More</span></a></div><div class="tree-item-children"></div></div><div class="tree-item mod-tree-file" data-depth="4"><div class="tree-item-contents"><a class="tree-item-link" href="курсы/learn-you-a-haskell-for-great-good!/en/chapter-14-zippers.html"><span class="tree-item-title">Chapter 14 Zippers</span></a></div><div class="tree-item-children"></div></div><div class="tree-item mod-tree-file" data-depth="4"><div class="tree-item-contents"><a class="tree-item-link" href="курсы/learn-you-a-haskell-for-great-good!/en/chapter-2-starting-out.html"><span class="tree-item-title">Chapter 2 Starting Out</span></a></div><div class="tree-item-children"></div></div><div class="tree-item mod-tree-file" data-depth="4"><div class="tree-item-contents"><a class="tree-item-link" href="курсы/learn-you-a-haskell-for-great-good!/en/chapter-3-types-and-typeclasses.html"><span class="tree-item-title">Chapter 3 Types and Typeclasses</span></a></div><div class="tree-item-children"></div></div><div class="tree-item mod-tree-file" data-depth="4"><div class="tree-item-contents"><a class="tree-item-link" href="курсы/learn-you-a-haskell-for-great-good!/en/chapter-4-syntax-in-functions.html"><span class="tree-item-title">Chapter 4 Syntax in Functions</span></a></div><div class="tree-item-children"></div></div><div class="tree-item mod-tree-file" data-depth="4"><div class="tree-item-contents"><a class="tree-item-link" href="курсы/learn-you-a-haskell-for-great-good!/en/chapter-5-recursion.html"><span class="tree-item-title">Chapter 5 Recursion</span></a></div><div class="tree-item-children"></div></div><div class="tree-item mod-tree-file" data-depth="4"><div class="tree-item-contents"><a class="tree-item-link" href="курсы/learn-you-a-haskell-for-great-good!/en/chapter-6-higher-order-functions.html"><span class="tree-item-title">Chapter 6 Higher order functions</span></a></div><div class="tree-item-children"></div></div><div class="tree-item mod-tree-file" data-depth="4"><div class="tree-item-contents"><a class="tree-item-link" href="курсы/learn-you-a-haskell-for-great-good!/en/chapter-7-modules.html"><span class="tree-item-title">Chapter 7 Modules</span></a></div><div class="tree-item-children"></div></div><div class="tree-item mod-tree-file" data-depth="4"><div class="tree-item-contents"><a class="tree-item-link" href="курсы/learn-you-a-haskell-for-great-good!/en/chapter-8-making-our-own-types-and-typeclasses.html"><span class="tree-item-title">Chapter 8 Making Our Own Types and Typeclasses</span></a></div><div class="tree-item-children"></div></div><div class="tree-item mod-tree-file" data-depth="4"><div class="tree-item-contents"><a class="tree-item-link" href="курсы/learn-you-a-haskell-for-great-good!/en/chapter-9-input-and-output.html"><span class="tree-item-title">Chapter 9 Input and Output</span></a></div><div class="tree-item-children"></div></div><div class="tree-item mod-tree-file" data-depth="4"><div class="tree-item-contents"><a class="tree-item-link" href="курсы/learn-you-a-haskell-for-great-good!/en/table-of-content.html"><span class="tree-item-title">Table Of Content</span></a></div><div class="tree-item-children"></div></div></div></div><div class="tree-item mod-tree-folder mod-collapsible is-collapsed" data-depth="3"><div class="tree-item-contents"><div class="tree-item-icon collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div><a class="tree-item-link" href="курсы/learn-you-a-haskell-for-great-good!/ru"><span class="tree-item-title">ru</span></a></div><div class="tree-item-children"><div class="tree-item mod-tree-file" data-depth="4"><div class="tree-item-contents"><a class="tree-item-link" href="курсы/learn-you-a-haskell-for-great-good!/ru/оглавление.html"><span class="tree-item-title">Оглавление</span></a></div><div class="tree-item-children"></div></div></div></div><div class="tree-item mod-tree-file" data-depth="3"><div class="tree-item-contents"><a class="tree-item-link" href="курсы/learn-you-a-haskell-for-great-good!/readme.html"><span class="tree-item-title">README</span></a></div><div class="tree-item-children"></div></div></div></div></div></div><div class="tree-item mod-tree-folder mod-collapsible is-collapsed" data-depth="1"><div class="tree-item-contents"><div class="tree-item-icon collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div><a class="tree-item-link" href="мои-решения"><span class="tree-item-title">Мои решения</span></a></div><div class="tree-item-children"><div class="tree-item mod-tree-folder mod-collapsible is-collapsed" data-depth="2"><div class="tree-item-contents"><div class="tree-item-icon collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div><a class="tree-item-link" href="мои-решения/о-haskell-по-человечески"><span class="tree-item-title">О Haskell по-человечески</span></a></div><div class="tree-item-children"><div class="tree-item mod-tree-file" data-depth="3"><div class="tree-item-contents"><a class="tree-item-link" href="мои-решения/о-haskell-по-человечески/о-haskell-по-человечески-(итого).html"><span class="tree-item-title">О Haskell по-человечески (Итого)</span></a></div><div class="tree-item-children"></div></div></div></div></div></div><div class="tree-item mod-tree-file" data-depth="1"><div class="tree-item-contents"><a class="tree-item-link" href="отчеты.html"><span class="tree-item-title">Отчеты</span></a></div><div class="tree-item-children"></div></div><div class="tree-item mod-tree-file" data-depth="1"><div class="tree-item-contents"><a class="tree-item-link" href="полезные-ресурсы.html"><span class="tree-item-title">Полезные ресурсы</span></a></div><div class="tree-item-children"></div></div><div class="tree-item mod-tree-file" data-depth="1"><div class="tree-item-contents"><a class="tree-item-link" href="readme.html"><span class="tree-item-title">README</span></a></div><div class="tree-item-children"></div></div></div></div></div></div><div class="document-container"><div class="markdown-preview-view markdown-rendered node-insert-event allow-fold-headings show-indentation-guide allow-fold-lists show-frontmatter" style="tab-size: 4;" tabindex="-1"><style id="MJX-CHTML-styles"></style><div class="markdown-preview-sizer markdown-preview-section" style="padding-bottom: ; padding-top: var(--file-margins); padding-right: var(--file-margins); padding-left: var(--file-margins); width: 100%; position: absolute;"><div class="markdown-preview-pusher" style="width: 1px; height: 0.1px; margin-bottom: 0px;"></div><div class="mod-header"></div><div><h1 data-heading="Types and Typeclasses" id="Types_and_Typeclasses">Types and Typeclasses</h1></div><div><h2 data-heading="Believe the type" id="Believe_the_type" style="display: flex;"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>Believe the type</h2></div><div><p><img alt="moo" src="http://s3.amazonaws.com/lyah/cow.png" referrerpolicy="no-referrer"></p></div><div><p>Previously we mentioned that Haskell has a static type system. The type of every expression is known at compile time, which leads to safer code. If you write a program where you try to divide a boolean type with some number, it won't even compile. That's good because it's better to catch such errors at compile time instead of having your program crash. Everything in Haskell has a type, so the compiler can reason quite a lot about your program before compiling it.</p></div><div><p>Unlike Java or Pascal, Haskell has type inference. If we write a number, we don't have to tell Haskell it's a number. It can&nbsp;<em>infer</em>&nbsp;that on its own, so we don't have to explicitly write out the types of our functions and expressions to get things done. We covered some of the basics of Haskell with only a very superficial glance at types. However, understanding the type system is a very important part of learning Haskell.</p></div><div><p>A type is a kind of label that every expression has. It tells us in which category of things that expression fits. The expression&nbsp;<code>True</code>&nbsp;is a boolean,&nbsp;<code>"hello"</code>&nbsp;is a string, etc.</p></div><div><p>Now we'll use GHCI to examine the types of some expressions. We'll do that by using the&nbsp;<code>:t</code>&nbsp;command which, followed by any valid expression, tells us its type. Let's give it a whirl.</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token operator">:</span><span class="token hvariable">t</span> <span class="token char string">'a'</span>
<span class="token char string">'a'</span> <span class="token operator">::</span> <span class="token constant">Char</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token operator">:</span><span class="token hvariable">t</span> <span class="token constant">True</span>
<span class="token constant">True</span> <span class="token operator">::</span> <span class="token constant">Bool</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token operator">:</span><span class="token hvariable">t</span> <span class="token string">"HELLO!"</span>
<span class="token string">"HELLO!"</span> <span class="token operator">::</span> <span class="token punctuation">[</span><span class="token constant">Char</span><span class="token punctuation">]</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token operator">:</span><span class="token hvariable">t</span> <span class="token punctuation">(</span><span class="token constant">True</span><span class="token punctuation">,</span> <span class="token char string">'a'</span><span class="token punctuation">)</span>
<span class="token punctuation">(</span><span class="token constant">True</span><span class="token punctuation">,</span> <span class="token char string">'a'</span><span class="token punctuation">)</span> <span class="token operator">::</span> <span class="token punctuation">(</span><span class="token constant">Bool</span><span class="token punctuation">,</span> <span class="token constant">Char</span><span class="token punctuation">)</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token operator">:</span><span class="token hvariable">t</span> <span class="token number">4</span> <span class="token operator">==</span> <span class="token number">5</span>
<span class="token number">4</span> <span class="token operator">==</span> <span class="token number">5</span> <span class="token operator">::</span> <span class="token constant">Bool</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p><img alt="bomb" src="http://s3.amazonaws.com/lyah/bomb.png" referrerpolicy="no-referrer">Here we see that doing&nbsp;<code>:t</code>&nbsp;on an expression prints out the expression followed by&nbsp;<code>::</code>&nbsp;and its type.&nbsp;<code>::</code>&nbsp;is read as "has type of". Explicit types are always denoted with the first letter in capital case.&nbsp;<code>'a'</code>, as it would seem, has a type of&nbsp;<code>Char</code>. It's not hard to conclude that it stands for&nbsp;<em>character</em>.&nbsp;<code>True</code>&nbsp;is of a&nbsp;<code>Bool</code>&nbsp;type. That makes sense. But what's this? Examining the type of&nbsp;<code>"HELLO!"</code>&nbsp;yields a&nbsp;<code>[Char]</code>. The square brackets denote a list. So we read that as it being&nbsp;<em>a list of characters</em>. Unlike lists, each tuple length has its own type. So the expression of&nbsp;<code>(True, 'a')</code>&nbsp;has a type of&nbsp;<code>(Bool, Char)</code>, whereas an expression such as&nbsp;<code>('a','b','c')</code>&nbsp;would have the type of&nbsp;<code>(Char, Char, Char)</code>.&nbsp;<code>4 == 5</code>&nbsp;will always return&nbsp;<code>False</code>, so its type is&nbsp;<code>Bool</code>.</p></div><div><p>Functions also have types. When writing our own functions, we can choose to give them an explicit type declaration. This is generally considered to be good practice except when writing very short functions. From here on, we'll give all the functions that we make type declarations. Remember the list comprehension we made previously that filters a string so that only caps remain? Here's how it looks like with a type declaration.</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">removeNonUppercase</span> <span class="token operator">::</span> <span class="token punctuation">[</span><span class="token constant">Char</span><span class="token punctuation">]</span> <span class="token operator">-&gt;</span> <span class="token punctuation">[</span><span class="token constant">Char</span><span class="token punctuation">]</span>
<span class="token hvariable">removeNonUppercase</span> <span class="token hvariable">st</span> <span class="token operator">=</span> <span class="token punctuation">[</span> <span class="token hvariable">c</span> <span class="token operator">|</span> <span class="token hvariable">c</span> <span class="token operator">&lt;-</span> <span class="token hvariable">st</span><span class="token punctuation">,</span> <span class="token hvariable">c</span> <span class="token operator">`elem`</span> <span class="token punctuation">[</span><span class="token char string">'A'</span><span class="token operator">..</span><span class="token char string">'Z'</span><span class="token punctuation">]</span><span class="token punctuation">]</span> 
</code><button class="copy-code-button">Копировать</button></pre></div><div><p><code>removeNonUppercase</code>&nbsp;has a type of&nbsp;<code>[Char] -&gt; [Char]</code>, meaning that it maps from a string to a string. That's because it takes one string as a parameter and returns another as a result. The&nbsp;<code>[Char]</code>&nbsp;type is synonymous with&nbsp;<code>String</code>&nbsp;so it's clearer if we write&nbsp;<code>removeNonUppercase :: String -&gt; String</code>. We didn't have to give this function a type declaration because the compiler can infer by itself that it's a function from a string to a string but we did anyway. But how do we write out the type of a function that takes several parameters? Here's a simple function that takes three integers and adds them together:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">addThree</span> <span class="token operator">::</span> <span class="token constant">Int</span> <span class="token operator">-&gt;</span> <span class="token constant">Int</span> <span class="token operator">-&gt;</span> <span class="token constant">Int</span> <span class="token operator">-&gt;</span> <span class="token constant">Int</span>
<span class="token hvariable">addThree</span> <span class="token hvariable">x</span> <span class="token hvariable">y</span> <span class="token hvariable">z</span> <span class="token operator">=</span> <span class="token hvariable">x</span> <span class="token operator">+</span> <span class="token hvariable">y</span> <span class="token operator">+</span> <span class="token hvariable">z</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>The parameters are separated with&nbsp;<code>-&gt;</code>&nbsp;and there's no special distinction between the parameters and the return type. The return type is the last item in the declaration and the parameters are the first three. Later on we'll see why they're all just separated with&nbsp;<code>-&gt;</code>&nbsp;instead of having some more explicit distinction between the return types and the parameters like&nbsp;<code>Int, Int, Int -&gt; Int</code>&nbsp;or something.</p></div><div><p>If you want to give your function a type declaration but are unsure as to what it should be, you can always just write the function without it and then check it with&nbsp;<code>:t</code>. Functions are expressions too, so&nbsp;<code>:t</code>&nbsp;works on them without a problem.</p></div><div><p>Here's an overview of some common types.</p></div><div><p><code>Int</code>&nbsp;stands for integer. It's used for whole numbers.&nbsp;<code>7</code>&nbsp;can be an&nbsp;<code>Int</code>&nbsp;but&nbsp;<code>7.2</code>&nbsp;cannot.&nbsp;<code>Int</code>&nbsp;is bounded, which means that it has a minimum and a maximum value. Usually on 32-bit machines the maximum possible&nbsp;<code>Int</code>&nbsp;is 2147483647 and the minimum is -2147483648.</p></div><div><p><code>Integer</code>&nbsp;stands for, er … also integer. The main difference is that it's not bounded so it can be used to represent really really big numbers. I mean like really big.&nbsp;<code>Int</code>, however, is more efficient.</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">factorial</span> <span class="token operator">::</span> <span class="token constant">Integer</span> <span class="token operator">-&gt;</span> <span class="token constant">Integer</span>
<span class="token hvariable">factorial</span> <span class="token hvariable">n</span> <span class="token operator">=</span> <span class="token builtin">product</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token operator">..</span><span class="token hvariable">n</span><span class="token punctuation">]</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token hvariable">factorial</span> <span class="token number">50</span>
<span class="token number">30414093201713378043612608166064768844377641568960512000000000000</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p><code>Float</code>&nbsp;is a real floating point with single precision.</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">circumference</span> <span class="token operator">::</span> <span class="token constant">Float</span> <span class="token operator">-&gt;</span> <span class="token constant">Float</span>
<span class="token hvariable">circumference</span> <span class="token hvariable">r</span> <span class="token operator">=</span> <span class="token number">2</span> <span class="token operator">*</span> <span class="token builtin">pi</span> <span class="token operator">*</span> <span class="token hvariable">r</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token hvariable">circumference</span> <span class="token number">4.0</span>
<span class="token number">25.132742</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p><code>Double</code>&nbsp;is a real floating point with double the precision!</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">circumference'</span> <span class="token operator">::</span> <span class="token constant">Double</span> <span class="token operator">-&gt;</span> <span class="token constant">Double</span>
<span class="token hvariable">circumference'</span> <span class="token hvariable">r</span> <span class="token operator">=</span> <span class="token number">2</span> <span class="token operator">*</span> <span class="token builtin">pi</span> <span class="token operator">*</span> <span class="token hvariable">r</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token hvariable">circumference'</span> <span class="token number">4.0</span>
<span class="token number">25.132741228718345</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p><code>Bool</code>&nbsp;is a boolean type. It can have only two values:&nbsp;<code>True</code>&nbsp;and&nbsp;<code>False</code>.</p></div><div><p><code>Char</code>&nbsp;represents a character. It's denoted by single quotes. A list of characters is a string.</p></div><div><p>Tuples are types but they are dependent on their length as well as the types of their components, so there is theoretically an infinite number of tuple types, which is too many to cover in this tutorial. Note that the empty tuple&nbsp;<code>()</code>&nbsp;is also a type which can only have a single value:&nbsp;<code>()</code></p></div><div><h2 data-heading="Type variables" id="Type_variables" style="display: flex;"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>Type variables</h2></div><div><p>What do you think is the type of the&nbsp;<code>head</code>&nbsp;function? Because&nbsp;<code>head</code>&nbsp;takes a list of any type and returns the first element, so what could it be? Let's check!</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token operator">:</span><span class="token hvariable">t</span> <span class="token builtin">head</span>
<span class="token builtin">head</span> <span class="token operator">::</span> <span class="token punctuation">[</span><span class="token hvariable">a</span><span class="token punctuation">]</span> <span class="token operator">-&gt;</span> <span class="token hvariable">a</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p><img alt="box" src="http://s3.amazonaws.com/lyah/box.png" referrerpolicy="no-referrer">Hmmm! What is this&nbsp;<code>a</code>? Is it a type? Remember that we previously stated that types are written in capital case, so it can't exactly be a type. Because it's not in capital case it's actually a&nbsp;<strong>type variable</strong>. That means that&nbsp;<code>a</code>&nbsp;can be of any type. This is much like generics in other languages, only in Haskell it's much more powerful because it allows us to easily write very general functions if they don't use any specific behavior of the types in them. Functions that have type variables are called&nbsp;<strong>polymorphic functions</strong>. The type declaration of&nbsp;<code>head</code>&nbsp;states that it takes a list of any type and returns one element of that type.</p></div><div><p>Although type variables can have names longer than one character, we usually give them names of a, b, c, d …</p></div><div><p>Remember&nbsp;<code>fst</code>? It returns the first component of a pair. Let's examine its type.</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token operator">:</span><span class="token hvariable">t</span> <span class="token builtin">fst</span>
<span class="token builtin">fst</span> <span class="token operator">::</span> <span class="token punctuation">(</span><span class="token hvariable">a</span><span class="token punctuation">,</span> <span class="token hvariable">b</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token hvariable">a</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>We see that&nbsp;<code>fst</code>&nbsp;takes a tuple which contains two types and returns an element which is of the same type as the pair's first component. That's why we can use&nbsp;<code>fst</code>&nbsp;on a pair that contains any two types. Note that just because&nbsp;<code>a</code>&nbsp;and&nbsp;<code>b</code>&nbsp;are different type variables, they don't have to be different types. It just states that the first component's type and the return value's type are the same.</p></div><div><h2 data-heading="Typeclasses 101" id="Typeclasses_101" style="display: flex;"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>Typeclasses 101</h2></div><div><p><img alt="class" src="http://s3.amazonaws.com/lyah/classes.png" referrerpolicy="no-referrer"></p></div><div><p>A typeclass is a sort of interface that defines some behavior. If a type is a part of a typeclass, that means that it supports and implements the behavior the typeclass describes. A lot of people coming from OOP get confused by typeclasses because they think they are like classes in object oriented languages. Well, they're not. You can think of them kind of as Java interfaces, only better.</p></div><div><p>What's the type signature of the&nbsp;<code>==</code>&nbsp;function?</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token operator">:</span><span class="token hvariable">t</span> <span class="token punctuation">(</span><span class="token operator">==</span><span class="token punctuation">)</span>
<span class="token punctuation">(</span><span class="token operator">==</span><span class="token punctuation">)</span> <span class="token operator">::</span> <span class="token punctuation">(</span><span class="token constant">Eq</span> <span class="token hvariable">a</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token hvariable">a</span> <span class="token operator">-&gt;</span> <span class="token hvariable">a</span> <span class="token operator">-&gt;</span> <span class="token constant">Bool</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p><em>Note</em>: the equality operator,&nbsp;==&nbsp;is a function. So are&nbsp;+,&nbsp;*,&nbsp;-,&nbsp;/&nbsp;and pretty much all operators. If a function is comprised only of special characters, it's considered an infix function by default. If we want to examine its type, pass it to another function or call it as a prefix function, we have to surround it in parentheses.</p></div><div><p>Interesting. We see a new thing here, the&nbsp;<code>=&gt;</code>&nbsp;symbol. Everything before the&nbsp;<code>=&gt;</code>&nbsp;symbol is called a&nbsp;<strong>class constraint</strong>. We can read the previous type declaration like this: the equality function takes any two values that are of the same type and returns a&nbsp;<code>Bool</code>. The type of those two values must be a member of the&nbsp;<code>Eq</code>&nbsp;class (this was the class constraint).</p></div><div><p>The&nbsp;<code>Eq</code>&nbsp;typeclass provides an interface for testing for equality. Any type where it makes sense to test for equality between two values of that type should be a member of the&nbsp;<code>Eq</code>&nbsp;class. All standard Haskell types except for IO (the type for dealing with input and output) and functions are a part of the&nbsp;<code>Eq</code>&nbsp;typeclass.</p></div><div><p>The&nbsp;<code>elem</code>&nbsp;function has a type of&nbsp;<code>(Eq a) =&gt; a -&gt; [a] -&gt; Bool</code>&nbsp;because it uses&nbsp;<code>==</code>&nbsp;over a list to check whether some value we're looking for is in it.</p></div><div><p>Some basic typeclasses:</p></div><div><p><code>Eq</code>&nbsp;is used for types that support equality testing. The functions its members implement are&nbsp;<code>==</code>&nbsp;and&nbsp;<code>/=</code>. So if there's an&nbsp;<code>Eq</code>&nbsp;class constraint for a type variable in a function, it uses&nbsp;<code>==</code>&nbsp;or&nbsp;<code>/=</code>&nbsp;somewhere inside its definition. All the types we mentioned previously except for functions are part of&nbsp;<code>Eq</code>, so they can be tested for equality.</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token number">5</span> <span class="token operator">==</span> <span class="token number">5</span>
<span class="token constant">True</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token number">5</span> <span class="token operator">/=</span> <span class="token number">5</span>
<span class="token constant">False</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token char string">'a'</span> <span class="token operator">==</span> <span class="token char string">'a'</span>
<span class="token constant">True</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token string">"Ho Ho"</span> <span class="token operator">==</span> <span class="token string">"Ho Ho"</span>
<span class="token constant">True</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token number">3.432</span> <span class="token operator">==</span> <span class="token number">3.432</span>
<span class="token constant">True</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p><code>Ord</code>&nbsp;is for types that have an ordering.</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token operator">:</span><span class="token hvariable">t</span> <span class="token punctuation">(</span><span class="token operator">&gt;</span><span class="token punctuation">)</span>
<span class="token punctuation">(</span><span class="token operator">&gt;</span><span class="token punctuation">)</span> <span class="token operator">::</span> <span class="token punctuation">(</span><span class="token constant">Ord</span> <span class="token hvariable">a</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token hvariable">a</span> <span class="token operator">-&gt;</span> <span class="token hvariable">a</span> <span class="token operator">-&gt;</span> <span class="token constant">Bool</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>All the types we covered so far except for functions are part of&nbsp;<code>Ord</code>.&nbsp;<code>Ord</code>&nbsp;covers all the standard comparing functions such as&nbsp;<code>&gt;</code>,&nbsp;<code>&lt;</code>,&nbsp;<code>&gt;=</code>&nbsp;and&nbsp;<code>&lt;=</code>. The&nbsp;<code>compare</code>&nbsp;function takes two&nbsp;<code>Ord</code>&nbsp;members of the same type and returns an ordering.&nbsp;<code>Ordering</code>&nbsp;is a type that can be&nbsp;<code>GT</code>,&nbsp;<code>LT</code>&nbsp;or&nbsp;<code>EQ</code>, meaning&nbsp;<em>greater than</em>,&nbsp;<em>lesser than</em>&nbsp;and&nbsp;<em>equal</em>, respectively.</p></div><div><p>To be a member of&nbsp;<code>Ord</code>, a type must first have membership in the prestigious and exclusive&nbsp;<code>Eq</code>&nbsp;club.</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token string">"Abrakadabra"</span> <span class="token operator">&lt;</span> <span class="token string">"Zebra"</span>
<span class="token constant">True</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token string">"Abrakadabra"</span> <span class="token operator">`compare`</span> <span class="token string">"Zebra"</span>
<span class="token constant">LT</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token number">5</span> <span class="token operator">&gt;=</span> <span class="token number">2</span>
<span class="token constant">True</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token number">5</span> <span class="token operator">`compare`</span> <span class="token number">3</span>
<span class="token constant">GT</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Members of&nbsp;<code>Show</code>&nbsp;can be presented as strings. All types covered so far except for functions are a part of&nbsp;<code>Show</code>. The most used function that deals with the&nbsp;<code>Show</code>&nbsp;typeclass is&nbsp;<code>show</code>. It takes a value whose type is a member of&nbsp;<code>Show</code>&nbsp;and presents it to us as a string.</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token builtin">show</span> <span class="token number">3</span>
<span class="token string">"3"</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token builtin">show</span> <span class="token number">5.334</span>
<span class="token string">"5.334"</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token builtin">show</span> <span class="token constant">True</span>
<span class="token string">"True"</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p><code>Read</code>&nbsp;is sort of the opposite typeclass of&nbsp;<code>Show</code>. The&nbsp;<code>read</code>&nbsp;function takes a string and returns a type which is a member of&nbsp;<code>Read</code>.</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token builtin">read</span> <span class="token string">"True"</span> <span class="token operator">||</span> <span class="token constant">False</span>
<span class="token constant">True</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token builtin">read</span> <span class="token string">"8.2"</span> <span class="token operator">+</span> <span class="token number">3.8</span>
<span class="token number">12.0</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token builtin">read</span> <span class="token string">"5"</span> <span class="token operator">-</span> <span class="token number">2</span>
<span class="token number">3</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token builtin">read</span> <span class="token string">"[1,2,3,4]"</span> <span class="token operator">++</span> <span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span>
<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">]</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>So far so good. Again, all types covered so far are in this typeclass. But what happens if we try to do just&nbsp;<code>read "4"</code>?</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token builtin">read</span> <span class="token string">"4"</span>
<span class="token operator">&lt;</span><span class="token hvariable">interactive</span><span class="token operator">&gt;:</span><span class="token number">1</span><span class="token operator">:</span><span class="token number">0</span><span class="token operator">:</span>
    <span class="token constant">Ambiguous</span> <span class="token keyword">type</span> <span class="token hvariable">variable</span> `<span class="token hvariable">a'</span> <span class="token keyword">in</span> <span class="token hvariable">the</span> <span class="token hvariable">constraint</span><span class="token operator">:</span>
      `<span class="token constant">Read</span> <span class="token hvariable">a'</span> <span class="token hvariable">arising</span> <span class="token hvariable">from</span> <span class="token hvariable">a</span> <span class="token hvariable">use</span> <span class="token keyword">of</span> `<span class="token builtin">read</span>' <span class="token hvariable">at</span> <span class="token operator">&lt;</span><span class="token hvariable">interactive</span><span class="token operator">&gt;:</span><span class="token number">1</span><span class="token operator">:</span><span class="token number">0</span><span class="token operator">-</span><span class="token number">7</span>
    <span class="token constant">Probable</span> <span class="token hvariable">fix</span><span class="token operator">:</span> <span class="token hvariable">add</span> <span class="token hvariable">a</span> <span class="token keyword">type</span> <span class="token hvariable">signature</span> <span class="token hvariable">that</span> <span class="token hvariable">fixes</span> <span class="token hvariable">these</span> <span class="token keyword">type</span> <span class="token hvariable">variable</span><span class="token punctuation">(</span><span class="token hvariable">s</span><span class="token punctuation">)</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>What GHCI is telling us here is that it doesn't know what we want in return. Notice that in the previous uses of&nbsp;<code>read</code>&nbsp;we did something with the result afterwards. That way, GHCI could infer what kind of result we wanted out of our&nbsp;<code>read</code>. If we used it as a boolean, it knew it had to return a&nbsp;<code>Bool</code>. But now, it knows we want some type that is part of the&nbsp;<code>Read</code>&nbsp;class, it just doesn't know which one. Let's take a look at the type signature of&nbsp;<code>read</code>.</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token operator">:</span><span class="token hvariable">t</span> <span class="token builtin">read</span>
<span class="token builtin">read</span> <span class="token operator">::</span> <span class="token punctuation">(</span><span class="token constant">Read</span> <span class="token hvariable">a</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token constant">String</span> <span class="token operator">-&gt;</span> <span class="token hvariable">a</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>See? It returns a type that's part of&nbsp;<code>Read</code>&nbsp;but if we don't try to use it in some way later, it has no way of knowing which type. That's why we can use explicit&nbsp;<strong>type annotations</strong>. Type annotations are a way of explicitly saying what the type of an expression should be. We do that by adding&nbsp;<code>::</code>&nbsp;at the end of the expression and then specifying a type. Observe:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token builtin">read</span> <span class="token string">"5"</span> <span class="token operator">::</span> <span class="token constant">Int</span>
<span class="token number">5</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token builtin">read</span> <span class="token string">"5"</span> <span class="token operator">::</span> <span class="token constant">Float</span>
<span class="token number">5.0</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token punctuation">(</span><span class="token builtin">read</span> <span class="token string">"5"</span> <span class="token operator">::</span> <span class="token constant">Float</span><span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token number">4</span>
<span class="token number">20.0</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token builtin">read</span> <span class="token string">"[1,2,3,4]"</span> <span class="token operator">::</span> <span class="token punctuation">[</span><span class="token constant">Int</span><span class="token punctuation">]</span>
<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">]</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token builtin">read</span> <span class="token string">"(3, 'a')"</span> <span class="token operator">::</span> <span class="token punctuation">(</span><span class="token constant">Int</span><span class="token punctuation">,</span> <span class="token constant">Char</span><span class="token punctuation">)</span>
<span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span> <span class="token char string">'a'</span><span class="token punctuation">)</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Most expressions are such that the compiler can infer what their type is by itself. But sometimes, the compiler doesn't know whether to return a value of type&nbsp;<code>Int</code>&nbsp;or&nbsp;<code>Float</code>&nbsp;for an expression like&nbsp;<code>read "5"</code>. To see what the type is, Haskell would have to actually evaluate&nbsp;<code>read "5"</code>. But since Haskell is a statically typed language, it has to know all the types before the code is compiled (or in the case of GHCI, evaluated). So we have to tell Haskell: "Hey, this expression should have this type, in case you don't know!".</p></div><div><p><code>Enum</code>&nbsp;members are sequentially ordered types — they can be enumerated. The main advantage of the&nbsp;<code>Enum</code>&nbsp;typeclass is that we can use its types in list ranges. They also have defined successors and predecesors, which you can get with the&nbsp;<code>succ</code>&nbsp;and&nbsp;<code>pred</code>&nbsp;functions. Types in this class:&nbsp;<code>()</code>,&nbsp;<code>Bool</code>,&nbsp;<code>Char</code>,&nbsp;<code>Ordering</code>,&nbsp;<code>Int</code>,&nbsp;<code>Integer</code>,&nbsp;<code>Float</code>&nbsp;and&nbsp;<code>Double</code>.</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token punctuation">[</span><span class="token char string">'a'</span><span class="token operator">..</span><span class="token char string">'e'</span><span class="token punctuation">]</span>
<span class="token string">"abcde"</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token punctuation">[</span><span class="token constant">LT</span> <span class="token operator">..</span> <span class="token constant">GT</span><span class="token punctuation">]</span>
<span class="token punctuation">[</span><span class="token constant">LT</span><span class="token punctuation">,</span><span class="token constant">EQ</span><span class="token punctuation">,</span><span class="token constant">GT</span><span class="token punctuation">]</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token punctuation">[</span><span class="token number">3</span> <span class="token operator">..</span> <span class="token number">5</span><span class="token punctuation">]</span>
<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">]</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token builtin">succ</span> <span class="token char string">'B'</span>
<span class="token char string">'C'</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p><code>Bounded</code>&nbsp;members have an upper and a lower bound.</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token builtin">minBound</span> <span class="token operator">::</span> <span class="token constant">Int</span>
<span class="token operator">-</span><span class="token number">2147483648</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token builtin">maxBound</span> <span class="token operator">::</span> <span class="token constant">Char</span>
<span class="token char string">'\1114111'</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token builtin">maxBound</span> <span class="token operator">::</span> <span class="token constant">Bool</span>
<span class="token constant">True</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token builtin">minBound</span> <span class="token operator">::</span> <span class="token constant">Bool</span>
<span class="token constant">False</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p><code>minBound</code>&nbsp;and&nbsp;<code>maxBound</code>&nbsp;are interesting because they have a type of&nbsp;<code>(Bounded a) =&gt; a</code>. In a sense they are polymorphic constants.</p></div><div><p>All tuples are also part of&nbsp;<code>Bounded</code>&nbsp;if the components are also in it.</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token builtin">maxBound</span> <span class="token operator">::</span> <span class="token punctuation">(</span><span class="token constant">Bool</span><span class="token punctuation">,</span> <span class="token constant">Int</span><span class="token punctuation">,</span> <span class="token constant">Char</span><span class="token punctuation">)</span>
<span class="token punctuation">(</span><span class="token constant">True</span><span class="token punctuation">,</span><span class="token number">2147483647</span><span class="token punctuation">,</span><span class="token char string">'\1114111'</span><span class="token punctuation">)</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p><code>Num</code>&nbsp;is a numeric typeclass. Its members have the property of being able to act like numbers. Let's examine the type of a number.</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token operator">:</span><span class="token hvariable">t</span> <span class="token number">20</span>
<span class="token number">20</span> <span class="token operator">::</span> <span class="token punctuation">(</span><span class="token constant">Num</span> <span class="token hvariable">t</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token hvariable">t</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>It appears that whole numbers are also polymorphic constants. They can act like any type that's a member of the&nbsp;<code>Num</code>&nbsp;typeclass.</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token number">20</span> <span class="token operator">::</span> <span class="token constant">Int</span>
<span class="token number">20</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token number">20</span> <span class="token operator">::</span> <span class="token constant">Integer</span>
<span class="token number">20</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token number">20</span> <span class="token operator">::</span> <span class="token constant">Float</span>
<span class="token number">20.0</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token number">20</span> <span class="token operator">::</span> <span class="token constant">Double</span>
<span class="token number">20.0</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Those are types that are in the&nbsp;<code>Num</code>&nbsp;typeclass. If we examine the type of&nbsp;<code>*</code>, we'll see that it accepts all numbers.</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token operator">:</span><span class="token hvariable">t</span> <span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">)</span>
<span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">)</span> <span class="token operator">::</span> <span class="token punctuation">(</span><span class="token constant">Num</span> <span class="token hvariable">a</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token hvariable">a</span> <span class="token operator">-&gt;</span> <span class="token hvariable">a</span> <span class="token operator">-&gt;</span> <span class="token hvariable">a</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>It takes two numbers of the same type and returns a number of that type. That's why&nbsp;<code>(5 :: Int) * (6 :: Integer)</code>&nbsp;will result in a type error whereas&nbsp;<code>5 * (6 :: Integer)</code>&nbsp;will work just fine and produce an&nbsp;<code>Integer</code>&nbsp;because&nbsp;<code>5</code>&nbsp;can act like an&nbsp;<code>Integer</code>&nbsp;or an&nbsp;<code>Int</code>.</p></div><div><p>To join&nbsp;<code>Num</code>, a type must already be friends with&nbsp;<code>Show</code>&nbsp;and&nbsp;<code>Eq</code>.</p></div><div><p><code>Integral</code>&nbsp;is also a numeric typeclass.&nbsp;<code>Num</code>&nbsp;includes all numbers, including real numbers and integral numbers,&nbsp;<code>Integral</code>&nbsp;includes only integral (whole) numbers. In this typeclass are&nbsp;<code>Int</code>&nbsp;and&nbsp;<code>Integer</code>.</p></div><div><p><code>Floating</code>&nbsp;includes only floating point numbers, so&nbsp;<code>Float</code>&nbsp;and&nbsp;<code>Double</code>.</p></div><div><p>A very useful function for dealing with numbers is&nbsp;<code>fromIntegral</code>. It has a type declaration of&nbsp;<code>fromIntegral :: (Num b, Integral a) =&gt; a -&gt; b</code>. From its type signature we see that it takes an integral number and turns it into a more general number. That's useful when you want integral and floating point types to work together nicely. For instance, the&nbsp;<code>length</code>&nbsp;function has a type declaration of&nbsp;<code>length :: [a] -&gt; Int</code>&nbsp;instead of having a more general type of&nbsp;<code>(Num b) =&gt; length :: [a] -&gt; b</code>. I think that's there for historical reasons or something, although in my opinion, it's pretty stupid. Anyway, if we try to get a length of a list and then add it to&nbsp;<code>3.2</code>, we'll get an error because we tried to add together an&nbsp;<code>Int</code>&nbsp;and a floating point number. So to get around this, we do&nbsp;<code>fromIntegral (length [1,2,3,4]) + 3.2</code>&nbsp;and it all works out.</p></div><div><p>Notice that&nbsp;<code>fromIntegral</code>&nbsp;has several class constraints in its type signature. That's completely valid and as you can see, the class constraints are separated by commas inside the parentheses.</p></div><div class="mod-footer"></div></div></div></div><div class="sidebar-right sidebar"><div class="sidebar-content"><span class="sidebar-section-header">Interactive Graph</span><div class="graph-view-placeholder">
		<div class="graph-view-container">
			<div class="graph-icon graph-expand" role="button" aria-label="Expand" data-tooltip-position="top"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon lucide-arrow-up-right"><line x1="7" y1="17" x2="17" y2="7"></line><polyline points="7 7 17 7 17 17"></polyline></svg></div>
			<canvas id="graph-canvas" width="512px" height="512px"></canvas>
		</div>
		</div><div class="tree-container outline-tree" data-depth="0"><div class="tree-header"><span class="sidebar-section-header">Table Of Contents</span><button class="clickable-icon collapse-tree-button"><iconify-icon icon="ph:arrows-in-line-horizontal-bold" width="18px" height="18px" rotate="90deg" color="currentColor"></iconify-icon></button></div><div class="tree-scroll-area"><div class="tree-item mod-tree-heading" data-depth="1"><div class="tree-item-contents"><a class="tree-item-link" href="#Types_and_Typeclasses"><span class="tree-item-title">Types and Typeclasses</span></a></div><div class="tree-item-children"><div class="tree-item mod-tree-heading" data-depth="2"><div class="tree-item-contents"><a class="tree-item-link" href="#Believe_the_type"><span class="tree-item-title">Believe the type</span></a></div><div class="tree-item-children"></div></div><div class="tree-item mod-tree-heading" data-depth="2"><div class="tree-item-contents"><a class="tree-item-link" href="#Type_variables"><span class="tree-item-title">Type variables</span></a></div><div class="tree-item-children"></div></div><div class="tree-item mod-tree-heading" data-depth="2"><div class="tree-item-contents"><a class="tree-item-link" href="#Typeclasses_101"><span class="tree-item-title">Typeclasses 101</span></a></div><div class="tree-item-children"></div></div></div></div></div></div></div></div></div></body></html>