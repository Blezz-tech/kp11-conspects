<!DOCTYPE html>
<html><head>
			
		<title>Chapter 5 Recursion</title>
		<base href="../../../">
		<meta id="root-path" root-path="../../../">

		<link rel="icon" sizes="96x96" href="https://publish-01.obsidian.md/access/f786db9fac45774fa4f0d8112e232d67/favicon-96x96.png">
		<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes, minimum-scale=1.0, maximum-scale=5.0">
		<meta charset="UTF-8">
		<script src="https://code.iconify.design/iconify-icon/1.0.3/iconify-icon.min.js"></script>

			<link rel="stylesheet" href="lib/styles/obsidian-styles.css">
			<link rel="stylesheet" href="lib/styles/theme.css">
			<link rel="stylesheet" href="lib/styles/plugin-styles.css">
			<link rel="stylesheet" href="lib/styles/snippets.css">
			<style>  </style>

			
			<!-- Graph View Data -->
			<script>
			let nodes=
{"nodeCount":22,"linkCount":21,"radii":[7,5.346938775510203,4.855867346938775,4.301020408163265,3.6823979591836737,3.6823979591836737,3.6823979591836737,3.6823979591836737,3.6823979591836737,3.6823979591836737,3.6823979591836737,3.6823979591836737,3.6823979591836737,3.6823979591836737,3.6823979591836737,3.6823979591836737,3.6823979591836737,3.6823979591836737,3.6823979591836737,3.6823979591836737,3.6823979591836737,3.6823979591836737],"labels":["Table Of Content","Отчеты","README","README","О Haskell по-человечески (Итого)","Полезные ресурсы","О Haskell по-человечески (Оригинал)","Оглавление","Chapter 13 For a Few Monads More","Chapter 12 A Fistful of Monads","Chapter 11 Functors, Applicative Functors and Monoids","Chapter 10 Functionally Solving Problems","Chapter 9 Input and Output","Chapter 8 Making Our Own Types and Typeclasses","Chapter 7 Modules","Chapter 6 Higher order functions","Chapter 5 Recursion","Chapter 4 Syntax in Functions","Chapter 14 Zippers","Chapter 1 Introduction","Chapter 2 Starting Out","Chapter 3 Types and Typeclasses"],"paths":["курсы/learn-you-a-haskell-for-great-good!/en/table-of-content.html","отчеты.html","курсы/learn-you-a-haskell-for-great-good!/readme.html","readme.html","мои-решения/о-haskell-по-человечески/о-haskell-по-человечески-(итого).html","полезные-ресурсы.html","курсы/о-haskell-по-человечески/о-haskell-по-человечески-(оригинал).html","курсы/learn-you-a-haskell-for-great-good!/ru/оглавление.html","курсы/learn-you-a-haskell-for-great-good!/en/chapter-13-for-a-few-monads-more.html","курсы/learn-you-a-haskell-for-great-good!/en/chapter-12-a-fistful-of-monads.html","курсы/learn-you-a-haskell-for-great-good!/en/chapter-11-functors,-applicative-functors-and-monoids.html","курсы/learn-you-a-haskell-for-great-good!/en/chapter-10-functionally-solving-problems.html","курсы/learn-you-a-haskell-for-great-good!/en/chapter-9-input-and-output.html","курсы/learn-you-a-haskell-for-great-good!/en/chapter-8-making-our-own-types-and-typeclasses.html","курсы/learn-you-a-haskell-for-great-good!/en/chapter-7-modules.html","курсы/learn-you-a-haskell-for-great-good!/en/chapter-6-higher-order-functions.html","курсы/learn-you-a-haskell-for-great-good!/en/chapter-5-recursion.html","курсы/learn-you-a-haskell-for-great-good!/en/chapter-4-syntax-in-functions.html","курсы/learn-you-a-haskell-for-great-good!/en/chapter-14-zippers.html","курсы/learn-you-a-haskell-for-great-good!/en/chapter-1-introduction.html","курсы/learn-you-a-haskell-for-great-good!/en/chapter-2-starting-out.html","курсы/learn-you-a-haskell-for-great-good!/en/chapter-3-types-and-typeclasses.html"],"linkSources":[3,3,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,2],"linkTargets":[5,1,6,4,2,19,20,21,17,16,15,14,13,12,11,10,9,8,18,0,7]};
			let attractionForce = 1;
			let linkLength = 10;
			let repulsionForce = 150;
			let centralForce = 3;
			let edgePruning = 100;
			</script>
			
<script type="module" src="lib/scripts/graph_view.js"></script>

<script src="lib/scripts/graph_wasm.js"></script>

<script src="lib/scripts/tinycolor.js"></script>

<script src="https://cdnjs.cloudflare.com/ajax/libs/pixi.js/7.2.4/pixi.min.js" integrity="sha512-Ch/O6kL8BqUwAfCF7Ie5SX1Hin+BJgYH4pNjRqXdTEqMsis1TUYg+j6nnI9uduPjGaj7DN4UKCZgpvoExt6dkw==" crossorigin="anonymous" referrerpolicy="no-referrer"></script>

<script src="lib/scripts/webpage.js"></script>

			</head><body class="theme-dark mod-windows is-frameless is-maximized is-hidden-frameless obsidian-app show-inline-title show-view-header" style="--zoom-factor:1; --font-text-size:16px; --line-width:100%; --line-width-adaptive:100%; --file-line-width:100%; --content-width:500em; --sidebar-width:25em; --collapse-arrow-size:0.4em; --tree-horizontal-spacing:1em; --tree-vertical-spacing:0.5em; --sidebar-margin:12px;"><div class="webpage-container"><div class="sidebar-left sidebar"><div class="sidebar-content"><div><label class="theme-toggle-container" for="theme_toggle"><input class="theme-toggle-input" type="checkbox" id="theme_toggle"><div class="toggle-background"></div></label></div><div class="tree-container file-tree mod-nav-indicator" data-depth="0"><div class="tree-header"><span class="sidebar-section-header">learn-haskell-valut</span><button class="clickable-icon collapse-tree-button is-collapsed"><iconify-icon icon="ph:arrows-in-line-horizontal-bold" width="18px" height="18px" rotate="90deg" color="currentColor"></iconify-icon></button></div><div class="tree-scroll-area"><div class="tree-item mod-tree-folder mod-collapsible is-collapsed" data-depth="1"><div class="tree-item-contents"><div class="tree-item-icon collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div><a class="tree-item-link" href="курсы"><span class="tree-item-title">Курсы</span></a></div><div class="tree-item-children"><div class="tree-item mod-tree-folder mod-collapsible is-collapsed" data-depth="2"><div class="tree-item-contents"><div class="tree-item-icon collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div><a class="tree-item-link" href="курсы/о-haskell-по-человечески"><span class="tree-item-title">О Haskell по-человечески</span></a></div><div class="tree-item-children"><div class="tree-item mod-tree-file" data-depth="3"><div class="tree-item-contents"><a class="tree-item-link" href="курсы/о-haskell-по-человечески/о-haskell-по-человечески-(оригинал).html"><span class="tree-item-title">О Haskell по-человечески (Оригинал)</span></a></div><div class="tree-item-children"></div></div></div></div><div class="tree-item mod-tree-folder mod-collapsible is-collapsed" data-depth="2"><div class="tree-item-contents"><div class="tree-item-icon collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div><a class="tree-item-link" href="курсы/learn-you-a-haskell-for-great-good!"><span class="tree-item-title">Learn You a Haskell for Great Good!</span></a></div><div class="tree-item-children"><div class="tree-item mod-tree-folder mod-collapsible is-collapsed" data-depth="3"><div class="tree-item-contents"><div class="tree-item-icon collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div><a class="tree-item-link" href="курсы/learn-you-a-haskell-for-great-good!/en"><span class="tree-item-title">en</span></a></div><div class="tree-item-children"><div class="tree-item mod-tree-file" data-depth="4"><div class="tree-item-contents"><a class="tree-item-link" href="курсы/learn-you-a-haskell-for-great-good!/en/chapter-1-introduction.html"><span class="tree-item-title">Chapter 1 Introduction</span></a></div><div class="tree-item-children"></div></div><div class="tree-item mod-tree-file" data-depth="4"><div class="tree-item-contents"><a class="tree-item-link" href="курсы/learn-you-a-haskell-for-great-good!/en/chapter-10-functionally-solving-problems.html"><span class="tree-item-title">Chapter 10 Functionally Solving Problems</span></a></div><div class="tree-item-children"></div></div><div class="tree-item mod-tree-file" data-depth="4"><div class="tree-item-contents"><a class="tree-item-link" href="курсы/learn-you-a-haskell-for-great-good!/en/chapter-11-functors,-applicative-functors-and-monoids.html"><span class="tree-item-title">Chapter 11 Functors, Applicative Functors and Monoids</span></a></div><div class="tree-item-children"></div></div><div class="tree-item mod-tree-file" data-depth="4"><div class="tree-item-contents"><a class="tree-item-link" href="курсы/learn-you-a-haskell-for-great-good!/en/chapter-12-a-fistful-of-monads.html"><span class="tree-item-title">Chapter 12 A Fistful of Monads</span></a></div><div class="tree-item-children"></div></div><div class="tree-item mod-tree-file" data-depth="4"><div class="tree-item-contents"><a class="tree-item-link" href="курсы/learn-you-a-haskell-for-great-good!/en/chapter-13-for-a-few-monads-more.html"><span class="tree-item-title">Chapter 13 For a Few Monads More</span></a></div><div class="tree-item-children"></div></div><div class="tree-item mod-tree-file" data-depth="4"><div class="tree-item-contents"><a class="tree-item-link" href="курсы/learn-you-a-haskell-for-great-good!/en/chapter-14-zippers.html"><span class="tree-item-title">Chapter 14 Zippers</span></a></div><div class="tree-item-children"></div></div><div class="tree-item mod-tree-file" data-depth="4"><div class="tree-item-contents"><a class="tree-item-link" href="курсы/learn-you-a-haskell-for-great-good!/en/chapter-2-starting-out.html"><span class="tree-item-title">Chapter 2 Starting Out</span></a></div><div class="tree-item-children"></div></div><div class="tree-item mod-tree-file" data-depth="4"><div class="tree-item-contents"><a class="tree-item-link" href="курсы/learn-you-a-haskell-for-great-good!/en/chapter-3-types-and-typeclasses.html"><span class="tree-item-title">Chapter 3 Types and Typeclasses</span></a></div><div class="tree-item-children"></div></div><div class="tree-item mod-tree-file" data-depth="4"><div class="tree-item-contents"><a class="tree-item-link" href="курсы/learn-you-a-haskell-for-great-good!/en/chapter-4-syntax-in-functions.html"><span class="tree-item-title">Chapter 4 Syntax in Functions</span></a></div><div class="tree-item-children"></div></div><div class="tree-item mod-tree-file" data-depth="4"><div class="tree-item-contents"><a class="tree-item-link" href="курсы/learn-you-a-haskell-for-great-good!/en/chapter-5-recursion.html"><span class="tree-item-title">Chapter 5 Recursion</span></a></div><div class="tree-item-children"></div></div><div class="tree-item mod-tree-file" data-depth="4"><div class="tree-item-contents"><a class="tree-item-link" href="курсы/learn-you-a-haskell-for-great-good!/en/chapter-6-higher-order-functions.html"><span class="tree-item-title">Chapter 6 Higher order functions</span></a></div><div class="tree-item-children"></div></div><div class="tree-item mod-tree-file" data-depth="4"><div class="tree-item-contents"><a class="tree-item-link" href="курсы/learn-you-a-haskell-for-great-good!/en/chapter-7-modules.html"><span class="tree-item-title">Chapter 7 Modules</span></a></div><div class="tree-item-children"></div></div><div class="tree-item mod-tree-file" data-depth="4"><div class="tree-item-contents"><a class="tree-item-link" href="курсы/learn-you-a-haskell-for-great-good!/en/chapter-8-making-our-own-types-and-typeclasses.html"><span class="tree-item-title">Chapter 8 Making Our Own Types and Typeclasses</span></a></div><div class="tree-item-children"></div></div><div class="tree-item mod-tree-file" data-depth="4"><div class="tree-item-contents"><a class="tree-item-link" href="курсы/learn-you-a-haskell-for-great-good!/en/chapter-9-input-and-output.html"><span class="tree-item-title">Chapter 9 Input and Output</span></a></div><div class="tree-item-children"></div></div><div class="tree-item mod-tree-file" data-depth="4"><div class="tree-item-contents"><a class="tree-item-link" href="курсы/learn-you-a-haskell-for-great-good!/en/table-of-content.html"><span class="tree-item-title">Table Of Content</span></a></div><div class="tree-item-children"></div></div></div></div><div class="tree-item mod-tree-folder mod-collapsible is-collapsed" data-depth="3"><div class="tree-item-contents"><div class="tree-item-icon collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div><a class="tree-item-link" href="курсы/learn-you-a-haskell-for-great-good!/ru"><span class="tree-item-title">ru</span></a></div><div class="tree-item-children"><div class="tree-item mod-tree-file" data-depth="4"><div class="tree-item-contents"><a class="tree-item-link" href="курсы/learn-you-a-haskell-for-great-good!/ru/оглавление.html"><span class="tree-item-title">Оглавление</span></a></div><div class="tree-item-children"></div></div></div></div><div class="tree-item mod-tree-file" data-depth="3"><div class="tree-item-contents"><a class="tree-item-link" href="курсы/learn-you-a-haskell-for-great-good!/readme.html"><span class="tree-item-title">README</span></a></div><div class="tree-item-children"></div></div></div></div></div></div><div class="tree-item mod-tree-folder mod-collapsible is-collapsed" data-depth="1"><div class="tree-item-contents"><div class="tree-item-icon collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div><a class="tree-item-link" href="мои-решения"><span class="tree-item-title">Мои решения</span></a></div><div class="tree-item-children"><div class="tree-item mod-tree-folder mod-collapsible is-collapsed" data-depth="2"><div class="tree-item-contents"><div class="tree-item-icon collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div><a class="tree-item-link" href="мои-решения/о-haskell-по-человечески"><span class="tree-item-title">О Haskell по-человечески</span></a></div><div class="tree-item-children"><div class="tree-item mod-tree-file" data-depth="3"><div class="tree-item-contents"><a class="tree-item-link" href="мои-решения/о-haskell-по-человечески/о-haskell-по-человечески-(итого).html"><span class="tree-item-title">О Haskell по-человечески (Итого)</span></a></div><div class="tree-item-children"></div></div></div></div></div></div><div class="tree-item mod-tree-file" data-depth="1"><div class="tree-item-contents"><a class="tree-item-link" href="отчеты.html"><span class="tree-item-title">Отчеты</span></a></div><div class="tree-item-children"></div></div><div class="tree-item mod-tree-file" data-depth="1"><div class="tree-item-contents"><a class="tree-item-link" href="полезные-ресурсы.html"><span class="tree-item-title">Полезные ресурсы</span></a></div><div class="tree-item-children"></div></div><div class="tree-item mod-tree-file" data-depth="1"><div class="tree-item-contents"><a class="tree-item-link" href="readme.html"><span class="tree-item-title">README</span></a></div><div class="tree-item-children"></div></div></div></div></div></div><div class="document-container"><div class="markdown-preview-view markdown-rendered node-insert-event allow-fold-headings show-indentation-guide allow-fold-lists show-frontmatter" style="tab-size: 4;" tabindex="-1"><style id="MJX-CHTML-styles"></style><div class="markdown-preview-sizer markdown-preview-section" style="padding-bottom: ; padding-top: var(--file-margins); padding-right: var(--file-margins); padding-left: var(--file-margins); width: 100%; position: absolute;"><div class="markdown-preview-pusher" style="width: 1px; height: 0.1px; margin-bottom: 0px;"></div><div class="mod-header"></div><div><h1 data-heading="Recursion" id="Recursion">Recursion</h1></div><div><h2 data-heading="Hello recursion!" id="Hello_recursion!" style="display: flex;"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>Hello recursion!</h2></div><div><p><img alt="SOVIET RUSSIA" src="http://s3.amazonaws.com/lyah/recursion.png" referrerpolicy="no-referrer"></p></div><div><p>We mention recursion briefly in the previous chapter. In this chapter, we'll take a closer look at recursion, why it's important to Haskell and how we can work out very concise and elegant solutions to problems by thinking recursively.</p></div><div><p>If you still don't know what recursion is, read this sentence. Haha! Just kidding! Recursion is actually a way of defining functions in which the function is applied inside its own definition. Definitions in mathematics are often given recursively. For instance, the fibonacci sequence is defined recursively. First, we define the first two fibonacci numbers non-recursively. We say that&nbsp;<em>F(0) = 0</em>&nbsp;and&nbsp;<em>F(1) = 1</em>, meaning that the 0th and 1st fibonacci numbers are 0 and 1, respectively. Then we say that for any other natural number, that fibonacci number is the sum of the previous two fibonacci numbers. So&nbsp;<em>F(n) = F(n-1) + F(n-2)</em>. That way,&nbsp;<em>F(3)</em>&nbsp;is&nbsp;<em>F(2) + F(1)</em>, which is&nbsp;<em>(F(1) + F(0)) + F(1)</em>. Because we've now come down to only non-recursively defined fibonacci numbers, we can safely say that&nbsp;<em>F(3)</em>&nbsp;is 2. Having an element or two in a recursion definition defined non-recursively (like&nbsp;<em>F(0)</em>&nbsp;and&nbsp;<em>F(1)</em>&nbsp;here) is also called the&nbsp;<strong>edge condition</strong>&nbsp;and is important if you want your recursive function to terminate. If we hadn't defined&nbsp;<em>F(0)</em>&nbsp;and&nbsp;<em>F(1)</em>&nbsp;non recursively, you'd never get a solution any number because you'd reach 0 and then you'd go into negative numbers. All of a sudden, you'd be saying that&nbsp;<em>F(-2000)</em>&nbsp;is&nbsp;<em>F(-2001) + F(-2002)</em>&nbsp;and there still wouldn't be an end in sight!</p></div><div><p>Recursion is important to Haskell because unlike imperative languages, you do computations in Haskell by declaring what something&nbsp;<em>is</em>&nbsp;instead of declaring&nbsp;<em>how</em>&nbsp;you get it. That's why there are no while loops or for loops in Haskell and instead we many times have to use recursion to declare what something is.</p></div><div><h2 data-heading="Maximum awesome" id="Maximum_awesome" style="display: flex;"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>Maximum awesome</h2></div><div><p>The&nbsp;<code>maximum</code>&nbsp;function takes a list of things that can be ordered (e.g. instances of the&nbsp;<code>Ord</code>&nbsp;typeclass) and returns the biggest of them. Think about how you'd implement that in an imperative fashion. You'd probably set up a variable to hold the maximum value so far and then you'd loop through the elements of a list and if an element is bigger than then the current maximum value, you'd replace it with that element. The maximum value that remains at the end is the result. Whew! That's quite a lot of words to describe such a simple algorithm!</p></div><div><p>Now let's see how we'd define it recursively. We could first set up an edge condition and say that the maximum of a singleton list is equal to the only element in it. Then we can say that the maximum of a longer list is the head if the head is bigger than the maximum of the tail. If the maximum of the tail is bigger, well, then it's the maximum of the tail. That's it! Now let's implement that in Haskell.</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token builtin">maximum</span>' <span class="token operator">::</span> <span class="token punctuation">(</span><span class="token constant">Ord</span> <span class="token hvariable">a</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">[</span><span class="token hvariable">a</span><span class="token punctuation">]</span> <span class="token operator">-&gt;</span> <span class="token hvariable">a</span>
<span class="token builtin">maximum</span>' <span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token builtin">error</span> <span class="token string">"maximum of empty list"</span>
<span class="token builtin">maximum</span>' <span class="token punctuation">[</span><span class="token hvariable">x</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token hvariable">x</span>
<span class="token builtin">maximum</span>' <span class="token punctuation">(</span><span class="token hvariable">x</span><span class="token operator">:</span><span class="token hvariable">xs</span><span class="token punctuation">)</span> 
    <span class="token operator">|</span> <span class="token hvariable">x</span> <span class="token operator">&gt;</span> <span class="token hvariable">maxTail</span> <span class="token operator">=</span> <span class="token hvariable">x</span>
    <span class="token operator">|</span> <span class="token builtin">otherwise</span> <span class="token operator">=</span> <span class="token hvariable">maxTail</span>
    <span class="token keyword">where</span> <span class="token hvariable">maxTail</span> <span class="token operator">=</span> <span class="token builtin">maximum</span>' <span class="token hvariable">xs</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>As you can see, pattern matching goes great with recursion! Most imperative languages don't have pattern matching so you have to make a lot of if else statements to test for edge conditions. Here, we simply put them out as patterns. So the first edge condition says that if the list is empty, crash! Makes sense because what's the maximum of an empty list? I don't know. The second pattern also lays out an edge condition. It says that if it's the singleton list, just give back the only element.</p></div><div><p>Now the third pattern is where the action happens. We use pattern matching to split a list into a head and a tail. This is a very common idiom when doing recursion with lists, so get used to it. We use a&nbsp;<em>where</em>&nbsp;binding to define&nbsp;<code>maxTail</code>&nbsp;as the maximum of the rest of the list. Then we check if the head is greater than the maximum of the rest of the list. If it is, we return the head. Otherwise, we return the maximum of the rest of the list.</p></div><div><p>Let's take an example list of numbers and check out how this would work on them:&nbsp;<code>[2,5,1]</code>. If we call&nbsp;<code>maximum'</code>&nbsp;on that, the first two patterns won't match. The third one will and the list is split into&nbsp;<code>2</code>&nbsp;and&nbsp;<code>[5,1]</code>. The&nbsp;<em>where</em>&nbsp;clause wants to know the maximum of&nbsp;<code>[5,1]</code>, so we follow that route. It matches the third pattern again and&nbsp;<code>[5,1]</code>&nbsp;is split into&nbsp;<code>5</code>&nbsp;and&nbsp;<code>[1]</code>. Again, the&nbsp;<code>where</code>&nbsp;clause wants to know the maximum of&nbsp;<code>[1]</code>. Because that's the edge condition, it returns&nbsp;<code>1</code>. Finally! So going up one step, comparing&nbsp;<code>5</code>&nbsp;to the maximum of&nbsp;<code>[1]</code>&nbsp;(which is&nbsp;<code>1</code>), we obviously get back&nbsp;<code>5</code>. So now we know that the maximum of&nbsp;<code>[5,1]</code>&nbsp;is&nbsp;<code>5</code>. We go up one step again where we had&nbsp;<code>2</code>&nbsp;and&nbsp;<code>[5,1]</code>. Comparing&nbsp;<code>2</code>&nbsp;with the maximum of&nbsp;<code>[5,1]</code>, which is&nbsp;<code>5</code>, we choose&nbsp;<code>5</code>.</p></div><div><p>An even clearer way to write this function is to use&nbsp;<code>max</code>. If you remember,&nbsp;<code>max</code>&nbsp;is a function that takes two numbers and returns the bigger of them. Here's how we could rewrite&nbsp;<code>maximum'</code>&nbsp;by using&nbsp;<code>max</code>:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token builtin">maximum</span>' <span class="token operator">::</span> <span class="token punctuation">(</span><span class="token constant">Ord</span> <span class="token hvariable">a</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">[</span><span class="token hvariable">a</span><span class="token punctuation">]</span> <span class="token operator">-&gt;</span> <span class="token hvariable">a</span>
<span class="token builtin">maximum</span>' <span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token builtin">error</span> <span class="token string">"maximum of empty list"</span>
<span class="token builtin">maximum</span>' <span class="token punctuation">[</span><span class="token hvariable">x</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token hvariable">x</span>
<span class="token builtin">maximum</span>' <span class="token punctuation">(</span><span class="token hvariable">x</span><span class="token operator">:</span><span class="token hvariable">xs</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token builtin">max</span> <span class="token hvariable">x</span> <span class="token punctuation">(</span><span class="token builtin">maximum</span>' <span class="token hvariable">xs</span><span class="token punctuation">)</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>How's that for elegant! In essence, the maximum of a list is the max of the first element and the maximum of the tail.</p></div><div><p><img alt="max" src="http://s3.amazonaws.com/lyah/maxs.png" referrerpolicy="no-referrer"></p></div><div><h2 data-heading="A few more recursive functions" id="A_few_more_recursive_functions" style="display: flex;"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>A few more recursive functions</h2></div><div><p>Now that we know how to generally think recursively, let's implement a few functions using recursion. First off, we'll implement&nbsp;<code>replicate</code>.&nbsp;<code>replicate</code>&nbsp;takes an&nbsp;<code>Int</code>&nbsp;and some element and returns a list that has several repetitions of the same element. For instance,&nbsp;<code>replicate 3 5</code>&nbsp;returns&nbsp;<code>[5,5,5]</code>. Let's think about the edge condition. My guess is that the edge condition is 0 or less. If we try to replicate something zero times, it should return an empty list. Also for negative numbers, because it doesn't really make sense.</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token builtin">replicate</span>' <span class="token operator">::</span> <span class="token punctuation">(</span><span class="token constant">Num</span> <span class="token hvariable">i</span><span class="token punctuation">,</span> <span class="token constant">Ord</span> <span class="token hvariable">i</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token hvariable">i</span> <span class="token operator">-&gt;</span> <span class="token hvariable">a</span> <span class="token operator">-&gt;</span> <span class="token punctuation">[</span><span class="token hvariable">a</span><span class="token punctuation">]</span>
<span class="token builtin">replicate</span>' <span class="token hvariable">n</span> <span class="token hvariable">x</span>
    <span class="token operator">|</span> <span class="token hvariable">n</span> <span class="token operator">&lt;=</span> <span class="token number">0</span>    <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
    <span class="token operator">|</span> <span class="token builtin">otherwise</span> <span class="token operator">=</span> <span class="token hvariable">x</span><span class="token operator">:</span><span class="token builtin">replicate</span>' <span class="token punctuation">(</span><span class="token hvariable">n</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token hvariable">x</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>We used guards here instead of patterns because we're testing for a boolean condition. If&nbsp;<code>n</code>&nbsp;is less than or equal to 0, return an empty list. Otherwise return a list that has&nbsp;<code>x</code>&nbsp;as the first element and then&nbsp;<code>x</code>&nbsp;replicated n-1 times as the tail. Eventually, the&nbsp;<code>(n-1)</code>&nbsp;part will cause our function to reach the edge condition.</p></div><div><p><em>Note:</em>&nbsp;Num&nbsp;is not a subclass of&nbsp;Ord. That means that what constitutes for a number doesn't really have to adhere to an ordering. So that's why we have to specify both the&nbsp;Num&nbsp;and&nbsp;Ord&nbsp;class constraints when doing addition or subtraction and also comparison.</p></div><div><p>Next up, we'll implement&nbsp;<code>take</code>. It takes a certain number of elements from a list. For instance,&nbsp;<code>take 3 [5,4,3,2,1]</code>&nbsp;will return&nbsp;<code>[5,4,3]</code>. If we try to take 0 or less elements from a list, we get an empty list. Also if we try to take anything from an empty list, we get an empty list. Notice that those are two edge conditions right there. So let's write that out:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token builtin">take</span>' <span class="token operator">::</span> <span class="token punctuation">(</span><span class="token constant">Num</span> <span class="token hvariable">i</span><span class="token punctuation">,</span> <span class="token constant">Ord</span> <span class="token hvariable">i</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token hvariable">i</span> <span class="token operator">-&gt;</span> <span class="token punctuation">[</span><span class="token hvariable">a</span><span class="token punctuation">]</span> <span class="token operator">-&gt;</span> <span class="token punctuation">[</span><span class="token hvariable">a</span><span class="token punctuation">]</span>
<span class="token builtin">take</span>' <span class="token hvariable">n</span> <span class="token hvariable">_</span>
    <span class="token operator">|</span> <span class="token hvariable">n</span> <span class="token operator">&lt;=</span> <span class="token number">0</span>   <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
<span class="token builtin">take</span>' <span class="token hvariable">_</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>     <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
<span class="token builtin">take</span>' <span class="token hvariable">n</span> <span class="token punctuation">(</span><span class="token hvariable">x</span><span class="token operator">:</span><span class="token hvariable">xs</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token hvariable">x</span> <span class="token operator">:</span> <span class="token builtin">take</span>' <span class="token punctuation">(</span><span class="token hvariable">n</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token hvariable">xs</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p><img alt="painter" src="http://s3.amazonaws.com/lyah/painter.png" referrerpolicy="no-referrer"></p></div><div><p>The first pattern specifies that if we try to take a 0 or negative number of elements, we get an empty list. Notice that we're using&nbsp;<code>_</code>&nbsp;to match the list because we don't really care what it is in this case. Also notice that we use a guard, but without an&nbsp;<code>otherwise</code>&nbsp;part. That means that if&nbsp;<code>n</code>&nbsp;turns out to be more than 0, the matching will fall through to the next pattern. The second pattern indicates that if we try to take anything from an empty list, we get an empty list. The third pattern breaks the list into a head and a tail. And then we state that taking&nbsp;<code>n</code>&nbsp;elements from a list equals a list that has&nbsp;<code>x</code>&nbsp;as the head and then a list that takes&nbsp;<code>n-1</code>&nbsp;elements from the tail as a tail. Try using a piece of paper to write down how the evaluation would look like if we try to take, say, 3 from&nbsp;<code>[4,3,2,1]</code>.</p></div><div><p><code>reverse</code>&nbsp;simply reverses a list. Think about the edge condition. What is it? Come on ... it's the empty list! An empty list reversed equals the empty list itself. O-kay. What about the rest of it? Well, you could say that if we split a list to a head and a tail, the reversed list is equal to the reversed tail and then the head at the end.</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token builtin">reverse</span>' <span class="token operator">::</span> <span class="token punctuation">[</span><span class="token hvariable">a</span><span class="token punctuation">]</span> <span class="token operator">-&gt;</span> <span class="token punctuation">[</span><span class="token hvariable">a</span><span class="token punctuation">]</span>
<span class="token builtin">reverse</span>' <span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
<span class="token builtin">reverse</span>' <span class="token punctuation">(</span><span class="token hvariable">x</span><span class="token operator">:</span><span class="token hvariable">xs</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token builtin">reverse</span>' <span class="token hvariable">xs</span> <span class="token operator">++</span> <span class="token punctuation">[</span><span class="token hvariable">x</span><span class="token punctuation">]</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>There we go!</p></div><div><p>Because Haskell supports infinite lists, our recursion doesn't really have to have an edge condition. But if it doesn't have it, it will either keep churning at something infinitely or produce an infinite data structure, like an infinite list. The good thing about infinite lists though is that we can cut them where we want.&nbsp;<code>repeat</code>&nbsp;takes an element and returns an infinite list that just has that element. A recursive implementation of that is really easy, watch.</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token builtin">repeat</span>' <span class="token operator">::</span> <span class="token hvariable">a</span> <span class="token operator">-&gt;</span> <span class="token punctuation">[</span><span class="token hvariable">a</span><span class="token punctuation">]</span>
<span class="token builtin">repeat</span>' <span class="token hvariable">x</span> <span class="token operator">=</span> <span class="token hvariable">x</span><span class="token operator">:</span><span class="token builtin">repeat</span>' <span class="token hvariable">x</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Calling&nbsp;<code>repeat 3</code>&nbsp;will give us a list that starts with&nbsp;<code>3</code>&nbsp;and then has an infinite amount of 3's as a tail. So calling&nbsp;<code>repeat 3</code>&nbsp;would evaluate like&nbsp;<code>3:repeat 3</code>, which is&nbsp;<code>3:(3:repeat 3)</code>, which is&nbsp;<code>3:(3:(3:repeat 3))</code>, etc.&nbsp;<code>repeat 3</code>&nbsp;will never finish evaluating, whereas&nbsp;<code>take 5 (repeat 3)</code>&nbsp;will give us a list of five 3's. So essentially it's like doing&nbsp;<code>replicate 5 3</code>.</p></div><div><p><code>zip</code>&nbsp;takes two lists and zips them together.&nbsp;<code>zip [1,2,3] [2,3]</code>&nbsp;returns&nbsp;<code>[(1,2),(2,3)]</code>, because it truncates the longer list to match the length of the shorter one. How about if we zip something with an empty list? Well, we get an empty list back then. So there's our edge condition. However,&nbsp;<code>zip</code>&nbsp;takes two lists as parameters, so there are actually two edge conditions.</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token builtin">zip</span>' <span class="token operator">::</span> <span class="token punctuation">[</span><span class="token hvariable">a</span><span class="token punctuation">]</span> <span class="token operator">-&gt;</span> <span class="token punctuation">[</span><span class="token hvariable">b</span><span class="token punctuation">]</span> <span class="token operator">-&gt;</span> <span class="token punctuation">[</span><span class="token punctuation">(</span><span class="token hvariable">a</span><span class="token punctuation">,</span><span class="token hvariable">b</span><span class="token punctuation">)</span><span class="token punctuation">]</span>
<span class="token builtin">zip</span>' <span class="token hvariable">_</span> <span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
<span class="token builtin">zip</span>' <span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token hvariable">_</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
<span class="token builtin">zip</span>' <span class="token punctuation">(</span><span class="token hvariable">x</span><span class="token operator">:</span><span class="token hvariable">xs</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token hvariable">y</span><span class="token operator">:</span><span class="token hvariable">ys</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token hvariable">x</span><span class="token punctuation">,</span><span class="token hvariable">y</span><span class="token punctuation">)</span><span class="token operator">:</span><span class="token builtin">zip</span>' <span class="token hvariable">xs</span> <span class="token hvariable">ys</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>First two patterns say that if the first list or second list is empty, we get an empty list. The third one says that two lists zipped are equal to pairing up their heads and then tacking on the zipped tails. Zipping&nbsp;<code>[1,2,3]</code>&nbsp;and&nbsp;<code>['a','b']</code>&nbsp;will eventually try to zip&nbsp;<code>[3]</code>&nbsp;with&nbsp;<code>[]</code>. The edge condition patterns kick in and so the result is&nbsp;<code>(1,'a'):(2,'b'):[]</code>, which is exactly the same as&nbsp;<code>[(1,'a'),(2,'b')]</code>.</p></div><div><p>Let's implement one more standard library function —&nbsp;<code>elem</code>. It takes an element and a list and sees if that element is in the list. The edge condition, as is most of the times with lists, is the empty list. We know that an empty list contains no elements, so it certainly doesn't have the droids we're looking for.</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token builtin">elem</span>' <span class="token operator">::</span> <span class="token punctuation">(</span><span class="token constant">Eq</span> <span class="token hvariable">a</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token hvariable">a</span> <span class="token operator">-&gt;</span> <span class="token punctuation">[</span><span class="token hvariable">a</span><span class="token punctuation">]</span> <span class="token operator">-&gt;</span> <span class="token constant">Bool</span>
<span class="token builtin">elem</span>' <span class="token hvariable">a</span> <span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token constant">False</span>
<span class="token builtin">elem</span>' <span class="token hvariable">a</span> <span class="token punctuation">(</span><span class="token hvariable">x</span><span class="token operator">:</span><span class="token hvariable">xs</span><span class="token punctuation">)</span>
    <span class="token operator">|</span> <span class="token hvariable">a</span> <span class="token operator">==</span> <span class="token hvariable">x</span>    <span class="token operator">=</span> <span class="token constant">True</span>
    <span class="token operator">|</span> <span class="token builtin">otherwise</span> <span class="token operator">=</span> <span class="token hvariable">a</span> <span class="token operator">`elem'`</span> <span class="token hvariable">xs</span> 
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Pretty simple and expected. If the head isn't the element then we check the tail. If we reach an empty list, the result is&nbsp;<code>False</code>.</p></div><div><h2 data-heading="Quick, sort!" id="Quick,_sort!" style="display: flex;"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>Quick, sort!</h2></div><div><p>We have a list of items that can be sorted. Their type is an instance of the&nbsp;<code>Ord</code>&nbsp;typeclass. And now, we want to sort them! There's a very cool algoritm for sorting called quicksort. It's a very clever way of sorting items. While it takes upwards of 10 lines to implement quicksort in imperative languages, the implementation is much shorter and elegant in Haskell. Quicksort has become a sort of poster child for Haskell. Therefore, let's implement it here, even though implementing quicksort in Haskell is considered really cheesy because everyone does it to showcase how elegant Haskell is.</p></div><div><p><img alt="quickman" src="http://s3.amazonaws.com/lyah/quickman.png" referrerpolicy="no-referrer"></p></div><div><p>So, the type signature is going to be&nbsp;<code>quicksort :: (Ord a) =&gt; [a] -&gt; [a]</code>. No surprises there. The edge condition? Empty list, as is expected. A sorted empty list is an empty list. Now here comes the main algorithm:&nbsp;<strong>a sorted list is a list that has all the values smaller than (or equal to) the head of the list in front (and those values are sorted), then comes the head of the list in the middle and then come all the values that are bigger than the head (they're also sorted).</strong>&nbsp;Notice that we said&nbsp;<em>sorted</em>&nbsp;two times in this definition, so we'll probably have to make the recursive call twice! Also notice that we defined it using the verb&nbsp;<em>is</em>&nbsp;to define the algorithm instead of saying&nbsp;<em>do this, do that, then do that ...</em>. That's the beauty of functional programming! How are we going to filter the list so that we get only the elements smaller than the head of our list and only elements that are bigger? List comprehensions. So, let's dive in and define this function.</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">quicksort</span> <span class="token operator">::</span> <span class="token punctuation">(</span><span class="token constant">Ord</span> <span class="token hvariable">a</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">[</span><span class="token hvariable">a</span><span class="token punctuation">]</span> <span class="token operator">-&gt;</span> <span class="token punctuation">[</span><span class="token hvariable">a</span><span class="token punctuation">]</span>
<span class="token hvariable">quicksort</span> <span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
<span class="token hvariable">quicksort</span> <span class="token punctuation">(</span><span class="token hvariable">x</span><span class="token operator">:</span><span class="token hvariable">xs</span><span class="token punctuation">)</span> <span class="token operator">=</span> 
    <span class="token keyword">let</span> <span class="token hvariable">smallerSorted</span> <span class="token operator">=</span> <span class="token hvariable">quicksort</span> <span class="token punctuation">[</span><span class="token hvariable">a</span> <span class="token operator">|</span> <span class="token hvariable">a</span> <span class="token operator">&lt;-</span> <span class="token hvariable">xs</span><span class="token punctuation">,</span> <span class="token hvariable">a</span> <span class="token operator">&lt;=</span> <span class="token hvariable">x</span><span class="token punctuation">]</span>
        <span class="token hvariable">biggerSorted</span> <span class="token operator">=</span> <span class="token hvariable">quicksort</span> <span class="token punctuation">[</span><span class="token hvariable">a</span> <span class="token operator">|</span> <span class="token hvariable">a</span> <span class="token operator">&lt;-</span> <span class="token hvariable">xs</span><span class="token punctuation">,</span> <span class="token hvariable">a</span> <span class="token operator">&gt;</span> <span class="token hvariable">x</span><span class="token punctuation">]</span>
    <span class="token keyword">in</span>  <span class="token hvariable">smallerSorted</span> <span class="token operator">++</span> <span class="token punctuation">[</span><span class="token hvariable">x</span><span class="token punctuation">]</span> <span class="token operator">++</span> <span class="token hvariable">biggerSorted</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Let's give it a small test run to see if it appears to behave correctly.</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token hvariable">quicksort</span> <span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">,</span><span class="token number">7</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">8</span><span class="token punctuation">,</span><span class="token number">9</span><span class="token punctuation">]</span>
<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">,</span><span class="token number">7</span><span class="token punctuation">,</span><span class="token number">8</span><span class="token punctuation">,</span><span class="token number">9</span><span class="token punctuation">,</span><span class="token number">10</span><span class="token punctuation">]</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token hvariable">quicksort</span> <span class="token string">"the quick brown fox jumps over the lazy dog"</span>
<span class="token string">"        abcdeeefghhijklmnoooopqrrsttuuvwxyz"</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Booyah! That's what I'm talking about! So if we have, say&nbsp;<code>[5,1,9,4,6,7,3]</code>&nbsp;and we want to sort it, this algorithm will first take the head, which is&nbsp;<code>5</code>&nbsp;and then put it in the middle of two lists that are smaller and bigger than it. So at one point, you'll have&nbsp;<code>[1,4,3] ++ [5] ++ [9,6,7]</code>. We know that once the list is sorted completely, the number&nbsp;<code>5</code>&nbsp;will stay in the fourth place since there are 3 numbers lower than it and 3 numbers higher than it. Now, if we sort&nbsp;<code>[1,4,3]</code>&nbsp;and&nbsp;<code>[9,6,7]</code>, we have a sorted list! We sort the two lists using the same function. Eventually, we'll break it up so much that we reach empty lists and an empty list is already sorted in a way, by virtue of being empty. Here's an illustration:</p></div><div><p><img alt="quicksort" src="http://s3.amazonaws.com/lyah/quicksort.png" referrerpolicy="no-referrer"></p></div><div><p>An element that is in place and won't move anymore is represented in&nbsp;<code>orange</code>. If you read them from left to right, you'll see the sorted list. Although we chose to compare all the elements to the heads, we could have used any element to compare against. In quicksort, an element that you compare against is called a pivot. They're in&nbsp;<code>green</code>&nbsp;here. We chose the head because it's easy to get by pattern matching. The elements that are smaller than the pivot are&nbsp;<code>light green</code>&nbsp;and elements larger than the pivot are&nbsp;<code>dark green</code>. The yellowish gradient thing represents an application of quicksort.</p></div><div><h2 data-heading="Thinking recursively" id="Thinking_recursively" style="display: flex;"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>Thinking recursively</h2></div><div><p>We did quite a bit of recursion so far and as you've probably noticed, there's a pattern here. Usually you define an edge case and then you define a function that does something between some element and the function applied to the rest. It doesn't matter if it's a list, a tree or any other data structure. A sum is the first element of a list plus the sum of the rest of the list. A product of a list is the first element of the list times the product of the rest of the list. The length of a list is one plus the length of the tail of the list. Ekcetera, ekcetera ...</p></div><div><p><img alt="brain" src="http://s3.amazonaws.com/lyah/brain.png" referrerpolicy="no-referrer"></p></div><div><p>Of course, these also have edge cases. Usually the edge case is some scenario where a recursive application doesn't make sense. When dealing with lists, the edge case is most often the empty list. If you're dealing with trees, the edge case is usually a node that doesn't have any children.</p></div><div><p>It's similar when you're dealing with numbers recursively. Usually it has to do with some number and the function applied to that number modified. We did the factorial function earlier and it's the product of a number and the factorial of that number minus one. Such a recursive application doesn't make sense with zero, because factorials are defined only for positive integers. Often the edge case value turns out to be an identity. The identity for multiplication is 1 because if you multiply something by 1, you get that something back. Also when doing sums of lists, we define the sum of an empty list as 0 and 0 is the identity for addition. In quicksort, the edge case is the empty list and the identity is also the empty list, because if you add an empty list to a list, you just get the original list back.</p></div><div><p>So when trying to think of a recursive way to solve a problem, try to think of when a recursive solution doesn't apply and see if you can use that as an edge case, think about identities and think about whether you'll break apart the parameters of the function (for instance, lists are usually broken into a head and a tail via pattern matching) and on which part you'll use the recursive call.</p></div><div class="mod-footer"></div></div></div></div><div class="sidebar-right sidebar"><div class="sidebar-content"><span class="sidebar-section-header">Interactive Graph</span><div class="graph-view-placeholder">
		<div class="graph-view-container">
			<div class="graph-icon graph-expand" role="button" aria-label="Expand" data-tooltip-position="top"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon lucide-arrow-up-right"><line x1="7" y1="17" x2="17" y2="7"></line><polyline points="7 7 17 7 17 17"></polyline></svg></div>
			<canvas id="graph-canvas" width="512px" height="512px"></canvas>
		</div>
		</div><div class="tree-container outline-tree" data-depth="0"><div class="tree-header"><span class="sidebar-section-header">Table Of Contents</span><button class="clickable-icon collapse-tree-button"><iconify-icon icon="ph:arrows-in-line-horizontal-bold" width="18px" height="18px" rotate="90deg" color="currentColor"></iconify-icon></button></div><div class="tree-scroll-area"><div class="tree-item mod-tree-heading" data-depth="1"><div class="tree-item-contents"><a class="tree-item-link" href="#Recursion"><span class="tree-item-title">Recursion</span></a></div><div class="tree-item-children"><div class="tree-item mod-tree-heading" data-depth="2"><div class="tree-item-contents"><a class="tree-item-link" href="#Hello_recursion!"><span class="tree-item-title">Hello recursion!</span></a></div><div class="tree-item-children"></div></div><div class="tree-item mod-tree-heading" data-depth="2"><div class="tree-item-contents"><a class="tree-item-link" href="#Maximum_awesome"><span class="tree-item-title">Maximum awesome</span></a></div><div class="tree-item-children"></div></div><div class="tree-item mod-tree-heading" data-depth="2"><div class="tree-item-contents"><a class="tree-item-link" href="#A_few_more_recursive_functions"><span class="tree-item-title">A few more recursive functions</span></a></div><div class="tree-item-children"></div></div><div class="tree-item mod-tree-heading" data-depth="2"><div class="tree-item-contents"><a class="tree-item-link" href="#Quick,_sort!"><span class="tree-item-title">Quick, sort!</span></a></div><div class="tree-item-children"></div></div><div class="tree-item mod-tree-heading" data-depth="2"><div class="tree-item-contents"><a class="tree-item-link" href="#Thinking_recursively"><span class="tree-item-title">Thinking recursively</span></a></div><div class="tree-item-children"></div></div></div></div></div></div></div></div></div></body></html>