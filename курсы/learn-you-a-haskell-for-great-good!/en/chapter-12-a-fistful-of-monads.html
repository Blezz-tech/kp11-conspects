<!DOCTYPE html>
<html><head>
			
		<title>Chapter 12 A Fistful of Monads</title>
		<base href="../../../">
		<meta id="root-path" root-path="../../../">

		<link rel="icon" sizes="96x96" href="https://publish-01.obsidian.md/access/f786db9fac45774fa4f0d8112e232d67/favicon-96x96.png">
		<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes, minimum-scale=1.0, maximum-scale=5.0">
		<meta charset="UTF-8">
		<script src="https://code.iconify.design/iconify-icon/1.0.3/iconify-icon.min.js"></script>

			<link rel="stylesheet" href="lib/styles/obsidian-styles.css">
			<link rel="stylesheet" href="lib/styles/theme.css">
			<link rel="stylesheet" href="lib/styles/plugin-styles.css">
			<link rel="stylesheet" href="lib/styles/snippets.css">
			<style>  </style>

			
			<!-- Graph View Data -->
			<script>
			let nodes=
{"nodeCount":22,"linkCount":21,"radii":[7,5.346938775510203,4.855867346938775,4.301020408163265,3.6823979591836737,3.6823979591836737,3.6823979591836737,3.6823979591836737,3.6823979591836737,3.6823979591836737,3.6823979591836737,3.6823979591836737,3.6823979591836737,3.6823979591836737,3.6823979591836737,3.6823979591836737,3.6823979591836737,3.6823979591836737,3.6823979591836737,3.6823979591836737,3.6823979591836737,3.6823979591836737],"labels":["Table Of Content","Отчеты","README","README","О Haskell по-человечески (Итого)","Полезные ресурсы","О Haskell по-человечески (Оригинал)","Оглавление","Chapter 13 For a Few Monads More","Chapter 12 A Fistful of Monads","Chapter 11 Functors, Applicative Functors and Monoids","Chapter 10 Functionally Solving Problems","Chapter 9 Input and Output","Chapter 8 Making Our Own Types and Typeclasses","Chapter 7 Modules","Chapter 6 Higher order functions","Chapter 5 Recursion","Chapter 4 Syntax in Functions","Chapter 14 Zippers","Chapter 1 Introduction","Chapter 2 Starting Out","Chapter 3 Types and Typeclasses"],"paths":["курсы/learn-you-a-haskell-for-great-good!/en/table-of-content.html","отчеты.html","курсы/learn-you-a-haskell-for-great-good!/readme.html","readme.html","мои-решения/о-haskell-по-человечески/о-haskell-по-человечески-(итого).html","полезные-ресурсы.html","курсы/о-haskell-по-человечески/о-haskell-по-человечески-(оригинал).html","курсы/learn-you-a-haskell-for-great-good!/ru/оглавление.html","курсы/learn-you-a-haskell-for-great-good!/en/chapter-13-for-a-few-monads-more.html","курсы/learn-you-a-haskell-for-great-good!/en/chapter-12-a-fistful-of-monads.html","курсы/learn-you-a-haskell-for-great-good!/en/chapter-11-functors,-applicative-functors-and-monoids.html","курсы/learn-you-a-haskell-for-great-good!/en/chapter-10-functionally-solving-problems.html","курсы/learn-you-a-haskell-for-great-good!/en/chapter-9-input-and-output.html","курсы/learn-you-a-haskell-for-great-good!/en/chapter-8-making-our-own-types-and-typeclasses.html","курсы/learn-you-a-haskell-for-great-good!/en/chapter-7-modules.html","курсы/learn-you-a-haskell-for-great-good!/en/chapter-6-higher-order-functions.html","курсы/learn-you-a-haskell-for-great-good!/en/chapter-5-recursion.html","курсы/learn-you-a-haskell-for-great-good!/en/chapter-4-syntax-in-functions.html","курсы/learn-you-a-haskell-for-great-good!/en/chapter-14-zippers.html","курсы/learn-you-a-haskell-for-great-good!/en/chapter-1-introduction.html","курсы/learn-you-a-haskell-for-great-good!/en/chapter-2-starting-out.html","курсы/learn-you-a-haskell-for-great-good!/en/chapter-3-types-and-typeclasses.html"],"linkSources":[3,3,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,2],"linkTargets":[5,1,6,4,2,19,20,21,17,16,15,14,13,12,11,10,9,8,18,0,7]};
			let attractionForce = 1;
			let linkLength = 10;
			let repulsionForce = 150;
			let centralForce = 3;
			let edgePruning = 100;
			</script>
			
<script type="module" src="lib/scripts/graph_view.js"></script>

<script src="lib/scripts/graph_wasm.js"></script>

<script src="lib/scripts/tinycolor.js"></script>

<script src="https://cdnjs.cloudflare.com/ajax/libs/pixi.js/7.2.4/pixi.min.js" integrity="sha512-Ch/O6kL8BqUwAfCF7Ie5SX1Hin+BJgYH4pNjRqXdTEqMsis1TUYg+j6nnI9uduPjGaj7DN4UKCZgpvoExt6dkw==" crossorigin="anonymous" referrerpolicy="no-referrer"></script>

<script src="lib/scripts/webpage.js"></script>

			</head><body class="theme-dark mod-windows is-frameless is-maximized is-hidden-frameless obsidian-app show-inline-title show-view-header" style="--zoom-factor:1; --font-text-size:16px; --line-width:100%; --line-width-adaptive:100%; --file-line-width:100%; --content-width:500em; --sidebar-width:25em; --collapse-arrow-size:0.4em; --tree-horizontal-spacing:1em; --tree-vertical-spacing:0.5em; --sidebar-margin:12px;"><div class="webpage-container"><div class="sidebar-left sidebar"><div class="sidebar-content"><div><label class="theme-toggle-container" for="theme_toggle"><input class="theme-toggle-input" type="checkbox" id="theme_toggle"><div class="toggle-background"></div></label></div><div class="tree-container file-tree mod-nav-indicator" data-depth="0"><div class="tree-header"><span class="sidebar-section-header">learn-haskell-valut</span><button class="clickable-icon collapse-tree-button is-collapsed"><iconify-icon icon="ph:arrows-in-line-horizontal-bold" width="18px" height="18px" rotate="90deg" color="currentColor"></iconify-icon></button></div><div class="tree-scroll-area"><div class="tree-item mod-tree-folder mod-collapsible is-collapsed" data-depth="1"><div class="tree-item-contents"><div class="tree-item-icon collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div><a class="tree-item-link" href="курсы"><span class="tree-item-title">Курсы</span></a></div><div class="tree-item-children"><div class="tree-item mod-tree-folder mod-collapsible is-collapsed" data-depth="2"><div class="tree-item-contents"><div class="tree-item-icon collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div><a class="tree-item-link" href="курсы/о-haskell-по-человечески"><span class="tree-item-title">О Haskell по-человечески</span></a></div><div class="tree-item-children"><div class="tree-item mod-tree-file" data-depth="3"><div class="tree-item-contents"><a class="tree-item-link" href="курсы/о-haskell-по-человечески/о-haskell-по-человечески-(оригинал).html"><span class="tree-item-title">О Haskell по-человечески (Оригинал)</span></a></div><div class="tree-item-children"></div></div></div></div><div class="tree-item mod-tree-folder mod-collapsible is-collapsed" data-depth="2"><div class="tree-item-contents"><div class="tree-item-icon collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div><a class="tree-item-link" href="курсы/learn-you-a-haskell-for-great-good!"><span class="tree-item-title">Learn You a Haskell for Great Good!</span></a></div><div class="tree-item-children"><div class="tree-item mod-tree-folder mod-collapsible is-collapsed" data-depth="3"><div class="tree-item-contents"><div class="tree-item-icon collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div><a class="tree-item-link" href="курсы/learn-you-a-haskell-for-great-good!/en"><span class="tree-item-title">en</span></a></div><div class="tree-item-children"><div class="tree-item mod-tree-file" data-depth="4"><div class="tree-item-contents"><a class="tree-item-link" href="курсы/learn-you-a-haskell-for-great-good!/en/chapter-1-introduction.html"><span class="tree-item-title">Chapter 1 Introduction</span></a></div><div class="tree-item-children"></div></div><div class="tree-item mod-tree-file" data-depth="4"><div class="tree-item-contents"><a class="tree-item-link" href="курсы/learn-you-a-haskell-for-great-good!/en/chapter-10-functionally-solving-problems.html"><span class="tree-item-title">Chapter 10 Functionally Solving Problems</span></a></div><div class="tree-item-children"></div></div><div class="tree-item mod-tree-file" data-depth="4"><div class="tree-item-contents"><a class="tree-item-link" href="курсы/learn-you-a-haskell-for-great-good!/en/chapter-11-functors,-applicative-functors-and-monoids.html"><span class="tree-item-title">Chapter 11 Functors, Applicative Functors and Monoids</span></a></div><div class="tree-item-children"></div></div><div class="tree-item mod-tree-file" data-depth="4"><div class="tree-item-contents"><a class="tree-item-link" href="курсы/learn-you-a-haskell-for-great-good!/en/chapter-12-a-fistful-of-monads.html"><span class="tree-item-title">Chapter 12 A Fistful of Monads</span></a></div><div class="tree-item-children"></div></div><div class="tree-item mod-tree-file" data-depth="4"><div class="tree-item-contents"><a class="tree-item-link" href="курсы/learn-you-a-haskell-for-great-good!/en/chapter-13-for-a-few-monads-more.html"><span class="tree-item-title">Chapter 13 For a Few Monads More</span></a></div><div class="tree-item-children"></div></div><div class="tree-item mod-tree-file" data-depth="4"><div class="tree-item-contents"><a class="tree-item-link" href="курсы/learn-you-a-haskell-for-great-good!/en/chapter-14-zippers.html"><span class="tree-item-title">Chapter 14 Zippers</span></a></div><div class="tree-item-children"></div></div><div class="tree-item mod-tree-file" data-depth="4"><div class="tree-item-contents"><a class="tree-item-link" href="курсы/learn-you-a-haskell-for-great-good!/en/chapter-2-starting-out.html"><span class="tree-item-title">Chapter 2 Starting Out</span></a></div><div class="tree-item-children"></div></div><div class="tree-item mod-tree-file" data-depth="4"><div class="tree-item-contents"><a class="tree-item-link" href="курсы/learn-you-a-haskell-for-great-good!/en/chapter-3-types-and-typeclasses.html"><span class="tree-item-title">Chapter 3 Types and Typeclasses</span></a></div><div class="tree-item-children"></div></div><div class="tree-item mod-tree-file" data-depth="4"><div class="tree-item-contents"><a class="tree-item-link" href="курсы/learn-you-a-haskell-for-great-good!/en/chapter-4-syntax-in-functions.html"><span class="tree-item-title">Chapter 4 Syntax in Functions</span></a></div><div class="tree-item-children"></div></div><div class="tree-item mod-tree-file" data-depth="4"><div class="tree-item-contents"><a class="tree-item-link" href="курсы/learn-you-a-haskell-for-great-good!/en/chapter-5-recursion.html"><span class="tree-item-title">Chapter 5 Recursion</span></a></div><div class="tree-item-children"></div></div><div class="tree-item mod-tree-file" data-depth="4"><div class="tree-item-contents"><a class="tree-item-link" href="курсы/learn-you-a-haskell-for-great-good!/en/chapter-6-higher-order-functions.html"><span class="tree-item-title">Chapter 6 Higher order functions</span></a></div><div class="tree-item-children"></div></div><div class="tree-item mod-tree-file" data-depth="4"><div class="tree-item-contents"><a class="tree-item-link" href="курсы/learn-you-a-haskell-for-great-good!/en/chapter-7-modules.html"><span class="tree-item-title">Chapter 7 Modules</span></a></div><div class="tree-item-children"></div></div><div class="tree-item mod-tree-file" data-depth="4"><div class="tree-item-contents"><a class="tree-item-link" href="курсы/learn-you-a-haskell-for-great-good!/en/chapter-8-making-our-own-types-and-typeclasses.html"><span class="tree-item-title">Chapter 8 Making Our Own Types and Typeclasses</span></a></div><div class="tree-item-children"></div></div><div class="tree-item mod-tree-file" data-depth="4"><div class="tree-item-contents"><a class="tree-item-link" href="курсы/learn-you-a-haskell-for-great-good!/en/chapter-9-input-and-output.html"><span class="tree-item-title">Chapter 9 Input and Output</span></a></div><div class="tree-item-children"></div></div><div class="tree-item mod-tree-file" data-depth="4"><div class="tree-item-contents"><a class="tree-item-link" href="курсы/learn-you-a-haskell-for-great-good!/en/table-of-content.html"><span class="tree-item-title">Table Of Content</span></a></div><div class="tree-item-children"></div></div></div></div><div class="tree-item mod-tree-folder mod-collapsible is-collapsed" data-depth="3"><div class="tree-item-contents"><div class="tree-item-icon collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div><a class="tree-item-link" href="курсы/learn-you-a-haskell-for-great-good!/ru"><span class="tree-item-title">ru</span></a></div><div class="tree-item-children"><div class="tree-item mod-tree-file" data-depth="4"><div class="tree-item-contents"><a class="tree-item-link" href="курсы/learn-you-a-haskell-for-great-good!/ru/оглавление.html"><span class="tree-item-title">Оглавление</span></a></div><div class="tree-item-children"></div></div></div></div><div class="tree-item mod-tree-file" data-depth="3"><div class="tree-item-contents"><a class="tree-item-link" href="курсы/learn-you-a-haskell-for-great-good!/readme.html"><span class="tree-item-title">README</span></a></div><div class="tree-item-children"></div></div></div></div></div></div><div class="tree-item mod-tree-folder mod-collapsible is-collapsed" data-depth="1"><div class="tree-item-contents"><div class="tree-item-icon collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div><a class="tree-item-link" href="мои-решения"><span class="tree-item-title">Мои решения</span></a></div><div class="tree-item-children"><div class="tree-item mod-tree-folder mod-collapsible is-collapsed" data-depth="2"><div class="tree-item-contents"><div class="tree-item-icon collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div><a class="tree-item-link" href="мои-решения/о-haskell-по-человечески"><span class="tree-item-title">О Haskell по-человечески</span></a></div><div class="tree-item-children"><div class="tree-item mod-tree-file" data-depth="3"><div class="tree-item-contents"><a class="tree-item-link" href="мои-решения/о-haskell-по-человечески/о-haskell-по-человечески-(итого).html"><span class="tree-item-title">О Haskell по-человечески (Итого)</span></a></div><div class="tree-item-children"></div></div></div></div></div></div><div class="tree-item mod-tree-file" data-depth="1"><div class="tree-item-contents"><a class="tree-item-link" href="отчеты.html"><span class="tree-item-title">Отчеты</span></a></div><div class="tree-item-children"></div></div><div class="tree-item mod-tree-file" data-depth="1"><div class="tree-item-contents"><a class="tree-item-link" href="полезные-ресурсы.html"><span class="tree-item-title">Полезные ресурсы</span></a></div><div class="tree-item-children"></div></div><div class="tree-item mod-tree-file" data-depth="1"><div class="tree-item-contents"><a class="tree-item-link" href="readme.html"><span class="tree-item-title">README</span></a></div><div class="tree-item-children"></div></div></div></div></div></div><div class="document-container"><div class="markdown-preview-view markdown-rendered node-insert-event allow-fold-headings show-indentation-guide allow-fold-lists show-frontmatter" style="tab-size: 4;"><style id="MJX-CHTML-styles"></style><div class="markdown-preview-sizer markdown-preview-section" style="padding-bottom: ; padding-top: var(--file-margins); padding-right: var(--file-margins); padding-left: var(--file-margins); width: 100%; position: absolute;"><div class="markdown-preview-pusher" style="width: 1px; height: 0.1px; margin-bottom: 0px;"></div><div class="mod-header"></div><div><h1 data-heading="A Fistful of Monads" id="A_Fistful_of_Monads">A Fistful of Monads</h1></div><div><p>When we first talked about functors, we saw that they were a useful concept for values that can be mapped over. Then, we took that concept one step further by introducing applicative functors, which allow us to view values of certain data types as values with contexts and use normal functions on those values while preserving the meaning of those contexts.</p></div><div><p>In this chapter, we'll learn about monads, which are just beefed up applicative functors, much like applicative functors are only beefed up functors.</p></div><div><p><img alt="more cool than u" src="http://s3.amazonaws.com/lyah/smugpig.png" referrerpolicy="no-referrer"></p></div><div><p>When we started off with functors, we saw that it's possible to map functions over various data types. We saw that for this purpose, the&nbsp;<code>Functor</code>&nbsp;type class was introduced and it had us asking the question: when we have a function of type&nbsp;<code>a -&gt; b</code>&nbsp;and some data type&nbsp;<code>f a</code>, how do we map that function over the data type to end up with&nbsp;<code>f b</code>? We saw how to map something over a&nbsp;<code>Maybe a</code>, a list&nbsp;<code>[a]</code>, an&nbsp;<code>IO a</code>&nbsp;etc. We even saw how to map a function&nbsp;<code>a -&gt; b</code>&nbsp;over other functions of type&nbsp;<code>r -&gt; a</code>&nbsp;to get functions of type&nbsp;<code>r -&gt; b</code>. To answer this question of how to map a function over some data type, all we had to do was look at the type of&nbsp;<code>fmap</code>:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token builtin">fmap</span> <span class="token operator">::</span> <span class="token punctuation">(</span><span class="token constant">Functor</span> <span class="token hvariable">f</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">(</span><span class="token hvariable">a</span> <span class="token operator">-&gt;</span> <span class="token hvariable">b</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token hvariable">f</span> <span class="token hvariable">a</span> <span class="token operator">-&gt;</span> <span class="token hvariable">f</span> <span class="token hvariable">b</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>And then make it work for our data type by writing the appropriate&nbsp;<code>Functor</code>&nbsp;instance.</p></div><div><p>Then we saw a possible improvement of functors and said, hey, what if that function&nbsp;<code>a -&gt; b</code>&nbsp;is already wrapped inside a functor value? Like, what if we have&nbsp;<code>Just (*3)</code>, how do we apply that to&nbsp;<code>Just 5</code>? What if we don't want to apply it to&nbsp;<code>Just 5</code>&nbsp;but to a&nbsp;<code>Nothing</code>&nbsp;instead? Or if we have&nbsp;<code>[(*2),(+4)]</code>, how would we apply that to&nbsp;<code>[1,2,3]</code>? How would that work even? For this, the&nbsp;<code>Applicative</code>&nbsp;type class was introduced, in which we wanted the answer to the following type:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token punctuation">(</span><span class="token operator">&lt;*&gt;</span><span class="token punctuation">)</span> <span class="token operator">::</span> <span class="token punctuation">(</span><span class="token constant">Applicative</span> <span class="token hvariable">f</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token hvariable">f</span> <span class="token punctuation">(</span><span class="token hvariable">a</span> <span class="token operator">-&gt;</span> <span class="token hvariable">b</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token hvariable">f</span> <span class="token hvariable">a</span> <span class="token operator">-&gt;</span> <span class="token hvariable">f</span> <span class="token hvariable">b</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>We also saw that we can take a normal value and wrap it inside a data type. For instance, we can take a&nbsp;<code>1</code>&nbsp;and wrap it so that it becomes a&nbsp;<code>Just 1</code>. Or we can make it into a&nbsp;<code>[1]</code>. Or an I/O action that does nothing and just yields&nbsp;<code>1</code>. The function that does this is called&nbsp;<code>pure</code>.</p></div><div><p>Like we said, an applicative value can be seen as a value with an added context. A&nbsp;<em>fancy</em>&nbsp;value, to put it in technical terms. For instance, the character&nbsp;<code>'a'</code>&nbsp;is just a normal character, whereas&nbsp;<code>Just 'a'</code>&nbsp;has some added context. Instead of a&nbsp;<code>Char</code>, we have a&nbsp;<code>Maybe Char</code>, which tells us that its value might be a character, but it could also be an absence of a character.</p></div><div><p>It was neat to see how the&nbsp;<code>Applicative</code>&nbsp;type class allowed us to use normal functions on these values with context and how that context was preserved. Observe:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">)</span> <span class="token operator">&lt;$&gt;</span> <span class="token constant">Just</span> <span class="token number">2</span> <span class="token operator">&lt;*&gt;</span> <span class="token constant">Just</span> <span class="token number">8</span>
<span class="token constant">Just</span> <span class="token number">16</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token punctuation">(</span><span class="token operator">++</span><span class="token punctuation">)</span> <span class="token operator">&lt;$&gt;</span> <span class="token constant">Just</span> <span class="token string">"klingon"</span> <span class="token operator">&lt;*&gt;</span> <span class="token constant">Nothing</span>
<span class="token constant">Nothing</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token punctuation">(</span><span class="token operator">-</span><span class="token punctuation">)</span> <span class="token operator">&lt;$&gt;</span> <span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">]</span> <span class="token operator">&lt;*&gt;</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">]</span>
<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">]</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Ah, cool, so now that we treat them as applicative values,&nbsp;<code>Maybe a</code>&nbsp;values represent computations that might have failed,&nbsp;<code>[a]</code>&nbsp;values represent computations that have several results (non-deterministic computations),&nbsp;<code>IO a</code>&nbsp;values represent values that have side-effects, etc.</p></div><div><p>Monads are a natural extension of applicative functors and with them we're concerned with this: if you have a value with a context,&nbsp;<code>m a</code>, how do you apply to it a function that takes a normal&nbsp;<code>a</code>&nbsp;and returns a value with a context? That is, how do you apply a function of type&nbsp;<code>a -&gt; m b</code>&nbsp;to a value of type&nbsp;<code>m a</code>? So essentially, we will want this function:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token punctuation">(</span><span class="token operator">&gt;&gt;=</span><span class="token punctuation">)</span> <span class="token operator">::</span> <span class="token punctuation">(</span><span class="token constant">Monad</span> <span class="token hvariable">m</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token hvariable">m</span> <span class="token hvariable">a</span> <span class="token operator">-&gt;</span> <span class="token punctuation">(</span><span class="token hvariable">a</span> <span class="token operator">-&gt;</span> <span class="token hvariable">m</span> <span class="token hvariable">b</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token hvariable">m</span> <span class="token hvariable">b</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p><strong>If we have a fancy value and a function that takes a normal value but returns a fancy value, how do we feed that fancy value into the function?</strong>&nbsp;This is the main question that we will concern ourselves when dealing with monads. We write&nbsp;<code>m a</code>&nbsp;instead of&nbsp;<code>f a</code>&nbsp;because the&nbsp;<code>m</code>&nbsp;stands for&nbsp;<code>Monad</code>, but monads are just applicative functors that support&nbsp;<code>&gt;&gt;=</code>. The&nbsp;<code>&gt;&gt;=</code>&nbsp;function is pronounced as&nbsp;<em>bind</em>.</p></div><div><p>When we have a normal value&nbsp;<code>a</code>&nbsp;and a normal function&nbsp;<code>a -&gt; b</code>&nbsp;it's really easy to feed the value to the function — you just apply the function to the value normally and that's it. But when we're dealing with values that come with certain contexts, it takes a bit of thinking to see how these fancy values are fed to functions and how to take into account their behavior, but you'll see that it's easy as one two three.</p></div><div><h2 data-heading="Getting our feet wet with Maybe" id="Getting_our_feet_wet_with_Maybe" style="display: flex;"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>Getting our feet wet with Maybe</h2></div><div><p><img alt="monads, grasshoppa" src="http://s3.amazonaws.com/lyah/buddha.png" referrerpolicy="no-referrer"></p></div><div><p>Now that we have a vague idea of what monads are about, let's see if we can make that idea a bit less vague.</p></div><div><p>Much to no one's surprise,&nbsp;<code>Maybe</code>&nbsp;is a monad, so let's explore it a bit more and see if we can combine it with what we know about monads.</p></div><div><p>Make sure you understand&nbsp;<a data-tooltip-position="top" aria-label="http://learnyouahaskell.com/functors-applicative-functors-and-monoids#applicative-functors" rel="noopener" class="external-link" href="http://learnyouahaskell.com/functors-applicative-functors-and-monoids#applicative-functors" target="_blank">applicatives</a>&nbsp;at this point. It's good if you have a feel for how the various&nbsp;Applicative&nbsp;instances work and what kind of computations they represent, because monads are nothing more than taking our existing applicative knowledge and upgrading it.</p></div><div><p>A value of type&nbsp;<code>Maybe a</code>&nbsp;represents a value of type&nbsp;<code>a</code>&nbsp;with the context of possible failure attached. A value of&nbsp;<code>Just "dharma"</code>&nbsp;means that the string&nbsp;<code>"dharma"</code>&nbsp;is there whereas a value of&nbsp;<code>Nothing</code>&nbsp;represents its absence, or if you look at the string as the result of a computation, it means that the computation has failed.</p></div><div><p>When we looked at&nbsp;<code>Maybe</code>&nbsp;as a functor, we saw that if we want to&nbsp;<code>fmap</code>&nbsp;a function over it, it gets mapped over the insides if it's a&nbsp;<code>Just</code>&nbsp;value, otherwise the&nbsp;<code>Nothing</code>&nbsp;is kept because there's nothing to map it over!</p></div><div><p>Like this:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token builtin">fmap</span> <span class="token punctuation">(</span><span class="token operator">++</span><span class="token string">"!"</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token constant">Just</span> <span class="token string">"wisdom"</span><span class="token punctuation">)</span>
<span class="token constant">Just</span> <span class="token string">"wisdom!"</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token builtin">fmap</span> <span class="token punctuation">(</span><span class="token operator">++</span><span class="token string">"!"</span><span class="token punctuation">)</span> <span class="token constant">Nothing</span>
<span class="token constant">Nothing</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>As an applicative functor, it functions similarly. However, applicatives also have the function wrapped.&nbsp;<code>Maybe</code>&nbsp;is an applicative functor in such a way that when we use&nbsp;<code>&lt;*&gt;</code>&nbsp;to apply a function inside a&nbsp;<code>Maybe</code>&nbsp;to a value that's inside a&nbsp;<code>Maybe</code>, they both have to be&nbsp;<code>Just</code>&nbsp;values for the result to be a&nbsp;<code>Just</code>&nbsp;value, otherwise the result is&nbsp;<code>Nothing</code>. It makes sense because if you're missing either the function or the thing you're applying it to, you can't make something up out of thin air, so you have to propagate the failure:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token constant">Just</span> <span class="token punctuation">(</span><span class="token operator">+</span><span class="token number">3</span><span class="token punctuation">)</span> <span class="token operator">&lt;*&gt;</span> <span class="token constant">Just</span> <span class="token number">3</span>
<span class="token constant">Just</span> <span class="token number">6</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token constant">Nothing</span> <span class="token operator">&lt;*&gt;</span> <span class="token constant">Just</span> <span class="token string">"greed"</span>
<span class="token constant">Nothing</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token constant">Just</span> <span class="token builtin">ord</span> <span class="token operator">&lt;*&gt;</span> <span class="token constant">Nothing</span>
<span class="token constant">Nothing</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>When we use the applicative style to have normal functions act on&nbsp;<code>Maybe</code>&nbsp;values, it's similar. All the values have to be&nbsp;<code>Just</code>&nbsp;values, otherwise it's all for&nbsp;<code>Nothing</code>!</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token builtin">max</span> <span class="token operator">&lt;$&gt;</span> <span class="token constant">Just</span> <span class="token number">3</span> <span class="token operator">&lt;*&gt;</span> <span class="token constant">Just</span> <span class="token number">6</span>
<span class="token constant">Just</span> <span class="token number">6</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token builtin">max</span> <span class="token operator">&lt;$&gt;</span> <span class="token constant">Just</span> <span class="token number">3</span> <span class="token operator">&lt;*&gt;</span> <span class="token constant">Nothing</span>
<span class="token constant">Nothing</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>And now, let's think about how we would do&nbsp;<code>&gt;&gt;=</code>&nbsp;for&nbsp;<code>Maybe</code>. Like we said,&nbsp;<code>&gt;&gt;=</code>&nbsp;takes a monadic value, and a function that takes a normal value and returns a monadic value and manages to apply that function to the monadic value. How does it do that, if the function takes a normal value? Well, to do that, it has to take into account the context of that monadic value.</p></div><div><p>In this case,&nbsp;<code>&gt;&gt;=</code>&nbsp;would take a&nbsp;<code>Maybe a</code>&nbsp;value and a function of type&nbsp;<code>a -&gt; Maybe b</code>&nbsp;and somehow apply the function to the&nbsp;<code>Maybe a</code>. To figure out how it does that, we can use the intuition that we have from&nbsp;<code>Maybe</code>&nbsp;being an applicative functor. Let's say that we have a function&nbsp;<code>\x -&gt; Just (x+1)</code>. It takes a number, adds&nbsp;<code>1</code>&nbsp;to it and wraps it in a&nbsp;<code>Just</code>:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token punctuation">(</span><span class="token operator">\</span><span class="token hvariable">x</span> <span class="token operator">-&gt;</span> <span class="token constant">Just</span> <span class="token punctuation">(</span><span class="token hvariable">x</span><span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token number">1</span>
<span class="token constant">Just</span> <span class="token number">2</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token punctuation">(</span><span class="token operator">\</span><span class="token hvariable">x</span> <span class="token operator">-&gt;</span> <span class="token constant">Just</span> <span class="token punctuation">(</span><span class="token hvariable">x</span><span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token number">100</span>
<span class="token constant">Just</span> <span class="token number">101</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>If we feed it&nbsp;<code>1</code>, it evaluates to&nbsp;<code>Just 2</code>. If we give it the number&nbsp;<code>100</code>, the result is&nbsp;<code>Just 101</code>. Very straightforward. Now here's the kicker: how do we feed a&nbsp;<code>Maybe</code>&nbsp;value to this function? If we think about how&nbsp;<code>Maybe</code>&nbsp;acts as an applicative functor, answering this is pretty easy. If we feed it a&nbsp;<code>Just</code>&nbsp;value, take what's inside the&nbsp;<code>Just</code>&nbsp;and apply the function to it. If give it a&nbsp;<code>Nothing</code>, hmm, well, then we're left with a function but&nbsp;<code>Nothing</code>&nbsp;to apply it to. In that case, let's just do what we did before and say that the result is&nbsp;<code>Nothing</code>.</p></div><div><p>Instead of calling it&nbsp;<code>&gt;&gt;=</code>, let's call it&nbsp;<code>applyMaybe</code>&nbsp;for now. It takes a&nbsp;<code>Maybe a</code>&nbsp;and a function that returns a&nbsp;<code>Maybe b</code>&nbsp;and manages to apply that function to the&nbsp;<code>Maybe a</code>. Here it is in code:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">applyMaybe</span> <span class="token operator">::</span> <span class="token constant">Maybe</span> <span class="token hvariable">a</span> <span class="token operator">-&gt;</span> <span class="token punctuation">(</span><span class="token hvariable">a</span> <span class="token operator">-&gt;</span> <span class="token constant">Maybe</span> <span class="token hvariable">b</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token constant">Maybe</span> <span class="token hvariable">b</span>
<span class="token hvariable">applyMaybe</span> <span class="token constant">Nothing</span> <span class="token hvariable">f</span>  <span class="token operator">=</span> <span class="token constant">Nothing</span>
<span class="token hvariable">applyMaybe</span> <span class="token punctuation">(</span><span class="token constant">Just</span> <span class="token hvariable">x</span><span class="token punctuation">)</span> <span class="token hvariable">f</span> <span class="token operator">=</span> <span class="token hvariable">f</span> <span class="token hvariable">x</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Okay, now let's play with it for a bit. We'll use it as an infix function so that the&nbsp;<code>Maybe</code>&nbsp;value is on the left side and the function on the right:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token constant">Just</span> <span class="token number">3</span> <span class="token operator">`applyMaybe`</span> <span class="token operator">\</span><span class="token hvariable">x</span> <span class="token operator">-&gt;</span> <span class="token constant">Just</span> <span class="token punctuation">(</span><span class="token hvariable">x</span><span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span>
<span class="token constant">Just</span> <span class="token number">4</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token constant">Just</span> <span class="token string">"smile"</span> <span class="token operator">`applyMaybe`</span> <span class="token operator">\</span><span class="token hvariable">x</span> <span class="token operator">-&gt;</span> <span class="token constant">Just</span> <span class="token punctuation">(</span><span class="token hvariable">x</span> <span class="token operator">++</span> <span class="token string">" :)"</span><span class="token punctuation">)</span>
<span class="token constant">Just</span> <span class="token string">"smile :)"</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token constant">Nothing</span> <span class="token operator">`applyMaybe`</span> <span class="token operator">\</span><span class="token hvariable">x</span> <span class="token operator">-&gt;</span> <span class="token constant">Just</span> <span class="token punctuation">(</span><span class="token hvariable">x</span><span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span>
<span class="token constant">Nothing</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token constant">Nothing</span> <span class="token operator">`applyMaybe`</span> <span class="token operator">\</span><span class="token hvariable">x</span> <span class="token operator">-&gt;</span> <span class="token constant">Just</span> <span class="token punctuation">(</span><span class="token hvariable">x</span> <span class="token operator">++</span> <span class="token string">" :)"</span><span class="token punctuation">)</span>
<span class="token constant">Nothing</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>In the above example, we see that when we used&nbsp;<code>applyMaybe</code>&nbsp;with a&nbsp;<code>Just</code>&nbsp;value and a function, the function simply got applied to the value inside the&nbsp;<code>Just</code>. When we tried to use it with a&nbsp;<code>Nothing</code>, the whole result was&nbsp;<code>Nothing</code>. What about if the function returns a&nbsp;<code>Nothing</code>? Let's see:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token constant">Just</span> <span class="token number">3</span> <span class="token operator">`applyMaybe`</span> <span class="token operator">\</span><span class="token hvariable">x</span> <span class="token operator">-&gt;</span> <span class="token keyword">if</span> <span class="token hvariable">x</span> <span class="token operator">&gt;</span> <span class="token number">2</span> <span class="token keyword">then</span> <span class="token constant">Just</span> <span class="token hvariable">x</span> <span class="token keyword">else</span> <span class="token constant">Nothing</span>
<span class="token constant">Just</span> <span class="token number">3</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token constant">Just</span> <span class="token number">1</span> <span class="token operator">`applyMaybe`</span> <span class="token operator">\</span><span class="token hvariable">x</span> <span class="token operator">-&gt;</span> <span class="token keyword">if</span> <span class="token hvariable">x</span> <span class="token operator">&gt;</span> <span class="token number">2</span> <span class="token keyword">then</span> <span class="token constant">Just</span> <span class="token hvariable">x</span> <span class="token keyword">else</span> <span class="token constant">Nothing</span>
<span class="token constant">Nothing</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Just what we expected. If the monadic value on the left is a&nbsp;<code>Nothing</code>, the whole thing is&nbsp;<code>Nothing</code>. And if the function on the right returns a&nbsp;<code>Nothing</code>, the result is&nbsp;<code>Nothing</code>&nbsp;again. This is very similar to when we used&nbsp;<code>Maybe</code>&nbsp;as an applicative and we got a&nbsp;<code>Nothing</code>&nbsp;result if somewhere in there was a&nbsp;<code>Nothing</code>.</p></div><div><p>It looks like that for&nbsp;<code>Maybe</code>, we've figured out how to take a fancy value and feed it to a function that takes a normal value and returns a fancy one. We did this by keeping in mind that a&nbsp;<code>Maybe</code>&nbsp;value represents a computation that might have failed.</p></div><div><p>You might be asking yourself, how is this useful? It may seem like applicative functors are stronger than monads, since applicative functors allow us to take a normal function and make it operate on values with contexts. We'll see that monads can do that as well because they're an upgrade of applicative functors, and that they can also do some cool stuff that applicative functors can't.</p></div><div><p>We'll come back to&nbsp;<code>Maybe</code>&nbsp;in a minute, but first, let's check out the type class that belongs to monads.</p></div><div><h2 data-heading="The Monad type class" id="The_Monad_type_class" style="display: flex;"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>The Monad type class</h2></div><div><p>Just like functors have the&nbsp;<code>Functor</code>&nbsp;type class and applicative functors have the&nbsp;<code>Applicative</code>&nbsp;type class, monads come with their own type class:&nbsp;<code>Monad</code>! Wow, who would have thought? This is what the type class looks like:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token keyword">class</span> <span class="token constant">Monad</span> <span class="token hvariable">m</span> <span class="token keyword">where</span>
    <span class="token builtin">return</span> <span class="token operator">::</span> <span class="token hvariable">a</span> <span class="token operator">-&gt;</span> <span class="token hvariable">m</span> <span class="token hvariable">a</span>

    <span class="token punctuation">(</span><span class="token operator">&gt;&gt;=</span><span class="token punctuation">)</span> <span class="token operator">::</span> <span class="token hvariable">m</span> <span class="token hvariable">a</span> <span class="token operator">-&gt;</span> <span class="token punctuation">(</span><span class="token hvariable">a</span> <span class="token operator">-&gt;</span> <span class="token hvariable">m</span> <span class="token hvariable">b</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token hvariable">m</span> <span class="token hvariable">b</span>

    <span class="token punctuation">(</span><span class="token operator">&gt;&gt;</span><span class="token punctuation">)</span> <span class="token operator">::</span> <span class="token hvariable">m</span> <span class="token hvariable">a</span> <span class="token operator">-&gt;</span> <span class="token hvariable">m</span> <span class="token hvariable">b</span> <span class="token operator">-&gt;</span> <span class="token hvariable">m</span> <span class="token hvariable">b</span>
    <span class="token hvariable">x</span> <span class="token operator">&gt;&gt;</span> <span class="token hvariable">y</span> <span class="token operator">=</span> <span class="token hvariable">x</span> <span class="token operator">&gt;&gt;=</span> <span class="token operator">\</span><span class="token hvariable">_</span> <span class="token operator">-&gt;</span> <span class="token hvariable">y</span>

    <span class="token builtin">fail</span> <span class="token operator">::</span> <span class="token constant">String</span> <span class="token operator">-&gt;</span> <span class="token hvariable">m</span> <span class="token hvariable">a</span>
    <span class="token builtin">fail</span> <span class="token hvariable">msg</span> <span class="token operator">=</span> <span class="token builtin">error</span> <span class="token hvariable">msg</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p><img alt="this is you on monads" src="http://s3.amazonaws.com/lyah/kid.png" referrerpolicy="no-referrer"></p></div><div><p>Let's start with the first line. It says&nbsp;<code>class Monad m where</code>. But wait, didn't we say that monads are just beefed up applicative functors? Shouldn't there be a class constraint in there along the lines of&nbsp;<code>class (Applicative m) = &gt; Monad m where</code>&nbsp;so that a type has to be an applicative functor first before it can be made a monad? Well, there should, but when Haskell was made, it hadn't occured to people that applicative functors are a good fit for Haskell so they weren't in there. But rest assured, every monad is an applicative functor, even if the&nbsp;<code>Monad</code>&nbsp;class declaration doesn't say so.</p></div><div><p>The first function that the&nbsp;<code>Monad</code>&nbsp;type class defines is&nbsp;<code>return</code>. It's the same as&nbsp;<code>pure</code>, only with a different name. Its type is&nbsp;<code>(Monad m) =&gt; a -&gt; m a</code>. It takes a value and puts it in a minimal default context that still holds that value. In other words, it takes something and wraps it in a monad. It always does the same thing as the&nbsp;<code>pure</code>&nbsp;function from the&nbsp;<code>Applicative</code>&nbsp;type class, which means we're already acquainted with&nbsp;<code>return</code>. We already used&nbsp;<code>return</code>&nbsp;when doing I/O. We used it to take a value and make a bogus I/O action that does nothing but yield that value. For&nbsp;<code>Maybe</code>&nbsp;it takes a value and wraps it in a&nbsp;<code>Just</code>.</p></div><div><p>Just a reminder:&nbsp;return&nbsp;is nothing like the&nbsp;return&nbsp;that's in most other languages. It doesn't end function execution or anything, it just takes a normal value and puts it in a context.</p></div><div><p><img alt="hmmm yaes" src="http://s3.amazonaws.com/lyah/tur2.png" referrerpolicy="no-referrer"></p></div><div><p>The next function is&nbsp;<code>&gt;&gt;=</code>, or bind. It's like function application, only instead of taking a normal value and feeding it to a normal function, it takes a monadic value (that is, a value with a context) and feeds it to a function that takes a normal value but returns a monadic value.</p></div><div><p>Next up, we have&nbsp;<code>&gt;&gt;</code>. We won't pay too much attention to it for now because it comes with a default implementation and we pretty much never implement it when making&nbsp;<code>Monad</code>&nbsp;instances.</p></div><div><p>The final function of the&nbsp;<code>Monad</code>&nbsp;type class is&nbsp;<code>fail</code>. We never use it explicitly in our code. Instead, it's used by Haskell to enable failure in a special syntactic construct for monads that we'll meet later. We don't need to concern ourselves with&nbsp;<code>fail</code>&nbsp;too much for now.</p></div><div><p>Now that we know what the&nbsp;<code>Monad</code>&nbsp;type class looks like, let's take a look at how&nbsp;<code>Maybe</code>&nbsp;is an instance of&nbsp;<code>Monad</code>!</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token keyword">instance</span> <span class="token constant">Monad</span> <span class="token constant">Maybe</span> <span class="token keyword">where</span>
    <span class="token builtin">return</span> <span class="token hvariable">x</span> <span class="token operator">=</span> <span class="token constant">Just</span> <span class="token hvariable">x</span>
    <span class="token constant">Nothing</span> <span class="token operator">&gt;&gt;=</span> <span class="token hvariable">f</span> <span class="token operator">=</span> <span class="token constant">Nothing</span>
    <span class="token constant">Just</span> <span class="token hvariable">x</span> <span class="token operator">&gt;&gt;=</span> <span class="token hvariable">f</span>  <span class="token operator">=</span> <span class="token hvariable">f</span> <span class="token hvariable">x</span>
    <span class="token builtin">fail</span> <span class="token hvariable">_</span> <span class="token operator">=</span> <span class="token constant">Nothing</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p><code>return</code>&nbsp;is the same as&nbsp;<code>pure</code>, so that one's a no-brainer. We do what we did in the&nbsp;<code>Applicative</code>&nbsp;type class and wrap it in a&nbsp;<code>Just</code>.</p></div><div><p>The&nbsp;<code>&gt;&gt;=</code>&nbsp;function is the same as our&nbsp;<code>applyMaybe</code>. When feeding the&nbsp;<code>Maybe a</code>&nbsp;to our function, we keep in mind the context and return a&nbsp;<code>Nothing</code>&nbsp;if the value on the left is&nbsp;<code>Nothing</code>&nbsp;because if there's no value then there's no way to apply our function to it. If it's a&nbsp;<code>Just</code>&nbsp;we take what's inside and apply&nbsp;<code>f</code>&nbsp;to it.</p></div><div><p>We can play around with&nbsp;<code>Maybe</code>&nbsp;as a monad:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token builtin">return</span> <span class="token string">"WHAT"</span> <span class="token operator">::</span> <span class="token constant">Maybe</span> <span class="token constant">String</span>
<span class="token constant">Just</span> <span class="token string">"WHAT"</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token constant">Just</span> <span class="token number">9</span> <span class="token operator">&gt;&gt;=</span> <span class="token operator">\</span><span class="token hvariable">x</span> <span class="token operator">-&gt;</span> <span class="token builtin">return</span> <span class="token punctuation">(</span><span class="token hvariable">x</span><span class="token operator">*</span><span class="token number">10</span><span class="token punctuation">)</span>
<span class="token constant">Just</span> <span class="token number">90</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token constant">Nothing</span> <span class="token operator">&gt;&gt;=</span> <span class="token operator">\</span><span class="token hvariable">x</span> <span class="token operator">-&gt;</span> <span class="token builtin">return</span> <span class="token punctuation">(</span><span class="token hvariable">x</span><span class="token operator">*</span><span class="token number">10</span><span class="token punctuation">)</span>
<span class="token constant">Nothing</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Nothing new or exciting on the first line since we already used&nbsp;<code>pure</code>&nbsp;with&nbsp;<code>Maybe</code>&nbsp;and we know that&nbsp;<code>return</code>&nbsp;is just&nbsp;<code>pure</code>&nbsp;with a different name. The next two lines showcase&nbsp;<code>&gt;&gt;=</code>&nbsp;a bit more.</p></div><div><p>Notice how when we fed&nbsp;<code>Just 9</code>&nbsp;to the function&nbsp;<code>\x -&gt; return (x*10)</code>, the&nbsp;<code>x</code>&nbsp;took on the value&nbsp;<code>9</code>&nbsp;inside the function. It seems as though we were able to extract the value from a&nbsp;<code>Maybe</code>&nbsp;without pattern-matching. And we still didn't lose the context of our&nbsp;<code>Maybe</code>&nbsp;value, because when it's&nbsp;<code>Nothing</code>, the result of using&nbsp;<code>&gt;&gt;=</code>&nbsp;will be&nbsp;<code>Nothing</code>&nbsp;as well.</p></div><div><h2 data-heading="Walk the line" id="Walk_the_line" style="display: flex;"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>Walk the line</h2></div><div><p><img alt="pierre" src="http://s3.amazonaws.com/lyah/pierre.png" referrerpolicy="no-referrer"></p></div><div><p>Now that we know how to feed a&nbsp;<code>Maybe a</code>&nbsp;value to a function of type&nbsp;<code>a -&gt; Maybe b</code>&nbsp;while taking into account the context of possible failure, let's see how we can use&nbsp;<code>&gt;&gt;=</code>&nbsp;repeatedly to handle computations of several&nbsp;<code>Maybe a</code>&nbsp;values.</p></div><div><p>Pierre has decided to take a break from his job at the fish farm and try tightrope walking. He's not that bad at it, but he does have one problem: birds keep landing on his balancing pole! They come and they take a short rest, chat with their avian friends and then take off in search of breadcrumbs. This wouldn't bother him so much if the number of birds on the left side of the pole was always equal to the number of birds on the right side. But sometimes, all the birds decide that they like one side better and so they throw him off balance, which results in an embarrassing tumble for Pierre (he's using a safety net).</p></div><div><p>Let's say that he keeps his balance if the number of birds on the left side of the pole and on the right side of the pole is within three. So if there's one bird on the right side and four birds on the left side, he's okay. But if a fifth bird lands on the left side, then he loses his balance and takes a dive.</p></div><div><p>We're going to simulate birds landing on and flying away from the pole and see if Pierre is still at it after a certain number of birdy arrivals and departures. For instance, we want to see what happens to Pierre if first one bird arrives on the left side, then four birds occupy the right side and then the bird that was on the left side decides to fly away.</p></div><div><p>We can represent the pole with a simple pair of integers. The first component will signify the number of birds on the left side and the second component the number of birds on the right side:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token keyword">type</span> <span class="token constant">Birds</span> <span class="token operator">=</span> <span class="token constant">Int</span>
<span class="token keyword">type</span> <span class="token constant">Pole</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token constant">Birds</span><span class="token punctuation">,</span><span class="token constant">Birds</span><span class="token punctuation">)</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>First we made a type synonym for&nbsp;<code>Int</code>, called&nbsp;<code>Birds</code>, because we're using integers to represent how many birds there are. And then we made a type synonym&nbsp;<code>(Birds,Birds)</code>&nbsp;and we called it&nbsp;<code>Pole</code>&nbsp;(not to be confused with a person of Polish descent).</p></div><div><p>Next up, how about we make a function that takes a number of birds and lands them on one side of the pole. Here are the functions:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">landLeft</span> <span class="token operator">::</span> <span class="token constant">Birds</span> <span class="token operator">-&gt;</span> <span class="token constant">Pole</span> <span class="token operator">-&gt;</span> <span class="token constant">Pole</span>
<span class="token hvariable">landLeft</span> <span class="token hvariable">n</span> <span class="token punctuation">(</span><span class="token hvariable">left</span><span class="token punctuation">,</span><span class="token hvariable">right</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token hvariable">left</span> <span class="token operator">+</span> <span class="token hvariable">n</span><span class="token punctuation">,</span><span class="token hvariable">right</span><span class="token punctuation">)</span>

<span class="token hvariable">landRight</span> <span class="token operator">::</span> <span class="token constant">Birds</span> <span class="token operator">-&gt;</span> <span class="token constant">Pole</span> <span class="token operator">-&gt;</span> <span class="token constant">Pole</span>
<span class="token hvariable">landRight</span> <span class="token hvariable">n</span> <span class="token punctuation">(</span><span class="token hvariable">left</span><span class="token punctuation">,</span><span class="token hvariable">right</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token hvariable">left</span><span class="token punctuation">,</span><span class="token hvariable">right</span> <span class="token operator">+</span> <span class="token hvariable">n</span><span class="token punctuation">)</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Pretty straightforward stuff. Let's try them out:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token hvariable">landLeft</span> <span class="token number">2</span> <span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">)</span>
<span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">)</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token hvariable">landRight</span> <span class="token number">1</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">)</span>
<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">)</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token hvariable">landRight</span> <span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">)</span>
<span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">)</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>To make birds fly away we just had a negative number of birds land on one side. Because landing a bird on the&nbsp;<code>Pole</code>&nbsp;returns a&nbsp;<code>Pole</code>, we can chain applications of&nbsp;<code>landLeft</code>&nbsp;and&nbsp;<code>landRight</code>:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token hvariable">landLeft</span> <span class="token number">2</span> <span class="token punctuation">(</span><span class="token hvariable">landRight</span> <span class="token number">1</span> <span class="token punctuation">(</span><span class="token hvariable">landLeft</span> <span class="token number">1</span> <span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">)</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>When we apply the function&nbsp;<code>landLeft 1</code>&nbsp;to&nbsp;<code>(0,0)</code>&nbsp;we get&nbsp;<code>(1,0)</code>. Then, we land a bird on the right side, resulting in&nbsp;<code>(1,1)</code>. Finally two birds land on the left side, resulting in&nbsp;<code>(3,1)</code>. We apply a function to something by first writing the function and then writing its parameter, but here it would be better if the pole went first and then the landing function. If we make a function like this:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">x</span> <span class="token operator">-:</span> <span class="token hvariable">f</span> <span class="token operator">=</span> <span class="token hvariable">f</span> <span class="token hvariable">x</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>We can apply functions by first writing the parameter and then the function:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token number">100</span> <span class="token operator">-:</span> <span class="token punctuation">(</span><span class="token operator">*</span><span class="token number">3</span><span class="token punctuation">)</span>
<span class="token number">300</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token constant">True</span> <span class="token operator">-:</span> <span class="token builtin">not</span>
<span class="token constant">False</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">-:</span> <span class="token hvariable">landLeft</span> <span class="token number">2</span>
<span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">)</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>By using this, we can repeatedly land birds on the pole in a more readable manner:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">-:</span> <span class="token hvariable">landLeft</span> <span class="token number">1</span> <span class="token operator">-:</span> <span class="token hvariable">landRight</span> <span class="token number">1</span> <span class="token operator">-:</span> <span class="token hvariable">landLeft</span> <span class="token number">2</span>
<span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">)</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Pretty cool! This example is equivalent to the one before where we repeatedly landed birds on the pole, only it looks neater. Here, it's more obvious that we start off with&nbsp;<code>(0,0)</code>&nbsp;and then land one bird one the left, then one on the right and finally two on the left.</p></div><div><p>So far so good, but what happens if 10 birds land on one side?</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token hvariable">landLeft</span> <span class="token number">10</span> <span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">)</span>
<span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">)</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>10 birds on the left side and only 3 on the right? That's sure to send poor Pierre falling through the air! This is pretty obvious here but what if we had a sequence of landings like this:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">-:</span> <span class="token hvariable">landLeft</span> <span class="token number">1</span> <span class="token operator">-:</span> <span class="token hvariable">landRight</span> <span class="token number">4</span> <span class="token operator">-:</span> <span class="token hvariable">landLeft</span> <span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">-:</span> <span class="token hvariable">landRight</span> <span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">2</span><span class="token punctuation">)</span>
<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">)</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>It might seem like everything is okay but if you follow the steps here, you'll see that at one time there are 4 birds on the right side and no birds on the left! To fix this, we have to take another look at our&nbsp;<code>landLeft</code>&nbsp;and&nbsp;<code>landRight</code>&nbsp;functions. From what we've seen, we want these functions to be able to fail. That is, we want them to return a new pole if the balance is okay but fail if the birds land in a lopsided manner. And what better way to add a context of failure to value than by using&nbsp;<code>Maybe</code>! Let's rework these functions:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">landLeft</span> <span class="token operator">::</span> <span class="token constant">Birds</span> <span class="token operator">-&gt;</span> <span class="token constant">Pole</span> <span class="token operator">-&gt;</span> <span class="token constant">Maybe</span> <span class="token constant">Pole</span>
<span class="token hvariable">landLeft</span> <span class="token hvariable">n</span> <span class="token punctuation">(</span><span class="token hvariable">left</span><span class="token punctuation">,</span><span class="token hvariable">right</span><span class="token punctuation">)</span>
    <span class="token operator">|</span> <span class="token builtin">abs</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token hvariable">left</span> <span class="token operator">+</span> <span class="token hvariable">n</span><span class="token punctuation">)</span> <span class="token operator">-</span> <span class="token hvariable">right</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token number">4</span> <span class="token operator">=</span> <span class="token constant">Just</span> <span class="token punctuation">(</span><span class="token hvariable">left</span> <span class="token operator">+</span> <span class="token hvariable">n</span><span class="token punctuation">,</span> <span class="token hvariable">right</span><span class="token punctuation">)</span>
    <span class="token operator">|</span> <span class="token builtin">otherwise</span>                    <span class="token operator">=</span> <span class="token constant">Nothing</span>

<span class="token hvariable">landRight</span> <span class="token operator">::</span> <span class="token constant">Birds</span> <span class="token operator">-&gt;</span> <span class="token constant">Pole</span> <span class="token operator">-&gt;</span> <span class="token constant">Maybe</span> <span class="token constant">Pole</span>
<span class="token hvariable">landRight</span> <span class="token hvariable">n</span> <span class="token punctuation">(</span><span class="token hvariable">left</span><span class="token punctuation">,</span><span class="token hvariable">right</span><span class="token punctuation">)</span>
    <span class="token operator">|</span> <span class="token builtin">abs</span> <span class="token punctuation">(</span><span class="token hvariable">left</span> <span class="token operator">-</span> <span class="token punctuation">(</span><span class="token hvariable">right</span> <span class="token operator">+</span> <span class="token hvariable">n</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">&lt;</span> <span class="token number">4</span> <span class="token operator">=</span> <span class="token constant">Just</span> <span class="token punctuation">(</span><span class="token hvariable">left</span><span class="token punctuation">,</span> <span class="token hvariable">right</span> <span class="token operator">+</span> <span class="token hvariable">n</span><span class="token punctuation">)</span>
    <span class="token operator">|</span> <span class="token builtin">otherwise</span>                    <span class="token operator">=</span> <span class="token constant">Nothing</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Instead of returning a&nbsp;<code>Pole</code>&nbsp;these functions now return a&nbsp;<code>Maybe Pole</code>. They still take the number of birds and the old pole as before, but then they check if landing that many birds on the pole would throw Pierre off balance. We use guards to check if the difference between the number of birds on the new pole is less than 4. If it is, we wrap the new pole in a&nbsp;<code>Just</code>&nbsp;and return that. If it isn't, we return a&nbsp;<code>Nothing</code>, indicating failure.</p></div><div><p>Let's give these babies a go:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token hvariable">landLeft</span> <span class="token number">2</span> <span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">)</span>
<span class="token constant">Just</span> <span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">)</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token hvariable">landLeft</span> <span class="token number">10</span> <span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">)</span>
<span class="token constant">Nothing</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Nice! When we land birds without throwing Pierre off balance, we get a new pole wrapped in a&nbsp;<code>Just</code>. But when many more birds end up on one side of the pole, we get a&nbsp;<code>Nothing</code>. This is cool, but we seem to have lost the ability to repeatedly land birds on the pole. We can't do&nbsp;<code>landLeft 1 (landRight 1 (0,0))</code>&nbsp;anymore because when we apply&nbsp;<code>landRight 1</code>&nbsp;to&nbsp;<code>(0,0)</code>, we don't get a&nbsp;<code>Pole</code>, but a&nbsp;<code>Maybe Pole</code>.&nbsp;<code>landLeft 1</code>&nbsp;takes a&nbsp;<code>Pole</code>&nbsp;and not a&nbsp;<code>Maybe Pole</code>.</p></div><div><p>We need a way of taking a&nbsp;<code>Maybe Pole</code>&nbsp;and feeding it to a function that takes a&nbsp;<code>Pole</code>&nbsp;and returns a&nbsp;<code>Maybe Pole</code>. Luckily, we have&nbsp;<code>&gt;&gt;=</code>, which does just that for&nbsp;<code>Maybe</code>. Let's give it a go:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token hvariable">landRight</span> <span class="token number">1</span> <span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">&gt;&gt;=</span> <span class="token hvariable">landLeft</span> <span class="token number">2</span>
<span class="token constant">Just</span> <span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">)</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Remember,&nbsp;<code>landLeft 2</code>&nbsp;has a type of&nbsp;<code>Pole -&gt; Maybe Pole</code>. We couldn't just feed it the&nbsp;<code>Maybe Pole</code>&nbsp;that is the result of&nbsp;<code>landRight 1 (0,0)</code>, so we use&nbsp;<code>&gt;&gt;=</code>&nbsp;to take that value with a context and give it to&nbsp;<code>landLeft 2</code>.&nbsp;<code>&gt;&gt;=</code>&nbsp;does indeed allow us to treat the&nbsp;<code>Maybe</code>&nbsp;value as a value with context because if we feed a&nbsp;<code>Nothing</code>&nbsp;into&nbsp;<code>landLeft 2</code>, the result is&nbsp;<code>Nothing</code>&nbsp;and the failure is propagated:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token constant">Nothing</span> <span class="token operator">&gt;&gt;=</span> <span class="token hvariable">landLeft</span> <span class="token number">2</span>
<span class="token constant">Nothing</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>With this, we can now chain landings that may fail because&nbsp;<code>&gt;&gt;=</code>&nbsp;allows us to feed a monadic value to a function that takes a normal one.</p></div><div><p>Here's a sequence of birdy landings:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token builtin">return</span> <span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">&gt;&gt;=</span> <span class="token hvariable">landRight</span> <span class="token number">2</span> <span class="token operator">&gt;&gt;=</span> <span class="token hvariable">landLeft</span> <span class="token number">2</span> <span class="token operator">&gt;&gt;=</span> <span class="token hvariable">landRight</span> <span class="token number">2</span>
<span class="token constant">Just</span> <span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">)</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>At the beginning, we used&nbsp;<code>return</code>&nbsp;to take a pole and wrap it in a&nbsp;<code>Just</code>. We could have just applied&nbsp;<code>landRight 2</code>&nbsp;to&nbsp;<code>(0,0)</code>, it would have been the same, but this way we can be more consistent by using&nbsp;<code>&gt;&gt;=</code>&nbsp;for every function.&nbsp;<code>Just (0,0)</code>&nbsp;gets fed to&nbsp;<code>landRight 2</code>, resulting in&nbsp;<code>Just (0,2)</code>. This, in turn, gets fed to&nbsp;<code>landLeft 2</code>, resulting in&nbsp;<code>Just (2,2)</code>, and so on.</p></div><div><p>Remember this example from before we introduced failure into Pierre's routine:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">-:</span> <span class="token hvariable">landLeft</span> <span class="token number">1</span> <span class="token operator">-:</span> <span class="token hvariable">landRight</span> <span class="token number">4</span> <span class="token operator">-:</span> <span class="token hvariable">landLeft</span> <span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">-:</span> <span class="token hvariable">landRight</span> <span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">2</span><span class="token punctuation">)</span>
<span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">)</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>It didn't simulate his interaction with birds very well because in the middle there his balance was off but the result didn't reflect that. But let's give that a go now by using monadic application (<code>&gt;&gt;=</code>) instead of normal application:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token builtin">return</span> <span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">&gt;&gt;=</span> <span class="token hvariable">landLeft</span> <span class="token number">1</span> <span class="token operator">&gt;&gt;=</span> <span class="token hvariable">landRight</span> <span class="token number">4</span> <span class="token operator">&gt;&gt;=</span> <span class="token hvariable">landLeft</span> <span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">&gt;&gt;=</span> <span class="token hvariable">landRight</span> <span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">2</span><span class="token punctuation">)</span>
<span class="token constant">Nothing</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p><img alt="iama banana" src="http://s3.amazonaws.com/lyah/banana.png" referrerpolicy="no-referrer"></p></div><div><p>Awesome. The final result represents failure, which is what we expected. Let's see how this result was obtained. First,&nbsp;<code>return</code>&nbsp;puts&nbsp;<code>(0,0)</code>&nbsp;into a default context, making it a&nbsp;<code>Just (0,0)</code>. Then,&nbsp;<code>Just (0,0) &gt;&gt;= landLeft 1</code>&nbsp;happens. Since the&nbsp;<code>Just (0,0)</code>&nbsp;is a&nbsp;<code>Just</code>&nbsp;value,&nbsp;<code>landLeft 1</code>&nbsp;gets applied to&nbsp;<code>(0,0)</code>, resulting in a&nbsp;<code>Just (1,0)</code>, because the birds are still relatively balanced. Next,&nbsp;<code>Just (1,0) &gt;&gt;= landRight 4</code>&nbsp;takes place and the result is&nbsp;<code>Just (1,4)</code>&nbsp;as the balance of the birds is still intact, although just barely.&nbsp;<code>Just (1,4)</code>&nbsp;gets fed to&nbsp;<code>landLeft (-1)</code>. This means that&nbsp;<code>landLeft (-1) (1,4)</code>&nbsp;takes place. Now because of how&nbsp;<code>landLeft</code>&nbsp;works, this results in a&nbsp;<code>Nothing</code>, because the resulting pole is off balance. Now that we have a&nbsp;<code>Nothing</code>, it gets fed to&nbsp;<code>landRight (-2)</code>, but because it's a&nbsp;<code>Nothing</code>, the result is automatically&nbsp;<code>Nothing</code>, as we have nothing to apply&nbsp;<code>landRight (-2)</code>&nbsp;to.</p></div><div><p>We couldn't have achieved this by just using&nbsp;<code>Maybe</code>&nbsp;as an applicative. If you try it, you'll get stuck, because applicative functors don't allow for the applicative values to interact with each other very much. They can, at best, be used as parameters to a function by using the applicative style. The applicative operators will fetch their results and feed them to the function in a manner appropriate for each applicative and then put the final applicative value together, but there isn't that much interaction going on between them. Here, however, each step relies on the previous one's result. On every landing, the possible result from the previous one is examined and the pole is checked for balance. This determines whether the landing will succeed or fail.</p></div><div><p>We may also devise a function that ignores the current number of birds on the balancing pole and just makes Pierre slip and fall. We can call it&nbsp;<code>banana</code>:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">banana</span> <span class="token operator">::</span> <span class="token constant">Pole</span> <span class="token operator">-&gt;</span> <span class="token constant">Maybe</span> <span class="token constant">Pole</span>
<span class="token hvariable">banana</span> <span class="token hvariable">_</span> <span class="token operator">=</span> <span class="token constant">Nothing</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Now we can chain it together with our bird landings. It will always cause our walker to fall, because it ignores whatever's passed to it and always returns a failure. Check it:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token builtin">return</span> <span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">&gt;&gt;=</span> <span class="token hvariable">landLeft</span> <span class="token number">1</span> <span class="token operator">&gt;&gt;=</span> <span class="token hvariable">banana</span> <span class="token operator">&gt;&gt;=</span> <span class="token hvariable">landRight</span> <span class="token number">1</span>
<span class="token constant">Nothing</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>The value&nbsp;<code>Just (1,0)</code>&nbsp;gets fed to&nbsp;<code>banana</code>, but it produces a&nbsp;<code>Nothing</code>, which causes everything to result in a&nbsp;<code>Nothing</code>. How unfortunate!</p></div><div><p>Instead of making functions that ignore their input and just return a predetermined monadic value, we can use the&nbsp;<code>&gt;&gt;</code>&nbsp;function, whose default implementation is this:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token punctuation">(</span><span class="token operator">&gt;&gt;</span><span class="token punctuation">)</span> <span class="token operator">::</span> <span class="token punctuation">(</span><span class="token constant">Monad</span> <span class="token hvariable">m</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token hvariable">m</span> <span class="token hvariable">a</span> <span class="token operator">-&gt;</span> <span class="token hvariable">m</span> <span class="token hvariable">b</span> <span class="token operator">-&gt;</span> <span class="token hvariable">m</span> <span class="token hvariable">b</span>
<span class="token hvariable">m</span> <span class="token operator">&gt;&gt;</span> <span class="token hvariable">n</span> <span class="token operator">=</span> <span class="token hvariable">m</span> <span class="token operator">&gt;&gt;=</span> <span class="token operator">\</span><span class="token hvariable">_</span> <span class="token operator">-&gt;</span> <span class="token hvariable">n</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Normally, passing some value to a function that ignores its parameter and always just returns some predetermined value would always result in that predetermined value. With monads however, their context and meaning has to be considered as well. Here's how&nbsp;<code>&gt;&gt;</code>&nbsp;acts with&nbsp;<code>Maybe</code>:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token constant">Nothing</span> <span class="token operator">&gt;&gt;</span> <span class="token constant">Just</span> <span class="token number">3</span>
<span class="token constant">Nothing</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token constant">Just</span> <span class="token number">3</span> <span class="token operator">&gt;&gt;</span> <span class="token constant">Just</span> <span class="token number">4</span>
<span class="token constant">Just</span> <span class="token number">4</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token constant">Just</span> <span class="token number">3</span> <span class="token operator">&gt;&gt;</span> <span class="token constant">Nothing</span>
<span class="token constant">Nothing</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>If you replace&nbsp;<code>&gt;&gt;</code>&nbsp;with&nbsp;<code>&gt;&gt;= \_ -&gt;</code>, it's easy to see why it acts like it does.</p></div><div><p>We can replace our&nbsp;<code>banana</code>&nbsp;function in the chain with a&nbsp;<code>&gt;&gt;</code>&nbsp;and then a&nbsp;<code>Nothing</code>:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token builtin">return</span> <span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">&gt;&gt;=</span> <span class="token hvariable">landLeft</span> <span class="token number">1</span> <span class="token operator">&gt;&gt;</span> <span class="token constant">Nothing</span> <span class="token operator">&gt;&gt;=</span> <span class="token hvariable">landRight</span> <span class="token number">1</span>
<span class="token constant">Nothing</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>There we go, guaranteed and obvious failure!</p></div><div><p>It's also worth taking a look at what this would look like if we hadn't made the clever choice of treating&nbsp;<code>Maybe</code>&nbsp;values as values with a failure context and feeding them to functions like we did. Here's how a series of bird landings would look like:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">routine</span> <span class="token operator">::</span> <span class="token constant">Maybe</span> <span class="token constant">Pole</span>
<span class="token hvariable">routine</span> <span class="token operator">=</span> <span class="token keyword">case</span> <span class="token hvariable">landLeft</span> <span class="token number">1</span> <span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">of</span>
    <span class="token constant">Nothing</span> <span class="token operator">-&gt;</span> <span class="token constant">Nothing</span>
    <span class="token constant">Just</span> <span class="token hvariable">pole1</span> <span class="token operator">-&gt;</span> <span class="token keyword">case</span> <span class="token hvariable">landRight</span> <span class="token number">4</span> <span class="token hvariable">pole1</span> <span class="token keyword">of</span> 
        <span class="token constant">Nothing</span> <span class="token operator">-&gt;</span> <span class="token constant">Nothing</span>
        <span class="token constant">Just</span> <span class="token hvariable">pole2</span> <span class="token operator">-&gt;</span> <span class="token keyword">case</span> <span class="token hvariable">landLeft</span> <span class="token number">2</span> <span class="token hvariable">pole2</span> <span class="token keyword">of</span>
            <span class="token constant">Nothing</span> <span class="token operator">-&gt;</span> <span class="token constant">Nothing</span>
            <span class="token constant">Just</span> <span class="token hvariable">pole3</span> <span class="token operator">-&gt;</span> <span class="token hvariable">landLeft</span> <span class="token number">1</span> <span class="token hvariable">pole3</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p><img alt="john joe glanton" src="http://s3.amazonaws.com/lyah/centaur.png" referrerpolicy="no-referrer"></p></div><div><p>We land a bird on the left and then we examine the possibility of failure and the possibility of success. In the case of failure, we return a&nbsp;<code>Nothing</code>. In the case of success, we land birds on the right and then do the same thing all over again. Converting this monstrosity into a neat chain of monadic applications with&nbsp;<code>&gt;&gt;=</code>&nbsp;is a classic example of how the&nbsp;<code>Maybe</code>&nbsp;monad saves us a lot of time when we have to successively do computations that are based on computations that might have failed.</p></div><div><p>Notice how the&nbsp;<code>Maybe</code>&nbsp;implementation of&nbsp;<code>&gt;&gt;=</code>&nbsp;features exactly this logic of seeing if a value is&nbsp;<code>Nothing</code>&nbsp;and if it is, returning a&nbsp;<code>Nothing</code>&nbsp;right away and if it isn't, going forward with what's inside the&nbsp;<code>Just</code>.</p></div><div><p>In this section, we took some functions that we had and saw that they would work better if the values that they returned supported failure. By turning those values into&nbsp;<code>Maybe</code>&nbsp;values and replacing normal function application with&nbsp;<code>&gt;&gt;=</code>, we got a mechanism for handling failure pretty much for free, because&nbsp;<code>&gt;&gt;=</code>&nbsp;is supposed to preserve the context of the value to which it applies functions. In this case, the context was that our values were values with failure and so when we applied functions to such values, the possibility of failure was always taken into account.</p></div><div><h2 data-heading="do notation" id="do_notation" style="display: flex;"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>do notation</h2></div><div><p>Monads in Haskell are so useful that they got their own special syntax called&nbsp;<code>do</code>&nbsp;notation. We've already encountered&nbsp;<code>do</code>&nbsp;notation when we were doing I/O and there we said that it was for gluing together several I/O actions into one. Well, as it turns out,&nbsp;<code>do</code>&nbsp;notation isn't just for&nbsp;<code>IO</code>, but can be used for any monad. Its principle is still the same: gluing together monadic values in sequence. We're going to take a look at how&nbsp;<code>do</code>&nbsp;notation works and why it's useful.</p></div><div><p>Consider this familiar example of monadic application:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token constant">Just</span> <span class="token number">3</span> <span class="token operator">&gt;&gt;=</span> <span class="token punctuation">(</span><span class="token operator">\</span><span class="token hvariable">x</span> <span class="token operator">-&gt;</span> <span class="token constant">Just</span> <span class="token punctuation">(</span><span class="token builtin">show</span> <span class="token hvariable">x</span> <span class="token operator">++</span> <span class="token string">"!"</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token constant">Just</span> <span class="token string">"3!"</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Been there, done that. Feeding a monadic value to a function that returns one, no big deal. Notice how when we do this,&nbsp;<code>x</code>&nbsp;becomes&nbsp;<code>3</code>&nbsp;inside the lambda. Once we're inside that lambda, it's just a normal value rather than a monadic value. Now, what if we had another&nbsp;<code>&gt;&gt;=</code>&nbsp;inside that function? Check this out:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token constant">Just</span> <span class="token number">3</span> <span class="token operator">&gt;&gt;=</span> <span class="token punctuation">(</span><span class="token operator">\</span><span class="token hvariable">x</span> <span class="token operator">-&gt;</span> <span class="token constant">Just</span> <span class="token string">"!"</span> <span class="token operator">&gt;&gt;=</span> <span class="token punctuation">(</span><span class="token operator">\</span><span class="token hvariable">y</span> <span class="token operator">-&gt;</span> <span class="token constant">Just</span> <span class="token punctuation">(</span><span class="token builtin">show</span> <span class="token hvariable">x</span> <span class="token operator">++</span> <span class="token hvariable">y</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token constant">Just</span> <span class="token string">"3!"</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Ah, a nested use of&nbsp;<code>&gt;&gt;=</code>! In the outermost lambda, we feed&nbsp;<code>Just "!"</code>&nbsp;to the lambda&nbsp;<code>\y -&gt; Just (show x ++ y)</code>. Inside this lambda, the&nbsp;<code>y</code>&nbsp;becomes&nbsp;<code>"!"</code>.&nbsp;<code>x</code>&nbsp;is still&nbsp;<code>3</code>&nbsp;because we got it from the outer lambda. All this sort of reminds me of the following expression:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token keyword">let</span> <span class="token hvariable">x</span> <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span> <span class="token hvariable">y</span> <span class="token operator">=</span> <span class="token string">"!"</span> <span class="token keyword">in</span> <span class="token builtin">show</span> <span class="token hvariable">x</span> <span class="token operator">++</span> <span class="token hvariable">y</span>
<span class="token string">"3!"</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>The main difference between these two is that the values in the former example are monadic. They're values with a failure context. We can replace any of them with a failure:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token constant">Nothing</span> <span class="token operator">&gt;&gt;=</span> <span class="token punctuation">(</span><span class="token operator">\</span><span class="token hvariable">x</span> <span class="token operator">-&gt;</span> <span class="token constant">Just</span> <span class="token string">"!"</span> <span class="token operator">&gt;&gt;=</span> <span class="token punctuation">(</span><span class="token operator">\</span><span class="token hvariable">y</span> <span class="token operator">-&gt;</span> <span class="token constant">Just</span> <span class="token punctuation">(</span><span class="token builtin">show</span> <span class="token hvariable">x</span> <span class="token operator">++</span> <span class="token hvariable">y</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token constant">Nothing</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token constant">Just</span> <span class="token number">3</span> <span class="token operator">&gt;&gt;=</span> <span class="token punctuation">(</span><span class="token operator">\</span><span class="token hvariable">x</span> <span class="token operator">-&gt;</span> <span class="token constant">Nothing</span> <span class="token operator">&gt;&gt;=</span> <span class="token punctuation">(</span><span class="token operator">\</span><span class="token hvariable">y</span> <span class="token operator">-&gt;</span> <span class="token constant">Just</span> <span class="token punctuation">(</span><span class="token builtin">show</span> <span class="token hvariable">x</span> <span class="token operator">++</span> <span class="token hvariable">y</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token constant">Nothing</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token constant">Just</span> <span class="token number">3</span> <span class="token operator">&gt;&gt;=</span> <span class="token punctuation">(</span><span class="token operator">\</span><span class="token hvariable">x</span> <span class="token operator">-&gt;</span> <span class="token constant">Just</span> <span class="token string">"!"</span> <span class="token operator">&gt;&gt;=</span> <span class="token punctuation">(</span><span class="token operator">\</span><span class="token hvariable">y</span> <span class="token operator">-&gt;</span> <span class="token constant">Nothing</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token constant">Nothing</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>In the first line, feeding a&nbsp;<code>Nothing</code>&nbsp;to a function naturally results in a&nbsp;<code>Nothing</code>. In the second line, we feed&nbsp;<code>Just 3</code>&nbsp;to a function and the&nbsp;<code>x</code>&nbsp;becomes&nbsp;<code>3</code>, but then we feed a&nbsp;<code>Nothing</code>&nbsp;to the inner lambda and the result of that is&nbsp;<code>Nothing</code>, which causes the outer lambda to produce&nbsp;<code>Nothing</code>&nbsp;as well. So this is sort of like assigning values to variables in&nbsp;<code>let</code>&nbsp;expressions, only that the values in question are monadic values.</p></div><div><p>To further illustrate this point, let's write this in a script and have each&nbsp;<code>Maybe</code>&nbsp;value take up its own line:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">foo</span> <span class="token operator">::</span> <span class="token constant">Maybe</span> <span class="token constant">String</span>
<span class="token hvariable">foo</span> <span class="token operator">=</span> <span class="token constant">Just</span> <span class="token number">3</span>   <span class="token operator">&gt;&gt;=</span> <span class="token punctuation">(</span><span class="token operator">\</span><span class="token hvariable">x</span> <span class="token operator">-&gt;</span>
      <span class="token constant">Just</span> <span class="token string">"!"</span> <span class="token operator">&gt;&gt;=</span> <span class="token punctuation">(</span><span class="token operator">\</span><span class="token hvariable">y</span> <span class="token operator">-&gt;</span>
      <span class="token constant">Just</span> <span class="token punctuation">(</span><span class="token builtin">show</span> <span class="token hvariable">x</span> <span class="token operator">++</span> <span class="token hvariable">y</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>To save us from writing all these annoying lambdas, Haskell gives us&nbsp;<code>do</code>&nbsp;notation. It allows us to write the previous piece of code like this:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">foo</span> <span class="token operator">::</span> <span class="token constant">Maybe</span> <span class="token constant">String</span>
<span class="token hvariable">foo</span> <span class="token operator">=</span> <span class="token keyword">do</span>
    <span class="token hvariable">x</span> <span class="token operator">&lt;-</span> <span class="token constant">Just</span> <span class="token number">3</span>
    <span class="token hvariable">y</span> <span class="token operator">&lt;-</span> <span class="token constant">Just</span> <span class="token string">"!"</span>
    <span class="token constant">Just</span> <span class="token punctuation">(</span><span class="token builtin">show</span> <span class="token hvariable">x</span> <span class="token operator">++</span> <span class="token hvariable">y</span><span class="token punctuation">)</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p><img alt="90s owl" src="http://s3.amazonaws.com/lyah/owld.png" referrerpolicy="no-referrer"></p></div><div><p>It would seem as though we've gained the ability to temporarily extract things from&nbsp;<code>Maybe</code>&nbsp;values without having to check if the&nbsp;<code>Maybe</code>&nbsp;values are&nbsp;<code>Just</code>&nbsp;values or&nbsp;<code>Nothing</code>&nbsp;values at every step. How cool! If any of the values that we try to extract from are&nbsp;<code>Nothing</code>, the whole&nbsp;<code>do</code>&nbsp;expression will result in a&nbsp;<code>Nothing</code>. We're yanking out their (possibly existing) values and letting&nbsp;<code>&gt;&gt;=</code>&nbsp;worry about the context that comes with those values. It's important to remember that&nbsp;<code>do</code>&nbsp;expressions are just different syntax for chaining monadic values.</p></div><div><p>In a&nbsp;<code>do</code>&nbsp;expression, every line is a monadic value. To inspect its result, we use&nbsp;<code>&lt;-</code>. If we have a&nbsp;<code>Maybe String</code>&nbsp;and we bind it with&nbsp;<code>&lt;-</code>&nbsp;to a variable, that variable will be a&nbsp;<code>String</code>, just like when we used&nbsp;<code>&gt;&gt;=</code>&nbsp;to feed monadic values to lambdas. The last monadic value in a&nbsp;<code>do</code>&nbsp;expression, like&nbsp;<code>Just (show x ++ y)</code>&nbsp;here, can't be used with&nbsp;<code>&lt;-</code>&nbsp;to bind its result, because that wouldn't make sense if we translated the&nbsp;<code>do</code>&nbsp;expression back to a chain of&nbsp;<code>&gt;&gt;=</code>&nbsp;applications. Rather, its result is the result of the whole glued up monadic value, taking into account the possible failure of any of the previous ones.</p></div><div><p>For instance, examine the following line:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token constant">Just</span> <span class="token number">9</span> <span class="token operator">&gt;&gt;=</span> <span class="token punctuation">(</span><span class="token operator">\</span><span class="token hvariable">x</span> <span class="token operator">-&gt;</span> <span class="token constant">Just</span> <span class="token punctuation">(</span><span class="token hvariable">x</span> <span class="token operator">&gt;</span> <span class="token number">8</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token constant">Just</span> <span class="token constant">True</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Because the left parameter of&nbsp;<code>&gt;&gt;=</code>&nbsp;is a&nbsp;<code>Just</code>&nbsp;value, the lambda is applied to&nbsp;<code>9</code>&nbsp;and the result is a&nbsp;<code>Just True</code>. If we rewrite this in&nbsp;<code>do</code>&nbsp;notation, we get:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">marySue</span> <span class="token operator">::</span> <span class="token constant">Maybe</span> <span class="token constant">Bool</span>
<span class="token hvariable">marySue</span> <span class="token operator">=</span> <span class="token keyword">do</span> 
    <span class="token hvariable">x</span> <span class="token operator">&lt;-</span> <span class="token constant">Just</span> <span class="token number">9</span>
    <span class="token constant">Just</span> <span class="token punctuation">(</span><span class="token hvariable">x</span> <span class="token operator">&gt;</span> <span class="token number">8</span><span class="token punctuation">)</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>If we compare these two, it's easy to see why the result of the whole monadic value is the result of the last monadic value in the&nbsp;<code>do</code>&nbsp;expression with all the previous ones chained into it.</p></div><div><p>Our tightwalker's routine can also be expressed with&nbsp;<code>do</code>&nbsp;notation.&nbsp;<code>landLeft</code>&nbsp;and&nbsp;<code>landRight</code>&nbsp;take a number of birds and a pole and produce a pole wrapped in a&nbsp;<code>Just</code>, unless the tightwalker slips, in which case a&nbsp;<code>Nothing</code>&nbsp;is produced. We used&nbsp;<code>&gt;&gt;=</code>&nbsp;to chain successive steps because each one relied on the previous one and each one had an added context of possible failure. Here's two birds landing on the left side, then two birds landing on the right and then one bird landing on the left:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">routine</span> <span class="token operator">::</span> <span class="token constant">Maybe</span> <span class="token constant">Pole</span>
<span class="token hvariable">routine</span> <span class="token operator">=</span> <span class="token keyword">do</span>
    <span class="token hvariable">start</span> <span class="token operator">&lt;-</span> <span class="token builtin">return</span> <span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">)</span>
    <span class="token hvariable">first</span> <span class="token operator">&lt;-</span> <span class="token hvariable">landLeft</span> <span class="token number">2</span> <span class="token hvariable">start</span>
    <span class="token hvariable">second</span> <span class="token operator">&lt;-</span> <span class="token hvariable">landRight</span> <span class="token number">2</span> <span class="token hvariable">first</span>
    <span class="token hvariable">landLeft</span> <span class="token number">1</span> <span class="token hvariable">second</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Let's see if he succeeds:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token hvariable">routine</span>
<span class="token constant">Just</span> <span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">)</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>He does! Great. When we were doing these routines by explicitly writing&nbsp;<code>&gt;&gt;=</code>, we usually said something like&nbsp;<code>return (0,0) &gt;&gt;= landLeft 2</code>, because&nbsp;<code>landLeft 2</code>&nbsp;is a function that returns a&nbsp;<code>Maybe</code>&nbsp;value. With&nbsp;<code>do</code>&nbsp;expressions however, each line must feature a monadic value. So we explicitly pass the previous&nbsp;<code>Pole</code>&nbsp;to the&nbsp;<code>landLeft</code>&nbsp;<code>landRight</code>&nbsp;functions. If we examined the variables to which we bound our&nbsp;<code>Maybe</code>&nbsp;values,&nbsp;<code>start</code>&nbsp;would be&nbsp;<code>(0,0)</code>,&nbsp;<code>first</code>&nbsp;would be&nbsp;<code>(2,0)</code>&nbsp;and so on.</p></div><div><p>Because&nbsp;<code>do</code>&nbsp;expressions are written line by line, they may look like imperative code to some people. But the thing is, they're just sequential, as each value in each line relies on the result of the previous ones, along with their contexts (in this case, whether they succeeded or failed).</p></div><div><p>Again, let's take a look at what this piece of code would look like if we hadn't used the monadic aspects of&nbsp;<code>Maybe</code>:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">routine</span> <span class="token operator">::</span> <span class="token constant">Maybe</span> <span class="token constant">Pole</span>
<span class="token hvariable">routine</span> <span class="token operator">=</span> 
    <span class="token keyword">case</span> <span class="token constant">Just</span> <span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">)</span> <span class="token keyword">of</span> 
        <span class="token constant">Nothing</span> <span class="token operator">-&gt;</span> <span class="token constant">Nothing</span>
        <span class="token constant">Just</span> <span class="token hvariable">start</span> <span class="token operator">-&gt;</span> <span class="token keyword">case</span> <span class="token hvariable">landLeft</span> <span class="token number">2</span> <span class="token hvariable">start</span> <span class="token keyword">of</span>
            <span class="token constant">Nothing</span> <span class="token operator">-&gt;</span> <span class="token constant">Nothing</span>
            <span class="token constant">Just</span> <span class="token hvariable">first</span> <span class="token operator">-&gt;</span> <span class="token keyword">case</span> <span class="token hvariable">landRight</span> <span class="token number">2</span> <span class="token hvariable">first</span> <span class="token keyword">of</span>
                <span class="token constant">Nothing</span> <span class="token operator">-&gt;</span> <span class="token constant">Nothing</span>
                <span class="token constant">Just</span> <span class="token hvariable">second</span> <span class="token operator">-&gt;</span> <span class="token hvariable">landLeft</span> <span class="token number">1</span> <span class="token hvariable">second</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>See how in the case of success, the tuple inside&nbsp;<code>Just (0,0)</code>&nbsp;becomes&nbsp;<code>start</code>, the result of&nbsp;<code>landLeft 2 start</code>&nbsp;becomes&nbsp;<code>first</code>, etc.</p></div><div><p>If we want to throw the Pierre a banana peel in&nbsp;<code>do</code>&nbsp;notation, we can do the following:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">routine</span> <span class="token operator">::</span> <span class="token constant">Maybe</span> <span class="token constant">Pole</span>
<span class="token hvariable">routine</span> <span class="token operator">=</span> <span class="token keyword">do</span>
    <span class="token hvariable">start</span> <span class="token operator">&lt;-</span> <span class="token builtin">return</span> <span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">)</span>
    <span class="token hvariable">first</span> <span class="token operator">&lt;-</span> <span class="token hvariable">landLeft</span> <span class="token number">2</span> <span class="token hvariable">start</span>
    <span class="token constant">Nothing</span>
    <span class="token hvariable">second</span> <span class="token operator">&lt;-</span> <span class="token hvariable">landRight</span> <span class="token number">2</span> <span class="token hvariable">first</span>
    <span class="token hvariable">landLeft</span> <span class="token number">1</span> <span class="token hvariable">second</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>When we write a line in&nbsp;<code>do</code>&nbsp;notation without binding the monadic value with&nbsp;<code>&lt;-</code>, it's just like putting&nbsp;<code>&gt;&gt;</code>&nbsp;after the monadic value whose result we want to ignore. We sequence the monadic value but we ignore its result because we don't care what it is and it's prettier than writing&nbsp;<code>_ &lt;- Nothing</code>, which is equivalent to the above.</p></div><div><p>When to use&nbsp;<code>do</code>&nbsp;notation and when to explicitly use&nbsp;<code>&gt;&gt;=</code>&nbsp;is up to you. I think this example lends itself to explicitly writing&nbsp;<code>&gt;&gt;=</code>&nbsp;because each step relies specifically on the result of the previous one. With&nbsp;<code>do</code>&nbsp;notation, we had to specifically write on which pole the birds are landing, but every time we used that came directly before. But still, it gave us some insight into&nbsp;<code>do</code>&nbsp;notation.</p></div><div><p>In&nbsp;<code>do</code>&nbsp;notation, when we bind monadic values to names, we can utilize pattern matching, just like in&nbsp;<code>let</code>&nbsp;expressions and function parameters. Here's an example of pattern matching in a&nbsp;<code>do</code>&nbsp;expression:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">justH</span> <span class="token operator">::</span> <span class="token constant">Maybe</span> <span class="token constant">Char</span>
<span class="token hvariable">justH</span> <span class="token operator">=</span> <span class="token keyword">do</span>
    <span class="token punctuation">(</span><span class="token hvariable">x</span><span class="token operator">:</span><span class="token hvariable">xs</span><span class="token punctuation">)</span> <span class="token operator">&lt;-</span> <span class="token constant">Just</span> <span class="token string">"hello"</span>
    <span class="token builtin">return</span> <span class="token hvariable">x</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>We use pattern matching to get the first character of the string&nbsp;<code>"hello"</code>&nbsp;and then we present it as the result. So&nbsp;<code>justH</code>&nbsp;evaluates to&nbsp;<code>Just 'h'</code>.</p></div><div><p>What if this pattern matching were to fail? When matching on a pattern in a function fails, the next pattern is matched. If the matching falls through all the patterns for a given function, an error is thrown and our program crashes. On the other hand, failed pattern matching in&nbsp;<code>let</code>&nbsp;expressions results in an error being produced right away, because the mechanism of falling through patterns isn't present in&nbsp;<code>let</code>&nbsp;expressions. When pattern matching fails in a&nbsp;<code>do</code>&nbsp;expression, the&nbsp;<code>fail</code>&nbsp;function is called. It's part of the&nbsp;<code>Monad</code>&nbsp;type class and it enables failed pattern matching to result in a failure in the context of the current monad instead of making our program crash. Its default implementation is this:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token builtin">fail</span> <span class="token operator">::</span> <span class="token punctuation">(</span><span class="token constant">Monad</span> <span class="token hvariable">m</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token constant">String</span> <span class="token operator">-&gt;</span> <span class="token hvariable">m</span> <span class="token hvariable">a</span>
<span class="token builtin">fail</span> <span class="token hvariable">msg</span> <span class="token operator">=</span> <span class="token builtin">error</span> <span class="token hvariable">msg</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>So by default it does make our program crash, but monads that incorporate a context of possible failure (like&nbsp;<code>Maybe</code>) usually implement it on their own. For&nbsp;<code>Maybe</code>, its implemented like so:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token builtin">fail</span> <span class="token hvariable">_</span> <span class="token operator">=</span> <span class="token constant">Nothing</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>It ignores the error message and makes a&nbsp;<code>Nothing</code>. So when pattern matching fails in a&nbsp;<code>Maybe</code>&nbsp;value that's written in&nbsp;<code>do</code>&nbsp;notation, the whole value results in a&nbsp;<code>Nothing</code>. This is preferable to having our program crash. Here's a&nbsp;<code>do</code>&nbsp;expression with a pattern that's bound to fail:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">wopwop</span> <span class="token operator">::</span> <span class="token constant">Maybe</span> <span class="token constant">Char</span>
<span class="token hvariable">wopwop</span> <span class="token operator">=</span> <span class="token keyword">do</span>
    <span class="token punctuation">(</span><span class="token hvariable">x</span><span class="token operator">:</span><span class="token hvariable">xs</span><span class="token punctuation">)</span> <span class="token operator">&lt;-</span> <span class="token constant">Just</span> <span class="token string">""</span>
    <span class="token builtin">return</span> <span class="token hvariable">x</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>The pattern matching fails, so the effect is the same as if the whole line with the pattern was replaced with a&nbsp;<code>Nothing</code>. Let's try this out:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token hvariable">wopwop</span>
<span class="token constant">Nothing</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>The failed pattern matching has caused a failure within the context of our monad instead of causing a program-wide failure, which is pretty neat.</p></div><div><h2 data-heading="The list monad" id="The_list_monad" style="display: flex;"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>The list monad</h2></div><div><p><img alt="dead cat" src="http://s3.amazonaws.com/lyah/deadcat.png" referrerpolicy="no-referrer"></p></div><div><p>So far, we've seen how&nbsp;<code>Maybe</code>&nbsp;values can be viewed as values with a failure context and how we can incorporate failure handling into our code by using&nbsp;<code>&gt;&gt;=</code>&nbsp;to feed them to functions. In this section, we're going to take a look at how to use the monadic aspects of lists to bring non-determinism into our code in a clear and readable manner.</p></div><div><p>We've already talked about how lists represent non-deterministic values when they're used as applicatives. A value like&nbsp;<code>5</code>&nbsp;is deterministic. It has only one result and we know exactly what it is. On the other hand, a value like&nbsp;<code>[3,8,9]</code>&nbsp;contains several results, so we can view it as one value that is actually many values at the same time. Using lists as applicative functors showcases this non-determinism nicely:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">)</span> <span class="token operator">&lt;$&gt;</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">]</span> <span class="token operator">&lt;*&gt;</span> <span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">,</span><span class="token number">100</span><span class="token punctuation">,</span><span class="token number">1000</span><span class="token punctuation">]</span>
<span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">,</span><span class="token number">100</span><span class="token punctuation">,</span><span class="token number">1000</span><span class="token punctuation">,</span><span class="token number">20</span><span class="token punctuation">,</span><span class="token number">200</span><span class="token punctuation">,</span><span class="token number">2000</span><span class="token punctuation">,</span><span class="token number">30</span><span class="token punctuation">,</span><span class="token number">300</span><span class="token punctuation">,</span><span class="token number">3000</span><span class="token punctuation">]</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>All the possible combinations of multiplying elements from the left list with elements from the right list are included in the resulting list. When dealing with non-determinism, there are many choices that we can make, so we just try all of them, and so the result is a non-deterministic value as well, only it has many more results.</p></div><div><p>This context of non-determinism translates to monads very nicely. Let's go ahead and see what the&nbsp;<code>Monad</code>&nbsp;instance for lists looks like:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token keyword">instance</span> <span class="token constant">Monad</span> <span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token keyword">where</span>
    <span class="token builtin">return</span> <span class="token hvariable">x</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token hvariable">x</span><span class="token punctuation">]</span>
    <span class="token hvariable">xs</span> <span class="token operator">&gt;&gt;=</span> <span class="token hvariable">f</span> <span class="token operator">=</span> <span class="token builtin">concat</span> <span class="token punctuation">(</span><span class="token builtin">map</span> <span class="token hvariable">f</span> <span class="token hvariable">xs</span><span class="token punctuation">)</span>
    <span class="token builtin">fail</span> <span class="token hvariable">_</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p><code>return</code>&nbsp;does the same thing as&nbsp;<code>pure</code>, so we should already be familiar with&nbsp;<code>return</code>&nbsp;for lists. It takes a value and puts it in a minimal default context that still yields that value. In other words, it makes a list that has only that one value as its result. This is useful for when we want to just wrap a normal value into a list so that it can interact with non-deterministic values.</p></div><div><p>To understand how&nbsp;<code>&gt;&gt;=</code>&nbsp;works for lists, it's best if we take a look at it in action to gain some intuition first.&nbsp;<code>&gt;&gt;=</code>&nbsp;is about taking a value with a context (a monadic value) and feeding it to a function that takes a normal value and returns one that has context. If that function just produced a normal value instead of one with a context,&nbsp;<code>&gt;&gt;=</code>&nbsp;wouldn't be so useful because after one use, the context would be lost. Anyway, let's try feeding a non-deterministic value to a function:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">]</span> <span class="token operator">&gt;&gt;=</span> <span class="token operator">\</span><span class="token hvariable">x</span> <span class="token operator">-&gt;</span> <span class="token punctuation">[</span><span class="token hvariable">x</span><span class="token punctuation">,</span><span class="token operator">-</span><span class="token hvariable">x</span><span class="token punctuation">]</span>
<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">5</span><span class="token punctuation">]</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>When we used&nbsp;<code>&gt;&gt;=</code>&nbsp;with&nbsp;<code>Maybe</code>, the monadic value was fed into the function while taking care of possible failures. Here, it takes care of non-determinism for us.&nbsp;<code>[3,4,5]</code>&nbsp;is a non-deterministic value and we feed it into a function that returns a non-deterministic value as well. The result is also non-deterministic, and it features all the possible results of taking elements from the list&nbsp;<code>[3,4,5]</code>&nbsp;and passing them to the function&nbsp;<code>\x -&gt; [x,-x]</code>. This function takes a number and produces two results: one negated and one that's unchanged. So when we use&nbsp;<code>&gt;&gt;=</code>&nbsp;to feed this list to the function, every number is negated and also kept unchanged. The&nbsp;<code>x</code>&nbsp;from the lambda takes on every value from the list that's fed to it.</p></div><div><p>To see how this is achieved, we can just follow the implementation. First, we start off with the list&nbsp;<code>[3,4,5]</code>. Then, we map the lambda over it and the result is the following:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">]</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>The lambda is applied to every element and we get a list of lists. Finally, we just flatten the list and voila! We've applied a non-deterministic function to a non-deterministic value!</p></div><div><p>Non-determinism also includes support for failure. The empty list&nbsp;<code>[]</code>&nbsp;is pretty much the equivalent of&nbsp;<code>Nothing</code>, because it signifies the absence of a result. That's why failing is just defined as the empty list. The error message gets thrown away. Let's play around with lists that fail:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">&gt;&gt;=</span> <span class="token operator">\</span><span class="token hvariable">x</span> <span class="token operator">-&gt;</span> <span class="token punctuation">[</span><span class="token string">"bad"</span><span class="token punctuation">,</span><span class="token string">"mad"</span><span class="token punctuation">,</span><span class="token string">"rad"</span><span class="token punctuation">]</span>
<span class="token punctuation">[</span><span class="token punctuation">]</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">]</span> <span class="token operator">&gt;&gt;=</span> <span class="token operator">\</span><span class="token hvariable">x</span> <span class="token operator">-&gt;</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
<span class="token punctuation">[</span><span class="token punctuation">]</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>In the first line, an empty list is fed into the lambda. Because the list has no elements, none of them can be passed to the function and so the result is an empty list. This is similar to feeding&nbsp;<code>Nothing</code>&nbsp;to a function. In the second line, each element gets passed to the function, but the element is ignored and the function just returns an empty list. Because the function fails for every element that goes in it, the result is a failure.</p></div><div><p>Just like with&nbsp;<code>Maybe</code>&nbsp;values, we can chain several lists with&nbsp;<code>&gt;&gt;=</code>, propagating the non-determinism:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">]</span> <span class="token operator">&gt;&gt;=</span> <span class="token operator">\</span><span class="token hvariable">n</span> <span class="token operator">-&gt;</span> <span class="token punctuation">[</span><span class="token char string">'a'</span><span class="token punctuation">,</span><span class="token char string">'b'</span><span class="token punctuation">]</span> <span class="token operator">&gt;&gt;=</span> <span class="token operator">\</span><span class="token hvariable">ch</span> <span class="token operator">-&gt;</span> <span class="token builtin">return</span> <span class="token punctuation">(</span><span class="token hvariable">n</span><span class="token punctuation">,</span><span class="token hvariable">ch</span><span class="token punctuation">)</span>
<span class="token punctuation">[</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token char string">'a'</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token char string">'b'</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token char string">'a'</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token char string">'b'</span><span class="token punctuation">)</span><span class="token punctuation">]</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p><img alt="concatmap" src="http://s3.amazonaws.com/lyah/concatmap.png" referrerpolicy="no-referrer"></p></div><div><p>The list&nbsp;<code>[1,2]</code>&nbsp;gets bound to&nbsp;<code>n</code>&nbsp;and&nbsp;<code>['a','b']</code>&nbsp;gets bound to&nbsp;<code>ch</code>. Then, we do&nbsp;<code>return (n,ch)</code>&nbsp;(or&nbsp;<code>[(n,ch)]</code>), which means taking a pair of&nbsp;<code>(n,ch)</code>&nbsp;and putting it in a default minimal context. In this case, it's making the smallest possible list that still presents&nbsp;<code>(n,ch)</code>&nbsp;as the result and features as little non-determinism as possible. Its effect on the context is minimal. What we're saying here is this: for every element in&nbsp;<code>[1,2]</code>, go over every element in&nbsp;<code>['a','b']</code>&nbsp;and produce a tuple of one element from each list.</p></div><div><p>Generally speaking, because&nbsp;<code>return</code>&nbsp;takes a value and wraps it in a minimal context, it doesn't have any extra effect (like failing in&nbsp;<code>Maybe</code>&nbsp;or resulting in more non-determinism for lists) but it does present something as its result.</p></div><div><p>When you have non-deterministic values interacting, you can view their computation as a tree where every possible result in a list represents a separate branch.</p></div><div><p>Here's the previous expression rewritten in&nbsp;<code>do</code>&nbsp;notation:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">listOfTuples</span> <span class="token operator">::</span> <span class="token punctuation">[</span><span class="token punctuation">(</span><span class="token constant">Int</span><span class="token punctuation">,</span><span class="token constant">Char</span><span class="token punctuation">)</span><span class="token punctuation">]</span>
<span class="token hvariable">listOfTuples</span> <span class="token operator">=</span> <span class="token keyword">do</span>
    <span class="token hvariable">n</span> <span class="token operator">&lt;-</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">]</span>
    <span class="token hvariable">ch</span> <span class="token operator">&lt;-</span> <span class="token punctuation">[</span><span class="token char string">'a'</span><span class="token punctuation">,</span><span class="token char string">'b'</span><span class="token punctuation">]</span>
    <span class="token builtin">return</span> <span class="token punctuation">(</span><span class="token hvariable">n</span><span class="token punctuation">,</span><span class="token hvariable">ch</span><span class="token punctuation">)</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>This makes it a bit more obvious that&nbsp;<code>n</code>&nbsp;takes on every value from&nbsp;<code>[1,2]</code>&nbsp;and&nbsp;<code>ch</code>&nbsp;takes on every value from&nbsp;<code>['a','b']</code>. Just like with&nbsp;<code>Maybe</code>, we're extracting the elements from the monadic values and treating them like normal values and&nbsp;<code>&gt;&gt;=</code>&nbsp;takes care of the context for us. The context in this case is non-determinism.</p></div><div><p>Using lists with&nbsp;<code>do</code>&nbsp;notation really reminds me of something we've seen before. Check out the following piece of code:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token punctuation">[</span> <span class="token punctuation">(</span><span class="token hvariable">n</span><span class="token punctuation">,</span><span class="token hvariable">ch</span><span class="token punctuation">)</span> <span class="token operator">|</span> <span class="token hvariable">n</span> <span class="token operator">&lt;-</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token hvariable">ch</span> <span class="token operator">&lt;-</span> <span class="token punctuation">[</span><span class="token char string">'a'</span><span class="token punctuation">,</span><span class="token char string">'b'</span><span class="token punctuation">]</span> <span class="token punctuation">]</span>
<span class="token punctuation">[</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token char string">'a'</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token char string">'b'</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token char string">'a'</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token char string">'b'</span><span class="token punctuation">)</span><span class="token punctuation">]</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Yes! List comprehensions! In our&nbsp;<code>do</code>&nbsp;notation example,&nbsp;<code>n</code>&nbsp;became every result from&nbsp;<code>[1,2]</code>&nbsp;and for every such result,&nbsp;<code>ch</code>&nbsp;was assigned a result from&nbsp;<code>['a','b']</code>&nbsp;and then the final line put&nbsp;<code>(n,ch)</code>&nbsp;into a default context (a singleton list) to present it as the result without introducing any additional non-determinism. In this list comprehension, the same thing happened, only we didn't have to write&nbsp;<code>return</code>&nbsp;at the end to present&nbsp;<code>(n,ch)</code>&nbsp;as the result because the output part of a list comprehension did that for us.</p></div><div><p>In fact, list comprehensions are just syntactic sugar for using lists as monads. In the end, list comprehensions and lists in&nbsp;<code>do</code>&nbsp;notation translate to using&nbsp;<code>&gt;&gt;=</code>&nbsp;to do computations that feature non-determinism.</p></div><div><p>List comprehensions allow us to filter our output. For instance, we can filter a list of numbers to search only for that numbers whose digits contain a&nbsp;<code>7</code>:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token punctuation">[</span> <span class="token hvariable">x</span> <span class="token operator">|</span> <span class="token hvariable">x</span> <span class="token operator">&lt;-</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token operator">..</span><span class="token number">50</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token char string">'7'</span> <span class="token operator">`elem`</span> <span class="token builtin">show</span> <span class="token hvariable">x</span> <span class="token punctuation">]</span>
<span class="token punctuation">[</span><span class="token number">7</span><span class="token punctuation">,</span><span class="token number">17</span><span class="token punctuation">,</span><span class="token number">27</span><span class="token punctuation">,</span><span class="token number">37</span><span class="token punctuation">,</span><span class="token number">47</span><span class="token punctuation">]</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>We apply&nbsp;<code>show</code>&nbsp;to&nbsp;<code>x</code>&nbsp;to turn our number into a string and then we check if the character&nbsp;<code>'7'</code>&nbsp;is part of that string. Pretty clever. To see how filtering in list comprehensions translates to the list monad, we have to check out the&nbsp;<code>guard</code>&nbsp;function and the&nbsp;<code>MonadPlus</code>&nbsp;type class. The&nbsp;<code>MonadPlus</code>&nbsp;type class is for monads that can also act as monoids. Here's its definition:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token keyword">class</span> <span class="token constant">Monad</span> <span class="token hvariable">m</span> <span class="token operator">=&gt;</span> <span class="token constant">MonadPlus</span> <span class="token hvariable">m</span> <span class="token keyword">where</span>
    <span class="token hvariable">mzero</span> <span class="token operator">::</span> <span class="token hvariable">m</span> <span class="token hvariable">a</span>
    <span class="token hvariable">mplus</span> <span class="token operator">::</span> <span class="token hvariable">m</span> <span class="token hvariable">a</span> <span class="token operator">-&gt;</span> <span class="token hvariable">m</span> <span class="token hvariable">a</span> <span class="token operator">-&gt;</span> <span class="token hvariable">m</span> <span class="token hvariable">a</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p><code>mzero</code>&nbsp;is synonymous to&nbsp;<code>mempty</code>&nbsp;from the&nbsp;<code>Monoid</code>&nbsp;type class and&nbsp;<code>mplus</code>&nbsp;corresponds to&nbsp;<code>mappend</code>. Because lists are monoids as well as monads, they can be made an instance of this type class:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token keyword">instance</span> <span class="token constant">MonadPlus</span> <span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token keyword">where</span>
    <span class="token hvariable">mzero</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
    <span class="token hvariable">mplus</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token operator">++</span><span class="token punctuation">)</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>For lists&nbsp;<code>mzero</code>&nbsp;represents a non-deterministic computation that has no results at all — a failed computation.&nbsp;<code>mplus</code>&nbsp;joins two non-deterministic values into one. The&nbsp;<code>guard</code>&nbsp;function is defined like this:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">guard</span> <span class="token operator">::</span> <span class="token punctuation">(</span><span class="token constant">MonadPlus</span> <span class="token hvariable">m</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token constant">Bool</span> <span class="token operator">-&gt;</span> <span class="token hvariable">m</span> <span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token hvariable">guard</span> <span class="token constant">True</span> <span class="token operator">=</span> <span class="token builtin">return</span> <span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token hvariable">guard</span> <span class="token constant">False</span> <span class="token operator">=</span> <span class="token hvariable">mzero</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>It takes a boolean value and if it's&nbsp;<code>True</code>, takes a&nbsp;<code>()</code>&nbsp;and puts it in a minimal default context that still succeeds. Otherwise, it makes a failed monadic value. Here it is in action:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token hvariable">guard</span> <span class="token punctuation">(</span><span class="token number">5</span> <span class="token operator">&gt;</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token operator">::</span> <span class="token constant">Maybe</span> <span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token constant">Just</span> <span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token hvariable">guard</span> <span class="token punctuation">(</span><span class="token number">1</span> <span class="token operator">&gt;</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token operator">::</span> <span class="token constant">Maybe</span> <span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token constant">Nothing</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token hvariable">guard</span> <span class="token punctuation">(</span><span class="token number">5</span> <span class="token operator">&gt;</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token operator">::</span> <span class="token punctuation">[</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">]</span>
<span class="token punctuation">[</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">]</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token hvariable">guard</span> <span class="token punctuation">(</span><span class="token number">1</span> <span class="token operator">&gt;</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token operator">::</span> <span class="token punctuation">[</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">]</span>
<span class="token punctuation">[</span><span class="token punctuation">]</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Looks interesting, but how is it useful? In the list monad, we use it to filter out non-deterministic computations. Observe:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token operator">..</span><span class="token number">50</span><span class="token punctuation">]</span> <span class="token operator">&gt;&gt;=</span> <span class="token punctuation">(</span><span class="token operator">\</span><span class="token hvariable">x</span> <span class="token operator">-&gt;</span> <span class="token hvariable">guard</span> <span class="token punctuation">(</span><span class="token char string">'7'</span> <span class="token operator">`elem`</span> <span class="token builtin">show</span> <span class="token hvariable">x</span><span class="token punctuation">)</span> <span class="token operator">&gt;&gt;</span> <span class="token builtin">return</span> <span class="token hvariable">x</span><span class="token punctuation">)</span>
<span class="token punctuation">[</span><span class="token number">7</span><span class="token punctuation">,</span><span class="token number">17</span><span class="token punctuation">,</span><span class="token number">27</span><span class="token punctuation">,</span><span class="token number">37</span><span class="token punctuation">,</span><span class="token number">47</span><span class="token punctuation">]</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>The result here is the same as the result of our previous list comprehension. How does&nbsp;<code>guard</code>&nbsp;achieve this? Let's first see how&nbsp;<code>guard</code>&nbsp;functions in conjunction with&nbsp;<code>&gt;&gt;</code>:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token hvariable">guard</span> <span class="token punctuation">(</span><span class="token number">5</span> <span class="token operator">&gt;</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token operator">&gt;&gt;</span> <span class="token builtin">return</span> <span class="token string">"cool"</span> <span class="token operator">::</span> <span class="token punctuation">[</span><span class="token constant">String</span><span class="token punctuation">]</span>
<span class="token punctuation">[</span><span class="token string">"cool"</span><span class="token punctuation">]</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token hvariable">guard</span> <span class="token punctuation">(</span><span class="token number">1</span> <span class="token operator">&gt;</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token operator">&gt;&gt;</span> <span class="token builtin">return</span> <span class="token string">"cool"</span> <span class="token operator">::</span> <span class="token punctuation">[</span><span class="token constant">String</span><span class="token punctuation">]</span>
<span class="token punctuation">[</span><span class="token punctuation">]</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>If&nbsp;<code>guard</code>&nbsp;succeeds, the result contained within it is an empty tuple. So then, we use&nbsp;<code>&gt;&gt;</code>&nbsp;to ignore that empty tuple and present something else as the result. However, if&nbsp;<code>guard</code>&nbsp;fails, then so will the&nbsp;<code>return</code>&nbsp;later on, because feeding an empty list to a function with&nbsp;<code>&gt;&gt;=</code>&nbsp;always results in an empty list. A&nbsp;<code>guard</code>&nbsp;basically says: if this boolean is&nbsp;<code>False</code>&nbsp;then produce a failure right here, otherwise make a successful value that has a dummy result of&nbsp;<code>()</code>&nbsp;inside it. All this does is to allow the computation to continue.</p></div><div><p>Here's the previous example rewritten in&nbsp;<code>do</code>&nbsp;notation:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">sevensOnly</span> <span class="token operator">::</span> <span class="token punctuation">[</span><span class="token constant">Int</span><span class="token punctuation">]</span>
<span class="token hvariable">sevensOnly</span> <span class="token operator">=</span> <span class="token keyword">do</span>
    <span class="token hvariable">x</span> <span class="token operator">&lt;-</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token operator">..</span><span class="token number">50</span><span class="token punctuation">]</span>
    <span class="token hvariable">guard</span> <span class="token punctuation">(</span><span class="token char string">'7'</span> <span class="token operator">`elem`</span> <span class="token builtin">show</span> <span class="token hvariable">x</span><span class="token punctuation">)</span>
    <span class="token builtin">return</span> <span class="token hvariable">x</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Had we forgotten to present&nbsp;<code>x</code>&nbsp;as the final result by using&nbsp;<code>return</code>, the resulting list would just be a list of empty tuples. Here's this again in the form of a list comprehension:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token punctuation">[</span> <span class="token hvariable">x</span> <span class="token operator">|</span> <span class="token hvariable">x</span> <span class="token operator">&lt;-</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token operator">..</span><span class="token number">50</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token char string">'7'</span> <span class="token operator">`elem`</span> <span class="token builtin">show</span> <span class="token hvariable">x</span> <span class="token punctuation">]</span>
<span class="token punctuation">[</span><span class="token number">7</span><span class="token punctuation">,</span><span class="token number">17</span><span class="token punctuation">,</span><span class="token number">27</span><span class="token punctuation">,</span><span class="token number">37</span><span class="token punctuation">,</span><span class="token number">47</span><span class="token punctuation">]</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>So filtering in list comprehensions is the same as using&nbsp;<code>guard</code>.</p></div><div><h3 data-heading="A knight's quest" id="A_knight's_quest" style="display: flex;"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>A knight's quest</h3></div><div><p>Here's a problem that really lends itself to being solved with non-determinism. Say you have a chess board and only one knight piece on it. We want to find out if the knight can reach a certain position in three moves. We'll just use a pair of numbers to represent the knight's position on the chess board. The first number will determine the column he's in and the second number will determine the row.</p></div><div><p><img alt="hee haw im a horse" src="http://s3.amazonaws.com/lyah/chess.png" referrerpolicy="no-referrer"></p></div><div><p>Let's make a type synonym for the knight's current position on the chess board:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token keyword">type</span> <span class="token constant">KnightPos</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token constant">Int</span><span class="token punctuation">,</span><span class="token constant">Int</span><span class="token punctuation">)</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>So let's say that the knight starts at&nbsp;<code>(6,2)</code>. Can he get to&nbsp;<code>(6,1)</code>&nbsp;in exactly three moves? Let's see. If we start off at&nbsp;<code>(6,2)</code>&nbsp;what's the best move to make next? I know, how about all of them! We have non-determinism at our disposal, so instead of picking one move, let's just pick all of them at once. Here's a function that takes the knight's position and returns all of its next moves:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">moveKnight</span> <span class="token operator">::</span> <span class="token constant">KnightPos</span> <span class="token operator">-&gt;</span> <span class="token punctuation">[</span><span class="token constant">KnightPos</span><span class="token punctuation">]</span>
<span class="token hvariable">moveKnight</span> <span class="token punctuation">(</span><span class="token hvariable">c</span><span class="token punctuation">,</span><span class="token hvariable">r</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token keyword">do</span>
    <span class="token punctuation">(</span><span class="token hvariable">c'</span><span class="token punctuation">,</span><span class="token hvariable">r'</span><span class="token punctuation">)</span> <span class="token operator">&lt;-</span> <span class="token punctuation">[</span><span class="token punctuation">(</span><span class="token hvariable">c</span><span class="token operator">+</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token hvariable">r</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token hvariable">c</span><span class="token operator">+</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token hvariable">r</span><span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token hvariable">c</span><span class="token operator">-</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token hvariable">r</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token hvariable">c</span><span class="token operator">-</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token hvariable">r</span><span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span>
               <span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token hvariable">c</span><span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token hvariable">r</span><span class="token operator">-</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token hvariable">c</span><span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token hvariable">r</span><span class="token operator">+</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token hvariable">c</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token hvariable">r</span><span class="token operator">-</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token hvariable">c</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token hvariable">r</span><span class="token operator">+</span><span class="token number">2</span><span class="token punctuation">)</span>
               <span class="token punctuation">]</span>
    <span class="token hvariable">guard</span> <span class="token punctuation">(</span><span class="token hvariable">c'</span> <span class="token operator">`elem`</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token operator">..</span><span class="token number">8</span><span class="token punctuation">]</span> <span class="token operator">&amp;&amp;</span> <span class="token hvariable">r'</span> <span class="token operator">`elem`</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token operator">..</span><span class="token number">8</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
    <span class="token builtin">return</span> <span class="token punctuation">(</span><span class="token hvariable">c'</span><span class="token punctuation">,</span><span class="token hvariable">r'</span><span class="token punctuation">)</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>The knight can always take one step horizontally or vertically and two steps horizontally or vertically but its movement has to be both horizontal and vertical.&nbsp;<code>(c',r')</code>&nbsp;takes on every value from the list of movements and then&nbsp;<code>guard</code>&nbsp;makes sure that the new move,&nbsp;<code>(c',r')</code>&nbsp;is still on the board. If it it's not, it produces an empty list, which causes a failure and&nbsp;<code>return (c',r')</code>&nbsp;isn't carried out for that position.</p></div><div><p>This function can also be written without the use of lists as a monad, but we did it here just for kicks. Here is the same function done with&nbsp;<code>filter</code>:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">moveKnight</span> <span class="token operator">::</span> <span class="token constant">KnightPos</span> <span class="token operator">-&gt;</span> <span class="token punctuation">[</span><span class="token constant">KnightPos</span><span class="token punctuation">]</span>
<span class="token hvariable">moveKnight</span> <span class="token punctuation">(</span><span class="token hvariable">c</span><span class="token punctuation">,</span><span class="token hvariable">r</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token builtin">filter</span> <span class="token hvariable">onBoard</span>
    <span class="token punctuation">[</span><span class="token punctuation">(</span><span class="token hvariable">c</span><span class="token operator">+</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token hvariable">r</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token hvariable">c</span><span class="token operator">+</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token hvariable">r</span><span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token hvariable">c</span><span class="token operator">-</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token hvariable">r</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token hvariable">c</span><span class="token operator">-</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token hvariable">r</span><span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span>
    <span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token hvariable">c</span><span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token hvariable">r</span><span class="token operator">-</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token hvariable">c</span><span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token hvariable">r</span><span class="token operator">+</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token hvariable">c</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token hvariable">r</span><span class="token operator">-</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token hvariable">c</span><span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token hvariable">r</span><span class="token operator">+</span><span class="token number">2</span><span class="token punctuation">)</span>
    <span class="token punctuation">]</span>
    <span class="token keyword">where</span> <span class="token hvariable">onBoard</span> <span class="token punctuation">(</span><span class="token hvariable">c</span><span class="token punctuation">,</span><span class="token hvariable">r</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token hvariable">c</span> <span class="token operator">`elem`</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token operator">..</span><span class="token number">8</span><span class="token punctuation">]</span> <span class="token operator">&amp;&amp;</span> <span class="token hvariable">r</span> <span class="token operator">`elem`</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token operator">..</span><span class="token number">8</span><span class="token punctuation">]</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Both of these do the same thing, so pick one that you think looks nicer. Let's give it a whirl:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token hvariable">moveKnight</span> <span class="token punctuation">(</span><span class="token number">6</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">)</span>
<span class="token punctuation">[</span><span class="token punctuation">(</span><span class="token number">8</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token number">8</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token number">7</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">]</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token hvariable">moveKnight</span> <span class="token punctuation">(</span><span class="token number">8</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">)</span>
<span class="token punctuation">[</span><span class="token punctuation">(</span><span class="token number">6</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token number">7</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">]</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Works like a charm! We take one position and we just carry out all the possible moves at once, so to speak. So now that we have a non-deterministic next position, we just use&nbsp;<code>&gt;&gt;=</code>&nbsp;to feed it to&nbsp;<code>moveKnight</code>. Here's a function that takes a position and returns all the positions that you can reach from it in three moves:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">in3</span> <span class="token operator">::</span> <span class="token constant">KnightPos</span> <span class="token operator">-&gt;</span> <span class="token punctuation">[</span><span class="token constant">KnightPos</span><span class="token punctuation">]</span>
<span class="token hvariable">in3</span> <span class="token hvariable">start</span> <span class="token operator">=</span> <span class="token keyword">do</span> 
    <span class="token hvariable">first</span> <span class="token operator">&lt;-</span> <span class="token hvariable">moveKnight</span> <span class="token hvariable">start</span>
    <span class="token hvariable">second</span> <span class="token operator">&lt;-</span> <span class="token hvariable">moveKnight</span> <span class="token hvariable">first</span>
    <span class="token hvariable">moveKnight</span> <span class="token hvariable">second</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>If you pass it&nbsp;<code>(6,2)</code>, the resulting list is quite big, because if there are several ways to reach some position in three moves, it crops up in the list several times. The above without&nbsp;<code>do</code>&nbsp;notation:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">in3</span> <span class="token hvariable">start</span> <span class="token operator">=</span> <span class="token builtin">return</span> <span class="token hvariable">start</span> <span class="token operator">&gt;&gt;=</span> <span class="token hvariable">moveKnight</span> <span class="token operator">&gt;&gt;=</span> <span class="token hvariable">moveKnight</span> <span class="token operator">&gt;&gt;=</span> <span class="token hvariable">moveKnight</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Using&nbsp;<code>&gt;&gt;=</code>&nbsp;once gives us all possible moves from the start and then when we use&nbsp;<code>&gt;&gt;=</code>&nbsp;the second time, for every possible first move, every possible next move is computed, and the same goes for the last move.</p></div><div><p>Putting a value in a default context by applying&nbsp;<code>return</code>&nbsp;to it and then feeding it to a function with&nbsp;<code>&gt;&gt;=</code>&nbsp;is the same as just normally applying the function to that value, but we did it here anyway for style.</p></div><div><p>Now, let's make a function that takes two positions and tells us if you can get from one to the other in exactly three steps:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">canReachIn3</span> <span class="token operator">::</span> <span class="token constant">KnightPos</span> <span class="token operator">-&gt;</span> <span class="token constant">KnightPos</span> <span class="token operator">-&gt;</span> <span class="token constant">Bool</span>
<span class="token hvariable">canReachIn3</span> <span class="token hvariable">start</span> <span class="token hvariable">end</span> <span class="token operator">=</span> <span class="token hvariable">end</span> <span class="token operator">`elem`</span> <span class="token hvariable">in3</span> <span class="token hvariable">start</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>We generate all the possible positions in three steps and then we see if the position we're looking for is among them. So let's see if we can get from&nbsp;<code>(6,2)</code>&nbsp;to&nbsp;<code>(6,1)</code>&nbsp;in three moves:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token punctuation">(</span><span class="token number">6</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">)</span> <span class="token operator">`canReachIn3`</span> <span class="token punctuation">(</span><span class="token number">6</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">)</span>
<span class="token constant">True</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Yes! How about from&nbsp;<code>(6,2)</code>&nbsp;to&nbsp;<code>(7,3)</code>?</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token punctuation">(</span><span class="token number">6</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">)</span> <span class="token operator">`canReachIn3`</span> <span class="token punctuation">(</span><span class="token number">7</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">)</span>
<span class="token constant">False</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>No! As an exercise, you can change this function so that when you can reach one position from the other, it tells you which moves to take. Later on, we'll see how to modify this function so that we also pass it the number of moves to take instead of that number being hardcoded like it is now.</p></div><div><h2 data-heading="Monad laws" id="Monad_laws" style="display: flex;"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>Monad laws</h2></div><div><p><img alt="the court finds you guilty of peeing all over 
everything" src="http://s3.amazonaws.com/lyah/judgedog.png" referrerpolicy="no-referrer"></p></div><div><p>Just like applicative functors, and functors before them, monads come with a few laws that all monad instances must abide by. Just because something is made an instance of the&nbsp;<code>Monad</code>&nbsp;type class doesn't mean that it's a monad, it just means that it was made an instance of a type class. For a type to truly be a monad, the monad laws must hold for that type. These laws allow us to make reasonable assumptions about the type and its behavior.</p></div><div><p>Haskell allows any type to be an instance of any type class as long as the types check out. It can't check if the monad laws hold for a type though, so if we're making a new instance of the&nbsp;<code>Monad</code>&nbsp;type class, we have to be reasonably sure that all is well with the monad laws for that type. We can rely on the types that come with the standard library to satisfy the laws, but later when we go about making our own monads, we're going to have to manually check the if the laws hold. But don't worry, they're not complicated.</p></div><div><h3 data-heading="Left identity" id="Left_identity" style="display: flex;"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>Left identity</h3></div><div><p>The first monad law states that if we take a value, put it in a default context with&nbsp;<code>return</code>&nbsp;and then feed it to a function by using&nbsp;<code>&gt;&gt;=</code>, it's the same as just taking the value and applying the function to it. To put it formally:</p></div><div><ul class="has-list-bullet">
<li data-line="0"><div class="list-bullet"></div>return x &gt;&gt;= f&nbsp;is the same damn thing as&nbsp;f x</li>
</ul></div><div><p>If you look at monadic values as values with a context and&nbsp;<code>return</code>&nbsp;as taking a value and putting it in a default minimal context that still presents that value as its result, it makes sense, because if that context is really minimal, feeding this monadic value to a function shouldn't be much different than just applying the function to the normal value, and indeed it isn't different at all.</p></div><div><p>For the&nbsp;<code>Maybe</code>&nbsp;monad&nbsp;<code>return</code>&nbsp;is defined as&nbsp;<code>Just</code>. The&nbsp;<code>Maybe</code>&nbsp;monad is all about possible failure, and if we have a value and want to put it in such a context, it makes sense that we treat it as a successful computation because, well, we know what the value is. Here's some&nbsp;<code>return</code>&nbsp;usage with&nbsp;<code>Maybe</code>:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token builtin">return</span> <span class="token number">3</span> <span class="token operator">&gt;&gt;=</span> <span class="token punctuation">(</span><span class="token operator">\</span><span class="token hvariable">x</span> <span class="token operator">-&gt;</span> <span class="token constant">Just</span> <span class="token punctuation">(</span><span class="token hvariable">x</span><span class="token operator">+</span><span class="token number">100000</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token constant">Just</span> <span class="token number">100003</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token punctuation">(</span><span class="token operator">\</span><span class="token hvariable">x</span> <span class="token operator">-&gt;</span> <span class="token constant">Just</span> <span class="token punctuation">(</span><span class="token hvariable">x</span><span class="token operator">+</span><span class="token number">100000</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token number">3</span>
<span class="token constant">Just</span> <span class="token number">100003</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>For the list monad&nbsp;<code>return</code>&nbsp;puts something in a singleton list. The&nbsp;<code>&gt;&gt;=</code>&nbsp;implementation for lists goes over all the values in the list and applies the function to them, but since there's only one value in a singleton list, it's the same as applying the function to that value:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token builtin">return</span> <span class="token string">"WoM"</span> <span class="token operator">&gt;&gt;=</span> <span class="token punctuation">(</span><span class="token operator">\</span><span class="token hvariable">x</span> <span class="token operator">-&gt;</span> <span class="token punctuation">[</span><span class="token hvariable">x</span><span class="token punctuation">,</span><span class="token hvariable">x</span><span class="token punctuation">,</span><span class="token hvariable">x</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
<span class="token punctuation">[</span><span class="token string">"WoM"</span><span class="token punctuation">,</span><span class="token string">"WoM"</span><span class="token punctuation">,</span><span class="token string">"WoM"</span><span class="token punctuation">]</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token punctuation">(</span><span class="token operator">\</span><span class="token hvariable">x</span> <span class="token operator">-&gt;</span> <span class="token punctuation">[</span><span class="token hvariable">x</span><span class="token punctuation">,</span><span class="token hvariable">x</span><span class="token punctuation">,</span><span class="token hvariable">x</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token string">"WoM"</span>
<span class="token punctuation">[</span><span class="token string">"WoM"</span><span class="token punctuation">,</span><span class="token string">"WoM"</span><span class="token punctuation">,</span><span class="token string">"WoM"</span><span class="token punctuation">]</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>We said that for&nbsp;<code>IO</code>, using&nbsp;<code>return</code>&nbsp;makes an I/O action that has no side-effects but just presents a value as its result. So it makes sense that this law holds for&nbsp;<code>IO</code>&nbsp;as well.</p></div><div><h3 data-heading="Right identity" id="Right_identity" style="display: flex;"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>Right identity</h3></div><div><p>The second law states that if we have a monadic value and we use&nbsp;<code>&gt;&gt;=</code>&nbsp;to feed it to&nbsp;<code>return</code>, the result is our original monadic value. Formally:</p></div><div><ul class="has-list-bullet">
<li data-line="0"><div class="list-bullet"></div>m &gt;&gt;= return&nbsp;is no different than just&nbsp;m</li>
</ul></div><div><p>This one might be a bit less obvious than the first one, but let's take a look at why it should hold. When we feed monadic values to functions by using&nbsp;<code>&gt;&gt;=</code>, those functions take normal values and return monadic ones.&nbsp;<code>return</code>&nbsp;is also one such function, if you consider its type. Like we said,&nbsp;<code>return</code>&nbsp;puts a value in a minimal context that still presents that value as its result. This means that, for instance, for&nbsp;<code>Maybe</code>, it doesn't introduce any failure and for lists, it doesn't introduce any extra non-determinism. Here's a test run for a few monads:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token constant">Just</span> <span class="token string">"move on up"</span> <span class="token operator">&gt;&gt;=</span> <span class="token punctuation">(</span><span class="token operator">\</span><span class="token hvariable">x</span> <span class="token operator">-&gt;</span> <span class="token builtin">return</span> <span class="token hvariable">x</span><span class="token punctuation">)</span>
<span class="token constant">Just</span> <span class="token string">"move on up"</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">]</span> <span class="token operator">&gt;&gt;=</span> <span class="token punctuation">(</span><span class="token operator">\</span><span class="token hvariable">x</span> <span class="token operator">-&gt;</span> <span class="token builtin">return</span> <span class="token hvariable">x</span><span class="token punctuation">)</span>
<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">]</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token builtin">putStrLn</span> <span class="token string">"Wah!"</span> <span class="token operator">&gt;&gt;=</span> <span class="token punctuation">(</span><span class="token operator">\</span><span class="token hvariable">x</span> <span class="token operator">-&gt;</span> <span class="token builtin">return</span> <span class="token hvariable">x</span><span class="token punctuation">)</span>
<span class="token constant">Wah</span><span class="token operator">!</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>If we take a closer look at the list example, the implementation for&nbsp;<code>&gt;&gt;=</code>&nbsp;is:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">xs</span> <span class="token operator">&gt;&gt;=</span> <span class="token hvariable">f</span> <span class="token operator">=</span> <span class="token builtin">concat</span> <span class="token punctuation">(</span><span class="token builtin">map</span> <span class="token hvariable">f</span> <span class="token hvariable">xs</span><span class="token punctuation">)</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>So when we feed&nbsp;<code>[1,2,3,4]</code>&nbsp;to&nbsp;<code>return</code>, first&nbsp;<code>return</code>&nbsp;gets mapped over&nbsp;<code>[1,2,3,4]</code>, resulting in&nbsp;<code>[[1],[2],[3],[4]]</code>&nbsp;and then this gets concatenated and we have our original list.</p></div><div><p>Left identity and right identity are basically laws that describe how&nbsp;<code>return</code>&nbsp;should behave. It's an important function for making normal values into monadic ones and it wouldn't be good if the monadic value that it produced did a lot of other stuff.</p></div><div><h3 data-heading="Associativity" id="Associativity" style="display: flex;"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>Associativity</h3></div><div><p>The final monad law says that when we have a chain of monadic function applications with&nbsp;<code>&gt;&gt;=</code>, it shouldn't matter how they're nested. Formally written:</p></div><div><ul class="has-list-bullet">
<li data-line="0"><div class="list-bullet"></div>Doing&nbsp;(m &gt;&gt;= f) &gt;&gt;= g&nbsp;is just like doing&nbsp;m &gt;&gt;= (\x -&gt; f x &gt;&gt;= g)</li>
</ul></div><div><p>Hmmm, now what's going on here? We have one monadic value,&nbsp;<code>m</code>&nbsp;and two monadic functions&nbsp;<code>f</code>&nbsp;and&nbsp;<code>g</code>. When we're doing&nbsp;<code>(m &gt;&gt;= f) &gt;&gt;= g</code>, we're feeding&nbsp;<code>m</code>&nbsp;to&nbsp;<code>f</code>, which results in a monadic value. Then, we feed that monadic value to&nbsp;<code>g</code>. In the expression&nbsp;<code>m &gt;&gt;= (\x -&gt; f x &gt;&gt;= g)</code>, we take a monadic value and we feed it to a function that feeds the result of&nbsp;<code>f x</code>&nbsp;to&nbsp;<code>g</code>. It's not easy to see how those two are equal, so let's take a look at an example that makes this equality a bit clearer.</p></div><div><p>Remember when we had our tightrope walker Pierre walk a rope while birds landed on his balancing pole? To simulate birds landing on his balancing pole, we made a chain of several functions that might produce failure:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token builtin">return</span> <span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">&gt;&gt;=</span> <span class="token hvariable">landRight</span> <span class="token number">2</span> <span class="token operator">&gt;&gt;=</span> <span class="token hvariable">landLeft</span> <span class="token number">2</span> <span class="token operator">&gt;&gt;=</span> <span class="token hvariable">landRight</span> <span class="token number">2</span>
<span class="token constant">Just</span> <span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">)</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>We started with&nbsp;<code>Just (0,0)</code>&nbsp;and then bound that value to the next monadic function,&nbsp;<code>landRight 2</code>. The result of that was another monadic value which got bound into the next monadic function, and so on. If we were to explicitly parenthesize this, we'd write:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token builtin">return</span> <span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">&gt;&gt;=</span> <span class="token hvariable">landRight</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token operator">&gt;&gt;=</span> <span class="token hvariable">landLeft</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token operator">&gt;&gt;=</span> <span class="token hvariable">landRight</span> <span class="token number">2</span>
<span class="token constant">Just</span> <span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">)</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>But we can also write the routine like this:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token builtin">return</span> <span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">&gt;&gt;=</span> <span class="token punctuation">(</span><span class="token operator">\</span><span class="token hvariable">x</span> <span class="token operator">-&gt;</span>
<span class="token hvariable">landRight</span> <span class="token number">2</span> <span class="token hvariable">x</span> <span class="token operator">&gt;&gt;=</span> <span class="token punctuation">(</span><span class="token operator">\</span><span class="token hvariable">y</span> <span class="token operator">-&gt;</span>
<span class="token hvariable">landLeft</span> <span class="token number">2</span> <span class="token hvariable">y</span> <span class="token operator">&gt;&gt;=</span> <span class="token punctuation">(</span><span class="token operator">\</span><span class="token hvariable">z</span> <span class="token operator">-&gt;</span>
<span class="token hvariable">landRight</span> <span class="token number">2</span> <span class="token hvariable">z</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p><code>return (0,0)</code>&nbsp;is the same as&nbsp;<code>Just (0,0)</code>&nbsp;and when we feed it to the lambda, the&nbsp;<code>x</code>&nbsp;becomes&nbsp;<code>(0,0)</code>.&nbsp;<code>landRight</code>&nbsp;takes a number of birds and a pole (a tuple of numbers) and that's what it gets passed. This results in a&nbsp;<code>Just (0,2)</code>&nbsp;and when we feed this to the next lambda,&nbsp;<code>y</code>&nbsp;is&nbsp;<code>(0,2)</code>. This goes on until the final bird landing produces a&nbsp;<code>Just (2,4)</code>, which is indeed the result of the whole expression.</p></div><div><p>So it doesn't matter how you nest feeding values to monadic functions, what matters is their meaning. Here's another way to look at this law: consider composing two functions,&nbsp;<code>f</code>&nbsp;and&nbsp;<code>g</code>. Composing two functions is implemented like so:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token punctuation">(</span><span class="token punctuation">.</span><span class="token punctuation">)</span> <span class="token operator">::</span> <span class="token punctuation">(</span><span class="token hvariable">b</span> <span class="token operator">-&gt;</span> <span class="token hvariable">c</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token punctuation">(</span><span class="token hvariable">a</span> <span class="token operator">-&gt;</span> <span class="token hvariable">b</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token punctuation">(</span><span class="token hvariable">a</span> <span class="token operator">-&gt;</span> <span class="token hvariable">c</span><span class="token punctuation">)</span>
<span class="token hvariable">f</span> <span class="token operator">.</span> <span class="token hvariable">g</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token operator">\</span><span class="token hvariable">x</span> <span class="token operator">-&gt;</span> <span class="token hvariable">f</span> <span class="token punctuation">(</span><span class="token hvariable">g</span> <span class="token hvariable">x</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>If the type of&nbsp;<code>g</code>&nbsp;is&nbsp;<code>a -&gt; b</code>&nbsp;and the type of&nbsp;<code>f</code>&nbsp;is&nbsp;<code>b -&gt; c</code>, we arrange them into a new function which has a type of&nbsp;<code>a -&gt; c</code>, so that its parameter is passed between those functions. Now what if those two functions were monadic, that is, what if the values they returned were monadic values? If we had a function of type&nbsp;<code>a -&gt; m b</code>, we couldn't just pass its result to a function of type&nbsp;<code>b -&gt; m c</code>, because that function accepts a normal&nbsp;<code>b</code>, not a monadic one. We could however, use&nbsp;<code>&gt;&gt;=</code>&nbsp;to make that happen. So by using&nbsp;<code>&gt;&gt;=</code>, we can compose two monadic functions:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token punctuation">(</span><span class="token operator">&lt;=&lt;</span><span class="token punctuation">)</span> <span class="token operator">::</span> <span class="token punctuation">(</span><span class="token constant">Monad</span> <span class="token hvariable">m</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">(</span><span class="token hvariable">b</span> <span class="token operator">-&gt;</span> <span class="token hvariable">m</span> <span class="token hvariable">c</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token punctuation">(</span><span class="token hvariable">a</span> <span class="token operator">-&gt;</span> <span class="token hvariable">m</span> <span class="token hvariable">b</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token punctuation">(</span><span class="token hvariable">a</span> <span class="token operator">-&gt;</span> <span class="token hvariable">m</span> <span class="token hvariable">c</span><span class="token punctuation">)</span>
<span class="token hvariable">f</span> <span class="token operator">&lt;=&lt;</span> <span class="token hvariable">g</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token operator">\</span><span class="token hvariable">x</span> <span class="token operator">-&gt;</span> <span class="token hvariable">g</span> <span class="token hvariable">x</span> <span class="token operator">&gt;&gt;=</span> <span class="token hvariable">f</span><span class="token punctuation">)</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>So now we can compose two monadic functions:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token keyword">let</span> <span class="token hvariable">f</span> <span class="token hvariable">x</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token hvariable">x</span><span class="token punctuation">,</span><span class="token operator">-</span><span class="token hvariable">x</span><span class="token punctuation">]</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token keyword">let</span> <span class="token hvariable">g</span> <span class="token hvariable">x</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token hvariable">x</span><span class="token operator">*</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token hvariable">x</span><span class="token operator">*</span><span class="token number">2</span><span class="token punctuation">]</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token keyword">let</span> <span class="token hvariable">h</span> <span class="token operator">=</span> <span class="token hvariable">f</span> <span class="token operator">&lt;=&lt;</span> <span class="token hvariable">g</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token hvariable">h</span> <span class="token number">3</span>
<span class="token punctuation">[</span><span class="token number">9</span><span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">9</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">6</span><span class="token punctuation">]</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Cool. So what does that have to do with the associativity law? Well, when we look at the law as a law of compositions, it states that&nbsp;<code>f &lt;=&lt; (g &lt;=&lt; h)</code>&nbsp;should be the same as&nbsp;<code>(f &lt;=&lt; g) &lt;=&lt; h</code>. This is just another way of saying that for monads, the nesting of operations shouldn't matter.</p></div><div><p>If we translate the first two laws to use&nbsp;<code>&lt;=&lt;</code>, then the left identity law states that for every monadic function&nbsp;<code>f</code>,&nbsp;<code>f &lt;=&lt; return</code>&nbsp;is the same as writing just&nbsp;<code>f</code>&nbsp;and the right identity law says that&nbsp;<code>return &lt;=&lt; f</code>&nbsp;is also no different from&nbsp;<code>f</code>.</p></div><div><p>This is very similar to how if&nbsp;<code>f</code>&nbsp;is a normal function,&nbsp;<code>(f . g) . h</code>&nbsp;is the same as&nbsp;<code>f . (g . h)</code>,&nbsp;<code>f . id</code>&nbsp;is always the same as&nbsp;<code>f</code>&nbsp;and&nbsp;<code>id . f</code>&nbsp;is also just&nbsp;<code>f</code>.</p></div><div><p>In this chapter, we took a look at the basics of monads and learned how the&nbsp;<code>Maybe</code>&nbsp;monad and the list monad work. In the next chapter, we'll take a look at a whole bunch of other cool monads and we'll also learn how to make our own.</p></div><div class="mod-footer"></div></div></div></div><div class="sidebar-right sidebar"><div class="sidebar-content"><span class="sidebar-section-header">Interactive Graph</span><div class="graph-view-placeholder">
		<div class="graph-view-container">
			<div class="graph-icon graph-expand" role="button" aria-label="Expand" data-tooltip-position="top"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon lucide-arrow-up-right"><line x1="7" y1="17" x2="17" y2="7"></line><polyline points="7 7 17 7 17 17"></polyline></svg></div>
			<canvas id="graph-canvas" width="512px" height="512px"></canvas>
		</div>
		</div><div class="tree-container outline-tree" data-depth="0"><div class="tree-header"><span class="sidebar-section-header">Table Of Contents</span><button class="clickable-icon collapse-tree-button"><iconify-icon icon="ph:arrows-in-line-horizontal-bold" width="18px" height="18px" rotate="90deg" color="currentColor"></iconify-icon></button></div><div class="tree-scroll-area"><div class="tree-item mod-tree-heading" data-depth="1"><div class="tree-item-contents"><a class="tree-item-link" href="#A_Fistful_of_Monads"><span class="tree-item-title">A Fistful of Monads</span></a></div><div class="tree-item-children"><div class="tree-item mod-tree-heading" data-depth="2"><div class="tree-item-contents"><a class="tree-item-link" href="#Getting_our_feet_wet_with_Maybe"><span class="tree-item-title">Getting our feet wet with Maybe</span></a></div><div class="tree-item-children"></div></div><div class="tree-item mod-tree-heading" data-depth="2"><div class="tree-item-contents"><a class="tree-item-link" href="#The_Monad_type_class"><span class="tree-item-title">The Monad type class</span></a></div><div class="tree-item-children"></div></div><div class="tree-item mod-tree-heading" data-depth="2"><div class="tree-item-contents"><a class="tree-item-link" href="#Walk_the_line"><span class="tree-item-title">Walk the line</span></a></div><div class="tree-item-children"></div></div><div class="tree-item mod-tree-heading" data-depth="2"><div class="tree-item-contents"><a class="tree-item-link" href="#do_notation"><span class="tree-item-title">do notation</span></a></div><div class="tree-item-children"></div></div><div class="tree-item mod-tree-heading mod-collapsible" data-depth="2"><div class="tree-item-contents"><div class="tree-item-icon collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div><a class="tree-item-link" href="#The_list_monad"><span class="tree-item-title">The list monad</span></a></div><div class="tree-item-children"><div class="tree-item mod-tree-heading" data-depth="3"><div class="tree-item-contents"><a class="tree-item-link" href="#A_knight's_quest"><span class="tree-item-title">A knight's quest</span></a></div><div class="tree-item-children"></div></div></div></div><div class="tree-item mod-tree-heading mod-collapsible" data-depth="2"><div class="tree-item-contents"><div class="tree-item-icon collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div><a class="tree-item-link" href="#Monad_laws"><span class="tree-item-title">Monad laws</span></a></div><div class="tree-item-children"><div class="tree-item mod-tree-heading" data-depth="3"><div class="tree-item-contents"><a class="tree-item-link" href="#Left_identity"><span class="tree-item-title">Left identity</span></a></div><div class="tree-item-children"></div></div><div class="tree-item mod-tree-heading" data-depth="3"><div class="tree-item-contents"><a class="tree-item-link" href="#Right_identity"><span class="tree-item-title">Right identity</span></a></div><div class="tree-item-children"></div></div><div class="tree-item mod-tree-heading" data-depth="3"><div class="tree-item-contents"><a class="tree-item-link" href="#Associativity"><span class="tree-item-title">Associativity</span></a></div><div class="tree-item-children"></div></div></div></div></div></div></div></div></div></div></div></body></html>