<!DOCTYPE html>
<html><head>
			
		<title>Chapter 8 Making Our Own Types and Typeclasses</title>
		<base href="../../../">
		<meta id="root-path" root-path="../../../">

		<link rel="icon" sizes="96x96" href="https://publish-01.obsidian.md/access/f786db9fac45774fa4f0d8112e232d67/favicon-96x96.png">
		<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes, minimum-scale=1.0, maximum-scale=5.0">
		<meta charset="UTF-8">
		<script src="https://code.iconify.design/iconify-icon/1.0.3/iconify-icon.min.js"></script>

			<link rel="stylesheet" href="lib/styles/obsidian-styles.css">
			<link rel="stylesheet" href="lib/styles/theme.css">
			<link rel="stylesheet" href="lib/styles/plugin-styles.css">
			<link rel="stylesheet" href="lib/styles/snippets.css">
			<style>  </style>

			
			<!-- Graph View Data -->
			<script>
			let nodes=
{"nodeCount":22,"linkCount":21,"radii":[7,5.346938775510203,4.855867346938775,4.301020408163265,3.6823979591836737,3.6823979591836737,3.6823979591836737,3.6823979591836737,3.6823979591836737,3.6823979591836737,3.6823979591836737,3.6823979591836737,3.6823979591836737,3.6823979591836737,3.6823979591836737,3.6823979591836737,3.6823979591836737,3.6823979591836737,3.6823979591836737,3.6823979591836737,3.6823979591836737,3.6823979591836737],"labels":["Table Of Content","Отчеты","README","README","О Haskell по-человечески (Итого)","Полезные ресурсы","О Haskell по-человечески (Оригинал)","Оглавление","Chapter 13 For a Few Monads More","Chapter 12 A Fistful of Monads","Chapter 11 Functors, Applicative Functors and Monoids","Chapter 10 Functionally Solving Problems","Chapter 9 Input and Output","Chapter 8 Making Our Own Types and Typeclasses","Chapter 7 Modules","Chapter 6 Higher order functions","Chapter 5 Recursion","Chapter 4 Syntax in Functions","Chapter 14 Zippers","Chapter 1 Introduction","Chapter 2 Starting Out","Chapter 3 Types and Typeclasses"],"paths":["курсы/learn-you-a-haskell-for-great-good!/en/table-of-content.html","отчеты.html","курсы/learn-you-a-haskell-for-great-good!/readme.html","readme.html","мои-решения/о-haskell-по-человечески/о-haskell-по-человечески-(итого).html","полезные-ресурсы.html","курсы/о-haskell-по-человечески/о-haskell-по-человечески-(оригинал).html","курсы/learn-you-a-haskell-for-great-good!/ru/оглавление.html","курсы/learn-you-a-haskell-for-great-good!/en/chapter-13-for-a-few-monads-more.html","курсы/learn-you-a-haskell-for-great-good!/en/chapter-12-a-fistful-of-monads.html","курсы/learn-you-a-haskell-for-great-good!/en/chapter-11-functors,-applicative-functors-and-monoids.html","курсы/learn-you-a-haskell-for-great-good!/en/chapter-10-functionally-solving-problems.html","курсы/learn-you-a-haskell-for-great-good!/en/chapter-9-input-and-output.html","курсы/learn-you-a-haskell-for-great-good!/en/chapter-8-making-our-own-types-and-typeclasses.html","курсы/learn-you-a-haskell-for-great-good!/en/chapter-7-modules.html","курсы/learn-you-a-haskell-for-great-good!/en/chapter-6-higher-order-functions.html","курсы/learn-you-a-haskell-for-great-good!/en/chapter-5-recursion.html","курсы/learn-you-a-haskell-for-great-good!/en/chapter-4-syntax-in-functions.html","курсы/learn-you-a-haskell-for-great-good!/en/chapter-14-zippers.html","курсы/learn-you-a-haskell-for-great-good!/en/chapter-1-introduction.html","курсы/learn-you-a-haskell-for-great-good!/en/chapter-2-starting-out.html","курсы/learn-you-a-haskell-for-great-good!/en/chapter-3-types-and-typeclasses.html"],"linkSources":[3,3,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,2],"linkTargets":[5,1,6,4,2,19,20,21,17,16,15,14,13,12,11,10,9,8,18,0,7]};
			let attractionForce = 1;
			let linkLength = 10;
			let repulsionForce = 150;
			let centralForce = 3;
			let edgePruning = 100;
			</script>
			
<script type="module" src="lib/scripts/graph_view.js"></script>

<script src="lib/scripts/graph_wasm.js"></script>

<script src="lib/scripts/tinycolor.js"></script>

<script src="https://cdnjs.cloudflare.com/ajax/libs/pixi.js/7.2.4/pixi.min.js" integrity="sha512-Ch/O6kL8BqUwAfCF7Ie5SX1Hin+BJgYH4pNjRqXdTEqMsis1TUYg+j6nnI9uduPjGaj7DN4UKCZgpvoExt6dkw==" crossorigin="anonymous" referrerpolicy="no-referrer"></script>

<script src="lib/scripts/webpage.js"></script>

			</head><body class="theme-dark mod-windows is-frameless is-maximized is-hidden-frameless obsidian-app show-inline-title show-view-header" style="--zoom-factor:1; --font-text-size:16px; --line-width:100%; --line-width-adaptive:100%; --file-line-width:100%; --content-width:500em; --sidebar-width:25em; --collapse-arrow-size:0.4em; --tree-horizontal-spacing:1em; --tree-vertical-spacing:0.5em; --sidebar-margin:12px;"><div class="webpage-container"><div class="sidebar-left sidebar"><div class="sidebar-content"><div><label class="theme-toggle-container" for="theme_toggle"><input class="theme-toggle-input" type="checkbox" id="theme_toggle"><div class="toggle-background"></div></label></div><div class="tree-container file-tree mod-nav-indicator" data-depth="0"><div class="tree-header"><span class="sidebar-section-header">learn-haskell-valut</span><button class="clickable-icon collapse-tree-button is-collapsed"><iconify-icon icon="ph:arrows-in-line-horizontal-bold" width="18px" height="18px" rotate="90deg" color="currentColor"></iconify-icon></button></div><div class="tree-scroll-area"><div class="tree-item mod-tree-folder mod-collapsible is-collapsed" data-depth="1"><div class="tree-item-contents"><div class="tree-item-icon collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div><a class="tree-item-link" href="курсы"><span class="tree-item-title">Курсы</span></a></div><div class="tree-item-children"><div class="tree-item mod-tree-folder mod-collapsible is-collapsed" data-depth="2"><div class="tree-item-contents"><div class="tree-item-icon collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div><a class="tree-item-link" href="курсы/о-haskell-по-человечески"><span class="tree-item-title">О Haskell по-человечески</span></a></div><div class="tree-item-children"><div class="tree-item mod-tree-file" data-depth="3"><div class="tree-item-contents"><a class="tree-item-link" href="курсы/о-haskell-по-человечески/о-haskell-по-человечески-(оригинал).html"><span class="tree-item-title">О Haskell по-человечески (Оригинал)</span></a></div><div class="tree-item-children"></div></div></div></div><div class="tree-item mod-tree-folder mod-collapsible is-collapsed" data-depth="2"><div class="tree-item-contents"><div class="tree-item-icon collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div><a class="tree-item-link" href="курсы/learn-you-a-haskell-for-great-good!"><span class="tree-item-title">Learn You a Haskell for Great Good!</span></a></div><div class="tree-item-children"><div class="tree-item mod-tree-folder mod-collapsible is-collapsed" data-depth="3"><div class="tree-item-contents"><div class="tree-item-icon collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div><a class="tree-item-link" href="курсы/learn-you-a-haskell-for-great-good!/en"><span class="tree-item-title">en</span></a></div><div class="tree-item-children"><div class="tree-item mod-tree-file" data-depth="4"><div class="tree-item-contents"><a class="tree-item-link" href="курсы/learn-you-a-haskell-for-great-good!/en/chapter-1-introduction.html"><span class="tree-item-title">Chapter 1 Introduction</span></a></div><div class="tree-item-children"></div></div><div class="tree-item mod-tree-file" data-depth="4"><div class="tree-item-contents"><a class="tree-item-link" href="курсы/learn-you-a-haskell-for-great-good!/en/chapter-10-functionally-solving-problems.html"><span class="tree-item-title">Chapter 10 Functionally Solving Problems</span></a></div><div class="tree-item-children"></div></div><div class="tree-item mod-tree-file" data-depth="4"><div class="tree-item-contents"><a class="tree-item-link" href="курсы/learn-you-a-haskell-for-great-good!/en/chapter-11-functors,-applicative-functors-and-monoids.html"><span class="tree-item-title">Chapter 11 Functors, Applicative Functors and Monoids</span></a></div><div class="tree-item-children"></div></div><div class="tree-item mod-tree-file" data-depth="4"><div class="tree-item-contents"><a class="tree-item-link" href="курсы/learn-you-a-haskell-for-great-good!/en/chapter-12-a-fistful-of-monads.html"><span class="tree-item-title">Chapter 12 A Fistful of Monads</span></a></div><div class="tree-item-children"></div></div><div class="tree-item mod-tree-file" data-depth="4"><div class="tree-item-contents"><a class="tree-item-link" href="курсы/learn-you-a-haskell-for-great-good!/en/chapter-13-for-a-few-monads-more.html"><span class="tree-item-title">Chapter 13 For a Few Monads More</span></a></div><div class="tree-item-children"></div></div><div class="tree-item mod-tree-file" data-depth="4"><div class="tree-item-contents"><a class="tree-item-link" href="курсы/learn-you-a-haskell-for-great-good!/en/chapter-14-zippers.html"><span class="tree-item-title">Chapter 14 Zippers</span></a></div><div class="tree-item-children"></div></div><div class="tree-item mod-tree-file" data-depth="4"><div class="tree-item-contents"><a class="tree-item-link" href="курсы/learn-you-a-haskell-for-great-good!/en/chapter-2-starting-out.html"><span class="tree-item-title">Chapter 2 Starting Out</span></a></div><div class="tree-item-children"></div></div><div class="tree-item mod-tree-file" data-depth="4"><div class="tree-item-contents"><a class="tree-item-link" href="курсы/learn-you-a-haskell-for-great-good!/en/chapter-3-types-and-typeclasses.html"><span class="tree-item-title">Chapter 3 Types and Typeclasses</span></a></div><div class="tree-item-children"></div></div><div class="tree-item mod-tree-file" data-depth="4"><div class="tree-item-contents"><a class="tree-item-link" href="курсы/learn-you-a-haskell-for-great-good!/en/chapter-4-syntax-in-functions.html"><span class="tree-item-title">Chapter 4 Syntax in Functions</span></a></div><div class="tree-item-children"></div></div><div class="tree-item mod-tree-file" data-depth="4"><div class="tree-item-contents"><a class="tree-item-link" href="курсы/learn-you-a-haskell-for-great-good!/en/chapter-5-recursion.html"><span class="tree-item-title">Chapter 5 Recursion</span></a></div><div class="tree-item-children"></div></div><div class="tree-item mod-tree-file" data-depth="4"><div class="tree-item-contents"><a class="tree-item-link" href="курсы/learn-you-a-haskell-for-great-good!/en/chapter-6-higher-order-functions.html"><span class="tree-item-title">Chapter 6 Higher order functions</span></a></div><div class="tree-item-children"></div></div><div class="tree-item mod-tree-file" data-depth="4"><div class="tree-item-contents"><a class="tree-item-link" href="курсы/learn-you-a-haskell-for-great-good!/en/chapter-7-modules.html"><span class="tree-item-title">Chapter 7 Modules</span></a></div><div class="tree-item-children"></div></div><div class="tree-item mod-tree-file" data-depth="4"><div class="tree-item-contents"><a class="tree-item-link" href="курсы/learn-you-a-haskell-for-great-good!/en/chapter-8-making-our-own-types-and-typeclasses.html"><span class="tree-item-title">Chapter 8 Making Our Own Types and Typeclasses</span></a></div><div class="tree-item-children"></div></div><div class="tree-item mod-tree-file" data-depth="4"><div class="tree-item-contents"><a class="tree-item-link" href="курсы/learn-you-a-haskell-for-great-good!/en/chapter-9-input-and-output.html"><span class="tree-item-title">Chapter 9 Input and Output</span></a></div><div class="tree-item-children"></div></div><div class="tree-item mod-tree-file" data-depth="4"><div class="tree-item-contents"><a class="tree-item-link" href="курсы/learn-you-a-haskell-for-great-good!/en/table-of-content.html"><span class="tree-item-title">Table Of Content</span></a></div><div class="tree-item-children"></div></div></div></div><div class="tree-item mod-tree-folder mod-collapsible is-collapsed" data-depth="3"><div class="tree-item-contents"><div class="tree-item-icon collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div><a class="tree-item-link" href="курсы/learn-you-a-haskell-for-great-good!/ru"><span class="tree-item-title">ru</span></a></div><div class="tree-item-children"><div class="tree-item mod-tree-file" data-depth="4"><div class="tree-item-contents"><a class="tree-item-link" href="курсы/learn-you-a-haskell-for-great-good!/ru/оглавление.html"><span class="tree-item-title">Оглавление</span></a></div><div class="tree-item-children"></div></div></div></div><div class="tree-item mod-tree-file" data-depth="3"><div class="tree-item-contents"><a class="tree-item-link" href="курсы/learn-you-a-haskell-for-great-good!/readme.html"><span class="tree-item-title">README</span></a></div><div class="tree-item-children"></div></div></div></div></div></div><div class="tree-item mod-tree-folder mod-collapsible is-collapsed" data-depth="1"><div class="tree-item-contents"><div class="tree-item-icon collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div><a class="tree-item-link" href="мои-решения"><span class="tree-item-title">Мои решения</span></a></div><div class="tree-item-children"><div class="tree-item mod-tree-folder mod-collapsible is-collapsed" data-depth="2"><div class="tree-item-contents"><div class="tree-item-icon collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div><a class="tree-item-link" href="мои-решения/о-haskell-по-человечески"><span class="tree-item-title">О Haskell по-человечески</span></a></div><div class="tree-item-children"><div class="tree-item mod-tree-file" data-depth="3"><div class="tree-item-contents"><a class="tree-item-link" href="мои-решения/о-haskell-по-человечески/о-haskell-по-человечески-(итого).html"><span class="tree-item-title">О Haskell по-человечески (Итого)</span></a></div><div class="tree-item-children"></div></div></div></div></div></div><div class="tree-item mod-tree-file" data-depth="1"><div class="tree-item-contents"><a class="tree-item-link" href="отчеты.html"><span class="tree-item-title">Отчеты</span></a></div><div class="tree-item-children"></div></div><div class="tree-item mod-tree-file" data-depth="1"><div class="tree-item-contents"><a class="tree-item-link" href="полезные-ресурсы.html"><span class="tree-item-title">Полезные ресурсы</span></a></div><div class="tree-item-children"></div></div><div class="tree-item mod-tree-file" data-depth="1"><div class="tree-item-contents"><a class="tree-item-link" href="readme.html"><span class="tree-item-title">README</span></a></div><div class="tree-item-children"></div></div></div></div></div></div><div class="document-container"><div class="markdown-preview-view markdown-rendered node-insert-event allow-fold-headings show-indentation-guide allow-fold-lists show-frontmatter" style="tab-size: 4;" tabindex="-1"><style id="MJX-CHTML-styles"></style><div class="markdown-preview-sizer markdown-preview-section" style="padding-bottom: ; padding-top: var(--file-margins); padding-right: var(--file-margins); padding-left: var(--file-margins); width: 100%; position: absolute;"><div class="markdown-preview-pusher" style="width: 1px; height: 0.1px; margin-bottom: 0px;"></div><div class="mod-header"></div><div><h1 data-heading="Making Our Own Types and Typeclasses" id="Making_Our_Own_Types_and_Typeclasses">Making Our Own Types and Typeclasses</h1></div><div><p>In the previous chapters, we covered some existing Haskell types and typeclasses. In this chapter, we'll learn how to make our own and how to put them to work!</p></div><div><h2 data-heading="Algebraic data types intro" id="Algebraic_data_types_intro" style="display: flex;"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>Algebraic data types intro</h2></div><div><p>So far, we've run into a lot of data types.&nbsp;<code>Bool</code>,&nbsp;<code>Int</code>,&nbsp;<code>Char</code>,&nbsp;<code>Maybe</code>, etc. But how do we make our own? Well, one way is to use the&nbsp;<strong>data</strong>&nbsp;keyword to define a type. Let's see how the&nbsp;<code>Bool</code>&nbsp;type is defined in the standard library.</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token keyword">data</span> <span class="token constant">Bool</span> <span class="token operator">=</span> <span class="token constant">False</span> <span class="token operator">|</span> <span class="token constant">True</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p><code>data</code>&nbsp;means that we're defining a new data type. The part before the&nbsp;<code>=</code>&nbsp;denotes the type, which is&nbsp;<code>Bool</code>. The parts after the&nbsp;<code>=</code>&nbsp;are&nbsp;<strong>value constructors</strong>. They specify the different values that this type can have. The&nbsp;<code>|</code>&nbsp;is read as&nbsp;<em>or</em>. So we can read this as: the&nbsp;<code>Bool</code>&nbsp;type can have a value of&nbsp;<code>True</code>&nbsp;or&nbsp;<code>False</code>. Both the type name and the value constructors have to be capital cased.</p></div><div><p>In a similar fashion, we can think of the&nbsp;<code>Int</code>&nbsp;type as being defined like this:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token keyword">data</span> <span class="token constant">Int</span> <span class="token operator">=</span> <span class="token operator">-</span><span class="token number">2147483648</span> <span class="token operator">|</span> <span class="token operator">-</span><span class="token number">2147483647</span> <span class="token operator">|</span> <span class="token operator">...</span> <span class="token operator">|</span> <span class="token operator">-</span><span class="token number">1</span> <span class="token operator">|</span> <span class="token number">0</span> <span class="token operator">|</span> <span class="token number">1</span> <span class="token operator">|</span> <span class="token number">2</span> <span class="token operator">|</span> <span class="token operator">...</span> <span class="token operator">|</span> <span class="token number">2147483647</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p><img alt="caveman" src="http://s3.amazonaws.com/lyah/caveman.png" referrerpolicy="no-referrer"></p></div><div><p>The first and last value constructors are the minimum and maximum possible values of&nbsp;<code>Int</code>. It's not actually defined like this, the ellipses are here because we omitted a heapload of numbers, so this is just for illustrative purposes.</p></div><div><p>Now, let's think about how we would represent a shape in Haskell. One way would be to use tuples. A circle could be denoted as&nbsp;<code>(43.1, 55.0, 10.4)</code>&nbsp;where the first and second fields are the coordinates of the circle's center and the third field is the radius. Sounds OK, but those could also represent a 3D vector or anything else. A better solution would be to make our own type to represent a shape. Let's say that a shape can be a circle or a rectangle. Here it is:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token keyword">data</span> <span class="token constant">Shape</span> <span class="token operator">=</span> <span class="token constant">Circle</span> <span class="token constant">Float</span> <span class="token constant">Float</span> <span class="token constant">Float</span> <span class="token operator">|</span> <span class="token constant">Rectangle</span> <span class="token constant">Float</span> <span class="token constant">Float</span> <span class="token constant">Float</span> <span class="token constant">Float</span> 
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Now what's this? Think of it like this. The&nbsp;<code>Circle</code>&nbsp;value constructor has three fields, which take floats. So when we write a value constructor, we can optionally add some types after it and those types define the values it will contain. Here, the first two fields are the coordinates of its center, the third one its radius. The&nbsp;<code>Rectangle</code>&nbsp;value constructor has four fields which accept floats. The first two are the coordinates to its upper left corner and the second two are coordinates to its lower right one.</p></div><div><p>Now when I say fields, I actually mean parameters. Value constructors are actually functions that ultimately return a value of a data type. Let's take a look at the type signatures for these two value constructors.</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token operator">:</span><span class="token hvariable">t</span> <span class="token constant">Circle</span>
<span class="token constant">Circle</span> <span class="token operator">::</span> <span class="token constant">Float</span> <span class="token operator">-&gt;</span> <span class="token constant">Float</span> <span class="token operator">-&gt;</span> <span class="token constant">Float</span> <span class="token operator">-&gt;</span> <span class="token constant">Shape</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token operator">:</span><span class="token hvariable">t</span> <span class="token constant">Rectangle</span>
<span class="token constant">Rectangle</span> <span class="token operator">::</span> <span class="token constant">Float</span> <span class="token operator">-&gt;</span> <span class="token constant">Float</span> <span class="token operator">-&gt;</span> <span class="token constant">Float</span> <span class="token operator">-&gt;</span> <span class="token constant">Float</span> <span class="token operator">-&gt;</span> <span class="token constant">Shape</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Cool, so value constructors are functions like everything else. Who would have thought? Let's make a function that takes a shape and returns its surface.</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">surface</span> <span class="token operator">::</span> <span class="token constant">Shape</span> <span class="token operator">-&gt;</span> <span class="token constant">Float</span>
<span class="token hvariable">surface</span> <span class="token punctuation">(</span><span class="token constant">Circle</span> <span class="token hvariable">_</span> <span class="token hvariable">_</span> <span class="token hvariable">r</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token builtin">pi</span> <span class="token operator">*</span> <span class="token hvariable">r</span> <span class="token operator">^</span> <span class="token number">2</span>
<span class="token hvariable">surface</span> <span class="token punctuation">(</span><span class="token constant">Rectangle</span> <span class="token hvariable">x1</span> <span class="token hvariable">y1</span> <span class="token hvariable">x2</span> <span class="token hvariable">y2</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token builtin">abs</span> <span class="token operator">$</span> <span class="token hvariable">x2</span> <span class="token operator">-</span> <span class="token hvariable">x1</span><span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token punctuation">(</span><span class="token builtin">abs</span> <span class="token operator">$</span> <span class="token hvariable">y2</span> <span class="token operator">-</span> <span class="token hvariable">y1</span><span class="token punctuation">)</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>The first notable thing here is the type declaration. It says that the function takes a shape and returns a float. We couldn't write a type declaration of&nbsp;<code>Circle -&gt; Float</code>&nbsp;because&nbsp;<code>Circle</code>&nbsp;is not a type,&nbsp;<code>Shape</code>&nbsp;is. Just like we can't write a function with a type declaration of&nbsp;<code>True -&gt; Int</code>. The next thing we notice here is that we can pattern match against constructors. We pattern matched against constructors before (all the time actually) when we pattern matched against values like&nbsp;<code>[]</code>&nbsp;or&nbsp;<code>False</code>&nbsp;or&nbsp;<code>5</code>, only those values didn't have any fields. We just write a constructor and then bind its fields to names. Because we're interested in the radius, we don't actually care about the first two fields, which tell us where the circle is.</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token hvariable">surface</span> <span class="token operator">$</span> <span class="token constant">Circle</span> <span class="token number">10</span> <span class="token number">20</span> <span class="token number">10</span>
<span class="token number">314.15927</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token hvariable">surface</span> <span class="token operator">$</span> <span class="token constant">Rectangle</span> <span class="token number">0</span> <span class="token number">0</span> <span class="token number">100</span> <span class="token number">100</span>
<span class="token number">10000.0</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Yay, it works! But if we try to just print out&nbsp;<code>Circle 10 20 5</code>&nbsp;in the prompt, we'll get an error. That's because Haskell doesn't know how to display our data type as a string (yet). Remember, when we try to print a value out in the prompt, Haskell first runs the&nbsp;<code>show</code>&nbsp;function to get the string representation of our value and then it prints that out to the terminal. To make our&nbsp;<code>Shape</code>&nbsp;type part of the&nbsp;<code>Show</code>&nbsp;typeclass, we modify it like this:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token keyword">data</span> <span class="token constant">Shape</span> <span class="token operator">=</span> <span class="token constant">Circle</span> <span class="token constant">Float</span> <span class="token constant">Float</span> <span class="token constant">Float</span> <span class="token operator">|</span> <span class="token constant">Rectangle</span> <span class="token constant">Float</span> <span class="token constant">Float</span> <span class="token constant">Float</span> <span class="token constant">Float</span> <span class="token keyword">deriving</span> <span class="token punctuation">(</span><span class="token constant">Show</span><span class="token punctuation">)</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>We won't concern ourselves with deriving too much for now. Let's just say that if we add&nbsp;<code>deriving (Show)</code>&nbsp;at the end of a&nbsp;<em>data</em>&nbsp;declaration, Haskell automagically makes that type part of the&nbsp;<code>Show</code>&nbsp;typeclass. So now, we can do this:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token constant">Circle</span> <span class="token number">10</span> <span class="token number">20</span> <span class="token number">5</span>
<span class="token constant">Circle</span> <span class="token number">10.0</span> <span class="token number">20.0</span> <span class="token number">5.0</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token constant">Rectangle</span> <span class="token number">50</span> <span class="token number">230</span> <span class="token number">60</span> <span class="token number">90</span>
<span class="token constant">Rectangle</span> <span class="token number">50.0</span> <span class="token number">230.0</span> <span class="token number">60.0</span> <span class="token number">90.0</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Value constructors are functions, so we can map them and partially apply them and everything. If we want a list of concentric circles with different radii, we can do this.</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token builtin">map</span> <span class="token punctuation">(</span><span class="token constant">Circle</span> <span class="token number">10</span> <span class="token number">20</span><span class="token punctuation">)</span> <span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">]</span>
<span class="token punctuation">[</span><span class="token constant">Circle</span> <span class="token number">10.0</span> <span class="token number">20.0</span> <span class="token number">4.0</span><span class="token punctuation">,</span><span class="token constant">Circle</span> <span class="token number">10.0</span> <span class="token number">20.0</span> <span class="token number">5.0</span><span class="token punctuation">,</span><span class="token constant">Circle</span> <span class="token number">10.0</span> <span class="token number">20.0</span> <span class="token number">6.0</span><span class="token punctuation">,</span><span class="token constant">Circle</span> <span class="token number">10.0</span> <span class="token number">20.0</span> <span class="token number">6.0</span><span class="token punctuation">]</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Our data type is good, although it could be better. Let's make an intermediate data type that defines a point in two-dimensional space. Then we can use that to make our shapes more understandable.</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token keyword">data</span> <span class="token constant">Point</span> <span class="token operator">=</span> <span class="token constant">Point</span> <span class="token constant">Float</span> <span class="token constant">Float</span> <span class="token keyword">deriving</span> <span class="token punctuation">(</span><span class="token constant">Show</span><span class="token punctuation">)</span>
<span class="token keyword">data</span> <span class="token constant">Shape</span> <span class="token operator">=</span> <span class="token constant">Circle</span> <span class="token constant">Point</span> <span class="token constant">Float</span> <span class="token operator">|</span> <span class="token constant">Rectangle</span> <span class="token constant">Point</span> <span class="token constant">Point</span> <span class="token keyword">deriving</span> <span class="token punctuation">(</span><span class="token constant">Show</span><span class="token punctuation">)</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Notice that when defining a point, we used the same name for the data type and the value constructor. This has no special meaning, although it's common to use the same name as the type if there's only one value constructor. So now the&nbsp;<code>Circle</code>&nbsp;has two fields, one is of type&nbsp;<code>Point</code>&nbsp;and the other of type&nbsp;<code>Float</code>. This makes it easier to understand what's what. Same goes for the rectangle. We have to adjust our&nbsp;<code>surface</code>&nbsp;function to reflect these changes.</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">surface</span> <span class="token operator">::</span> <span class="token constant">Shape</span> <span class="token operator">-&gt;</span> <span class="token constant">Float</span>
<span class="token hvariable">surface</span> <span class="token punctuation">(</span><span class="token constant">Circle</span> <span class="token hvariable">_</span> <span class="token hvariable">r</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token builtin">pi</span> <span class="token operator">*</span> <span class="token hvariable">r</span> <span class="token operator">^</span> <span class="token number">2</span>
<span class="token hvariable">surface</span> <span class="token punctuation">(</span><span class="token constant">Rectangle</span> <span class="token punctuation">(</span><span class="token constant">Point</span> <span class="token hvariable">x1</span> <span class="token hvariable">y1</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token constant">Point</span> <span class="token hvariable">x2</span> <span class="token hvariable">y2</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token builtin">abs</span> <span class="token operator">$</span> <span class="token hvariable">x2</span> <span class="token operator">-</span> <span class="token hvariable">x1</span><span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token punctuation">(</span><span class="token builtin">abs</span> <span class="token operator">$</span> <span class="token hvariable">y2</span> <span class="token operator">-</span> <span class="token hvariable">y1</span><span class="token punctuation">)</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>The only thing we had to change were the patterns. We disregarded the whole point in the circle pattern. In the rectangle pattern, we just used a nested pattern matching to get the fields of the points. If we wanted to reference the points themselves for some reason, we could have used as-patterns.</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token hvariable">surface</span> <span class="token punctuation">(</span><span class="token constant">Rectangle</span> <span class="token punctuation">(</span><span class="token constant">Point</span> <span class="token number">0</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token constant">Point</span> <span class="token number">100</span> <span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token number">10000.0</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token hvariable">surface</span> <span class="token punctuation">(</span><span class="token constant">Circle</span> <span class="token punctuation">(</span><span class="token constant">Point</span> <span class="token number">0</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token number">24</span><span class="token punctuation">)</span>
<span class="token number">1809.5574</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>How about a function that nudges a shape? It takes a shape, the amount to move it on the x axis and the amount to move it on the y axis and then returns a new shape that has the same dimensions, only it's located somewhere else.</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">nudge</span> <span class="token operator">::</span> <span class="token constant">Shape</span> <span class="token operator">-&gt;</span> <span class="token constant">Float</span> <span class="token operator">-&gt;</span> <span class="token constant">Float</span> <span class="token operator">-&gt;</span> <span class="token constant">Shape</span>
<span class="token hvariable">nudge</span> <span class="token punctuation">(</span><span class="token constant">Circle</span> <span class="token punctuation">(</span><span class="token constant">Point</span> <span class="token hvariable">x</span> <span class="token hvariable">y</span><span class="token punctuation">)</span> <span class="token hvariable">r</span><span class="token punctuation">)</span> <span class="token hvariable">a</span> <span class="token hvariable">b</span> <span class="token operator">=</span> <span class="token constant">Circle</span> <span class="token punctuation">(</span><span class="token constant">Point</span> <span class="token punctuation">(</span><span class="token hvariable">x</span><span class="token operator">+</span><span class="token hvariable">a</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token hvariable">y</span><span class="token operator">+</span><span class="token hvariable">b</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token hvariable">r</span>
<span class="token hvariable">nudge</span> <span class="token punctuation">(</span><span class="token constant">Rectangle</span> <span class="token punctuation">(</span><span class="token constant">Point</span> <span class="token hvariable">x1</span> <span class="token hvariable">y1</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token constant">Point</span> <span class="token hvariable">x2</span> <span class="token hvariable">y2</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token hvariable">a</span> <span class="token hvariable">b</span> <span class="token operator">=</span> <span class="token constant">Rectangle</span> <span class="token punctuation">(</span><span class="token constant">Point</span> <span class="token punctuation">(</span><span class="token hvariable">x1</span><span class="token operator">+</span><span class="token hvariable">a</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token hvariable">y1</span><span class="token operator">+</span><span class="token hvariable">b</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token constant">Point</span> <span class="token punctuation">(</span><span class="token hvariable">x2</span><span class="token operator">+</span><span class="token hvariable">a</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token hvariable">y2</span><span class="token operator">+</span><span class="token hvariable">b</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Pretty straightforward. We add the nudge amounts to the points that denote the position of the shape.</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token hvariable">nudge</span> <span class="token punctuation">(</span><span class="token constant">Circle</span> <span class="token punctuation">(</span><span class="token constant">Point</span> <span class="token number">34</span> <span class="token number">34</span><span class="token punctuation">)</span> <span class="token number">10</span><span class="token punctuation">)</span> <span class="token number">5</span> <span class="token number">10</span>
<span class="token constant">Circle</span> <span class="token punctuation">(</span><span class="token constant">Point</span> <span class="token number">39.0</span> <span class="token number">44.0</span><span class="token punctuation">)</span> <span class="token number">10.0</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>If we don't want to deal directly with points, we can make some auxilliary functions that create shapes of some size at the zero coordinates and then nudge those.</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">baseCircle</span> <span class="token operator">::</span> <span class="token constant">Float</span> <span class="token operator">-&gt;</span> <span class="token constant">Shape</span>
<span class="token hvariable">baseCircle</span> <span class="token hvariable">r</span> <span class="token operator">=</span> <span class="token constant">Circle</span> <span class="token punctuation">(</span><span class="token constant">Point</span> <span class="token number">0</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token hvariable">r</span>

<span class="token hvariable">baseRect</span> <span class="token operator">::</span> <span class="token constant">Float</span> <span class="token operator">-&gt;</span> <span class="token constant">Float</span> <span class="token operator">-&gt;</span> <span class="token constant">Shape</span>
<span class="token hvariable">baseRect</span> <span class="token hvariable">width</span> <span class="token hvariable">height</span> <span class="token operator">=</span> <span class="token constant">Rectangle</span> <span class="token punctuation">(</span><span class="token constant">Point</span> <span class="token number">0</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token constant">Point</span> <span class="token hvariable">width</span> <span class="token hvariable">height</span><span class="token punctuation">)</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token hvariable">nudge</span> <span class="token punctuation">(</span><span class="token hvariable">baseRect</span> <span class="token number">40</span> <span class="token number">100</span><span class="token punctuation">)</span> <span class="token number">60</span> <span class="token number">23</span>
<span class="token constant">Rectangle</span> <span class="token punctuation">(</span><span class="token constant">Point</span> <span class="token number">60.0</span> <span class="token number">23.0</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token constant">Point</span> <span class="token number">100.0</span> <span class="token number">123.0</span><span class="token punctuation">)</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>You can, of course, export your data types in your modules. To do that, just write your type along with the functions you are exporting and then add some parentheses and in them specify the value constructors that you want to export for it, separated by commas. If you want to export all the value constructors for a given type, just write&nbsp;<code>..</code>.</p></div><div><p>If we wanted to export the functions and types that we defined here in a module, we could start it off like this:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token keyword">module</span> <span class="token constant">Shapes</span> 
<span class="token punctuation">(</span> <span class="token constant">Point</span><span class="token punctuation">(</span><span class="token operator">..</span><span class="token punctuation">)</span>
<span class="token punctuation">,</span> <span class="token constant">Shape</span><span class="token punctuation">(</span><span class="token operator">..</span><span class="token punctuation">)</span>
<span class="token punctuation">,</span> <span class="token hvariable">surface</span>
<span class="token punctuation">,</span> <span class="token hvariable">nudge</span>
<span class="token punctuation">,</span> <span class="token hvariable">baseCircle</span>
<span class="token punctuation">,</span> <span class="token hvariable">baseRect</span>
<span class="token punctuation">)</span> <span class="token keyword">where</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>By doing&nbsp;<code>Shape(..)</code>, we exported all the value constructors for&nbsp;<code>Shape</code>, so that means that whoever imports our module can make shapes by using the&nbsp;<code>Rectangle</code>&nbsp;and&nbsp;<code>Circle</code>&nbsp;value constructors. It's the same as writing&nbsp;<code>Shape (Rectangle, Circle)</code>.</p></div><div><p>We could also opt not to export any value constructors for&nbsp;<code>Shape</code>&nbsp;by just writing&nbsp;<code>Shape</code>&nbsp;in the export statement. That way, someone importing our module could only make shapes by using the auxilliary functions&nbsp;<code>baseCircle</code>&nbsp;and&nbsp;<code>baseRect</code>.&nbsp;<code>Data.Map</code>&nbsp;uses that approach. You can't create a map by doing&nbsp;<code>Map.Map [(1,2),(3,4)]</code>&nbsp;because it doesn't export that value constructor. However, you can make a mapping by using one of the auxilliary functions like&nbsp;<code>Map.fromList</code>. Remember, value constructors are just functions that take the fields as parameters and return a value of some type (like&nbsp;<code>Shape</code>) as a result. So when we choose not to export them, we just prevent the person importing our module from using those functions, but if some other functions that are exported return a type, we can use them to make values of our custom data types.</p></div><div><p>Not exporting the value constructors of a data types makes them more abstract in such a way that we hide their implementation. Also, whoever uses our module can't pattern match against the value constructors.</p></div><div><h2 data-heading="Record syntax" id="Record_syntax" style="display: flex;"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>Record syntax</h2></div><div><p><img alt="record" src="http://s3.amazonaws.com/lyah/record.png" referrerpolicy="no-referrer"></p></div><div><p>OK, we've been tasked with creating a data type that describes a person. The info that we want to store about that person is: first name, last name, age, height, phone number, and favorite ice-cream flavor. I don't know about you, but that's all I ever want to know about a person. Let's give it a go!</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token keyword">data</span> <span class="token constant">Person</span> <span class="token operator">=</span> <span class="token constant">Person</span> <span class="token constant">String</span> <span class="token constant">String</span> <span class="token constant">Int</span> <span class="token constant">Float</span> <span class="token constant">String</span> <span class="token constant">String</span> <span class="token keyword">deriving</span> <span class="token punctuation">(</span><span class="token constant">Show</span><span class="token punctuation">)</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>O-kay. The first field is the first name, the second is the last name, the third is the age and so on. Let's make a person.</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token keyword">let</span> <span class="token hvariable">guy</span> <span class="token operator">=</span> <span class="token constant">Person</span> <span class="token string">"Buddy"</span> <span class="token string">"Finklestein"</span> <span class="token number">43</span> <span class="token number">184.2</span> <span class="token string">"526-2928"</span> <span class="token string">"Chocolate"</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token hvariable">guy</span>
<span class="token constant">Person</span> <span class="token string">"Buddy"</span> <span class="token string">"Finklestein"</span> <span class="token number">43</span> <span class="token number">184.2</span> <span class="token string">"526-2928"</span> <span class="token string">"Chocolate"</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>That's kind of cool, although slightly unreadable. What if we want to create a function to get seperate info from a person? A function that gets some person's first name, a function that gets some person's last name, etc. Well, we'd have to define them kind of like this.</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">firstName</span> <span class="token operator">::</span> <span class="token constant">Person</span> <span class="token operator">-&gt;</span> <span class="token constant">String</span>
<span class="token hvariable">firstName</span> <span class="token punctuation">(</span><span class="token constant">Person</span> <span class="token hvariable">firstname</span> <span class="token hvariable">_</span> <span class="token hvariable">_</span> <span class="token hvariable">_</span> <span class="token hvariable">_</span> <span class="token hvariable">_</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token hvariable">firstname</span>

<span class="token hvariable">lastName</span> <span class="token operator">::</span> <span class="token constant">Person</span> <span class="token operator">-&gt;</span> <span class="token constant">String</span>
<span class="token hvariable">lastName</span> <span class="token punctuation">(</span><span class="token constant">Person</span> <span class="token hvariable">_</span> <span class="token hvariable">lastname</span> <span class="token hvariable">_</span> <span class="token hvariable">_</span> <span class="token hvariable">_</span> <span class="token hvariable">_</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token hvariable">lastname</span>

<span class="token hvariable">age</span> <span class="token operator">::</span> <span class="token constant">Person</span> <span class="token operator">-&gt;</span> <span class="token constant">Int</span>
<span class="token hvariable">age</span> <span class="token punctuation">(</span><span class="token constant">Person</span> <span class="token hvariable">_</span> <span class="token hvariable">_</span> <span class="token hvariable">age</span> <span class="token hvariable">_</span> <span class="token hvariable">_</span> <span class="token hvariable">_</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token hvariable">age</span>

<span class="token hvariable">height</span> <span class="token operator">::</span> <span class="token constant">Person</span> <span class="token operator">-&gt;</span> <span class="token constant">Float</span>
<span class="token hvariable">height</span> <span class="token punctuation">(</span><span class="token constant">Person</span> <span class="token hvariable">_</span> <span class="token hvariable">_</span> <span class="token hvariable">_</span> <span class="token hvariable">height</span> <span class="token hvariable">_</span> <span class="token hvariable">_</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token hvariable">height</span>

<span class="token hvariable">phoneNumber</span> <span class="token operator">::</span> <span class="token constant">Person</span> <span class="token operator">-&gt;</span> <span class="token constant">String</span>
<span class="token hvariable">phoneNumber</span> <span class="token punctuation">(</span><span class="token constant">Person</span> <span class="token hvariable">_</span> <span class="token hvariable">_</span> <span class="token hvariable">_</span> <span class="token hvariable">_</span> <span class="token hvariable">number</span> <span class="token hvariable">_</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token hvariable">number</span>

<span class="token hvariable">flavor</span> <span class="token operator">::</span> <span class="token constant">Person</span> <span class="token operator">-&gt;</span> <span class="token constant">String</span>
<span class="token hvariable">flavor</span> <span class="token punctuation">(</span><span class="token constant">Person</span> <span class="token hvariable">_</span> <span class="token hvariable">_</span> <span class="token hvariable">_</span> <span class="token hvariable">_</span> <span class="token hvariable">_</span> <span class="token hvariable">flavor</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token hvariable">flavor</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Whew! I certainly did not enjoy writing that! Despite being very cumbersome and BORING to write, this method works.</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token keyword">let</span> <span class="token hvariable">guy</span> <span class="token operator">=</span> <span class="token constant">Person</span> <span class="token string">"Buddy"</span> <span class="token string">"Finklestein"</span> <span class="token number">43</span> <span class="token number">184.2</span> <span class="token string">"526-2928"</span> <span class="token string">"Chocolate"</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token hvariable">firstName</span> <span class="token hvariable">guy</span>
<span class="token string">"Buddy"</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token hvariable">height</span> <span class="token hvariable">guy</span>
<span class="token number">184.2</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token hvariable">flavor</span> <span class="token hvariable">guy</span>
<span class="token string">"Chocolate"</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>There must be a better way, you say! Well no, there isn't, sorry.</p></div><div><p>Just kidding, there is. Hahaha! The makers of Haskell were very smart and anticipated this scenario. They included an alternative way to write data types. Here's how we could achieve the above functionality with record syntax.</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token keyword">data</span> <span class="token constant">Person</span> <span class="token operator">=</span> <span class="token constant">Person</span> <span class="token punctuation">{</span> <span class="token hvariable">firstName</span> <span class="token operator">::</span> <span class="token constant">String</span>
                     <span class="token punctuation">,</span> <span class="token hvariable">lastName</span> <span class="token operator">::</span> <span class="token constant">String</span>
                     <span class="token punctuation">,</span> <span class="token hvariable">age</span> <span class="token operator">::</span> <span class="token constant">Int</span>
                     <span class="token punctuation">,</span> <span class="token hvariable">height</span> <span class="token operator">::</span> <span class="token constant">Float</span>
                     <span class="token punctuation">,</span> <span class="token hvariable">phoneNumber</span> <span class="token operator">::</span> <span class="token constant">String</span>
                     <span class="token punctuation">,</span> <span class="token hvariable">flavor</span> <span class="token operator">::</span> <span class="token constant">String</span>
                     <span class="token punctuation">}</span> <span class="token keyword">deriving</span> <span class="token punctuation">(</span><span class="token constant">Show</span><span class="token punctuation">)</span> 
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>So instead of just naming the field types one after another and separating them with spaces, we use curly brackets. First we write the name of the field, for instance,&nbsp;<code>firstName</code>&nbsp;and then we write a double colon&nbsp;<code>::</code>&nbsp;(also called Paamayim Nekudotayim, haha) and then we specify the type. The resulting data type is exactly the same. The main benefit of this is that it creates functions that lookup fields in the data type. By using record syntax to create this data type, Haskell automatically made these functions:&nbsp;<code>firstName</code>,&nbsp;<code>lastName</code>,&nbsp;<code>age</code>,&nbsp;<code>height</code>,&nbsp;<code>phoneNumber</code>&nbsp;and&nbsp;<code>flavor</code>.</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token operator">:</span><span class="token hvariable">t</span> <span class="token hvariable">flavor</span>
<span class="token hvariable">flavor</span> <span class="token operator">::</span> <span class="token constant">Person</span> <span class="token operator">-&gt;</span> <span class="token constant">String</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token operator">:</span><span class="token hvariable">t</span> <span class="token hvariable">firstName</span>
<span class="token hvariable">firstName</span> <span class="token operator">::</span> <span class="token constant">Person</span> <span class="token operator">-&gt;</span> <span class="token constant">String</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>There's another benefit to using record syntax. When we derive&nbsp;<code>Show</code>&nbsp;for the type, it displays it differently if we use record syntax to define and instantiate the type. Say we have a type that represents a car. We want to keep track of the company that made it, the model name and its year of production. Watch.</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token keyword">data</span> <span class="token constant">Car</span> <span class="token operator">=</span> <span class="token constant">Car</span> <span class="token constant">String</span> <span class="token constant">String</span> <span class="token constant">Int</span> <span class="token keyword">deriving</span> <span class="token punctuation">(</span><span class="token constant">Show</span><span class="token punctuation">)</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token constant">Car</span> <span class="token string">"Ford"</span> <span class="token string">"Mustang"</span> <span class="token number">1967</span>
<span class="token constant">Car</span> <span class="token string">"Ford"</span> <span class="token string">"Mustang"</span> <span class="token number">1967</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>If we define it using record syntax, we can make a new car like this.</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token keyword">data</span> <span class="token constant">Car</span> <span class="token operator">=</span> <span class="token constant">Car</span> <span class="token punctuation">{</span><span class="token hvariable">company</span> <span class="token operator">::</span> <span class="token constant">String</span><span class="token punctuation">,</span> <span class="token hvariable">model</span> <span class="token operator">::</span> <span class="token constant">String</span><span class="token punctuation">,</span> <span class="token hvariable">year</span> <span class="token operator">::</span> <span class="token constant">Int</span><span class="token punctuation">}</span> <span class="token keyword">deriving</span> <span class="token punctuation">(</span><span class="token constant">Show</span><span class="token punctuation">)</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token constant">Car</span> <span class="token punctuation">{</span><span class="token hvariable">company</span><span class="token operator">=</span><span class="token string">"Ford"</span><span class="token punctuation">,</span> <span class="token hvariable">model</span><span class="token operator">=</span><span class="token string">"Mustang"</span><span class="token punctuation">,</span> <span class="token hvariable">year</span><span class="token operator">=</span><span class="token number">1967</span><span class="token punctuation">}</span>
<span class="token constant">Car</span> <span class="token punctuation">{</span><span class="token hvariable">company</span> <span class="token operator">=</span> <span class="token string">"Ford"</span><span class="token punctuation">,</span> <span class="token hvariable">model</span> <span class="token operator">=</span> <span class="token string">"Mustang"</span><span class="token punctuation">,</span> <span class="token hvariable">year</span> <span class="token operator">=</span> <span class="token number">1967</span><span class="token punctuation">}</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>When making a new car, we don't have to necessarily put the fields in the proper order, as long as we list all of them. But if we don't use record syntax, we have to specify them in order.</p></div><div><p>Use record syntax when a constructor has several fields and it's not obvious which field is which. If we make a 3D vector data type by doing&nbsp;<code>data Vector = Vector Int Int Int</code>, it's pretty obvious that the fields are the components of a vector. However, in our&nbsp;<code>Person</code>&nbsp;and&nbsp;<code>Car</code>&nbsp;types, it wasn't so obvious and we greatly benefited from using record syntax.</p></div><div><h2 data-heading="Type parameters" id="Type_parameters" style="display: flex;"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>Type parameters</h2></div><div><p>A value constructor can take some values parameters and then produce a new value. For instance, the&nbsp;<code>Car</code>&nbsp;constructor takes three values and produces a car value. In a similar manner,&nbsp;<strong>type constructors</strong>&nbsp;can take types as parameters to produce new types. This might sound a bit too meta at first, but it's not that complicated. If you're familiar with templates in C++, you'll see some parallels. To get a clear picture of what type parameters work like in action, let's take a look at how a type we've already met is implemented.</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token keyword">data</span> <span class="token constant">Maybe</span> <span class="token hvariable">a</span> <span class="token operator">=</span> <span class="token constant">Nothing</span> <span class="token operator">|</span> <span class="token constant">Just</span> <span class="token hvariable">a</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p><img alt="yeti" src="http://s3.amazonaws.com/lyah/yeti.png" referrerpolicy="no-referrer"></p></div><div><p>The&nbsp;<code>a</code>&nbsp;here is the type parameter. And because there's a type parameter involved, we call&nbsp;<code>Maybe</code>&nbsp;a type constructor. Depending on what we want this data type to hold when it's not&nbsp;<code>Nothing</code>, this type constructor can end up producing a type of&nbsp;<code>Maybe Int</code>,&nbsp;<code>Maybe Car</code>,&nbsp;<code>Maybe String</code>, etc. No value can have a type of just&nbsp;<code>Maybe</code>, because that's not a type per se, it's a type constructor. In order for this to be a real type that a value can be part of, it has to have all its type parameters filled up.</p></div><div><p>So if we pass&nbsp;<code>Char</code>&nbsp;as the type parameter to&nbsp;<code>Maybe</code>, we get a type of&nbsp;<code>Maybe Char</code>. The value&nbsp;<code>Just 'a'</code>&nbsp;has a type of&nbsp;<code>Maybe Char</code>, for example.</p></div><div><p>You might not know it, but we used a type that has a type parameter before we used&nbsp;<code>Maybe</code>. That type is the list type. Although there's some syntactic sugar in play, the list type takes a parameter to produce a concrete type. Values can have an&nbsp;<code>[Int]</code>&nbsp;type, a&nbsp;<code>[Char]</code>&nbsp;type, a&nbsp;<code>[[String]]</code>&nbsp;type, but you can't have a value that just has a type of&nbsp;<code>[]</code>.</p></div><div><p>Let's play around with the&nbsp;<code>Maybe</code>&nbsp;type.</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token constant">Just</span> <span class="token string">"Haha"</span>
<span class="token constant">Just</span> <span class="token string">"Haha"</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token constant">Just</span> <span class="token number">84</span>
<span class="token constant">Just</span> <span class="token number">84</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token operator">:</span><span class="token hvariable">t</span> <span class="token constant">Just</span> <span class="token string">"Haha"</span>
<span class="token constant">Just</span> <span class="token string">"Haha"</span> <span class="token operator">::</span> <span class="token constant">Maybe</span> <span class="token punctuation">[</span><span class="token constant">Char</span><span class="token punctuation">]</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token operator">:</span><span class="token hvariable">t</span> <span class="token constant">Just</span> <span class="token number">84</span>
<span class="token constant">Just</span> <span class="token number">84</span> <span class="token operator">::</span> <span class="token punctuation">(</span><span class="token constant">Num</span> <span class="token hvariable">t</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token constant">Maybe</span> <span class="token hvariable">t</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token operator">:</span><span class="token hvariable">t</span> <span class="token constant">Nothing</span>
<span class="token constant">Nothing</span> <span class="token operator">::</span> <span class="token constant">Maybe</span> <span class="token hvariable">a</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token constant">Just</span> <span class="token number">10</span> <span class="token operator">::</span> <span class="token constant">Maybe</span> <span class="token constant">Double</span>
<span class="token constant">Just</span> <span class="token number">10.0</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Type parameters are useful because we can make different types with them depending on what kind of types we want contained in our data type. When we do&nbsp;<code>:t Just "Haha"</code>, the type inference engine figures it out to be of the type&nbsp;<code>Maybe [Char]</code>, because if the&nbsp;<code>a</code>&nbsp;in the&nbsp;<code>Just a</code>&nbsp;is a string, then the&nbsp;<code>a</code>&nbsp;in&nbsp;<code>Maybe a</code>&nbsp;must also be a string.</p></div><div><p>Notice that the type of&nbsp;<code>Nothing</code>&nbsp;is&nbsp;<code>Maybe a</code>. Its type is polymorphic. If some function requires a&nbsp;<code>Maybe Int</code>&nbsp;as a parameter, we can give it a&nbsp;<code>Nothing</code>, because a&nbsp;<code>Nothing</code>&nbsp;doesn't contain a value anyway and so it doesn't matter. The&nbsp;<code>Maybe a</code>&nbsp;type can act like a&nbsp;<code>Maybe Int</code>&nbsp;if it has to, just like&nbsp;<code>5</code>&nbsp;can act like an&nbsp;<code>Int</code>&nbsp;or a&nbsp;<code>Double</code>. Similarly, the type of the empty list is&nbsp;<code>[a]</code>. An empty list can act like a list of anything. That's why we can do&nbsp;<code>[1,2,3] ++ []</code>&nbsp;and&nbsp;<code>["ha","ha","ha"] ++ []</code>.</p></div><div><p>Using type parameters is very beneficial, but only when using them makes sense. Usually we use them when our data type would work regardless of the type of the value it then holds inside it, like with our&nbsp;<code>Maybe a</code>&nbsp;type. If our type acts as some kind of box, it's good to use them. We could change our&nbsp;<code>Car</code>&nbsp;data type from this:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token keyword">data</span> <span class="token constant">Car</span> <span class="token operator">=</span> <span class="token constant">Car</span> <span class="token punctuation">{</span> <span class="token hvariable">company</span> <span class="token operator">::</span> <span class="token constant">String</span>
               <span class="token punctuation">,</span> <span class="token hvariable">model</span> <span class="token operator">::</span> <span class="token constant">String</span>
               <span class="token punctuation">,</span> <span class="token hvariable">year</span> <span class="token operator">::</span> <span class="token constant">Int</span>
               <span class="token punctuation">}</span> <span class="token keyword">deriving</span> <span class="token punctuation">(</span><span class="token constant">Show</span><span class="token punctuation">)</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>To this:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token keyword">data</span> <span class="token constant">Car</span> <span class="token hvariable">a</span> <span class="token hvariable">b</span> <span class="token hvariable">c</span> <span class="token operator">=</span> <span class="token constant">Car</span> <span class="token punctuation">{</span> <span class="token hvariable">company</span> <span class="token operator">::</span> <span class="token hvariable">a</span>
                     <span class="token punctuation">,</span> <span class="token hvariable">model</span> <span class="token operator">::</span> <span class="token hvariable">b</span>
                     <span class="token punctuation">,</span> <span class="token hvariable">year</span> <span class="token operator">::</span> <span class="token hvariable">c</span> 
                     <span class="token punctuation">}</span> <span class="token keyword">deriving</span> <span class="token punctuation">(</span><span class="token constant">Show</span><span class="token punctuation">)</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>But would we really benefit? The answer is: probably no, because we'd just end up defining functions that only work on the&nbsp;<code>Car String String Int</code>&nbsp;type. For instance, given our first definition of&nbsp;<code>Car</code>, we could make a function that displays the car's properties in a nice little text.</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">tellCar</span> <span class="token operator">::</span> <span class="token constant">Car</span> <span class="token operator">-&gt;</span> <span class="token constant">String</span>
<span class="token hvariable">tellCar</span> <span class="token punctuation">(</span><span class="token constant">Car</span> <span class="token punctuation">{</span><span class="token hvariable">company</span> <span class="token operator">=</span> <span class="token hvariable">c</span><span class="token punctuation">,</span> <span class="token hvariable">model</span> <span class="token operator">=</span> <span class="token hvariable">m</span><span class="token punctuation">,</span> <span class="token hvariable">year</span> <span class="token operator">=</span> <span class="token hvariable">y</span><span class="token punctuation">}</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token string">"This "</span> <span class="token operator">++</span> <span class="token hvariable">c</span> <span class="token operator">++</span> <span class="token string">" "</span> <span class="token operator">++</span> <span class="token hvariable">m</span> <span class="token operator">++</span> <span class="token string">" was made in "</span> <span class="token operator">++</span> <span class="token builtin">show</span> <span class="token hvariable">y</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token keyword">let</span> <span class="token hvariable">stang</span> <span class="token operator">=</span> <span class="token constant">Car</span> <span class="token punctuation">{</span><span class="token hvariable">company</span><span class="token operator">=</span><span class="token string">"Ford"</span><span class="token punctuation">,</span> <span class="token hvariable">model</span><span class="token operator">=</span><span class="token string">"Mustang"</span><span class="token punctuation">,</span> <span class="token hvariable">year</span><span class="token operator">=</span><span class="token number">1967</span><span class="token punctuation">}</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token hvariable">tellCar</span> <span class="token hvariable">stang</span>
<span class="token string">"This Ford Mustang was made in 1967"</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>A cute little function! The type declaration is cute and it works nicely. Now what if&nbsp;<code>Car</code>&nbsp;was&nbsp;<code>Car a b c</code>?</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">tellCar</span> <span class="token operator">::</span> <span class="token punctuation">(</span><span class="token constant">Show</span> <span class="token hvariable">a</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token constant">Car</span> <span class="token constant">String</span> <span class="token constant">String</span> <span class="token hvariable">a</span> <span class="token operator">-&gt;</span> <span class="token constant">String</span>
<span class="token hvariable">tellCar</span> <span class="token punctuation">(</span><span class="token constant">Car</span> <span class="token punctuation">{</span><span class="token hvariable">company</span> <span class="token operator">=</span> <span class="token hvariable">c</span><span class="token punctuation">,</span> <span class="token hvariable">model</span> <span class="token operator">=</span> <span class="token hvariable">m</span><span class="token punctuation">,</span> <span class="token hvariable">year</span> <span class="token operator">=</span> <span class="token hvariable">y</span><span class="token punctuation">}</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token string">"This "</span> <span class="token operator">++</span> <span class="token hvariable">c</span> <span class="token operator">++</span> <span class="token string">" "</span> <span class="token operator">++</span> <span class="token hvariable">m</span> <span class="token operator">++</span> <span class="token string">" was made in "</span> <span class="token operator">++</span> <span class="token builtin">show</span> <span class="token hvariable">y</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>We'd have to force this function to take a&nbsp;<code>Car</code>&nbsp;type of&nbsp;<code>(Show a) =&gt; Car String String a</code>. You can see that the type signature is more complicated and the only benefit we'd actually get would be that we can use any type that's an instance of the&nbsp;<code>Show</code>&nbsp;typeclass as the type for&nbsp;<code>c</code>.</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token hvariable">tellCar</span> <span class="token punctuation">(</span><span class="token constant">Car</span> <span class="token string">"Ford"</span> <span class="token string">"Mustang"</span> <span class="token number">1967</span><span class="token punctuation">)</span>
<span class="token string">"This Ford Mustang was made in 1967"</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token hvariable">tellCar</span> <span class="token punctuation">(</span><span class="token constant">Car</span> <span class="token string">"Ford"</span> <span class="token string">"Mustang"</span> <span class="token string">"nineteen sixty seven"</span><span class="token punctuation">)</span>
<span class="token string">"This Ford Mustang was made in \"nineteen sixty seven\""</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token operator">:</span><span class="token hvariable">t</span> <span class="token constant">Car</span> <span class="token string">"Ford"</span> <span class="token string">"Mustang"</span> <span class="token number">1967</span>
<span class="token constant">Car</span> <span class="token string">"Ford"</span> <span class="token string">"Mustang"</span> <span class="token number">1967</span> <span class="token operator">::</span> <span class="token punctuation">(</span><span class="token constant">Num</span> <span class="token hvariable">t</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token constant">Car</span> <span class="token punctuation">[</span><span class="token constant">Char</span><span class="token punctuation">]</span> <span class="token punctuation">[</span><span class="token constant">Char</span><span class="token punctuation">]</span> <span class="token hvariable">t</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token operator">:</span><span class="token hvariable">t</span> <span class="token constant">Car</span> <span class="token string">"Ford"</span> <span class="token string">"Mustang"</span> <span class="token string">"nineteen sixty seven"</span>
<span class="token constant">Car</span> <span class="token string">"Ford"</span> <span class="token string">"Mustang"</span> <span class="token string">"nineteen sixty seven"</span> <span class="token operator">::</span> <span class="token constant">Car</span> <span class="token punctuation">[</span><span class="token constant">Char</span><span class="token punctuation">]</span> <span class="token punctuation">[</span><span class="token constant">Char</span><span class="token punctuation">]</span> <span class="token punctuation">[</span><span class="token constant">Char</span><span class="token punctuation">]</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p><img alt="meekrat" src="http://s3.amazonaws.com/lyah/meekrat.png" referrerpolicy="no-referrer"></p></div><div><p>In real life though, we'd end up using&nbsp;<code>Car String String Int</code>&nbsp;most of the time and so it would seem that parameterizing the&nbsp;<code>Car</code>&nbsp;type isn't really worth it. We usually use type parameters when the type that's contained inside the data type's various value constructors isn't really that important for the type to work. A list of stuff is a list of stuff and it doesn't matter what the type of that stuff is, it can still work. If we want to sum a list of numbers, we can specify later in the summing function that we specifically want a list of numbers. Same goes for&nbsp;<code>Maybe</code>.&nbsp;<code>Maybe</code>&nbsp;represents an option of either having nothing or having one of something. It doesn't matter what the type of that something is.</p></div><div><p>Another example of a parameterized type that we've already met is&nbsp;<code>Map k v</code>&nbsp;from&nbsp;<code>Data.Map</code>. The&nbsp;<code>k</code>&nbsp;is the type of the keys in a map and the&nbsp;<code>v</code>&nbsp;is the type of the values. This is a good example of where type parameters are very useful. Having maps parameterized enables us to have mappings from any type to any other type, as long as the type of the key is part of the&nbsp;<code>Ord</code>&nbsp;typeclass. If we were defining a mapping type, we could add a typeclass constraint in the&nbsp;<em>data</em>&nbsp;declaration:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token keyword">data</span> <span class="token punctuation">(</span><span class="token constant">Ord</span> <span class="token hvariable">k</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token constant">Map</span> <span class="token hvariable">k</span> <span class="token hvariable">v</span> <span class="token operator">=</span> <span class="token operator">...</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>However, it's a very strong convention in Haskell to&nbsp;<strong>never add typeclass constraints in data declarations.</strong>&nbsp;Why? Well, because we don't benefit a lot, but we end up writing more class constraints, even when we don't need them. If we put or don't put the&nbsp;<code>Ord k</code>&nbsp;constraint in the&nbsp;<em>data</em>&nbsp;declaration for&nbsp;<code>Map k v</code>, we're going to have to put the constraint into functions that assume the keys in a map can be ordered. But if we don't put the constraint in the data declaration, we don't have to put&nbsp;<code>(Ord k) =&gt;</code>&nbsp;in the type declarations of functions that don't care whether the keys can be ordered or not. An example of such a function is&nbsp;<code>toList</code>, that just takes a mapping and converts it to an associative list. Its type signature is&nbsp;<code>toList :: Map k a -&gt; [(k, a)]</code>. If&nbsp;<code>Map k v</code>&nbsp;had a type constraint in its&nbsp;<em>data</em>&nbsp;declaration, the type for&nbsp;<code>toList</code>&nbsp;would have to be&nbsp;<code>toList :: (Ord k) =&gt; Map k a -&gt; [(k, a)]</code>, even though the function doesn't do any comparing of keys by order.</p></div><div><p>So don't put type constraints into&nbsp;<em>data</em>&nbsp;declarations even if it seems to make sense, because you'll have to put them into the function type declarations either way.</p></div><div><p>Let's implement a 3D vector type and add some operations for it. We'll be using a parameterized type because even though it will usually contain numeric types, it will still support several of them.</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token keyword">data</span> <span class="token constant">Vector</span> <span class="token hvariable">a</span> <span class="token operator">=</span> <span class="token constant">Vector</span> <span class="token hvariable">a</span> <span class="token hvariable">a</span> <span class="token hvariable">a</span> <span class="token keyword">deriving</span> <span class="token punctuation">(</span><span class="token constant">Show</span><span class="token punctuation">)</span>

<span class="token hvariable">vplus</span> <span class="token operator">::</span> <span class="token punctuation">(</span><span class="token constant">Num</span> <span class="token hvariable">t</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token constant">Vector</span> <span class="token hvariable">t</span> <span class="token operator">-&gt;</span> <span class="token constant">Vector</span> <span class="token hvariable">t</span> <span class="token operator">-&gt;</span> <span class="token constant">Vector</span> <span class="token hvariable">t</span>
<span class="token punctuation">(</span><span class="token constant">Vector</span> <span class="token hvariable">i</span> <span class="token hvariable">j</span> <span class="token hvariable">k</span><span class="token punctuation">)</span> <span class="token operator">`vplus`</span> <span class="token punctuation">(</span><span class="token constant">Vector</span> <span class="token hvariable">l</span> <span class="token hvariable">m</span> <span class="token hvariable">n</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token constant">Vector</span> <span class="token punctuation">(</span><span class="token hvariable">i</span><span class="token operator">+</span><span class="token hvariable">l</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token hvariable">j</span><span class="token operator">+</span><span class="token hvariable">m</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token hvariable">k</span><span class="token operator">+</span><span class="token hvariable">n</span><span class="token punctuation">)</span>

<span class="token hvariable">vectMult</span> <span class="token operator">::</span> <span class="token punctuation">(</span><span class="token constant">Num</span> <span class="token hvariable">t</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token constant">Vector</span> <span class="token hvariable">t</span> <span class="token operator">-&gt;</span> <span class="token hvariable">t</span> <span class="token operator">-&gt;</span> <span class="token constant">Vector</span> <span class="token hvariable">t</span>
<span class="token punctuation">(</span><span class="token constant">Vector</span> <span class="token hvariable">i</span> <span class="token hvariable">j</span> <span class="token hvariable">k</span><span class="token punctuation">)</span> <span class="token operator">`vectMult`</span> <span class="token hvariable">m</span> <span class="token operator">=</span> <span class="token constant">Vector</span> <span class="token punctuation">(</span><span class="token hvariable">i</span><span class="token operator">*</span><span class="token hvariable">m</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token hvariable">j</span><span class="token operator">*</span><span class="token hvariable">m</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token hvariable">k</span><span class="token operator">*</span><span class="token hvariable">m</span><span class="token punctuation">)</span>

<span class="token hvariable">scalarMult</span> <span class="token operator">::</span> <span class="token punctuation">(</span><span class="token constant">Num</span> <span class="token hvariable">t</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token constant">Vector</span> <span class="token hvariable">t</span> <span class="token operator">-&gt;</span> <span class="token constant">Vector</span> <span class="token hvariable">t</span> <span class="token operator">-&gt;</span> <span class="token hvariable">t</span>
<span class="token punctuation">(</span><span class="token constant">Vector</span> <span class="token hvariable">i</span> <span class="token hvariable">j</span> <span class="token hvariable">k</span><span class="token punctuation">)</span> <span class="token operator">`scalarMult`</span> <span class="token punctuation">(</span><span class="token constant">Vector</span> <span class="token hvariable">l</span> <span class="token hvariable">m</span> <span class="token hvariable">n</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token hvariable">i</span><span class="token operator">*</span><span class="token hvariable">l</span> <span class="token operator">+</span> <span class="token hvariable">j</span><span class="token operator">*</span><span class="token hvariable">m</span> <span class="token operator">+</span> <span class="token hvariable">k</span><span class="token operator">*</span><span class="token hvariable">n</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p><code>vplus</code>&nbsp;is for adding two vectors together. Two vectors are added just by adding their corresponding components.&nbsp;<code>scalarMult</code>&nbsp;is for the scalar product of two vectors and&nbsp;<code>vectMult</code>&nbsp;is for multiplying a vector with a scalar. These functions can operate on types of&nbsp;<code>Vector Int</code>,&nbsp;<code>Vector Integer</code>,&nbsp;<code>Vector Float</code>, whatever, as long as the&nbsp;<code>a</code>&nbsp;from&nbsp;<code>Vector a</code>&nbsp;is from the&nbsp;<code>Num</code>&nbsp;typeclass. Also, if you examine the type declaration for these functions, you'll see that they can operate only on vectors of the same type and the numbers involved must also be of the type that is contained in the vectors. Notice that we didn't put a&nbsp;<code>Num</code>&nbsp;class constraint in the&nbsp;<em>data</em>&nbsp;declaration, because we'd have to repeat it in the functions anyway.</p></div><div><p>Once again, it's very important to distinguish between the type constructor and the value constructor. When declaring a data type, the part before the&nbsp;<code>=</code>&nbsp;is the type constructor and the constructors after it (possibly separated by&nbsp;<code>|</code>'s) are value constructors. Giving a function a type of&nbsp;<code>Vector t t t -&gt; Vector t t t -&gt; t</code>&nbsp;would be wrong, because we have to put types in type declaration and the vector&nbsp;<strong>type</strong>&nbsp;constructor takes only one parameter, whereas the value constructor takes three. Let's play around with our vectors.</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token constant">Vector</span> <span class="token number">3</span> <span class="token number">5</span> <span class="token number">8</span> <span class="token operator">`vplus`</span> <span class="token constant">Vector</span> <span class="token number">9</span> <span class="token number">2</span> <span class="token number">8</span>
<span class="token constant">Vector</span> <span class="token number">12</span> <span class="token number">7</span> <span class="token number">16</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token constant">Vector</span> <span class="token number">3</span> <span class="token number">5</span> <span class="token number">8</span> <span class="token operator">`vplus`</span> <span class="token constant">Vector</span> <span class="token number">9</span> <span class="token number">2</span> <span class="token number">8</span> <span class="token operator">`vplus`</span> <span class="token constant">Vector</span> <span class="token number">0</span> <span class="token number">2</span> <span class="token number">3</span>
<span class="token constant">Vector</span> <span class="token number">12</span> <span class="token number">9</span> <span class="token number">19</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token constant">Vector</span> <span class="token number">3</span> <span class="token number">9</span> <span class="token number">7</span> <span class="token operator">`vectMult`</span> <span class="token number">10</span>
<span class="token constant">Vector</span> <span class="token number">30</span> <span class="token number">90</span> <span class="token number">70</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token constant">Vector</span> <span class="token number">4</span> <span class="token number">9</span> <span class="token number">5</span> <span class="token operator">`scalarMult`</span> <span class="token constant">Vector</span> <span class="token number">9.0</span> <span class="token number">2.0</span> <span class="token number">4.0</span>
<span class="token number">74.0</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token constant">Vector</span> <span class="token number">2</span> <span class="token number">9</span> <span class="token number">3</span> <span class="token operator">`vectMult`</span> <span class="token punctuation">(</span><span class="token constant">Vector</span> <span class="token number">4</span> <span class="token number">9</span> <span class="token number">5</span> <span class="token operator">`scalarMult`</span> <span class="token constant">Vector</span> <span class="token number">9</span> <span class="token number">2</span> <span class="token number">4</span><span class="token punctuation">)</span>
<span class="token constant">Vector</span> <span class="token number">148</span> <span class="token number">666</span> <span class="token number">222</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><h2 data-heading="Derived instances" id="Derived_instances" style="display: flex;"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>Derived instances</h2></div><div><p><img alt="gob" src="http://s3.amazonaws.com/lyah/gob.png" referrerpolicy="no-referrer"></p></div><div><p>In the&nbsp;<a data-tooltip-position="top" aria-label="http://learnyouahaskell.com/types-and-typeclasses#typeclasses-101" rel="noopener" class="external-link" href="http://learnyouahaskell.com/types-and-typeclasses#typeclasses-101" target="_blank">Typeclasses 101</a>&nbsp;section, we explained the basics of typeclasses. We explained that a typeclass is a sort of an interface that defines some behavior. A type can be made an&nbsp;<strong>instance</strong>&nbsp;of a typeclass if it supports that behavior. Example: the&nbsp;<code>Int</code>&nbsp;type is an instance of the&nbsp;<code>Eq</code>&nbsp;typeclass because the&nbsp;<code>Eq</code>&nbsp;typeclass defines behavior for stuff that can be equated. And because integers can be equated,&nbsp;<code>Int</code>&nbsp;is a part of the&nbsp;<code>Eq</code>&nbsp;typeclass. The real usefulness comes with the functions that act as the interface for&nbsp;<code>Eq</code>, namely&nbsp;<code>==</code>&nbsp;and&nbsp;<code>/=</code>. If a type is a part of the&nbsp;<code>Eq</code>&nbsp;typeclass, we can use the&nbsp;<code>==</code>&nbsp;functions with values of that type. That's why expressions like&nbsp;<code>4 == 4</code>&nbsp;and&nbsp;<code>"foo" /= "bar"</code>&nbsp;typecheck.</p></div><div><p>We also mentioned that they're often confused with classes in languages like Java, Python, C++ and the like, which then baffles a lot of people. In those languages, classes are a blueprint from which we then create objects that contain state and can do some actions. Typeclasses are more like interfaces. We don't make data from typeclasses. Instead, we first make our data type and then we think about what it can act like. If it can act like something that can be equated, we make it an instance of the&nbsp;<code>Eq</code>&nbsp;typeclass. If it can act like something that can be ordered, we make it an instance of the&nbsp;<code>Ord</code>&nbsp;typeclass.</p></div><div><p>In the next section, we'll take a look at how we can manually make our types instances of typeclasses by implementing the functions defined by the typeclasses. But right now, let's see how Haskell can automatically make our type an instance of any of the following typeclasses:&nbsp;<code>Eq</code>,&nbsp;<code>Ord</code>,&nbsp;<code>Enum</code>,&nbsp;<code>Bounded</code>,&nbsp;<code>Show</code>,&nbsp;<code>Read</code>. Haskell can derive the behavior of our types in these contexts if we use the&nbsp;<em>deriving</em>&nbsp;keyword when making our data type.</p></div><div><p>Consider this data type:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token keyword">data</span> <span class="token constant">Person</span> <span class="token operator">=</span> <span class="token constant">Person</span> <span class="token punctuation">{</span> <span class="token hvariable">firstName</span> <span class="token operator">::</span> <span class="token constant">String</span>
                     <span class="token punctuation">,</span> <span class="token hvariable">lastName</span> <span class="token operator">::</span> <span class="token constant">String</span>
                     <span class="token punctuation">,</span> <span class="token hvariable">age</span> <span class="token operator">::</span> <span class="token constant">Int</span>
                     <span class="token punctuation">}</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>It describes a person. Let's assume that no two people have the same combination of first name, last name and age. Now, if we have records for two people, does it make sense to see if they represent the same person? Sure it does. We can try to equate them and see if they're equal or not. That's why it would make sense for this type to be part of the&nbsp;<code>Eq</code>&nbsp;typeclass. We'll derive the instance.</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token keyword">data</span> <span class="token constant">Person</span> <span class="token operator">=</span> <span class="token constant">Person</span> <span class="token punctuation">{</span> <span class="token hvariable">firstName</span> <span class="token operator">::</span> <span class="token constant">String</span>
                     <span class="token punctuation">,</span> <span class="token hvariable">lastName</span> <span class="token operator">::</span> <span class="token constant">String</span>
                     <span class="token punctuation">,</span> <span class="token hvariable">age</span> <span class="token operator">::</span> <span class="token constant">Int</span>
                     <span class="token punctuation">}</span> <span class="token keyword">deriving</span> <span class="token punctuation">(</span><span class="token constant">Eq</span><span class="token punctuation">)</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>When we derive the&nbsp;<code>Eq</code>&nbsp;instance for a type and then try to compare two values of that type with&nbsp;<code>==</code>&nbsp;or&nbsp;<code>/=</code>, Haskell will see if the value constructors match (there's only one value constructor here though) and then it will check if all the data contained inside matches by testing each pair of fields with&nbsp;<code>==</code>. There's only one catch though, the types of all the fields also have to be part of the&nbsp;<code>Eq</code>&nbsp;typeclass. But since both&nbsp;<code>String</code>&nbsp;and&nbsp;<code>Int</code>&nbsp;are, we're OK. Let's test our&nbsp;<code>Eq</code>&nbsp;instance.</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token keyword">let</span> <span class="token hvariable">mikeD</span> <span class="token operator">=</span> <span class="token constant">Person</span> <span class="token punctuation">{</span><span class="token hvariable">firstName</span> <span class="token operator">=</span> <span class="token string">"Michael"</span><span class="token punctuation">,</span> <span class="token hvariable">lastName</span> <span class="token operator">=</span> <span class="token string">"Diamond"</span><span class="token punctuation">,</span> <span class="token hvariable">age</span> <span class="token operator">=</span> <span class="token number">43</span><span class="token punctuation">}</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token keyword">let</span> <span class="token hvariable">adRock</span> <span class="token operator">=</span> <span class="token constant">Person</span> <span class="token punctuation">{</span><span class="token hvariable">firstName</span> <span class="token operator">=</span> <span class="token string">"Adam"</span><span class="token punctuation">,</span> <span class="token hvariable">lastName</span> <span class="token operator">=</span> <span class="token string">"Horovitz"</span><span class="token punctuation">,</span> <span class="token hvariable">age</span> <span class="token operator">=</span> <span class="token number">41</span><span class="token punctuation">}</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token keyword">let</span> <span class="token hvariable">mca</span> <span class="token operator">=</span> <span class="token constant">Person</span> <span class="token punctuation">{</span><span class="token hvariable">firstName</span> <span class="token operator">=</span> <span class="token string">"Adam"</span><span class="token punctuation">,</span> <span class="token hvariable">lastName</span> <span class="token operator">=</span> <span class="token string">"Yauch"</span><span class="token punctuation">,</span> <span class="token hvariable">age</span> <span class="token operator">=</span> <span class="token number">44</span><span class="token punctuation">}</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token hvariable">mca</span> <span class="token operator">==</span> <span class="token hvariable">adRock</span>
<span class="token constant">False</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token hvariable">mikeD</span> <span class="token operator">==</span> <span class="token hvariable">adRock</span>
<span class="token constant">False</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token hvariable">mikeD</span> <span class="token operator">==</span> <span class="token hvariable">mikeD</span>
<span class="token constant">True</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token hvariable">mikeD</span> <span class="token operator">==</span> <span class="token constant">Person</span> <span class="token punctuation">{</span><span class="token hvariable">firstName</span> <span class="token operator">=</span> <span class="token string">"Michael"</span><span class="token punctuation">,</span> <span class="token hvariable">lastName</span> <span class="token operator">=</span> <span class="token string">"Diamond"</span><span class="token punctuation">,</span> <span class="token hvariable">age</span> <span class="token operator">=</span> <span class="token number">43</span><span class="token punctuation">}</span>
<span class="token constant">True</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Of course, since&nbsp;<code>Person</code>&nbsp;is now in&nbsp;<code>Eq</code>, we can use it as the&nbsp;<code>a</code>&nbsp;for all functions that have a class constraint of&nbsp;<code>Eq a</code>&nbsp;in their type signature, such as&nbsp;<code>elem</code>.</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token keyword">let</span> <span class="token hvariable">beastieBoys</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token hvariable">mca</span><span class="token punctuation">,</span> <span class="token hvariable">adRock</span><span class="token punctuation">,</span> <span class="token hvariable">mikeD</span><span class="token punctuation">]</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token hvariable">mikeD</span> <span class="token operator">`elem`</span> <span class="token hvariable">beastieBoys</span>
<span class="token constant">True</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>The&nbsp;<code>Show</code>&nbsp;and&nbsp;<code>Read</code>&nbsp;typeclasses are for things that can be converted to or from strings, respectively. Like with&nbsp;<code>Eq</code>, if a type's constructors have fields, their type has to be a part of&nbsp;<code>Show</code>&nbsp;or&nbsp;<code>Read</code>&nbsp;if we want to make our type an instance of them. Let's make our&nbsp;<code>Person</code>&nbsp;data type a part of&nbsp;<code>Show</code>&nbsp;and&nbsp;<code>Read</code>&nbsp;as well.</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token keyword">data</span> <span class="token constant">Person</span> <span class="token operator">=</span> <span class="token constant">Person</span> <span class="token punctuation">{</span> <span class="token hvariable">firstName</span> <span class="token operator">::</span> <span class="token constant">String</span>
                     <span class="token punctuation">,</span> <span class="token hvariable">lastName</span> <span class="token operator">::</span> <span class="token constant">String</span>
                     <span class="token punctuation">,</span> <span class="token hvariable">age</span> <span class="token operator">::</span> <span class="token constant">Int</span>
                     <span class="token punctuation">}</span> <span class="token keyword">deriving</span> <span class="token punctuation">(</span><span class="token constant">Eq</span><span class="token punctuation">,</span> <span class="token constant">Show</span><span class="token punctuation">,</span> <span class="token constant">Read</span><span class="token punctuation">)</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Now we can print a person out to the terminal.</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token keyword">let</span> <span class="token hvariable">mikeD</span> <span class="token operator">=</span> <span class="token constant">Person</span> <span class="token punctuation">{</span><span class="token hvariable">firstName</span> <span class="token operator">=</span> <span class="token string">"Michael"</span><span class="token punctuation">,</span> <span class="token hvariable">lastName</span> <span class="token operator">=</span> <span class="token string">"Diamond"</span><span class="token punctuation">,</span> <span class="token hvariable">age</span> <span class="token operator">=</span> <span class="token number">43</span><span class="token punctuation">}</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token hvariable">mikeD</span>
<span class="token constant">Person</span> <span class="token punctuation">{</span><span class="token hvariable">firstName</span> <span class="token operator">=</span> <span class="token string">"Michael"</span><span class="token punctuation">,</span> <span class="token hvariable">lastName</span> <span class="token operator">=</span> <span class="token string">"Diamond"</span><span class="token punctuation">,</span> <span class="token hvariable">age</span> <span class="token operator">=</span> <span class="token number">43</span><span class="token punctuation">}</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token string">"mikeD is: "</span> <span class="token operator">++</span> <span class="token builtin">show</span> <span class="token hvariable">mikeD</span>
<span class="token string">"mikeD is: Person {firstName = \"Michael\", lastName = \"Diamond\", age = 43}"</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Had we tried to print a person on the terminal before making the&nbsp;<code>Person</code>&nbsp;data type part of&nbsp;<code>Show</code>, Haskell would have complained at us, claiming it doesn't know how to represent a person as a string. But now that we've derived a&nbsp;<code>Show</code>&nbsp;instance for it, it does know.</p></div><div><p><code>Read</code>&nbsp;is pretty much the inverse typeclass of&nbsp;<code>Show</code>.&nbsp;<code>Show</code>&nbsp;is for converting values of our a type to a string,&nbsp;<code>Read</code>&nbsp;is for converting strings to values of our type. Remember though, when we use the&nbsp;<code>read</code>&nbsp;function, we have to use an explicit type annotation to tell Haskell which type we want to get as a result. If we don't make the type we want as a result explicit, Haskell doesn't know which type we want.</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token builtin">read</span> <span class="token string">"Person {firstName =\"Michael\", lastName =\"Diamond\", age = 43}"</span> <span class="token operator">::</span> <span class="token constant">Person</span>
<span class="token constant">Person</span> <span class="token punctuation">{</span><span class="token hvariable">firstName</span> <span class="token operator">=</span> <span class="token string">"Michael"</span><span class="token punctuation">,</span> <span class="token hvariable">lastName</span> <span class="token operator">=</span> <span class="token string">"Diamond"</span><span class="token punctuation">,</span> <span class="token hvariable">age</span> <span class="token operator">=</span> <span class="token number">43</span><span class="token punctuation">}</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>If we use the result of our&nbsp;<code>read</code>&nbsp;later on in a way that Haskell can infer that it should read it as a person, we don't have to use type annotation.</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token builtin">read</span> <span class="token string">"Person {firstName =\"Michael\", lastName =\"Diamond\", age = 43}"</span> <span class="token operator">==</span> <span class="token hvariable">mikeD</span>
<span class="token constant">True</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>We can also read parameterized types, but we have to fill in the type parameters. So we can't do&nbsp;<code>read "Just 't'" :: Maybe a</code>, but we can do&nbsp;<code>read "Just 't'" :: Maybe Char</code>.</p></div><div><p>We can derive instances for the&nbsp;<code>Ord</code>&nbsp;type class, which is for types that have values that can be ordered. If we compare two values of the same type that were made using different constructors, the value which was made with a constructor that's defined first is considered smaller. For instance, consider the&nbsp;<code>Bool</code>&nbsp;type, which can have a value of either&nbsp;<code>False</code>&nbsp;or&nbsp;<code>True</code>. For the purpose of seeing how it behaves when compared, we can think of it as being implemented like this:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token keyword">data</span> <span class="token constant">Bool</span> <span class="token operator">=</span> <span class="token constant">False</span> <span class="token operator">|</span> <span class="token constant">True</span> <span class="token keyword">deriving</span> <span class="token punctuation">(</span><span class="token constant">Ord</span><span class="token punctuation">)</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Because the&nbsp;<code>False</code>&nbsp;value constructor is specified first and the&nbsp;<code>True</code>&nbsp;value constructor is specified after it, we can consider&nbsp;<code>True</code>&nbsp;as greater than&nbsp;<code>False</code>.</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token constant">True</span> <span class="token operator">`compare`</span> <span class="token constant">False</span>
<span class="token constant">GT</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token constant">True</span> <span class="token operator">&gt;</span> <span class="token constant">False</span>
<span class="token constant">True</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token constant">True</span> <span class="token operator">&lt;</span> <span class="token constant">False</span>
<span class="token constant">False</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>In the&nbsp;<code>Maybe a</code>&nbsp;data type, the&nbsp;<code>Nothing</code>&nbsp;value constructor is specified before the&nbsp;<code>Just</code>&nbsp;value constructor, so a value of&nbsp;<code>Nothing</code>&nbsp;is always smaller than a value of&nbsp;<code>Just something</code>, even if that something is minus one billion trillion. But if we compare two&nbsp;<code>Just</code>&nbsp;values, then it goes to compare what's inside them.</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token constant">Nothing</span> <span class="token operator">&lt;</span> <span class="token constant">Just</span> <span class="token number">100</span>
<span class="token constant">True</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token constant">Nothing</span> <span class="token operator">&gt;</span> <span class="token constant">Just</span> <span class="token punctuation">(</span><span class="token operator">-</span><span class="token number">49999</span><span class="token punctuation">)</span>
<span class="token constant">False</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token constant">Just</span> <span class="token number">3</span> <span class="token operator">`compare`</span> <span class="token constant">Just</span> <span class="token number">2</span>
<span class="token constant">GT</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token constant">Just</span> <span class="token number">100</span> <span class="token operator">&gt;</span> <span class="token constant">Just</span> <span class="token number">50</span>
<span class="token constant">True</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>But we can't do something like&nbsp;<code>Just (*3) &gt; Just (*2)</code>, because&nbsp;<code>(*3)</code>&nbsp;and&nbsp;<code>(*2)</code>&nbsp;are functions, which aren't instances of&nbsp;<code>Ord</code>.</p></div><div><p>We can easily use algebraic data types to make enumerations and the&nbsp;<code>Enum</code>&nbsp;and&nbsp;<code>Bounded</code>&nbsp;typeclasses help us with that. Consider the following data type:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token keyword">data</span> <span class="token constant">Day</span> <span class="token operator">=</span> <span class="token constant">Monday</span> <span class="token operator">|</span> <span class="token constant">Tuesday</span> <span class="token operator">|</span> <span class="token constant">Wednesday</span> <span class="token operator">|</span> <span class="token constant">Thursday</span> <span class="token operator">|</span> <span class="token constant">Friday</span> <span class="token operator">|</span> <span class="token constant">Saturday</span> <span class="token operator">|</span> <span class="token constant">Sunday</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Because all the value constructors are nullary (take no parameters, i.e. fields), we can make it part of the&nbsp;<code>Enum</code>&nbsp;typeclass. The&nbsp;<code>Enum</code>&nbsp;typeclass is for things that have predecessors and successors. We can also make it part of the&nbsp;<code>Bounded</code>&nbsp;typeclass, which is for things that have a lowest possible value and highest possible value. And while we're at it, let's also make it an instance of all the other derivable typeclasses and see what we can do with it.</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token keyword">data</span> <span class="token constant">Day</span> <span class="token operator">=</span> <span class="token constant">Monday</span> <span class="token operator">|</span> <span class="token constant">Tuesday</span> <span class="token operator">|</span> <span class="token constant">Wednesday</span> <span class="token operator">|</span> <span class="token constant">Thursday</span> <span class="token operator">|</span> <span class="token constant">Friday</span> <span class="token operator">|</span> <span class="token constant">Saturday</span> <span class="token operator">|</span> <span class="token constant">Sunday</span> 
           <span class="token keyword">deriving</span> <span class="token punctuation">(</span><span class="token constant">Eq</span><span class="token punctuation">,</span> <span class="token constant">Ord</span><span class="token punctuation">,</span> <span class="token constant">Show</span><span class="token punctuation">,</span> <span class="token constant">Read</span><span class="token punctuation">,</span> <span class="token constant">Bounded</span><span class="token punctuation">,</span> <span class="token constant">Enum</span><span class="token punctuation">)</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Because it's part of the&nbsp;<code>Show</code>&nbsp;and&nbsp;<code>Read</code>&nbsp;typeclasses, we can convert values of this type to and from strings.</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token constant">Wednesday</span>
<span class="token constant">Wednesday</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token builtin">show</span> <span class="token constant">Wednesday</span>
<span class="token string">"Wednesday"</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token builtin">read</span> <span class="token string">"Saturday"</span> <span class="token operator">::</span> <span class="token constant">Day</span>
<span class="token constant">Saturday</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Because it's part of the&nbsp;<code>Eq</code>&nbsp;and&nbsp;<code>Ord</code>&nbsp;typeclasses, we can compare or equate days.</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token constant">Saturday</span> <span class="token operator">==</span> <span class="token constant">Sunday</span>
<span class="token constant">False</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token constant">Saturday</span> <span class="token operator">==</span> <span class="token constant">Saturday</span>
<span class="token constant">True</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token constant">Saturday</span> <span class="token operator">&gt;</span> <span class="token constant">Friday</span>
<span class="token constant">True</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token constant">Monday</span> <span class="token operator">`compare`</span> <span class="token constant">Wednesday</span>
<span class="token constant">LT</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>It's also part of&nbsp;<code>Bounded</code>, so we can get the lowest and highest day.</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token builtin">minBound</span> <span class="token operator">::</span> <span class="token constant">Day</span>
<span class="token constant">Monday</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token builtin">maxBound</span> <span class="token operator">::</span> <span class="token constant">Day</span>
<span class="token constant">Sunday</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>It's also an instance of&nbsp;<code>Enum</code>. We can get predecessors and successors of days and we can make list ranges from them!</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token builtin">succ</span> <span class="token constant">Monday</span>
<span class="token constant">Tuesday</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token builtin">pred</span> <span class="token constant">Saturday</span>
<span class="token constant">Friday</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token punctuation">[</span><span class="token constant">Thursday</span> <span class="token operator">..</span> <span class="token constant">Sunday</span><span class="token punctuation">]</span>
<span class="token punctuation">[</span><span class="token constant">Thursday</span><span class="token punctuation">,</span><span class="token constant">Friday</span><span class="token punctuation">,</span><span class="token constant">Saturday</span><span class="token punctuation">,</span><span class="token constant">Sunday</span><span class="token punctuation">]</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token punctuation">[</span><span class="token builtin">minBound</span> <span class="token operator">..</span> <span class="token builtin">maxBound</span><span class="token punctuation">]</span> <span class="token operator">::</span> <span class="token punctuation">[</span><span class="token constant">Day</span><span class="token punctuation">]</span>
<span class="token punctuation">[</span><span class="token constant">Monday</span><span class="token punctuation">,</span><span class="token constant">Tuesday</span><span class="token punctuation">,</span><span class="token constant">Wednesday</span><span class="token punctuation">,</span><span class="token constant">Thursday</span><span class="token punctuation">,</span><span class="token constant">Friday</span><span class="token punctuation">,</span><span class="token constant">Saturday</span><span class="token punctuation">,</span><span class="token constant">Sunday</span><span class="token punctuation">]</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>That's pretty awesome.</p></div><div><h2 data-heading="Type synonyms" id="Type_synonyms" style="display: flex;"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>Type synonyms</h2></div><div><p>Previously, we mentioned that when writing types, the&nbsp;<code>[Char]</code>&nbsp;and&nbsp;<code>String</code>&nbsp;types are equivalent and interchangeable. That's implemented with&nbsp;<strong>type synonyms</strong>. Type synonyms don't really do anything per se, they're just about giving some types different names so that they make more sense to someone reading our code and documentation. Here's how the standard library defines&nbsp;<code>String</code>&nbsp;as a synonym for&nbsp;<code>[Char]</code>.</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"> <span class="token keyword">type</span> <span class="token constant">String</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token constant">Char</span><span class="token punctuation">]</span>
 
</code><button class="copy-code-button">Копировать</button></pre></div><div><p><img alt="chicken" src="http://s3.amazonaws.com/lyah/chicken.png" referrerpolicy="no-referrer"></p></div><div><p>We've introduced the&nbsp;<em>type</em>&nbsp;keyword. The keyword might be misleading to some, because we're not actually making anything new (we did that with the&nbsp;<em>data</em>&nbsp;keyword), but we're just making a synonym for an already existing type.</p></div><div><p>If we make a function that converts a string to uppercase and call it&nbsp;<code>toUpperString</code>&nbsp;or something, we can give it a type declaration of&nbsp;<code>toUpperString :: [Char] -&gt; [Char]</code>&nbsp;or&nbsp;<code>toUpperString :: String -&gt; String</code>. Both of these are essentially the same, only the latter is nicer to read.</p></div><div><p>When we were dealing with the&nbsp;<code>Data.Map</code>&nbsp;module, we first represented a phonebook with an association list before converting it into a map. As we've already found out, an association list is a list of key-value pairs. Let's look at a phonebook that we had.</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">phoneBook</span> <span class="token operator">::</span> <span class="token punctuation">[</span><span class="token punctuation">(</span><span class="token constant">String</span><span class="token punctuation">,</span><span class="token constant">String</span><span class="token punctuation">)</span><span class="token punctuation">]</span>
<span class="token hvariable">phoneBook</span> <span class="token operator">=</span>    
    <span class="token punctuation">[</span><span class="token punctuation">(</span><span class="token string">"betty"</span><span class="token punctuation">,</span><span class="token string">"555-2938"</span><span class="token punctuation">)</span>   
    <span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token string">"bonnie"</span><span class="token punctuation">,</span><span class="token string">"452-2928"</span><span class="token punctuation">)</span>   
    <span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token string">"patsy"</span><span class="token punctuation">,</span><span class="token string">"493-2928"</span><span class="token punctuation">)</span>   
    <span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token string">"lucille"</span><span class="token punctuation">,</span><span class="token string">"205-2928"</span><span class="token punctuation">)</span>   
    <span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token string">"wendy"</span><span class="token punctuation">,</span><span class="token string">"939-8282"</span><span class="token punctuation">)</span>   
    <span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token string">"penny"</span><span class="token punctuation">,</span><span class="token string">"853-2492"</span><span class="token punctuation">)</span>   
    <span class="token punctuation">]</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>We see that the type of&nbsp;<code>phoneBook</code>&nbsp;is&nbsp;<code>[(String,String)]</code>. That tells us that it's an association list that maps from strings to strings, but not much else. Let's make a type synonym to convey some more information in the type declaration.</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token keyword">type</span> <span class="token constant">PhoneBook</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">(</span><span class="token constant">String</span><span class="token punctuation">,</span><span class="token constant">String</span><span class="token punctuation">)</span><span class="token punctuation">]</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Now the type declaration for our phonebook can be&nbsp;<code>phoneBook :: PhoneBook</code>. Let's make a type synonym for&nbsp;<code>String</code>&nbsp;as well.</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token keyword">type</span> <span class="token constant">PhoneNumber</span> <span class="token operator">=</span> <span class="token constant">String</span>
<span class="token keyword">type</span> <span class="token constant">Name</span> <span class="token operator">=</span> <span class="token constant">String</span>
<span class="token keyword">type</span> <span class="token constant">PhoneBook</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">(</span><span class="token constant">Name</span><span class="token punctuation">,</span><span class="token constant">PhoneNumber</span><span class="token punctuation">)</span><span class="token punctuation">]</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Giving the&nbsp;<code>String</code>&nbsp;type synonyms is something that Haskell programmers do when they want to convey more information about what strings in their functions should be used as and what they represent.</p></div><div><p>So now, when we implement a function that takes a name and a number and sees if that name and number combination is in our phonebook, we can give it a very pretty and descriptive type declaration.</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">inPhoneBook</span> <span class="token operator">::</span> <span class="token constant">Name</span> <span class="token operator">-&gt;</span> <span class="token constant">PhoneNumber</span> <span class="token operator">-&gt;</span> <span class="token constant">PhoneBook</span> <span class="token operator">-&gt;</span> <span class="token constant">Bool</span>
<span class="token hvariable">inPhoneBook</span> <span class="token hvariable">name</span> <span class="token hvariable">pnumber</span> <span class="token hvariable">pbook</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token hvariable">name</span><span class="token punctuation">,</span><span class="token hvariable">pnumber</span><span class="token punctuation">)</span> <span class="token operator">`elem`</span> <span class="token hvariable">pbook</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>If we decided not to use type synonyms, our function would have a type of&nbsp;<code>String -&gt; String -&gt; [(String,String)] -&gt; Bool</code>. In this case, the type declaration that took advantage of type synonyms is easier to understand. However, you shouldn't go overboard with them. We introduce type synonyms either to describe what some existing type represents in our functions (and thus our type declarations become better documentation) or when something has a long-ish type that's repeated a lot (like&nbsp;<code>[(String,String)]</code>) but represents something more specific in the context of our functions.</p></div><div><p>Type synonyms can also be parameterized. If we want a type that represents an association list type but still want it to be general so it can use any type as the keys and values, we can do this:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token keyword">type</span> <span class="token constant">AssocList</span> <span class="token hvariable">k</span> <span class="token hvariable">v</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">(</span><span class="token hvariable">k</span><span class="token punctuation">,</span><span class="token hvariable">v</span><span class="token punctuation">)</span><span class="token punctuation">]</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Now, a function that gets the value by a key in an association list can have a type of&nbsp;<code>(Eq k) =&gt; k -&gt; AssocList k v -&gt; Maybe v</code>.&nbsp;<code>AssocList</code>&nbsp;is a type constructor that takes two types and produces a concrete type, like&nbsp;<code>AssocList Int String</code>, for instance.</p></div><div><p><em>Fonzie says:</em>&nbsp;Aaay! When I talk about&nbsp;<em>concrete types</em>&nbsp;I mean like fully applied types like&nbsp;Map Int String&nbsp;or if we're dealin' with one of them polymorphic functions,&nbsp;[a]&nbsp;or&nbsp;(Ord a) =&gt; Maybe a&nbsp;and stuff. And like, sometimes me and the boys say that&nbsp;Maybe&nbsp;is a type, but we don't mean that, cause every idiot knows&nbsp;Maybe&nbsp;is a type constructor. When I apply an extra type to&nbsp;Maybe, like&nbsp;Maybe String, then I have a concrete type. You know, values can only have types that are concrete types! So in conclusion, live fast, love hard and don't let anybody else use your comb!</p></div><div><p>Just like we can partially apply functions to get new functions, we can partially apply type parameters and get new type constructors from them. Just like we call a function with too few parameters to get back a new function, we can specify a type constructor with too few type parameters and get back a partially applied type constructor. If we wanted a type that represents a map (from&nbsp;<code>Data.Map</code>) from integers to something, we could either do this:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token keyword">type</span> <span class="token constant">IntMap</span> <span class="token hvariable">v</span> <span class="token operator">=</span> <span class="token constant">Map</span> <span class="token constant">Int</span> <span class="token hvariable">v</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Or we could do it like this:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token keyword">type</span> <span class="token constant">IntMap</span> <span class="token operator">=</span> <span class="token constant">Map</span> <span class="token constant">Int</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Either way, the&nbsp;<code>IntMap</code>&nbsp;type constructor takes one parameter and that is the type of what the integers will point to.</p></div><div><p><em>Oh yeah</em>. If you're going to try and implement this, you'll probably going to do a qualified import of&nbsp;Data.Map. When you do a qualified import, type constructors also have to be preceeded with a module name. So you'd write&nbsp;type IntMap = Map.Map Int.</p></div><div><p>Make sure that you really understand the distinction between type constructors and value constructors. Just because we made a type synonym called&nbsp;<code>IntMap</code>&nbsp;or&nbsp;<code>AssocList</code>&nbsp;doesn't mean that we can do stuff like&nbsp;<code>AssocList [(1,2),(4,5),(7,9)]</code>. All it means is that we can refer to its type by using different names. We can do&nbsp;<code>[(1,2),(3,5),(8,9)] :: AssocList Int Int</code>, which will make the numbers inside assume a type of&nbsp;<code>Int</code>, but we can still use that list as we would any normal list that has pairs of integers inside. Type synonyms (and types generally) can only be used in the type portion of Haskell. We're in Haskell's type portion whenever we're defining new types (so in&nbsp;<em>data</em>&nbsp;and&nbsp;<em>type</em>&nbsp;declarations) or when we're located after a&nbsp;<code>::</code>. The&nbsp;<code>::</code>&nbsp;is in type declarations or in type annotations.</p></div><div><p>Another cool data type that takes two types as its parameters is the&nbsp;<code>Either a b</code>&nbsp;type. This is roughly how it's defined:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token keyword">data</span> <span class="token constant">Either</span> <span class="token hvariable">a</span> <span class="token hvariable">b</span> <span class="token operator">=</span> <span class="token constant">Left</span> <span class="token hvariable">a</span> <span class="token operator">|</span> <span class="token constant">Right</span> <span class="token hvariable">b</span> <span class="token keyword">deriving</span> <span class="token punctuation">(</span><span class="token constant">Eq</span><span class="token punctuation">,</span> <span class="token constant">Ord</span><span class="token punctuation">,</span> <span class="token constant">Read</span><span class="token punctuation">,</span> <span class="token constant">Show</span><span class="token punctuation">)</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>It has two value constructors. If the&nbsp;<code>Left</code>&nbsp;is used, then its contents are of type&nbsp;<code>a</code>&nbsp;and if&nbsp;<code>Right</code>&nbsp;is used, then its contents are of type&nbsp;<code>b</code>. So we can use this type to encapsulate a value of one type or another and then when we get a value of type&nbsp;<code>Either a b</code>, we usually pattern match on both&nbsp;<code>Left</code>&nbsp;and&nbsp;<code>Right</code>&nbsp;and we different stuff based on which one of them it was.</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token constant">Right</span> <span class="token number">20</span>
<span class="token constant">Right</span> <span class="token number">20</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token constant">Left</span> <span class="token string">"w00t"</span>
<span class="token constant">Left</span> <span class="token string">"w00t"</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token operator">:</span><span class="token hvariable">t</span> <span class="token constant">Right</span> <span class="token char string">'a'</span>
<span class="token constant">Right</span> <span class="token char string">'a'</span> <span class="token operator">::</span> <span class="token constant">Either</span> <span class="token hvariable">a</span> <span class="token constant">Char</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token operator">:</span><span class="token hvariable">t</span> <span class="token constant">Left</span> <span class="token constant">True</span>
<span class="token constant">Left</span> <span class="token constant">True</span> <span class="token operator">::</span> <span class="token constant">Either</span> <span class="token constant">Bool</span> <span class="token hvariable">b</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>So far, we've seen that&nbsp;<code>Maybe a</code>&nbsp;was mostly used to represent the results of computations that could have either failed or not. But somtimes,&nbsp;<code>Maybe a</code>&nbsp;isn't good enough because&nbsp;<code>Nothing</code>&nbsp;doesn't really convey much information other than that something has failed. That's cool for functions that can fail in only one way or if we're just not interested in how and why they failed. A&nbsp;<code>Data.Map</code>&nbsp;lookup fails only if the key we were looking for wasn't in the map, so we know exactly what happened. However, when we're interested in how some function failed or why, we usually use the result type of&nbsp;<code>Either a b</code>, where&nbsp;<code>a</code>&nbsp;is some sort of type that can tell us something about the possible failure and&nbsp;<code>b</code>&nbsp;is the type of a successful computation. Hence, errors use the&nbsp;<code>Left</code>&nbsp;value constructor while results use&nbsp;<code>Right</code>.</p></div><div><p>An example: a high-school has lockers so that students have some place to put their Guns'n'Roses posters. Each locker has a code combination. When a student wants a new locker, they tell the locker supervisor which locker number they want and he gives them the code. However, if someone is already using that locker, he can't tell them the code for the locker and they have to pick a different one. We'll use a map from&nbsp;<code>Data.Map</code>&nbsp;to represent the lockers. It'll map from locker numbers to a pair of whether the locker is in use or not and the locker code.</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token import-statement"><span class="token keyword">import</span> <span class="token keyword">qualified</span> Data<span class="token punctuation">.</span>Map <span class="token keyword">as</span> Map</span>

<span class="token keyword">data</span> <span class="token constant">LockerState</span> <span class="token operator">=</span> <span class="token constant">Taken</span> <span class="token operator">|</span> <span class="token constant">Free</span> <span class="token keyword">deriving</span> <span class="token punctuation">(</span><span class="token constant">Show</span><span class="token punctuation">,</span> <span class="token constant">Eq</span><span class="token punctuation">)</span>

<span class="token keyword">type</span> <span class="token constant">Code</span> <span class="token operator">=</span> <span class="token constant">String</span>

<span class="token keyword">type</span> <span class="token constant">LockerMap</span> <span class="token operator">=</span> <span class="token constant">Map<span class="token punctuation">.</span>Map</span> <span class="token constant">Int</span> <span class="token punctuation">(</span><span class="token constant">LockerState</span><span class="token punctuation">,</span> <span class="token constant">Code</span><span class="token punctuation">)</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Simple stuff. We introduce a new data type to represent whether a locker is taken or free and we make a type synonym for the locker code. We also make a type synonym for the type that maps from integers to pairs of locker state and code. And now, we're going to make a function that searches for the code in a locker map. We're going to use an&nbsp;<code>Either String Code</code>&nbsp;type to represent our result, because our lookup can fail in two ways — the locker can be taken, in which case we can't tell the code or the locker number might not exist at all. If the lookup fails, we're just going to use a&nbsp;<code>String</code>&nbsp;to tell what's happened.</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">lockerLookup</span> <span class="token operator">::</span> <span class="token constant">Int</span> <span class="token operator">-&gt;</span> <span class="token constant">LockerMap</span> <span class="token operator">-&gt;</span> <span class="token constant">Either</span> <span class="token constant">String</span> <span class="token constant">Code</span>
<span class="token hvariable">lockerLookup</span> <span class="token hvariable">lockerNumber</span> <span class="token builtin">map</span> <span class="token operator">=</span> 
    <span class="token keyword">case</span> <span class="token constant">Map</span><span class="token punctuation">.</span><span class="token builtin">lookup</span> <span class="token hvariable">lockerNumber</span> <span class="token builtin">map</span> <span class="token keyword">of</span> 
        <span class="token constant">Nothing</span> <span class="token operator">-&gt;</span> <span class="token constant">Left</span> <span class="token operator">$</span> <span class="token string">"Locker number "</span> <span class="token operator">++</span> <span class="token builtin">show</span> <span class="token hvariable">lockerNumber</span> <span class="token operator">++</span> <span class="token string">" doesn't exist!"</span>
        <span class="token constant">Just</span> <span class="token punctuation">(</span><span class="token hvariable">state</span><span class="token punctuation">,</span> <span class="token hvariable">code</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token keyword">if</span> <span class="token hvariable">state</span> <span class="token operator">/=</span> <span class="token constant">Taken</span> 
                                <span class="token keyword">then</span> <span class="token constant">Right</span> <span class="token hvariable">code</span>
                                <span class="token keyword">else</span> <span class="token constant">Left</span> <span class="token operator">$</span> <span class="token string">"Locker "</span> <span class="token operator">++</span> <span class="token builtin">show</span> <span class="token hvariable">lockerNumber</span> <span class="token operator">++</span> <span class="token string">" is already taken!"</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>We do a normal lookup in the map. If we get a&nbsp;<code>Nothing</code>, we return a value of type&nbsp;<code>Left String</code>, saying that the locker doesn't exist at all. If we do find it, then we do an additional check to see if the locker is taken. If it is, return a&nbsp;<code>Left</code>&nbsp;saying that it's already taken. If it isn't, then return a value of type&nbsp;<code>Right Code</code>, in which we give the student the correct code for the locker. It's actually a&nbsp;<code>Right String</code>, but we introduced that type synonym to introduce some additional documentation into the type declaration. Here's an example map:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">lockers</span> <span class="token operator">::</span> <span class="token constant">LockerMap</span>
<span class="token hvariable">lockers</span> <span class="token operator">=</span> <span class="token hvariable">Map<span class="token punctuation">.</span>fromList</span> 
    <span class="token punctuation">[</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token constant">Taken</span><span class="token punctuation">,</span><span class="token string">"ZD39I"</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token number">101</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token constant">Free</span><span class="token punctuation">,</span><span class="token string">"JAH3I"</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token number">103</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token constant">Free</span><span class="token punctuation">,</span><span class="token string">"IQSA9"</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token number">105</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token constant">Free</span><span class="token punctuation">,</span><span class="token string">"QOTSA"</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token number">109</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token constant">Taken</span><span class="token punctuation">,</span><span class="token string">"893JJ"</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token number">110</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token constant">Taken</span><span class="token punctuation">,</span><span class="token string">"99292"</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token punctuation">]</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Now let's try looking up some locker codes.</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token hvariable">lockerLookup</span> <span class="token number">101</span> <span class="token hvariable">lockers</span>
<span class="token constant">Right</span> <span class="token string">"JAH3I"</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token hvariable">lockerLookup</span> <span class="token number">100</span> <span class="token hvariable">lockers</span>
<span class="token constant">Left</span> <span class="token string">"Locker 100 is already taken!"</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token hvariable">lockerLookup</span> <span class="token number">102</span> <span class="token hvariable">lockers</span>
<span class="token constant">Left</span> <span class="token string">"Locker number 102 doesn't exist!"</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token hvariable">lockerLookup</span> <span class="token number">110</span> <span class="token hvariable">lockers</span>
<span class="token constant">Left</span> <span class="token string">"Locker 110 is already taken!"</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token hvariable">lockerLookup</span> <span class="token number">105</span> <span class="token hvariable">lockers</span>
<span class="token constant">Right</span> <span class="token string">"QOTSA"</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>We could have used a&nbsp;<code>Maybe a</code>&nbsp;to represent the result but then we wouldn't know why we couldn't get the code. But now, we have information about the failure in our result type.</p></div><div><h2 data-heading="Recursive data structures" id="Recursive_data_structures" style="display: flex;"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>Recursive data structures</h2></div><div><p><img alt="the fonz" src="http://s3.amazonaws.com/lyah/thefonz.png" referrerpolicy="no-referrer"></p></div><div><p>As we've seen, a constructor in an algebraic data type can have several (or none at all) fields and each field must be of some concrete type. With that in mind, we can make types whose constructors have fields that are of the same type! Using that, we can create recursive data types, where one value of some type contains values of that type, which in turn contain more values of the same type and so on.</p></div><div><p>Think about this list:&nbsp;<code>[5]</code>. That's just syntactic sugar for&nbsp;<code>5:[]</code>. On the left side of the&nbsp;<code>:</code>, there's a value and on the right side, there's a list. And in this case, it's an empty list. Now how about the list&nbsp;<code>[4,5]</code>? Well, that desugars to&nbsp;<code>4:(5:[])</code>. Looking at the first&nbsp;<code>:</code>, we see that it also has an element on its left side and a list (<code>5:[]</code>) on its right side. Same goes for a list like&nbsp;<code>3:(4:(5:6:[]))</code>, which could be written either like that or like&nbsp;<code>3:4:5:6:[]</code>&nbsp;(because&nbsp;<code>:</code>&nbsp;is right-associative) or&nbsp;<code>[3,4,5,6]</code>.</p></div><div><p>We could say that a list can be an empty list or it can be an element joined together with a&nbsp;<code>:</code>&nbsp;with another list (that can be either the empty list or not).</p></div><div><p>Let's use algebraic data types to implement our own list then!</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token keyword">data</span> <span class="token constant">List</span> <span class="token hvariable">a</span> <span class="token operator">=</span> <span class="token constant">Empty</span> <span class="token operator">|</span> <span class="token constant">Cons</span> <span class="token hvariable">a</span> <span class="token punctuation">(</span><span class="token constant">List</span> <span class="token hvariable">a</span><span class="token punctuation">)</span> <span class="token keyword">deriving</span> <span class="token punctuation">(</span><span class="token constant">Show</span><span class="token punctuation">,</span> <span class="token constant">Read</span><span class="token punctuation">,</span> <span class="token constant">Eq</span><span class="token punctuation">,</span> <span class="token constant">Ord</span><span class="token punctuation">)</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>This reads just like our definition of lists from one of the previous paragraphs. It's either an empty list or a combination of a head with some value and a list. If you're confused about this, you might find it easier to understand in record syntax.</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token keyword">data</span> <span class="token constant">List</span> <span class="token hvariable">a</span> <span class="token operator">=</span> <span class="token constant">Empty</span> <span class="token operator">|</span> <span class="token constant">Cons</span> <span class="token punctuation">{</span> <span class="token hvariable">listHead</span> <span class="token operator">::</span> <span class="token hvariable">a</span><span class="token punctuation">,</span> <span class="token hvariable">listTail</span> <span class="token operator">::</span> <span class="token constant">List</span> <span class="token hvariable">a</span><span class="token punctuation">}</span> <span class="token keyword">deriving</span> <span class="token punctuation">(</span><span class="token constant">Show</span><span class="token punctuation">,</span> <span class="token constant">Read</span><span class="token punctuation">,</span> <span class="token constant">Eq</span><span class="token punctuation">,</span> <span class="token constant">Ord</span><span class="token punctuation">)</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>You might also be confused about the&nbsp;<code>Cons</code>&nbsp;constructor here.&nbsp;<em>cons</em>&nbsp;is another word for&nbsp;<code>:</code>. You see, in lists,&nbsp;<code>:</code>&nbsp;is actually a constructor that takes a value and another list and returns a list. We can already use our new list type! In other words, it has two fields. One field is of the type of&nbsp;<code>a</code>&nbsp;and the other is of the type&nbsp;<code>[a]</code>.</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token constant">Empty</span>
<span class="token constant">Empty</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token number">5</span> `<span class="token constant">Cons</span>` <span class="token constant">Empty</span>
<span class="token constant">Cons</span> <span class="token number">5</span> <span class="token constant">Empty</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token number">4</span> `<span class="token constant">Cons</span>` <span class="token punctuation">(</span><span class="token number">5</span> `<span class="token constant">Cons</span>` <span class="token constant">Empty</span><span class="token punctuation">)</span>
<span class="token constant">Cons</span> <span class="token number">4</span> <span class="token punctuation">(</span><span class="token constant">Cons</span> <span class="token number">5</span> <span class="token constant">Empty</span><span class="token punctuation">)</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token number">3</span> `<span class="token constant">Cons</span>` <span class="token punctuation">(</span><span class="token number">4</span> `<span class="token constant">Cons</span>` <span class="token punctuation">(</span><span class="token number">5</span> `<span class="token constant">Cons</span>` <span class="token constant">Empty</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token constant">Cons</span> <span class="token number">3</span> <span class="token punctuation">(</span><span class="token constant">Cons</span> <span class="token number">4</span> <span class="token punctuation">(</span><span class="token constant">Cons</span> <span class="token number">5</span> <span class="token constant">Empty</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>We called our&nbsp;<code>Cons</code>&nbsp;constructor in an infix manner so you can see how it's just like&nbsp;<code>:</code>.&nbsp;<code>Empty</code>&nbsp;is like&nbsp;<code>[]</code>&nbsp;and&nbsp;<code>4 `Cons` (5 `Cons` Empty)</code>&nbsp;is like&nbsp;<code>4:(5:[])</code>.</p></div><div><p>We can define functions to be automatically infix by making them comprised of only special characters. We can also do the same with constructors, since they're just functions that return a data type. So check this out.</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token keyword">infixr</span> <span class="token number">5</span> <span class="token operator">:-:</span>
<span class="token keyword">data</span> <span class="token constant">List</span> <span class="token hvariable">a</span> <span class="token operator">=</span> <span class="token constant">Empty</span> <span class="token operator">|</span> <span class="token hvariable">a</span> <span class="token operator">:-:</span> <span class="token punctuation">(</span><span class="token constant">List</span> <span class="token hvariable">a</span><span class="token punctuation">)</span> <span class="token keyword">deriving</span> <span class="token punctuation">(</span><span class="token constant">Show</span><span class="token punctuation">,</span> <span class="token constant">Read</span><span class="token punctuation">,</span> <span class="token constant">Eq</span><span class="token punctuation">,</span> <span class="token constant">Ord</span><span class="token punctuation">)</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>First off, we notice a new syntactic construct, the fixity declarations. When we define functions as operators, we can use that to give them a fixity (but we don't have to). A fixity states how tightly the operator binds and whether it's left-associative or right-associative. For instance,&nbsp;<code>*</code>'s fixity is&nbsp;<code>infixl 7 *</code>&nbsp;and&nbsp;<code>+</code>'s fixity is&nbsp;<code>infixl 6</code>. That means that they're both left-associative (<code>4 * 3 * 2</code>&nbsp;is&nbsp;<code>(4 * 3) * 2</code>) but&nbsp;<code>*</code>&nbsp;binds tighter than&nbsp;<code>+</code>, because it has a greater fixity, so&nbsp;<code>5 * 4 + 3</code>&nbsp;is&nbsp;<code>(5 * 4) + 3</code>.</p></div><div><p>Otherwise, we just wrote&nbsp;<code>a :-: (List a)</code>&nbsp;instead of&nbsp;<code>Cons a (List a)</code>. Now, we can write out lists in our list type like so:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token number">3</span> <span class="token operator">:-:</span> <span class="token number">4</span> <span class="token operator">:-:</span> <span class="token number">5</span> <span class="token operator">:-:</span> <span class="token constant">Empty</span>
<span class="token punctuation">(</span><span class="token operator">:-:</span><span class="token punctuation">)</span> <span class="token number">3</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token operator">:-:</span><span class="token punctuation">)</span> <span class="token number">4</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token operator">:-:</span><span class="token punctuation">)</span> <span class="token number">5</span> <span class="token constant">Empty</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token keyword">let</span> <span class="token hvariable">a</span> <span class="token operator">=</span> <span class="token number">3</span> <span class="token operator">:-:</span> <span class="token number">4</span> <span class="token operator">:-:</span> <span class="token number">5</span> <span class="token operator">:-:</span> <span class="token constant">Empty</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token number">100</span> <span class="token operator">:-:</span> <span class="token hvariable">a</span>
<span class="token punctuation">(</span><span class="token operator">:-:</span><span class="token punctuation">)</span> <span class="token number">100</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token operator">:-:</span><span class="token punctuation">)</span> <span class="token number">3</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token operator">:-:</span><span class="token punctuation">)</span> <span class="token number">4</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token operator">:-:</span><span class="token punctuation">)</span> <span class="token number">5</span> <span class="token constant">Empty</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>When deriving&nbsp;<code>Show</code>&nbsp;for our type, Haskell will still display it as if the constructor was a prefix function, hence the parentheses around the operator (remember,&nbsp;<code>4 + 3</code>&nbsp;is&nbsp;<code>(+) 4 3</code>).</p></div><div><p>Let's make a function that adds two of our lists together. This is how&nbsp;<code>++</code>&nbsp;is defined for normal lists:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token keyword">infixr</span> <span class="token number">5</span>  <span class="token operator">++</span>
<span class="token punctuation">(</span><span class="token operator">++</span><span class="token punctuation">)</span> <span class="token operator">::</span> <span class="token punctuation">[</span><span class="token hvariable">a</span><span class="token punctuation">]</span> <span class="token operator">-&gt;</span> <span class="token punctuation">[</span><span class="token hvariable">a</span><span class="token punctuation">]</span> <span class="token operator">-&gt;</span> <span class="token punctuation">[</span><span class="token hvariable">a</span><span class="token punctuation">]</span>
<span class="token punctuation">[</span><span class="token punctuation">]</span>     <span class="token operator">++</span> <span class="token hvariable">ys</span> <span class="token operator">=</span> <span class="token hvariable">ys</span>
<span class="token punctuation">(</span><span class="token hvariable">x</span><span class="token operator">:</span><span class="token hvariable">xs</span><span class="token punctuation">)</span> <span class="token operator">++</span> <span class="token hvariable">ys</span> <span class="token operator">=</span> <span class="token hvariable">x</span> <span class="token operator">:</span> <span class="token punctuation">(</span><span class="token hvariable">xs</span> <span class="token operator">++</span> <span class="token hvariable">ys</span><span class="token punctuation">)</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>So we'll just steal that for our own list. We'll name the function&nbsp;<code>.++</code>.</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token keyword">infixr</span> <span class="token number">5</span>  <span class="token operator">.++</span>
<span class="token punctuation">(</span><span class="token operator">.++</span><span class="token punctuation">)</span> <span class="token operator">::</span> <span class="token constant">List</span> <span class="token hvariable">a</span> <span class="token operator">-&gt;</span> <span class="token constant">List</span> <span class="token hvariable">a</span> <span class="token operator">-&gt;</span> <span class="token constant">List</span> <span class="token hvariable">a</span> 
<span class="token constant">Empty</span> <span class="token operator">.++</span> <span class="token hvariable">ys</span> <span class="token operator">=</span> <span class="token hvariable">ys</span>
<span class="token punctuation">(</span><span class="token hvariable">x</span> <span class="token operator">:-:</span> <span class="token hvariable">xs</span><span class="token punctuation">)</span> <span class="token operator">.++</span> <span class="token hvariable">ys</span> <span class="token operator">=</span> <span class="token hvariable">x</span> <span class="token operator">:-:</span> <span class="token punctuation">(</span><span class="token hvariable">xs</span> <span class="token operator">.++</span> <span class="token hvariable">ys</span><span class="token punctuation">)</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>And let's see if it works ...</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token keyword">let</span> <span class="token hvariable">a</span> <span class="token operator">=</span> <span class="token number">3</span> <span class="token operator">:-:</span> <span class="token number">4</span> <span class="token operator">:-:</span> <span class="token number">5</span> <span class="token operator">:-:</span> <span class="token constant">Empty</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token keyword">let</span> <span class="token hvariable">b</span> <span class="token operator">=</span> <span class="token number">6</span> <span class="token operator">:-:</span> <span class="token number">7</span> <span class="token operator">:-:</span> <span class="token constant">Empty</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token hvariable">a</span> <span class="token operator">.++</span> <span class="token hvariable">b</span>
<span class="token punctuation">(</span><span class="token operator">:-:</span><span class="token punctuation">)</span> <span class="token number">3</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token operator">:-:</span><span class="token punctuation">)</span> <span class="token number">4</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token operator">:-:</span><span class="token punctuation">)</span> <span class="token number">5</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token operator">:-:</span><span class="token punctuation">)</span> <span class="token number">6</span> <span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token operator">:-:</span><span class="token punctuation">)</span> <span class="token number">7</span> <span class="token constant">Empty</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Nice. Is nice. If we wanted, we could implement all of the functions that operate on lists on our own list type.</p></div><div><p>Notice how we pattern matched on&nbsp;<code>(x :-: xs)</code>. That works because pattern matching is actually about matching constructors. We can match on&nbsp;<code>:-:</code>&nbsp;because it is a constructor for our own list type and we can also match on&nbsp;<code>:</code>&nbsp;because it is a constructor for the built-in list type. Same goes for&nbsp;<code>[]</code>. Because pattern matching works (only) on constructors, we can match for stuff like that, normal prefix constructors or stuff like&nbsp;<code>8</code>&nbsp;or&nbsp;<code>'a'</code>, which are basically constructors for the numeric and character types, respectively.</p></div><div><p><img alt="binary search tree" src="http://s3.amazonaws.com/lyah/binarytree.png" referrerpolicy="no-referrer"></p></div><div><p>Now, we're going to implement a&nbsp;<strong>binary search tree</strong>. If you're not familiar with binary search trees from languages like C, here's what they are: an element points to two elements, one on its left and one on its right. The element to the left is smaller, the element to the right is bigger. Each of those elements can also point to two elements (or one, or none). In effect, each element has up to two sub-trees. And a cool thing about binary search trees is that we know that all the elements at the left sub-tree of, say, 5 are going to be smaller than 5. Elements in its right sub-tree are going to be bigger. So if we need to find if 8 is in our tree, we'd start at 5 and then because 8 is greater than 5, we'd go right. We're now at 7 and because 8 is greater than 7, we go right again. And we've found our element in three hops! Now if this were a normal list (or a tree, but really unbalanced), it would take us seven hops instead of three to see if 8 is in there.</p></div><div><p>Sets and maps from&nbsp;<code>Data.Set</code>&nbsp;and&nbsp;<code>Data.Map</code>&nbsp;are implemented using trees, only instead of normal binary search trees, they use balanced binary search trees, which are always balanced. But right now, we'll just be implementing normal binary search trees.</p></div><div><p>Here's what we're going to say: a tree is either an empty tree or it's an element that contains some value and two trees. Sounds like a perfect fit for an algebraic data type!</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token keyword">data</span> <span class="token constant">Tree</span> <span class="token hvariable">a</span> <span class="token operator">=</span> <span class="token constant">EmptyTree</span> <span class="token operator">|</span> <span class="token constant">Node</span> <span class="token hvariable">a</span> <span class="token punctuation">(</span><span class="token constant">Tree</span> <span class="token hvariable">a</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token constant">Tree</span> <span class="token hvariable">a</span><span class="token punctuation">)</span> <span class="token keyword">deriving</span> <span class="token punctuation">(</span><span class="token constant">Show</span><span class="token punctuation">,</span> <span class="token constant">Read</span><span class="token punctuation">,</span> <span class="token constant">Eq</span><span class="token punctuation">)</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Okay, good, this is good. Instead of manually building a tree, we're going to make a function that takes a tree and an element and inserts an element. We do this by comparing the value we want to insert to the root node and then if it's smaller, we go left, if it's larger, we go right. We do the same for every subsequent node until we reach an empty tree. Once we've reached an empty tree, we just insert a node with that value instead of the empty tree.</p></div><div><p>In languages like C, we'd do this by modifying the pointers and values inside the tree. In Haskell, we can't really modify our tree, so we have to make a new sub-tree each time we decide to go left or right and in the end the insertion function returns a completely new tree, because Haskell doesn't really have a concept of pointer, just values. Hence, the type for our insertion function is going to be something like&nbsp;<code>a -&gt; Tree a - &gt; Tree a</code>. It takes an element and a tree and returns a new tree that has that element inside. This might seem like it's inefficient but laziness takes care of that problem.</p></div><div><p>So, here are two functions. One is a utility function for making a singleton tree (a tree with just one node) and a function to insert an element into a tree.</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">singleton</span> <span class="token operator">::</span> <span class="token hvariable">a</span> <span class="token operator">-&gt;</span> <span class="token constant">Tree</span> <span class="token hvariable">a</span>
<span class="token hvariable">singleton</span> <span class="token hvariable">x</span> <span class="token operator">=</span> <span class="token constant">Node</span> <span class="token hvariable">x</span> <span class="token constant">EmptyTree</span> <span class="token constant">EmptyTree</span>

<span class="token hvariable">treeInsert</span> <span class="token operator">::</span> <span class="token punctuation">(</span><span class="token constant">Ord</span> <span class="token hvariable">a</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token hvariable">a</span> <span class="token operator">-&gt;</span> <span class="token constant">Tree</span> <span class="token hvariable">a</span> <span class="token operator">-&gt;</span> <span class="token constant">Tree</span> <span class="token hvariable">a</span>
<span class="token hvariable">treeInsert</span> <span class="token hvariable">x</span> <span class="token constant">EmptyTree</span> <span class="token operator">=</span> <span class="token hvariable">singleton</span> <span class="token hvariable">x</span>
<span class="token hvariable">treeInsert</span> <span class="token hvariable">x</span> <span class="token punctuation">(</span><span class="token constant">Node</span> <span class="token hvariable">a</span> <span class="token hvariable">left</span> <span class="token hvariable">right</span><span class="token punctuation">)</span> 
    <span class="token operator">|</span> <span class="token hvariable">x</span> <span class="token operator">==</span> <span class="token hvariable">a</span> <span class="token operator">=</span> <span class="token constant">Node</span> <span class="token hvariable">x</span> <span class="token hvariable">left</span> <span class="token hvariable">right</span>
    <span class="token operator">|</span> <span class="token hvariable">x</span> <span class="token operator">&lt;</span> <span class="token hvariable">a</span>  <span class="token operator">=</span> <span class="token constant">Node</span> <span class="token hvariable">a</span> <span class="token punctuation">(</span><span class="token hvariable">treeInsert</span> <span class="token hvariable">x</span> <span class="token hvariable">left</span><span class="token punctuation">)</span> <span class="token hvariable">right</span>
    <span class="token operator">|</span> <span class="token hvariable">x</span> <span class="token operator">&gt;</span> <span class="token hvariable">a</span>  <span class="token operator">=</span> <span class="token constant">Node</span> <span class="token hvariable">a</span> <span class="token hvariable">left</span> <span class="token punctuation">(</span><span class="token hvariable">treeInsert</span> <span class="token hvariable">x</span> <span class="token hvariable">right</span><span class="token punctuation">)</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>The&nbsp;<code>singleton</code>&nbsp;function is just a shortcut for making a node that has something and then two empty sub-trees. In the insertion function, we first have the edge condition as a pattern. If we've reached an empty sub-tree, that means we're where we want and instead of the empty tree, we put a singleton tree with our element. If we're not inserting into an empty tree, then we have to check some things. First off, if the element we're inserting is equal to the root element, just return a tree that's the same. If it's smaller, return a tree that has the same root value, the same right sub-tree but instead of its left sub-tree, put a tree that has our value inserted into it. Same (but the other way around) goes if our value is bigger than the root element.</p></div><div><p>Next up, we're going to make a function that checks if some element is in the tree. First, let's define the edge condition. If we're looking for an element in an empty tree, then it's certainly not there. Okay. Notice how this is the same as the edge condition when searching for elements in lists. If we're looking for an element in an empty list, it's not there. Anyway, if we're not looking for an element in an empty tree, then we check some things. If the element in the root node is what we're looking for, great! If it's not, what then? Well, we can take advantage of knowing that all the left elements are smaller than the root node. So if the element we're looking for is smaller than the root node, check to see if it's in the left sub-tree. If it's bigger, check to see if it's in the right sub-tree.</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">treeElem</span> <span class="token operator">::</span> <span class="token punctuation">(</span><span class="token constant">Ord</span> <span class="token hvariable">a</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token hvariable">a</span> <span class="token operator">-&gt;</span> <span class="token constant">Tree</span> <span class="token hvariable">a</span> <span class="token operator">-&gt;</span> <span class="token constant">Bool</span>
<span class="token hvariable">treeElem</span> <span class="token hvariable">x</span> <span class="token constant">EmptyTree</span> <span class="token operator">=</span> <span class="token constant">False</span>
<span class="token hvariable">treeElem</span> <span class="token hvariable">x</span> <span class="token punctuation">(</span><span class="token constant">Node</span> <span class="token hvariable">a</span> <span class="token hvariable">left</span> <span class="token hvariable">right</span><span class="token punctuation">)</span>
    <span class="token operator">|</span> <span class="token hvariable">x</span> <span class="token operator">==</span> <span class="token hvariable">a</span> <span class="token operator">=</span> <span class="token constant">True</span>
    <span class="token operator">|</span> <span class="token hvariable">x</span> <span class="token operator">&lt;</span> <span class="token hvariable">a</span>  <span class="token operator">=</span> <span class="token hvariable">treeElem</span> <span class="token hvariable">x</span> <span class="token hvariable">left</span>
    <span class="token operator">|</span> <span class="token hvariable">x</span> <span class="token operator">&gt;</span> <span class="token hvariable">a</span>  <span class="token operator">=</span> <span class="token hvariable">treeElem</span> <span class="token hvariable">x</span> <span class="token hvariable">right</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>All we had to do was write up the previous paragraph in code. Let's have some fun with our trees! Instead of manually building one (although we could), we'll use a fold to build up a tree from a list. Remember, pretty much everything that traverses a list one by one and then returns some sort of value can be implemented with a fold! We're going to start with the empty tree and then approach a list from the right and just insert element after element into our accumulator tree.</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token keyword">let</span> <span class="token hvariable">nums</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">8</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">7</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">]</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token keyword">let</span> <span class="token hvariable">numsTree</span> <span class="token operator">=</span> <span class="token builtin">foldr</span> <span class="token hvariable">treeInsert</span> <span class="token constant">EmptyTree</span> <span class="token hvariable">nums</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token hvariable">numsTree</span>
<span class="token constant">Node</span> <span class="token number">5</span> <span class="token punctuation">(</span><span class="token constant">Node</span> <span class="token number">3</span> <span class="token punctuation">(</span><span class="token constant">Node</span> <span class="token number">1</span> <span class="token constant">EmptyTree</span> <span class="token constant">EmptyTree</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token constant">Node</span> <span class="token number">4</span> <span class="token constant">EmptyTree</span> <span class="token constant">EmptyTree</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token constant">Node</span> <span class="token number">7</span> <span class="token punctuation">(</span><span class="token constant">Node</span> <span class="token number">6</span> <span class="token constant">EmptyTree</span> <span class="token constant">EmptyTree</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token constant">Node</span> <span class="token number">8</span> <span class="token constant">EmptyTree</span> <span class="token constant">EmptyTree</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>In that&nbsp;<code>foldr</code>,&nbsp;<code>treeInsert</code>&nbsp;was the folding function (it takes a tree and a list element and produces a new tree) and&nbsp;<code>EmptyTree</code>&nbsp;was the starting accumulator.&nbsp;<code>nums</code>, of course, was the list we were folding over.</p></div><div><p>When we print our tree to the console, it's not very readable, but if we try, we can make out its structure. We see that the root node is 5 and then it has two sub-trees, one of which has the root node of 3 and the other a 7, etc.</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token number">8</span> <span class="token operator">`treeElem`</span> <span class="token hvariable">numsTree</span>
<span class="token constant">True</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token number">100</span> <span class="token operator">`treeElem`</span> <span class="token hvariable">numsTree</span>
<span class="token constant">False</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token number">1</span> <span class="token operator">`treeElem`</span> <span class="token hvariable">numsTree</span>
<span class="token constant">True</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token number">10</span> <span class="token operator">`treeElem`</span> <span class="token hvariable">numsTree</span>
<span class="token constant">False</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Checking for membership also works nicely. Cool.</p></div><div><p>So as you can see, algebraic data structures are a really cool and powerful concept in Haskell. We can use them to make anything from boolean values and weekday enumerations to binary search trees and more!</p></div><div><h2 data-heading="Typeclasses 102" id="Typeclasses_102" style="display: flex;"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>Typeclasses 102</h2></div><div><p><img alt="tweet" src="http://s3.amazonaws.com/lyah/trafficlight.png" referrerpolicy="no-referrer"></p></div><div><p>So far, we've learned about some of the standard Haskell typeclasses and we've seen which types are in them. We've also learned how to automatically make our own types instances of the standard typeclasses by asking Haskell to derive the instances for us. In this section, we're going to learn how to make our own typeclasses and how to make types instances of them by hand.</p></div><div><p>A quick recap on typeclasses: typeclasses are like interfaces. A typeclass defines some behavior (like comparing for equality, comparing for ordering, enumeration) and then types that can behave in that way are made instances of that typeclass. The behavior of typeclasses is achieved by defining functions or just type declarations that we then implement. So when we say that a type is an instance of a typeclass, we mean that we can use the functions that the typeclass defines with that type.</p></div><div><p>Typeclasses have pretty much nothing to do with classes in languages like Java or Python. This confuses many people, so I want you to forget everything you know about classes in imperative languages right now.</p></div><div><p>For example, the&nbsp;<code>Eq</code>&nbsp;typeclass is for stuff that can be equated. It defines the functions&nbsp;<code>==</code>&nbsp;and&nbsp;<code>/=</code>. If we have a type (say,&nbsp;<code>Car</code>) and comparing two cars with the equality function&nbsp;<code>==</code>&nbsp;makes sense, then it makes sense for&nbsp;<code>Car</code>&nbsp;to be an instance of&nbsp;<code>Eq</code>.</p></div><div><p>This is how the&nbsp;<code>Eq</code>&nbsp;class is defined in the standard prelude:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token keyword">class</span> <span class="token constant">Eq</span> <span class="token hvariable">a</span> <span class="token keyword">where</span>
    <span class="token punctuation">(</span><span class="token operator">==</span><span class="token punctuation">)</span> <span class="token operator">::</span> <span class="token hvariable">a</span> <span class="token operator">-&gt;</span> <span class="token hvariable">a</span> <span class="token operator">-&gt;</span> <span class="token constant">Bool</span>
    <span class="token punctuation">(</span><span class="token operator">/=</span><span class="token punctuation">)</span> <span class="token operator">::</span> <span class="token hvariable">a</span> <span class="token operator">-&gt;</span> <span class="token hvariable">a</span> <span class="token operator">-&gt;</span> <span class="token constant">Bool</span>
    <span class="token hvariable">x</span> <span class="token operator">==</span> <span class="token hvariable">y</span> <span class="token operator">=</span> <span class="token builtin">not</span> <span class="token punctuation">(</span><span class="token hvariable">x</span> <span class="token operator">/=</span> <span class="token hvariable">y</span><span class="token punctuation">)</span>
    <span class="token hvariable">x</span> <span class="token operator">/=</span> <span class="token hvariable">y</span> <span class="token operator">=</span> <span class="token builtin">not</span> <span class="token punctuation">(</span><span class="token hvariable">x</span> <span class="token operator">==</span> <span class="token hvariable">y</span><span class="token punctuation">)</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Woah, woah, woah! Some new strange syntax and keywords there! Don't worry, this will all be clear in a second. First off, when we write&nbsp;<code>class Eq a where</code>, this means that we're defining a new typeclass and that's called&nbsp;<code>Eq</code>. The&nbsp;<code>a</code>&nbsp;is the type variable and it means that&nbsp;<code>a</code>&nbsp;will play the role of the type that we will soon be making an instance of&nbsp;<code>Eq</code>. It doesn't have to be called&nbsp;<code>a</code>, it doesn't even have to be one letter, it just has to be a lowercase word. Then, we define several functions. It's not mandatory to implement the function bodies themselves, we just have to specify the type declarations for the functions.</p></div><div><p>Some people might understand this better if we wrote&nbsp;class Eq equatable where&nbsp;and then specified the type declarations like&nbsp;(==) :: equatable -&gt; equatable -&gt; Bool.</p></div><div><p>Anyway, we&nbsp;<em>did</em>&nbsp;implement the function bodies for the functions that&nbsp;<code>Eq</code>&nbsp;defines, only we defined them in terms of mutual recursion. We said that two instances of&nbsp;<code>Eq</code>&nbsp;are equal if they are not different and they are different if they are not equal. We didn't have to do this, really, but we did and we'll see how this helps us soon.</p></div><div><p>If we have say&nbsp;class Eq a where&nbsp;and then define a type declaration within that class like&nbsp;(==) :: a -&gt; -a -&gt; Bool, then when we examine the type of that function later on, it will have the type of&nbsp;(Eq a) =&gt; a -&gt; a -&gt; Bool.</p></div><div><p>So once we have a class, what can we do with it? Well, not much, really. But once we start making types instances of that class, we start getting some nice functionality. So check out this type:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token keyword">data</span> <span class="token constant">TrafficLight</span> <span class="token operator">=</span> <span class="token constant">Red</span> <span class="token operator">|</span> <span class="token constant">Yellow</span> <span class="token operator">|</span> <span class="token constant">Green</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>It defines the states of a traffic light. Notice how we didn't derive any class instances for it. That's because we're going to write up some instances by hand, even though we could derive them for types like&nbsp;<code>Eq</code>&nbsp;and&nbsp;<code>Show</code>. Here's how we make it an instance of&nbsp;<code>Eq</code>.</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token keyword">instance</span> <span class="token constant">Eq</span> <span class="token constant">TrafficLight</span> <span class="token keyword">where</span>
    <span class="token constant">Red</span> <span class="token operator">==</span> <span class="token constant">Red</span> <span class="token operator">=</span> <span class="token constant">True</span>
    <span class="token constant">Green</span> <span class="token operator">==</span> <span class="token constant">Green</span> <span class="token operator">=</span> <span class="token constant">True</span>
    <span class="token constant">Yellow</span> <span class="token operator">==</span> <span class="token constant">Yellow</span> <span class="token operator">=</span> <span class="token constant">True</span>
    <span class="token hvariable">_</span> <span class="token operator">==</span> <span class="token hvariable">_</span> <span class="token operator">=</span> <span class="token constant">False</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>We did it by using the&nbsp;<em>instance</em>&nbsp;keyword. So&nbsp;<em>class</em>&nbsp;is for defining new typeclasses and&nbsp;<em>instance</em>&nbsp;is for making our types instances of typeclasses. When we were defining&nbsp;<code>Eq</code>, we wrote&nbsp;<code>class Eq a where</code>&nbsp;and we said that&nbsp;<code>a</code>&nbsp;plays the role of whichever type will be made an instance later on. We can see that clearly here, because when we're making an instance, we write&nbsp;<code>instance Eq TrafficLight where</code>. We replace the&nbsp;<code>a</code>&nbsp;with the actual type.</p></div><div><p>Because&nbsp;<code>==</code>&nbsp;was defined in terms of&nbsp;<code>/=</code>&nbsp;and vice versa in the&nbsp;<em>class</em>&nbsp;declaration, we only had to overwrite one of them in the instance declaration. That's called the minimal complete definition for the typeclass — the minimum of functions that we have to implement so that our type can behave like the class advertises. To fulfill the minimal complete definition for&nbsp;<code>Eq</code>, we have to overwrite either one of&nbsp;<code>==</code>&nbsp;or&nbsp;<code>/=</code>. If&nbsp;<code>Eq</code>&nbsp;was defined simply like this:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token keyword">class</span> <span class="token constant">Eq</span> <span class="token hvariable">a</span> <span class="token keyword">where</span>
    <span class="token punctuation">(</span><span class="token operator">==</span><span class="token punctuation">)</span> <span class="token operator">::</span> <span class="token hvariable">a</span> <span class="token operator">-&gt;</span> <span class="token hvariable">a</span> <span class="token operator">-&gt;</span> <span class="token constant">Bool</span>
    <span class="token punctuation">(</span><span class="token operator">/=</span><span class="token punctuation">)</span> <span class="token operator">::</span> <span class="token hvariable">a</span> <span class="token operator">-&gt;</span> <span class="token hvariable">a</span> <span class="token operator">-&gt;</span> <span class="token constant">Bool</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>we'd have to implement both of these functions when making a type an instance of it, because Haskell wouldn't know how these two functions are related. The minimal complete definition would then be: both&nbsp;<code>==</code>&nbsp;and&nbsp;<code>/=</code>.</p></div><div><p>You can see that we implemented&nbsp;<code>==</code>&nbsp;simply by doing pattern matching. Since there are many more cases where two lights aren't equal, we specified the ones that are equal and then just did a catch-all pattern saying that if it's none of the previous combinations, then two lights aren't equal.</p></div><div><p>Let's make this an instance of&nbsp;<code>Show</code>&nbsp;by hand, too. To satisfy the minimal complete definition for&nbsp;<code>Show</code>, we just have to implement its&nbsp;<code>show</code>&nbsp;function, which takes a value and turns it into a string.</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token keyword">instance</span> <span class="token constant">Show</span> <span class="token constant">TrafficLight</span> <span class="token keyword">where</span>
    <span class="token builtin">show</span> <span class="token constant">Red</span> <span class="token operator">=</span> <span class="token string">"Red light"</span>
    <span class="token builtin">show</span> <span class="token constant">Yellow</span> <span class="token operator">=</span> <span class="token string">"Yellow light"</span>
    <span class="token builtin">show</span> <span class="token constant">Green</span> <span class="token operator">=</span> <span class="token string">"Green light"</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Once again, we used pattern matching to achieve our goals. Let's see how it works in action:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token constant">Red</span> <span class="token operator">==</span> <span class="token constant">Red</span>
<span class="token constant">True</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token constant">Red</span> <span class="token operator">==</span> <span class="token constant">Yellow</span>
<span class="token constant">False</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token constant">Red</span> <span class="token operator">`elem`</span> <span class="token punctuation">[</span><span class="token constant">Red</span><span class="token punctuation">,</span> <span class="token constant">Yellow</span><span class="token punctuation">,</span> <span class="token constant">Green</span><span class="token punctuation">]</span>
<span class="token constant">True</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token punctuation">[</span><span class="token constant">Red</span><span class="token punctuation">,</span> <span class="token constant">Yellow</span><span class="token punctuation">,</span> <span class="token constant">Green</span><span class="token punctuation">]</span>
<span class="token punctuation">[</span><span class="token constant">Red</span> <span class="token hvariable">light</span><span class="token punctuation">,</span><span class="token constant">Yellow</span> <span class="token hvariable">light</span><span class="token punctuation">,</span><span class="token constant">Green</span> <span class="token hvariable">light</span><span class="token punctuation">]</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Nice. We could have just derived&nbsp;<code>Eq</code>&nbsp;and it would have had the same effect (but we didn't for educational purposes). However, deriving&nbsp;<code>Show</code>&nbsp;would have just directly translated the value constructors to strings. But if we want lights to appear like&nbsp;<code>"Red light"</code>, then we have to make the instance declaration by hand.</p></div><div><p>You can also make typeclasses that are subclasses of other typeclasses. The&nbsp;<em>class</em>&nbsp;declaration for&nbsp;<code>Num</code>&nbsp;is a bit long, but here's the first part:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token keyword">class</span> <span class="token punctuation">(</span><span class="token constant">Eq</span> <span class="token hvariable">a</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token constant">Num</span> <span class="token hvariable">a</span> <span class="token keyword">where</span>
   <span class="token operator">...</span>  
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>As we mentioned previously, there are a lot of places where we can cram in class constraints. So this is just like writing&nbsp;<code>class Num a where</code>, only we state that our type&nbsp;<code>a</code>&nbsp;must be an instance of&nbsp;<code>Eq</code>. We're essentially saying that we have to make a type an instance of&nbsp;<code>Eq</code>&nbsp;before we can make it an instance of&nbsp;<code>Num</code>. Before some type can be considered a number, it makes sense that we can determine whether values of that type can be equated or not. That's all there is to subclassing really, it's just a class constraint on a&nbsp;<em>class</em>&nbsp;declaration! When defining function bodies in the&nbsp;<em>class</em>&nbsp;declaration or when defining them in&nbsp;<em>instance</em>&nbsp;declarations, we can assume that&nbsp;<code>a</code>&nbsp;is a part of&nbsp;<code>Eq</code>&nbsp;and so we can use&nbsp;<code>==</code>&nbsp;on values of that type.</p></div><div><p>But how are the&nbsp;<code>Maybe</code>&nbsp;or list types made as instances of typeclasses? What makes&nbsp;<code>Maybe</code>&nbsp;different from, say,&nbsp;<code>TrafficLight</code>&nbsp;is that&nbsp;<code>Maybe</code>&nbsp;in itself isn't a concrete type, it's a type constructor that takes one type parameter (like&nbsp;<code>Char</code>&nbsp;or something) to produce a concrete type (like&nbsp;<code>Maybe Char</code>). Let's take a look at the&nbsp;<code>Eq</code>&nbsp;typeclass again:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token keyword">class</span> <span class="token constant">Eq</span> <span class="token hvariable">a</span> <span class="token keyword">where</span>
    <span class="token punctuation">(</span><span class="token operator">==</span><span class="token punctuation">)</span> <span class="token operator">::</span> <span class="token hvariable">a</span> <span class="token operator">-&gt;</span> <span class="token hvariable">a</span> <span class="token operator">-&gt;</span> <span class="token constant">Bool</span>
    <span class="token punctuation">(</span><span class="token operator">/=</span><span class="token punctuation">)</span> <span class="token operator">::</span> <span class="token hvariable">a</span> <span class="token operator">-&gt;</span> <span class="token hvariable">a</span> <span class="token operator">-&gt;</span> <span class="token constant">Bool</span>
    <span class="token hvariable">x</span> <span class="token operator">==</span> <span class="token hvariable">y</span> <span class="token operator">=</span> <span class="token builtin">not</span> <span class="token punctuation">(</span><span class="token hvariable">x</span> <span class="token operator">/=</span> <span class="token hvariable">y</span><span class="token punctuation">)</span>
    <span class="token hvariable">x</span> <span class="token operator">/=</span> <span class="token hvariable">y</span> <span class="token operator">=</span> <span class="token builtin">not</span> <span class="token punctuation">(</span><span class="token hvariable">x</span> <span class="token operator">==</span> <span class="token hvariable">y</span><span class="token punctuation">)</span> 
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>From the type declarations, we see that the&nbsp;<code>a</code>&nbsp;is used as a concrete type because all the types in functions have to be concrete (remember, you can't have a function of the type&nbsp;<code>a -&gt; Maybe</code>&nbsp;but you can have a function of&nbsp;<code>a -&gt; Maybe a</code>&nbsp;or&nbsp;<code>Maybe Int -&gt; Maybe String</code>). That's why we can't do something like</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token keyword">instance</span> <span class="token constant">Eq</span> <span class="token constant">Maybe</span> <span class="token keyword">where</span>
    <span class="token operator">...</span>  
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Because like we've seen, the&nbsp;<code>a</code>&nbsp;has to be a concrete type but&nbsp;<code>Maybe</code>&nbsp;isn't a concrete type. It's a type constructor that takes one parameter and then produces a concrete type. It would also be tedious to write&nbsp;<code>instance Eq (Maybe Int) where</code>,&nbsp;<code>instance Eq (Maybe Char) where</code>, etc. for every type ever. So we could write it out like so:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token keyword">instance</span> <span class="token constant">Eq</span> <span class="token punctuation">(</span><span class="token constant">Maybe</span> <span class="token hvariable">m</span><span class="token punctuation">)</span> <span class="token keyword">where</span>
    <span class="token constant">Just</span> <span class="token hvariable">x</span> <span class="token operator">==</span> <span class="token constant">Just</span> <span class="token hvariable">y</span> <span class="token operator">=</span> <span class="token hvariable">x</span> <span class="token operator">==</span> <span class="token hvariable">y</span>
    <span class="token constant">Nothing</span> <span class="token operator">==</span> <span class="token constant">Nothing</span> <span class="token operator">=</span> <span class="token constant">True</span>
    <span class="token hvariable">_</span> <span class="token operator">==</span> <span class="token hvariable">_</span> <span class="token operator">=</span> <span class="token constant">False</span>
      
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>This is like saying that we want to make all types of the form&nbsp;<code>Maybe something</code>&nbsp;an instance of&nbsp;<code>Eq</code>. We actually could have written&nbsp;<code>(Maybe something)</code>, but we usually opt for single letters to be true to the Haskell style. The&nbsp;<code>(Maybe m)</code>&nbsp;here plays the role of the&nbsp;<code>a</code>&nbsp;from&nbsp;<code>class Eq a where</code>. While&nbsp;<code>Maybe</code>&nbsp;isn't a concrete type,&nbsp;<code>Maybe m</code>&nbsp;is. By specifying a type parameter (<code>m</code>, which is in lowercase), we said that we want all types that are in the form of&nbsp;<code>Maybe m</code>, where&nbsp;<code>m</code>&nbsp;is any type, to be an instance of&nbsp;<code>Eq</code>.</p></div><div><p>There's one problem with this though. Can you spot it? We use&nbsp;<code>==</code>&nbsp;on the contents of the&nbsp;<code>Maybe</code>&nbsp;but we have no assurance that what the&nbsp;<code>Maybe</code>&nbsp;contains can be used with&nbsp;<code>Eq</code>! That's why we have to modify our&nbsp;<em>instance</em>&nbsp;declaration like this:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token keyword">instance</span> <span class="token punctuation">(</span><span class="token constant">Eq</span> <span class="token hvariable">m</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token constant">Eq</span> <span class="token punctuation">(</span><span class="token constant">Maybe</span> <span class="token hvariable">m</span><span class="token punctuation">)</span> <span class="token keyword">where</span>
    <span class="token constant">Just</span> <span class="token hvariable">x</span> <span class="token operator">==</span> <span class="token constant">Just</span> <span class="token hvariable">y</span> <span class="token operator">=</span> <span class="token hvariable">x</span> <span class="token operator">==</span> <span class="token hvariable">y</span>
    <span class="token constant">Nothing</span> <span class="token operator">==</span> <span class="token constant">Nothing</span> <span class="token operator">=</span> <span class="token constant">True</span>
    <span class="token hvariable">_</span> <span class="token operator">==</span> <span class="token hvariable">_</span> <span class="token operator">=</span> <span class="token constant">False</span>
      
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>We had to add a class constraint! With this&nbsp;<em>instance</em>&nbsp;declaration, we say this: we want all types of the form&nbsp;<code>Maybe m</code>&nbsp;to be part of the&nbsp;<code>Eq</code>&nbsp;typeclass, but only those types where the&nbsp;<code>m</code>&nbsp;(so what's contained inside the&nbsp;<code>Maybe</code>) is also a part of&nbsp;<code>Eq</code>. This is actually how Haskell would derive the instance too.</p></div><div><p>Most of the times, class constraints in&nbsp;<em>class</em>&nbsp;declarations are used for making a typeclass a subclass of another typeclass and class constraints in&nbsp;<em>instance</em>&nbsp;declarations are used to express requirements about the contents of some type. For instance, here we required the contents of the&nbsp;<code>Maybe</code>&nbsp;to also be part of the&nbsp;<code>Eq</code>&nbsp;typeclass.</p></div><div><p>When making instances, if you see that a type is used as a concrete type in the type declarations (like the&nbsp;<code>a</code>&nbsp;in&nbsp;<code>a -&gt; a -&gt; Bool</code>), you have to supply type parameters and add parentheses so that you end up with a concrete type.</p></div><div><p>Take into account that the type you're trying to make an instance of will replace the parameter in the&nbsp;<em>class</em>&nbsp;declaration. The&nbsp;a&nbsp;from&nbsp;class Eq a where&nbsp;will be replaced with a real type when you make an instance, so try mentally putting your type into the function type declarations as well.&nbsp;(<mark>) :: Maybe -&gt; Maybe -&gt; Bool&nbsp;doesn't make much sense but&nbsp;(</mark>) :: (Eq m) =&gt; Maybe m -&gt; Maybe m -&gt; Bool&nbsp;does. But this is just something to think about, because&nbsp;==&nbsp;will always have a type of&nbsp;(==) :: (Eq a) =&gt; a -&gt; a -&gt; Bool, no matter what instances we make.</p></div><div><p>Ooh, one more thing, check this out! If you want to see what the instances of a typeclass are, just do&nbsp;<code>:info YourTypeClass</code>&nbsp;in GHCI. So typing&nbsp;<code>:info Num</code>&nbsp;will show which functions the typeclass defines and it will give you a list of the types in the typeclass.&nbsp;<code>:info</code>&nbsp;works for types and type constructors too. If you do&nbsp;<code>:info Maybe</code>, it will show you all the typeclasses that&nbsp;<code>Maybe</code>&nbsp;is an instance of. Also&nbsp;<code>:info</code>&nbsp;can show you the type declaration of a function. I think that's pretty cool.</p></div><div><h2 data-heading="A yes-no typeclass" id="A_yes-no_typeclass" style="display: flex;"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>A yes-no typeclass</h2></div><div><p><img alt="yesno" src="http://s3.amazonaws.com/lyah/yesno.png" referrerpolicy="no-referrer"></p></div><div><p>In JavaScript and some other weakly typed languages, you can put almost anything inside an if expression. For example, you can do all of the following:&nbsp;<code>if (0) alert("YEAH!") else alert("NO!")</code>,&nbsp;<code>if ("") alert ("YEAH!") else alert("NO!")</code>,&nbsp;<code>if (false) alert("YEAH") else alert("NO!)</code>, etc. and all of these will throw an alert of&nbsp;<code>NO!</code>. If you do&nbsp;<code>if ("WHAT") alert ("YEAH") else alert("NO!")</code>, it will alert a&nbsp;<code>"YEAH!"</code>&nbsp;because JavaScript considers non-empty strings to be a sort of true-ish value.</p></div><div><p>Even though strictly using&nbsp;<code>Bool</code>&nbsp;for boolean semantics works better in Haskell, let's try and implement that JavaScript-ish behavior anyway. For fun! Let's start out with a&nbsp;<em>class</em>&nbsp;declaration.</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token keyword">class</span> <span class="token constant">YesNo</span> <span class="token hvariable">a</span> <span class="token keyword">where</span>
    <span class="token hvariable">yesno</span> <span class="token operator">::</span> <span class="token hvariable">a</span> <span class="token operator">-&gt;</span> <span class="token constant">Bool</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Pretty simple. The&nbsp;<code>YesNo</code>&nbsp;typeclass defines one function. That function takes one value of a type that can be considered to hold some concept of true-ness and tells us for sure if it's true or not. Notice that from the way we use the&nbsp;<code>a</code>&nbsp;in the function,&nbsp;<code>a</code>&nbsp;has to be a concrete type.</p></div><div><p>Next up, let's define some instances. For numbers, we'll assume that (like in JavaScript) any number that isn't 0 is true-ish and 0 is false-ish.</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token keyword">instance</span> <span class="token constant">YesNo</span> <span class="token constant">Int</span> <span class="token keyword">where</span>
    <span class="token hvariable">yesno</span> <span class="token number">0</span> <span class="token operator">=</span> <span class="token constant">False</span>
    <span class="token hvariable">yesno</span> <span class="token hvariable">_</span> <span class="token operator">=</span> <span class="token constant">True</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Empty lists (and by extensions, strings) are a no-ish value, while non-empty lists are a yes-ish value.</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token keyword">instance</span> <span class="token constant">YesNo</span> <span class="token punctuation">[</span><span class="token hvariable">a</span><span class="token punctuation">]</span> <span class="token keyword">where</span>
    <span class="token hvariable">yesno</span> <span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token constant">False</span>
    <span class="token hvariable">yesno</span> <span class="token hvariable">_</span> <span class="token operator">=</span> <span class="token constant">True</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Notice how we just put in a type parameter&nbsp;<code>a</code>&nbsp;in there to make the list a concrete type, even though we don't make any assumptions about the type that's contained in the list. What else, hmm ... I know,&nbsp;<code>Bool</code>&nbsp;itself also holds true-ness and false-ness and it's pretty obvious which is which.</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token keyword">instance</span> <span class="token constant">YesNo</span> <span class="token constant">Bool</span> <span class="token keyword">where</span>
    <span class="token hvariable">yesno</span> <span class="token operator">=</span> <span class="token builtin">id</span>   
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Huh? What's&nbsp;<code>id</code>? It's just a standard library function that takes a parameter and returns the same thing, which is what we would be writing here anyway.</p></div><div><p>Let's make&nbsp;<code>Maybe a</code>&nbsp;an instance too.</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token keyword">instance</span> <span class="token constant">YesNo</span> <span class="token punctuation">(</span><span class="token constant">Maybe</span> <span class="token hvariable">a</span><span class="token punctuation">)</span> <span class="token keyword">where</span>
    <span class="token hvariable">yesno</span> <span class="token punctuation">(</span><span class="token constant">Just</span> <span class="token hvariable">_</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token constant">True</span>
    <span class="token hvariable">yesno</span> <span class="token constant">Nothing</span> <span class="token operator">=</span> <span class="token constant">False</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>We didn't need a class constraint because we made no assumptions about the contents of the&nbsp;<code>Maybe</code>. We just said that it's true-ish if it's a&nbsp;<code>Just</code>&nbsp;value and false-ish if it's a&nbsp;<code>Nothing</code>. We still had to write out&nbsp;<code>(Maybe a)</code>&nbsp;instead of just&nbsp;<code>Maybe</code>&nbsp;because if you think about it, a&nbsp;<code>Maybe -&gt; Bool</code>&nbsp;function can't exist (because&nbsp;<code>Maybe</code>&nbsp;isn't a concrete type), whereas a&nbsp;<code>Maybe a -&gt; Bool</code>&nbsp;is fine and dandy. Still, this is really cool because now, any type of the form&nbsp;<code>Maybe something</code>&nbsp;is part of&nbsp;<code>YesNo</code>&nbsp;and it doesn't matter what that&nbsp;<code>something</code>&nbsp;is.</p></div><div><p>Previously, we defined a&nbsp;<code>Tree a</code>&nbsp;type, that represented a binary search tree. We can say an empty tree is false-ish and anything that's not an empty tree is true-ish.</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token keyword">instance</span> <span class="token constant">YesNo</span> <span class="token punctuation">(</span><span class="token constant">Tree</span> <span class="token hvariable">a</span><span class="token punctuation">)</span> <span class="token keyword">where</span>
    <span class="token hvariable">yesno</span> <span class="token constant">EmptyTree</span> <span class="token operator">=</span> <span class="token constant">False</span>
    <span class="token hvariable">yesno</span> <span class="token hvariable">_</span> <span class="token operator">=</span> <span class="token constant">True</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Can a traffic light be a yes or no value? Sure. If it's red, you stop. If it's green, you go. If it's yellow? Eh, I usually run the yellows because I live for adrenaline.</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token keyword">instance</span> <span class="token constant">YesNo</span> <span class="token constant">TrafficLight</span> <span class="token keyword">where</span>
    <span class="token hvariable">yesno</span> <span class="token constant">Red</span> <span class="token operator">=</span> <span class="token constant">False</span>
    <span class="token hvariable">yesno</span> <span class="token hvariable">_</span> <span class="token operator">=</span> <span class="token constant">True</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Cool, now that we have some instances, let's go play!</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token hvariable">yesno</span> <span class="token operator">$</span> <span class="token builtin">length</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
<span class="token constant">False</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token hvariable">yesno</span> <span class="token string">"haha"</span>
<span class="token constant">True</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token hvariable">yesno</span> <span class="token string">""</span>
<span class="token constant">False</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token hvariable">yesno</span> <span class="token operator">$</span> <span class="token constant">Just</span> <span class="token number">0</span>
<span class="token constant">True</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token hvariable">yesno</span> <span class="token constant">True</span>
<span class="token constant">True</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token hvariable">yesno</span> <span class="token constant">EmptyTree</span>
<span class="token constant">False</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token hvariable">yesno</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
<span class="token constant">False</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token hvariable">yesno</span> <span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">]</span>
<span class="token constant">True</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token operator">:</span><span class="token hvariable">t</span> <span class="token hvariable">yesno</span>
<span class="token hvariable">yesno</span> <span class="token operator">::</span> <span class="token punctuation">(</span><span class="token constant">YesNo</span> <span class="token hvariable">a</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token hvariable">a</span> <span class="token operator">-&gt;</span> <span class="token constant">Bool</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Right, it works! Let's make a function that mimics the if statement, but it works with&nbsp;<code>YesNo</code>&nbsp;values.</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">yesnoIf</span> <span class="token operator">::</span> <span class="token punctuation">(</span><span class="token constant">YesNo</span> <span class="token hvariable">y</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token hvariable">y</span> <span class="token operator">-&gt;</span> <span class="token hvariable">a</span> <span class="token operator">-&gt;</span> <span class="token hvariable">a</span> <span class="token operator">-&gt;</span> <span class="token hvariable">a</span>
<span class="token hvariable">yesnoIf</span> <span class="token hvariable">yesnoVal</span> <span class="token hvariable">yesResult</span> <span class="token hvariable">noResult</span> <span class="token operator">=</span> <span class="token keyword">if</span> <span class="token hvariable">yesno</span> <span class="token hvariable">yesnoVal</span> <span class="token keyword">then</span> <span class="token hvariable">yesResult</span> <span class="token keyword">else</span> <span class="token hvariable">noResult</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Pretty straightforward. It takes a yes-no-ish value and two things. If the yes-no-ish value is more of a yes, it returns the first of the two things, otherwise it returns the second of them.</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token hvariable">yesnoIf</span> <span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token string">"YEAH!"</span> <span class="token string">"NO!"</span>
<span class="token string">"NO!"</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token hvariable">yesnoIf</span> <span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">]</span> <span class="token string">"YEAH!"</span> <span class="token string">"NO!"</span>
<span class="token string">"YEAH!"</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token hvariable">yesnoIf</span> <span class="token constant">True</span> <span class="token string">"YEAH!"</span> <span class="token string">"NO!"</span>
<span class="token string">"YEAH!"</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token hvariable">yesnoIf</span> <span class="token punctuation">(</span><span class="token constant">Just</span> <span class="token number">500</span><span class="token punctuation">)</span> <span class="token string">"YEAH!"</span> <span class="token string">"NO!"</span>
<span class="token string">"YEAH!"</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token hvariable">yesnoIf</span> <span class="token constant">Nothing</span> <span class="token string">"YEAH!"</span> <span class="token string">"NO!"</span>
<span class="token string">"NO!"</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><h2 data-heading="The Functor typeclass" id="The_Functor_typeclass" style="display: flex;"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>The Functor typeclass</h2></div><div><p>So far, we've encountered a lot of the typeclasses in the standard library. We've played with&nbsp;<code>Ord</code>, which is for stuff that can be ordered. We've palled around with&nbsp;<code>Eq</code>, which is for things that can be equated. We've seen&nbsp;<code>Show</code>, which presents an interface for types whose values can be displayed as strings. Our good friend&nbsp;<code>Read</code>&nbsp;is there whenever we need to convert a string to a value of some type. And now, we're going to take a look at the&nbsp;<code>Functor</code>&nbsp;typeclass, which is basically for things that can be mapped over. You're probably thinking about lists now, since mapping over lists is such a dominant idiom in Haskell. And you're right, the list type is part of the&nbsp;<code>Functor</code>&nbsp;typeclass.</p></div><div><p>What better way to get to know the&nbsp;<code>Functor</code>&nbsp;typeclass than to see how it's implemented? Let's take a peek.</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token keyword">class</span> <span class="token constant">Functor</span> <span class="token hvariable">f</span> <span class="token keyword">where</span>
    <span class="token builtin">fmap</span> <span class="token operator">::</span> <span class="token punctuation">(</span><span class="token hvariable">a</span> <span class="token operator">-&gt;</span> <span class="token hvariable">b</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token hvariable">f</span> <span class="token hvariable">a</span> <span class="token operator">-&gt;</span> <span class="token hvariable">f</span> <span class="token hvariable">b</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p><img alt="I AM FUNCTOOOOR!!!" src="http://s3.amazonaws.com/lyah/functor.png" referrerpolicy="no-referrer"></p></div><div><p>Alright. We see that it defines one function,&nbsp;<code>fmap</code>, and doesn't provide any default implementation for it. The type of&nbsp;<code>fmap</code>&nbsp;is interesting. In the definitions of typeclasses so far, the type variable that played the role of the type in the typeclass was a concrete type, like the&nbsp;<code>a</code>&nbsp;in&nbsp;<code>(==) :: (Eq a) =&gt; a -&gt; a -&gt; Bool</code>. But now, the&nbsp;<code>f</code>&nbsp;is not a concrete type (a type that a value can hold, like&nbsp;<code>Int</code>,&nbsp;<code>Bool</code>&nbsp;or&nbsp;<code>Maybe String</code>), but a type constructor that takes one type parameter. A quick refresher example:&nbsp;<code>Maybe Int</code>&nbsp;is a concrete type, but&nbsp;<code>Maybe</code>&nbsp;is a type constructor that takes one type as the parameter. Anyway, we see that&nbsp;<code>fmap</code>&nbsp;takes a function from one type to another and a functor applied with one type and returns a functor applied with another type.</p></div><div><p>If this sounds a bit confusing, don't worry. All will be revealed soon when we check out a few examples. Hmm, this type declaration for&nbsp;<code>fmap</code>&nbsp;reminds me of something. If you don't know what the type signature of&nbsp;<code>map</code>&nbsp;is, it's:&nbsp;<code>map :: (a -&gt; b) -&gt; [a] -&gt; [b]</code>.</p></div><div><p>Ah, interesting! It takes a function from one type to another and a list of one type and returns a list of another type. My friends, I think we have ourselves a functor! In fact,&nbsp;<code>map</code>&nbsp;is just a&nbsp;<code>fmap</code>&nbsp;that works only on lists. Here's how the list is an instance of the&nbsp;<code>Functor</code>&nbsp;typeclass.</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token keyword">instance</span> <span class="token constant">Functor</span> <span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token keyword">where</span>
    <span class="token builtin">fmap</span> <span class="token operator">=</span> <span class="token builtin">map</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>That's it! Notice how we didn't write&nbsp;<code>instance Functor [a] where</code>, because from&nbsp;<code>fmap :: (a -&gt; b) -&gt; f a -&gt; f b</code>, we see that the&nbsp;<code>f</code>&nbsp;has to be a type constructor that takes one type.&nbsp;<code>[a]</code>&nbsp;is already a concrete type (of a list with any type inside it), while&nbsp;<code>[]</code>&nbsp;is a type constructor that takes one type and can produce types such as&nbsp;<code>[Int]</code>,&nbsp;<code>[String]</code>&nbsp;or even&nbsp;<code>[[String]]</code>.</p></div><div><p>Since for lists,&nbsp;<code>fmap</code>&nbsp;is just&nbsp;<code>map</code>, we get the same results when using them on lists.</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token builtin">map</span> <span class="token operator">::</span> <span class="token punctuation">(</span><span class="token hvariable">a</span> <span class="token operator">-&gt;</span> <span class="token hvariable">b</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token punctuation">[</span><span class="token hvariable">a</span><span class="token punctuation">]</span> <span class="token operator">-&gt;</span> <span class="token punctuation">[</span><span class="token hvariable">b</span><span class="token punctuation">]</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token builtin">fmap</span> <span class="token punctuation">(</span><span class="token operator">*</span><span class="token number">2</span><span class="token punctuation">)</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token operator">..</span><span class="token number">3</span><span class="token punctuation">]</span>
<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">]</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token builtin">map</span> <span class="token punctuation">(</span><span class="token operator">*</span><span class="token number">2</span><span class="token punctuation">)</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token operator">..</span><span class="token number">3</span><span class="token punctuation">]</span>
<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">]</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>What happens when we&nbsp;<code>map</code>&nbsp;or&nbsp;<code>fmap</code>&nbsp;over an empty list? Well, of course, we get an empty list. It just turns an empty list of type&nbsp;<code>[a]</code>&nbsp;into an empty list of type&nbsp;<code>[b]</code>.</p></div><div><p>Types that can act like a box can be functors. You can think of a list as a box that has an infinite amount of little compartments and they can all be empty, one can be full and the others empty or a number of them can be full. So, what else has the properties of being like a box? For one, the&nbsp;<code>Maybe a</code>&nbsp;type. In a way, it's like a box that can either hold nothing, in which case it has the value of&nbsp;<code>Nothing</code>, or it can hold one item, like&nbsp;<code>"HAHA"</code>, in which case it has a value of&nbsp;<code>Just "HAHA"</code>. Here's how&nbsp;<code>Maybe</code>&nbsp;is a functor.</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token keyword">instance</span> <span class="token constant">Functor</span> <span class="token constant">Maybe</span> <span class="token keyword">where</span>
    <span class="token builtin">fmap</span> <span class="token hvariable">f</span> <span class="token punctuation">(</span><span class="token constant">Just</span> <span class="token hvariable">x</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token constant">Just</span> <span class="token punctuation">(</span><span class="token hvariable">f</span> <span class="token hvariable">x</span><span class="token punctuation">)</span>
    <span class="token builtin">fmap</span> <span class="token hvariable">f</span> <span class="token constant">Nothing</span> <span class="token operator">=</span> <span class="token constant">Nothing</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Again, notice how we wrote&nbsp;<code>instance Functor Maybe where</code>&nbsp;instead of&nbsp;<code>instance Functor (Maybe m) where</code>, like we did when we were dealing with&nbsp;<code>Maybe</code>&nbsp;and&nbsp;<code>YesNo</code>.&nbsp;<code>Functor</code>&nbsp;wants a type constructor that takes one type and not a concrete type. If you mentally replace the&nbsp;<code>f</code>s with&nbsp;<code>Maybe</code>s,&nbsp;<code>fmap</code>&nbsp;acts like a&nbsp;<code>(a -&gt; b) -&gt; Maybe a -&gt; Maybe b</code>&nbsp;for this particular type, which looks OK. But if you replace&nbsp;<code>f</code>&nbsp;with&nbsp;<code>(Maybe m)</code>, then it would seem to act like a&nbsp;<code>(a -&gt; b) -&gt; Maybe m a -&gt; Maybe m b</code>, which doesn't make any damn sense because&nbsp;<code>Maybe</code>&nbsp;takes just one type parameter.</p></div><div><p>Anyway, the&nbsp;<code>fmap</code>&nbsp;implementation is pretty simple. If it's an empty value of&nbsp;<code>Nothing</code>, then just return a&nbsp;<code>Nothing</code>. If we map over an empty box, we get an empty box. It makes sense. Just like if we map over an empty list, we get back an empty list. If it's not an empty value, but rather a single value packed up in a&nbsp;<code>Just</code>, then we apply the function on the contents of the&nbsp;<code>Just</code>.</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token builtin">fmap</span> <span class="token punctuation">(</span><span class="token operator">++</span> <span class="token string">" HEY GUYS IM INSIDE THE JUST"</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token constant">Just</span> <span class="token string">"Something serious."</span><span class="token punctuation">)</span>
<span class="token constant">Just</span> <span class="token string">"Something serious. HEY GUYS IM INSIDE THE JUST"</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token builtin">fmap</span> <span class="token punctuation">(</span><span class="token operator">++</span> <span class="token string">" HEY GUYS IM INSIDE THE JUST"</span><span class="token punctuation">)</span> <span class="token constant">Nothing</span>
<span class="token constant">Nothing</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token builtin">fmap</span> <span class="token punctuation">(</span><span class="token operator">*</span><span class="token number">2</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token constant">Just</span> <span class="token number">200</span><span class="token punctuation">)</span>
<span class="token constant">Just</span> <span class="token number">400</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token builtin">fmap</span> <span class="token punctuation">(</span><span class="token operator">*</span><span class="token number">2</span><span class="token punctuation">)</span> <span class="token constant">Nothing</span>
<span class="token constant">Nothing</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Another thing that can be mapped over and made an instance of&nbsp;<code>Functor</code>&nbsp;is our&nbsp;<code>Tree a</code>&nbsp;type. It can be thought of as a box in a way (holds several or no values) and the&nbsp;<code>Tree</code>&nbsp;type constructor takes exactly one type parameter. If you look at&nbsp;<code>fmap</code>&nbsp;as if it were a function made only for&nbsp;<code>Tree</code>, its type signature would look like&nbsp;<code>(a -&gt; b) -&gt; Tree a -&gt; Tree b</code>. We're going to use recursion on this one. Mapping over an empty tree will produce an empty tree. Mapping over a non-empty tree will be a tree consisting of our function applied to the root value and its left and right sub-trees will be the previous sub-trees, only our function will be mapped over them.</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token keyword">instance</span> <span class="token constant">Functor</span> <span class="token constant">Tree</span> <span class="token keyword">where</span>
    <span class="token builtin">fmap</span> <span class="token hvariable">f</span> <span class="token constant">EmptyTree</span> <span class="token operator">=</span> <span class="token constant">EmptyTree</span>
    <span class="token builtin">fmap</span> <span class="token hvariable">f</span> <span class="token punctuation">(</span><span class="token constant">Node</span> <span class="token hvariable">x</span> <span class="token hvariable">leftsub</span> <span class="token hvariable">rightsub</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token constant">Node</span> <span class="token punctuation">(</span><span class="token hvariable">f</span> <span class="token hvariable">x</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token builtin">fmap</span> <span class="token hvariable">f</span> <span class="token hvariable">leftsub</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token builtin">fmap</span> <span class="token hvariable">f</span> <span class="token hvariable">rightsub</span><span class="token punctuation">)</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token builtin">fmap</span> <span class="token punctuation">(</span><span class="token operator">*</span><span class="token number">2</span><span class="token punctuation">)</span> <span class="token constant">EmptyTree</span>
<span class="token constant">EmptyTree</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token builtin">fmap</span> <span class="token punctuation">(</span><span class="token operator">*</span><span class="token number">4</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token builtin">foldr</span> <span class="token hvariable">treeInsert</span> <span class="token constant">EmptyTree</span> <span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">7</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">7</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
<span class="token constant">Node</span> <span class="token number">28</span> <span class="token punctuation">(</span><span class="token constant">Node</span> <span class="token number">4</span> <span class="token constant">EmptyTree</span> <span class="token punctuation">(</span><span class="token constant">Node</span> <span class="token number">8</span> <span class="token constant">EmptyTree</span> <span class="token punctuation">(</span><span class="token constant">Node</span> <span class="token number">12</span> <span class="token constant">EmptyTree</span> <span class="token punctuation">(</span><span class="token constant">Node</span> <span class="token number">20</span> <span class="token constant">EmptyTree</span> <span class="token constant">EmptyTree</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token constant">EmptyTree</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Nice! Now how about&nbsp;<code>Either a b</code>? Can this be made a functor? The&nbsp;<code>Functor</code>&nbsp;typeclass wants a type constructor that takes only one type parameter but&nbsp;<code>Either</code>&nbsp;takes two. Hmmm! I know, we'll partially apply&nbsp;<code>Either</code>&nbsp;by feeding it only one parameter so that it has one free parameter. Here's how&nbsp;<code>Either a</code>&nbsp;is a functor in the standard libraries:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token keyword">instance</span> <span class="token constant">Functor</span> <span class="token punctuation">(</span><span class="token constant">Either</span> <span class="token hvariable">a</span><span class="token punctuation">)</span> <span class="token keyword">where</span>
    <span class="token builtin">fmap</span> <span class="token hvariable">f</span> <span class="token punctuation">(</span><span class="token constant">Right</span> <span class="token hvariable">x</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token constant">Right</span> <span class="token punctuation">(</span><span class="token hvariable">f</span> <span class="token hvariable">x</span><span class="token punctuation">)</span>
    <span class="token builtin">fmap</span> <span class="token hvariable">f</span> <span class="token punctuation">(</span><span class="token constant">Left</span> <span class="token hvariable">x</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token constant">Left</span> <span class="token hvariable">x</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Well well, what did we do here? You can see how we made&nbsp;<code>Either a</code>&nbsp;an instance instead of just&nbsp;<code>Either</code>. That's because&nbsp;<code>Either a</code>&nbsp;is a type constructor that takes one parameter, whereas&nbsp;<code>Either</code>&nbsp;takes two. If&nbsp;<code>fmap</code>&nbsp;was specifically for&nbsp;<code>Either a</code>, the type signature would then be&nbsp;<code>(b -&gt; c) -&gt; Either a b -&gt; Either a c</code>&nbsp;because that's the same as&nbsp;<code>(b -&gt; c) -&gt; (Either a) b -&gt; (Either a) c</code>. In the implementation, we mapped in the case of a&nbsp;<code>Right</code>&nbsp;value constructor, but we didn't in the case of a&nbsp;<code>Left</code>. Why is that? Well, if we look back at how the&nbsp;<code>Either a b</code>&nbsp;type is defined, it's kind of like:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token keyword">data</span> <span class="token constant">Either</span> <span class="token hvariable">a</span> <span class="token hvariable">b</span> <span class="token operator">=</span> <span class="token constant">Left</span> <span class="token hvariable">a</span> <span class="token operator">|</span> <span class="token constant">Right</span> <span class="token hvariable">b</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Well, if we wanted to map one function over both of them,&nbsp;<code>a</code>&nbsp;and&nbsp;<code>b</code>&nbsp;would have to be the same type. I mean, if we tried to map a function that takes a string and returns a string and the&nbsp;<code>b</code>&nbsp;was a string but the&nbsp;<code>a</code>&nbsp;was a number, that wouldn't really work out. Also, from seeing what&nbsp;<code>fmap</code>'s type would be if it operated only on&nbsp;<code>Either</code>&nbsp;values, we see that the first parameter has to remain the same while the second one can change and the first parameter is actualized by the&nbsp;<code>Left</code>&nbsp;value constructor.</p></div><div><p>This also goes nicely with our box analogy if we think of the&nbsp;<code>Left</code>&nbsp;part as sort of an empty box with an error message written on the side telling us why it's empty.</p></div><div><p>Maps from&nbsp;<code>Data.Map</code>&nbsp;can also be made a functor because they hold values (or not!). In the case of&nbsp;<code>Map k v</code>,&nbsp;<code>fmap</code>&nbsp;will map a function&nbsp;<code>v -&gt; v'</code>&nbsp;over a map of type&nbsp;<code>Map k v</code>&nbsp;and return a map of type&nbsp;<code>Map k v'</code>.</p></div><div><p>Note, the&nbsp;'&nbsp;has no special meaning in types just like it doesn't have special meaning when naming values. It's used to denote things that are similar, only slightly changed.</p></div><div><p>Try figuring out how&nbsp;<code>Map k</code>&nbsp;is made an instance of&nbsp;<code>Functor</code>&nbsp;by yourself!</p></div><div><p>With the&nbsp;<code>Functor</code>&nbsp;typeclass, we've seen how typeclasses can represent pretty cool higher-order concepts. We've also had some more practice with partially applying types and making instances. In one of the next chapters, we'll also take a look at some laws that apply for functors.</p></div><div><p><em>Just one more thing!</em>&nbsp;Functors should obey some laws so that they may have some properties that we can depend on and not think about too much. If we use&nbsp;fmap (+1)&nbsp;over the list&nbsp;[1,2,3,4], we expect the result to be&nbsp;[2,3,4,5]&nbsp;and not its reverse,&nbsp;[5,4,3,2]. If we use&nbsp;fmap (\a -&gt; a)&nbsp;(the identity function, which just returns its parameter) over some list, we expect to get back the same list as a result. For example, if we gave the wrong functor instance to our&nbsp;Tree&nbsp;type, using&nbsp;fmap&nbsp;over a tree where the left sub-tree of a node only has elements that are smaller than the node and the right sub-tree only has nodes that are larger than the node might produce a tree where that's not the case. We'll go over the functor laws in more detail in one of the next chapters.</p></div><div><h2 data-heading="Kinds and some type-foo" id="Kinds_and_some_type-foo" style="display: flex;"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>Kinds and some type-foo</h2></div><div><p><img alt="TYPE FOO MASTER" src="http://s3.amazonaws.com/lyah/typefoo.png" referrerpolicy="no-referrer"></p></div><div><p>Type constructors take other types as parameters to eventually produce concrete types. That kind of reminds me of functions, which take values as parameters to produce values. We've seen that type constructors can be partially applied (<code>Either String</code>&nbsp;is a type that takes one type and produces a concrete type, like&nbsp;<code>Either String Int</code>), just like functions can. This is all very interesting indeed. In this section, we'll take a look at formally defining how types are applied to type constructors, just like we took a look at formally defining how values are applied to functions by using type declarations.&nbsp;<strong>You don't really have to read this section to continue on your magical Haskell quest</strong>&nbsp;and if you don't understand it, don't worry about it. However, getting this will give you a very thorough understanding of the type system.</p></div><div><p>So, values like&nbsp;<code>3</code>,&nbsp;<code>"YEAH"</code>&nbsp;or&nbsp;<code>takeWhile</code>&nbsp;(functions are also values, because we can pass them around and such) each have their own type. Types are little labels that values carry so that we can reason about the values. But types have their own little labels, called&nbsp;<strong>kinds</strong>. A kind is more or less the type of a type. This may sound a bit weird and confusing, but it's actually a really cool concept.</p></div><div><p>What are kinds and what are they good for? Well, let's examine the kind of a type by using the&nbsp;<code>:k</code>&nbsp;command in GHCI.</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token operator">:</span><span class="token hvariable">k</span> <span class="token constant">Int</span>
<span class="token constant">Int</span> <span class="token operator">::</span> <span class="token operator">*</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>A star? How quaint. What does that mean? A&nbsp;<code>*</code>&nbsp;means that the type is a concrete type. A concrete type is a type that doesn't take any type parameters and values can only have types that are concrete types. If I had to read&nbsp;<code>*</code>&nbsp;out loud (I haven't had to do that so far), I'd say&nbsp;<em>star</em>&nbsp;or just&nbsp;<em>type</em>.</p></div><div><p>Okay, now let's see what the kind of&nbsp;<code>Maybe</code>&nbsp;is.</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token operator">:</span><span class="token hvariable">k</span> <span class="token constant">Maybe</span>
<span class="token constant">Maybe</span> <span class="token operator">::</span> <span class="token operator">*</span> <span class="token operator">-&gt;</span> <span class="token operator">*</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>The&nbsp;<code>Maybe</code>&nbsp;type constructor takes one concrete type (like&nbsp;<code>Int</code>) and then returns a concrete type like&nbsp;<code>Maybe Int</code>. And that's what this kind tells us. Just like&nbsp;<code>Int -&gt; Int</code>&nbsp;means that a function takes an&nbsp;<code>Int</code>&nbsp;and returns an&nbsp;<code>Int</code>,&nbsp;<code>* -&gt; *</code>&nbsp;means that the type constructor takes one concrete type and returns a concrete type. Let's apply the type parameter to&nbsp;<code>Maybe</code>&nbsp;and see what the kind of that type is.</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token operator">:</span><span class="token hvariable">k</span> <span class="token constant">Maybe</span> <span class="token constant">Int</span>
<span class="token constant">Maybe</span> <span class="token constant">Int</span> <span class="token operator">::</span> <span class="token operator">*</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Just like I expected! We applied the type parameter to&nbsp;<code>Maybe</code>&nbsp;and got back a concrete type (that's what&nbsp;<code>* -&gt; *</code>&nbsp;means. A parallel (although not equivalent, types and kinds are two different things) to this is if we do&nbsp;<code>:t isUpper</code>&nbsp;and&nbsp;<code>:t isUpper 'A'</code>.&nbsp;<code>isUpper</code>&nbsp;has a type of&nbsp;<code>Char -&gt; Bool</code>&nbsp;and&nbsp;<code>isUpper 'A'</code>&nbsp;has a type of&nbsp;<code>Bool</code>, because its value is basically&nbsp;<code>True</code>. Both those types, however, have a kind of&nbsp;<code>*</code>.</p></div><div><p>We used&nbsp;<code>:k</code>&nbsp;on a type to get its kind, just like we can use&nbsp;<code>:t</code>&nbsp;on a value to get its type. Like we said, types are the labels of values and kinds are the labels of types and there are parallels between the two.</p></div><div><p>Let's look at another kind.</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token operator">:</span><span class="token hvariable">k</span> <span class="token constant">Either</span>
<span class="token constant">Either</span> <span class="token operator">::</span> <span class="token operator">*</span> <span class="token operator">-&gt;</span> <span class="token operator">*</span> <span class="token operator">-&gt;</span> <span class="token operator">*</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Aha, this tells us that&nbsp;<code>Either</code>&nbsp;takes two concrete types as type parameters to produce a concrete type. It also looks kind of like a type declaration of a function that takes two values and returns something. Type constructors are curried (just like functions), so we can partially apply them.</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token operator">:</span><span class="token hvariable">k</span> <span class="token constant">Either</span> <span class="token constant">String</span>
<span class="token constant">Either</span> <span class="token constant">String</span> <span class="token operator">::</span> <span class="token operator">*</span> <span class="token operator">-&gt;</span> <span class="token operator">*</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token operator">:</span><span class="token hvariable">k</span> <span class="token constant">Either</span> <span class="token constant">String</span> <span class="token constant">Int</span>
<span class="token constant">Either</span> <span class="token constant">String</span> <span class="token constant">Int</span> <span class="token operator">::</span> <span class="token operator">*</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>When we wanted to make&nbsp;<code>Either</code>&nbsp;a part of the&nbsp;<code>Functor</code>&nbsp;typeclass, we had to partially apply it because&nbsp;<code>Functor</code>&nbsp;wants types that take only one parameter while&nbsp;<code>Either</code>&nbsp;takes two. In other words,&nbsp;<code>Functor</code>&nbsp;wants types of kind&nbsp;<code>* -&gt; *</code>&nbsp;and so we had to partially apply&nbsp;<code>Either</code>&nbsp;to get a type of kind&nbsp;<code>* -&gt; *</code>&nbsp;instead of its original kind&nbsp;<code>* -&gt; * -&gt; *</code>. If we look at the definition of&nbsp;<code>Functor</code>&nbsp;again</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token keyword">class</span> <span class="token constant">Functor</span> <span class="token hvariable">f</span> <span class="token keyword">where</span> 
    <span class="token builtin">fmap</span> <span class="token operator">::</span> <span class="token punctuation">(</span><span class="token hvariable">a</span> <span class="token operator">-&gt;</span> <span class="token hvariable">b</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token hvariable">f</span> <span class="token hvariable">a</span> <span class="token operator">-&gt;</span> <span class="token hvariable">f</span> <span class="token hvariable">b</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>we see that the&nbsp;<code>f</code>&nbsp;type variable is used as a type that takes one concrete type to produce a concrete type. We know it has to produce a concrete type because it's used as the type of a value in a function. And from that, we can deduce that types that want to be friends with&nbsp;<code>Functor</code>&nbsp;have to be of kind&nbsp;<code>* -&gt; *</code>.</p></div><div><p>Now, let's do some type-foo. Take a look at this typeclass that I'm just going to make up right now:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token keyword">class</span> <span class="token constant">Tofu</span> <span class="token hvariable">t</span> <span class="token keyword">where</span>
    <span class="token hvariable">tofu</span> <span class="token operator">::</span> <span class="token hvariable">j</span> <span class="token hvariable">a</span> <span class="token operator">-&gt;</span> <span class="token hvariable">t</span> <span class="token hvariable">a</span> <span class="token hvariable">j</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Man, that looks weird. How would we make a type that could be an instance of that strange typeclass? Well, let's look at what its kind would have to be. Because&nbsp;<code>j a</code>&nbsp;is used as the type of a value that the&nbsp;<code>tofu</code>&nbsp;function takes as its parameter,&nbsp;<code>j a</code>&nbsp;has to have a kind of&nbsp;<code>*</code>. We assume&nbsp;<code>*</code>&nbsp;for&nbsp;<code>a</code>&nbsp;and so we can infer that&nbsp;<code>j</code>&nbsp;has to have a kind of&nbsp;<code>* -&gt; *</code>. We see that&nbsp;<code>t</code>&nbsp;has to produce a concrete value too and that it takes two types. And knowing that&nbsp;<code>a</code>&nbsp;has a kind of&nbsp;<code>*</code>&nbsp;and&nbsp;<code>j</code>&nbsp;has a kind of&nbsp;<code>* -&gt; *</code>, we infer that&nbsp;<code>t</code>&nbsp;has to have a kind of&nbsp;<code>* -&gt; (* -&gt; *) -&gt; *</code>. So it takes a concrete type (<code>a</code>), a type constructor that takes one concrete type (<code>j</code>) and produces a concrete type. Wow.</p></div><div><p>OK, so let's make a type with a kind of&nbsp;<code>* -&gt; (* -&gt; *) -&gt; *</code>. Here's one way of going about it.</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token keyword">data</span> <span class="token constant">Frank</span> <span class="token hvariable">a</span> <span class="token hvariable">b</span>  <span class="token operator">=</span> <span class="token constant">Frank</span> <span class="token punctuation">{</span><span class="token hvariable">frankField</span> <span class="token operator">::</span> <span class="token hvariable">b</span> <span class="token hvariable">a</span><span class="token punctuation">}</span> <span class="token keyword">deriving</span> <span class="token punctuation">(</span><span class="token constant">Show</span><span class="token punctuation">)</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>How do we know this type has a kind of&nbsp;<code>* -&gt; (* -&gt; *) - &gt; *</code>? Well, fields in ADTs are made to hold values, so they must be of kind&nbsp;<code>*</code>, obviously. We assume&nbsp;<code>*</code>&nbsp;for&nbsp;<code>a</code>, which means that&nbsp;<code>b</code>&nbsp;takes one type parameter and so its kind is&nbsp;<code>* -&gt; *</code>. Now we know the kinds of both&nbsp;<code>a</code>&nbsp;and&nbsp;<code>b</code>&nbsp;and because they're parameters for&nbsp;<code>Frank</code>, we see that&nbsp;<code>Frank</code>&nbsp;has a kind of&nbsp;<code>* -&gt; (* -&gt; *) -&gt; *</code>&nbsp;The first&nbsp;<code>*</code>&nbsp;represents&nbsp;<code>a</code>&nbsp;and the&nbsp;<code>(* -&gt; *)</code>&nbsp;represents&nbsp;<code>b</code>. Let's make some&nbsp;<code>Frank</code>&nbsp;values and check out their types.</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token operator">:</span><span class="token hvariable">t</span> <span class="token constant">Frank</span> <span class="token punctuation">{</span><span class="token hvariable">frankField</span> <span class="token operator">=</span> <span class="token constant">Just</span> <span class="token string">"HAHA"</span><span class="token punctuation">}</span>
<span class="token constant">Frank</span> <span class="token punctuation">{</span><span class="token hvariable">frankField</span> <span class="token operator">=</span> <span class="token constant">Just</span> <span class="token string">"HAHA"</span><span class="token punctuation">}</span> <span class="token operator">::</span> <span class="token constant">Frank</span> <span class="token punctuation">[</span><span class="token constant">Char</span><span class="token punctuation">]</span> <span class="token constant">Maybe</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token operator">:</span><span class="token hvariable">t</span> <span class="token constant">Frank</span> <span class="token punctuation">{</span><span class="token hvariable">frankField</span> <span class="token operator">=</span> <span class="token constant">Node</span> <span class="token char string">'a'</span> <span class="token constant">EmptyTree</span> <span class="token constant">EmptyTree</span><span class="token punctuation">}</span>
<span class="token constant">Frank</span> <span class="token punctuation">{</span><span class="token hvariable">frankField</span> <span class="token operator">=</span> <span class="token constant">Node</span> <span class="token char string">'a'</span> <span class="token constant">EmptyTree</span> <span class="token constant">EmptyTree</span><span class="token punctuation">}</span> <span class="token operator">::</span> <span class="token constant">Frank</span> <span class="token constant">Char</span> <span class="token constant">Tree</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token operator">:</span><span class="token hvariable">t</span> <span class="token constant">Frank</span> <span class="token punctuation">{</span><span class="token hvariable">frankField</span> <span class="token operator">=</span> <span class="token string">"YES"</span><span class="token punctuation">}</span>
<span class="token constant">Frank</span> <span class="token punctuation">{</span><span class="token hvariable">frankField</span> <span class="token operator">=</span> <span class="token string">"YES"</span><span class="token punctuation">}</span> <span class="token operator">::</span> <span class="token constant">Frank</span> <span class="token constant">Char</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Hmm. Because&nbsp;<code>frankField</code>&nbsp;has a type of form&nbsp;<code>a b</code>, its values must have types that are of a similar form as well. So they can be&nbsp;<code>Just "HAHA"</code>, which has a type of&nbsp;<code>Maybe [Char]</code>&nbsp;or it can have a value of&nbsp;<code>['Y','E','S']</code>, which has a type of&nbsp;<code>[Char]</code>&nbsp;(if we used our own list type for this, it would have a type of&nbsp;<code>List Char</code>). And we see that the types of the&nbsp;<code>Frank</code>&nbsp;values correspond with the kind for&nbsp;<code>Frank</code>.&nbsp;<code>[Char]</code>&nbsp;has a kind of&nbsp;<code>*</code>&nbsp;and&nbsp;<code>Maybe</code>&nbsp;has a kind of&nbsp;<code>* -&gt; *</code>. Because in order to have a value, it has to be a concrete type and thus has to be fully applied, every value of&nbsp;<code>Frank blah blaah</code>&nbsp;has a kind of&nbsp;<code>*</code>.</p></div><div><p>Making&nbsp;<code>Frank</code>&nbsp;an instance of&nbsp;<code>Tofu</code>&nbsp;is pretty simple. We see that&nbsp;<code>tofu</code>&nbsp;takes a&nbsp;<code>j a</code>&nbsp;(so an example type of that form would be&nbsp;<code>Maybe Int</code>) and returns a&nbsp;<code>t a j</code>. So if we replace&nbsp;<code>Frank</code>&nbsp;with&nbsp;<code>j</code>, the result type would be&nbsp;<code>Frank Int Maybe</code>.</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token keyword">instance</span> <span class="token constant">Tofu</span> <span class="token constant">Frank</span> <span class="token keyword">where</span>
    <span class="token hvariable">tofu</span> <span class="token hvariable">x</span> <span class="token operator">=</span> <span class="token constant">Frank</span> <span class="token hvariable">x</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token hvariable">tofu</span> <span class="token punctuation">(</span><span class="token constant">Just</span> <span class="token char string">'a'</span><span class="token punctuation">)</span> <span class="token operator">::</span> <span class="token constant">Frank</span> <span class="token constant">Char</span> <span class="token constant">Maybe</span>
<span class="token constant">Frank</span> <span class="token punctuation">{</span><span class="token hvariable">frankField</span> <span class="token operator">=</span> <span class="token constant">Just</span> <span class="token char string">'a'</span><span class="token punctuation">}</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token hvariable">tofu</span> <span class="token punctuation">[</span><span class="token string">"HELLO"</span><span class="token punctuation">]</span> <span class="token operator">::</span> <span class="token constant">Frank</span> <span class="token punctuation">[</span><span class="token constant">Char</span><span class="token punctuation">]</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
<span class="token constant">Frank</span> <span class="token punctuation">{</span><span class="token hvariable">frankField</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">"HELLO"</span><span class="token punctuation">]</span><span class="token punctuation">}</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Not very useful, but we did flex our type muscles. Let's do some more type-foo. We have this data type:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token keyword">data</span> <span class="token constant">Barry</span> <span class="token hvariable">t</span> <span class="token hvariable">k</span> <span class="token hvariable">p</span> <span class="token operator">=</span> <span class="token constant">Barry</span> <span class="token punctuation">{</span> <span class="token hvariable">yabba</span> <span class="token operator">::</span> <span class="token hvariable">p</span><span class="token punctuation">,</span> <span class="token hvariable">dabba</span> <span class="token operator">::</span> <span class="token hvariable">t</span> <span class="token hvariable">k</span> <span class="token punctuation">}</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>And now we want to make it an instance of&nbsp;<code>Functor</code>.&nbsp;<code>Functor</code>&nbsp;wants types of kind&nbsp;<code>* -&gt; *</code>&nbsp;but&nbsp;<code>Barry</code>&nbsp;doesn't look like it has that kind. What is the kind of&nbsp;<code>Barry</code>? Well, we see it takes three type parameters, so it's going to be&nbsp;<code>something -&gt; something -&gt; something -&gt; *</code>. It's safe to say that&nbsp;<code>p</code>&nbsp;is a concrete type and thus has a kind of&nbsp;<code>*</code>. For&nbsp;<code>k</code>, we assume&nbsp;<code>*</code>&nbsp;and so by extension,&nbsp;<code>t</code>&nbsp;has a kind of&nbsp;<code>* -&gt; *</code>. Now let's just replace those kinds with the&nbsp;<em>somethings</em>&nbsp;that we used as placeholders and we see it has a kind of&nbsp;<code>(* -&gt; *) -&gt; * -&gt; * -&gt; *</code>. Let's check that with GHCI.</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token operator">:</span><span class="token hvariable">k</span> <span class="token constant">Barry</span>
<span class="token constant">Barry</span> <span class="token operator">::</span> <span class="token punctuation">(</span><span class="token operator">*</span> <span class="token operator">-&gt;</span> <span class="token operator">*</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token operator">*</span> <span class="token operator">-&gt;</span> <span class="token operator">*</span> <span class="token operator">-&gt;</span> <span class="token operator">*</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Ah, we were right. How satisfying. Now, to make this type a part of&nbsp;<code>Functor</code>&nbsp;we have to partially apply the first two type parameters so that we're left with&nbsp;<code>* -&gt; *</code>. That means that the start of the instance declaration will be:&nbsp;<code>instance Functor (Barry a b) where</code>. If we look at&nbsp;<code>fmap</code>&nbsp;as if it was made specifically for&nbsp;<code>Barry</code>, it would have a type of&nbsp;<code>fmap :: (a -&gt; b) -&gt; Barry c d a -&gt; Barry c d b</code>, because we just replace the&nbsp;<code>Functor</code>'s&nbsp;<code>f</code>&nbsp;with&nbsp;<code>Barry c d</code>. The third type parameter from&nbsp;<code>Barry</code>&nbsp;will have to change and we see that it's conviniently in its own field.</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token keyword">instance</span> <span class="token constant">Functor</span> <span class="token punctuation">(</span><span class="token constant">Barry</span> <span class="token hvariable">a</span> <span class="token hvariable">b</span><span class="token punctuation">)</span> <span class="token keyword">where</span>
    <span class="token builtin">fmap</span> <span class="token hvariable">f</span> <span class="token punctuation">(</span><span class="token constant">Barry</span> <span class="token punctuation">{</span><span class="token hvariable">yabba</span> <span class="token operator">=</span> <span class="token hvariable">x</span><span class="token punctuation">,</span> <span class="token hvariable">dabba</span> <span class="token operator">=</span> <span class="token hvariable">y</span><span class="token punctuation">}</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token constant">Barry</span> <span class="token punctuation">{</span><span class="token hvariable">yabba</span> <span class="token operator">=</span> <span class="token hvariable">f</span> <span class="token hvariable">x</span><span class="token punctuation">,</span> <span class="token hvariable">dabba</span> <span class="token operator">=</span> <span class="token hvariable">y</span><span class="token punctuation">}</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>There we go! We just mapped the&nbsp;<code>f</code>&nbsp;over the first field.</p></div><div><p>In this section, we took a good look at how type parameters work and kind of formalized them with kinds, just like we formalized function parameters with type declarations. We saw that there are interesting parallels between functions and type constructors. They are, however, two completely different things. When working on real Haskell, you usually won't have to mess with kinds and do kind inference by hand like we did now. Usually, you just have to partially apply your own type to&nbsp;<code>* -&gt; *</code>&nbsp;or&nbsp;<code>*</code>&nbsp;when making it an instance of one of the standard typeclasses, but it's good to know how and why that actually works. It's also interesting to see that types have little types of their own. Again, you don't really have to understand everything we did here to read on, but if you understand how kinds work, chances are that you have a very solid grasp of Haskell's type system.</p></div><div class="mod-footer"></div></div></div></div><div class="sidebar-right sidebar"><div class="sidebar-content"><span class="sidebar-section-header">Interactive Graph</span><div class="graph-view-placeholder">
		<div class="graph-view-container">
			<div class="graph-icon graph-expand" role="button" aria-label="Expand" data-tooltip-position="top"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon lucide-arrow-up-right"><line x1="7" y1="17" x2="17" y2="7"></line><polyline points="7 7 17 7 17 17"></polyline></svg></div>
			<canvas id="graph-canvas" width="512px" height="512px"></canvas>
		</div>
		</div><div class="tree-container outline-tree" data-depth="0"><div class="tree-header"><span class="sidebar-section-header">Table Of Contents</span><button class="clickable-icon collapse-tree-button"><iconify-icon icon="ph:arrows-in-line-horizontal-bold" width="18px" height="18px" rotate="90deg" color="currentColor"></iconify-icon></button></div><div class="tree-scroll-area"><div class="tree-item mod-tree-heading" data-depth="1"><div class="tree-item-contents"><a class="tree-item-link" href="#Making_Our_Own_Types_and_Typeclasses"><span class="tree-item-title">Making Our Own Types and Typeclasses</span></a></div><div class="tree-item-children"><div class="tree-item mod-tree-heading" data-depth="2"><div class="tree-item-contents"><a class="tree-item-link" href="#Algebraic_data_types_intro"><span class="tree-item-title">Algebraic data types intro</span></a></div><div class="tree-item-children"></div></div><div class="tree-item mod-tree-heading" data-depth="2"><div class="tree-item-contents"><a class="tree-item-link" href="#Record_syntax"><span class="tree-item-title">Record syntax</span></a></div><div class="tree-item-children"></div></div><div class="tree-item mod-tree-heading" data-depth="2"><div class="tree-item-contents"><a class="tree-item-link" href="#Type_parameters"><span class="tree-item-title">Type parameters</span></a></div><div class="tree-item-children"></div></div><div class="tree-item mod-tree-heading" data-depth="2"><div class="tree-item-contents"><a class="tree-item-link" href="#Derived_instances"><span class="tree-item-title">Derived instances</span></a></div><div class="tree-item-children"></div></div><div class="tree-item mod-tree-heading" data-depth="2"><div class="tree-item-contents"><a class="tree-item-link" href="#Type_synonyms"><span class="tree-item-title">Type synonyms</span></a></div><div class="tree-item-children"></div></div><div class="tree-item mod-tree-heading" data-depth="2"><div class="tree-item-contents"><a class="tree-item-link" href="#Recursive_data_structures"><span class="tree-item-title">Recursive data structures</span></a></div><div class="tree-item-children"></div></div><div class="tree-item mod-tree-heading" data-depth="2"><div class="tree-item-contents"><a class="tree-item-link" href="#Typeclasses_102"><span class="tree-item-title">Typeclasses 102</span></a></div><div class="tree-item-children"></div></div><div class="tree-item mod-tree-heading" data-depth="2"><div class="tree-item-contents"><a class="tree-item-link" href="#A_yes-no_typeclass"><span class="tree-item-title">A yes-no typeclass</span></a></div><div class="tree-item-children"></div></div><div class="tree-item mod-tree-heading" data-depth="2"><div class="tree-item-contents"><a class="tree-item-link" href="#The_Functor_typeclass"><span class="tree-item-title">The Functor typeclass</span></a></div><div class="tree-item-children"></div></div><div class="tree-item mod-tree-heading" data-depth="2"><div class="tree-item-contents"><a class="tree-item-link" href="#Kinds_and_some_type-foo"><span class="tree-item-title">Kinds and some type-foo</span></a></div><div class="tree-item-children"></div></div></div></div></div></div></div></div></div></body></html>