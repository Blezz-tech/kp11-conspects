<!DOCTYPE html>
<html><head>
			
		<title>Chapter 4 Syntax in Functions</title>
		<base href="../../../">
		<meta id="root-path" root-path="../../../">

		<link rel="icon" sizes="96x96" href="https://publish-01.obsidian.md/access/f786db9fac45774fa4f0d8112e232d67/favicon-96x96.png">
		<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes, minimum-scale=1.0, maximum-scale=5.0">
		<meta charset="UTF-8">
		<script src="https://code.iconify.design/iconify-icon/1.0.3/iconify-icon.min.js"></script>

			<link rel="stylesheet" href="lib/styles/obsidian-styles.css">
			<link rel="stylesheet" href="lib/styles/theme.css">
			<link rel="stylesheet" href="lib/styles/plugin-styles.css">
			<link rel="stylesheet" href="lib/styles/snippets.css">
			<style>  </style>

			
			<!-- Graph View Data -->
			<script>
			let nodes=
{"nodeCount":22,"linkCount":21,"radii":[7,5.346938775510203,4.855867346938775,4.301020408163265,3.6823979591836737,3.6823979591836737,3.6823979591836737,3.6823979591836737,3.6823979591836737,3.6823979591836737,3.6823979591836737,3.6823979591836737,3.6823979591836737,3.6823979591836737,3.6823979591836737,3.6823979591836737,3.6823979591836737,3.6823979591836737,3.6823979591836737,3.6823979591836737,3.6823979591836737,3.6823979591836737],"labels":["Table Of Content","Отчеты","README","README","О Haskell по-человечески (Итого)","Полезные ресурсы","О Haskell по-человечески (Оригинал)","Оглавление","Chapter 13 For a Few Monads More","Chapter 12 A Fistful of Monads","Chapter 11 Functors, Applicative Functors and Monoids","Chapter 10 Functionally Solving Problems","Chapter 9 Input and Output","Chapter 8 Making Our Own Types and Typeclasses","Chapter 7 Modules","Chapter 6 Higher order functions","Chapter 5 Recursion","Chapter 4 Syntax in Functions","Chapter 14 Zippers","Chapter 1 Introduction","Chapter 2 Starting Out","Chapter 3 Types and Typeclasses"],"paths":["курсы/learn-you-a-haskell-for-great-good!/en/table-of-content.html","отчеты.html","курсы/learn-you-a-haskell-for-great-good!/readme.html","readme.html","мои-решения/о-haskell-по-человечески/о-haskell-по-человечески-(итого).html","полезные-ресурсы.html","курсы/о-haskell-по-человечески/о-haskell-по-человечески-(оригинал).html","курсы/learn-you-a-haskell-for-great-good!/ru/оглавление.html","курсы/learn-you-a-haskell-for-great-good!/en/chapter-13-for-a-few-monads-more.html","курсы/learn-you-a-haskell-for-great-good!/en/chapter-12-a-fistful-of-monads.html","курсы/learn-you-a-haskell-for-great-good!/en/chapter-11-functors,-applicative-functors-and-monoids.html","курсы/learn-you-a-haskell-for-great-good!/en/chapter-10-functionally-solving-problems.html","курсы/learn-you-a-haskell-for-great-good!/en/chapter-9-input-and-output.html","курсы/learn-you-a-haskell-for-great-good!/en/chapter-8-making-our-own-types-and-typeclasses.html","курсы/learn-you-a-haskell-for-great-good!/en/chapter-7-modules.html","курсы/learn-you-a-haskell-for-great-good!/en/chapter-6-higher-order-functions.html","курсы/learn-you-a-haskell-for-great-good!/en/chapter-5-recursion.html","курсы/learn-you-a-haskell-for-great-good!/en/chapter-4-syntax-in-functions.html","курсы/learn-you-a-haskell-for-great-good!/en/chapter-14-zippers.html","курсы/learn-you-a-haskell-for-great-good!/en/chapter-1-introduction.html","курсы/learn-you-a-haskell-for-great-good!/en/chapter-2-starting-out.html","курсы/learn-you-a-haskell-for-great-good!/en/chapter-3-types-and-typeclasses.html"],"linkSources":[3,3,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,2],"linkTargets":[5,1,6,4,2,19,20,21,17,16,15,14,13,12,11,10,9,8,18,0,7]};
			let attractionForce = 1;
			let linkLength = 10;
			let repulsionForce = 150;
			let centralForce = 3;
			let edgePruning = 100;
			</script>
			
<script type="module" src="lib/scripts/graph_view.js"></script>

<script src="lib/scripts/graph_wasm.js"></script>

<script src="lib/scripts/tinycolor.js"></script>

<script src="https://cdnjs.cloudflare.com/ajax/libs/pixi.js/7.2.4/pixi.min.js" integrity="sha512-Ch/O6kL8BqUwAfCF7Ie5SX1Hin+BJgYH4pNjRqXdTEqMsis1TUYg+j6nnI9uduPjGaj7DN4UKCZgpvoExt6dkw==" crossorigin="anonymous" referrerpolicy="no-referrer"></script>

<script src="lib/scripts/webpage.js"></script>

			</head><body class="theme-dark mod-windows is-frameless is-maximized is-hidden-frameless obsidian-app show-inline-title show-view-header" style="--zoom-factor:1; --font-text-size:16px; --line-width:100%; --line-width-adaptive:100%; --file-line-width:100%; --content-width:500em; --sidebar-width:25em; --collapse-arrow-size:0.4em; --tree-horizontal-spacing:1em; --tree-vertical-spacing:0.5em; --sidebar-margin:12px;"><div class="webpage-container"><div class="sidebar-left sidebar"><div class="sidebar-content"><div><label class="theme-toggle-container" for="theme_toggle"><input class="theme-toggle-input" type="checkbox" id="theme_toggle"><div class="toggle-background"></div></label></div><div class="tree-container file-tree mod-nav-indicator" data-depth="0"><div class="tree-header"><span class="sidebar-section-header">learn-haskell-valut</span><button class="clickable-icon collapse-tree-button is-collapsed"><iconify-icon icon="ph:arrows-in-line-horizontal-bold" width="18px" height="18px" rotate="90deg" color="currentColor"></iconify-icon></button></div><div class="tree-scroll-area"><div class="tree-item mod-tree-folder mod-collapsible is-collapsed" data-depth="1"><div class="tree-item-contents"><div class="tree-item-icon collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div><a class="tree-item-link" href="курсы"><span class="tree-item-title">Курсы</span></a></div><div class="tree-item-children"><div class="tree-item mod-tree-folder mod-collapsible is-collapsed" data-depth="2"><div class="tree-item-contents"><div class="tree-item-icon collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div><a class="tree-item-link" href="курсы/о-haskell-по-человечески"><span class="tree-item-title">О Haskell по-человечески</span></a></div><div class="tree-item-children"><div class="tree-item mod-tree-file" data-depth="3"><div class="tree-item-contents"><a class="tree-item-link" href="курсы/о-haskell-по-человечески/о-haskell-по-человечески-(оригинал).html"><span class="tree-item-title">О Haskell по-человечески (Оригинал)</span></a></div><div class="tree-item-children"></div></div></div></div><div class="tree-item mod-tree-folder mod-collapsible is-collapsed" data-depth="2"><div class="tree-item-contents"><div class="tree-item-icon collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div><a class="tree-item-link" href="курсы/learn-you-a-haskell-for-great-good!"><span class="tree-item-title">Learn You a Haskell for Great Good!</span></a></div><div class="tree-item-children"><div class="tree-item mod-tree-folder mod-collapsible is-collapsed" data-depth="3"><div class="tree-item-contents"><div class="tree-item-icon collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div><a class="tree-item-link" href="курсы/learn-you-a-haskell-for-great-good!/en"><span class="tree-item-title">en</span></a></div><div class="tree-item-children"><div class="tree-item mod-tree-file" data-depth="4"><div class="tree-item-contents"><a class="tree-item-link" href="курсы/learn-you-a-haskell-for-great-good!/en/chapter-1-introduction.html"><span class="tree-item-title">Chapter 1 Introduction</span></a></div><div class="tree-item-children"></div></div><div class="tree-item mod-tree-file" data-depth="4"><div class="tree-item-contents"><a class="tree-item-link" href="курсы/learn-you-a-haskell-for-great-good!/en/chapter-10-functionally-solving-problems.html"><span class="tree-item-title">Chapter 10 Functionally Solving Problems</span></a></div><div class="tree-item-children"></div></div><div class="tree-item mod-tree-file" data-depth="4"><div class="tree-item-contents"><a class="tree-item-link" href="курсы/learn-you-a-haskell-for-great-good!/en/chapter-11-functors,-applicative-functors-and-monoids.html"><span class="tree-item-title">Chapter 11 Functors, Applicative Functors and Monoids</span></a></div><div class="tree-item-children"></div></div><div class="tree-item mod-tree-file" data-depth="4"><div class="tree-item-contents"><a class="tree-item-link" href="курсы/learn-you-a-haskell-for-great-good!/en/chapter-12-a-fistful-of-monads.html"><span class="tree-item-title">Chapter 12 A Fistful of Monads</span></a></div><div class="tree-item-children"></div></div><div class="tree-item mod-tree-file" data-depth="4"><div class="tree-item-contents"><a class="tree-item-link" href="курсы/learn-you-a-haskell-for-great-good!/en/chapter-13-for-a-few-monads-more.html"><span class="tree-item-title">Chapter 13 For a Few Monads More</span></a></div><div class="tree-item-children"></div></div><div class="tree-item mod-tree-file" data-depth="4"><div class="tree-item-contents"><a class="tree-item-link" href="курсы/learn-you-a-haskell-for-great-good!/en/chapter-14-zippers.html"><span class="tree-item-title">Chapter 14 Zippers</span></a></div><div class="tree-item-children"></div></div><div class="tree-item mod-tree-file" data-depth="4"><div class="tree-item-contents"><a class="tree-item-link" href="курсы/learn-you-a-haskell-for-great-good!/en/chapter-2-starting-out.html"><span class="tree-item-title">Chapter 2 Starting Out</span></a></div><div class="tree-item-children"></div></div><div class="tree-item mod-tree-file" data-depth="4"><div class="tree-item-contents"><a class="tree-item-link" href="курсы/learn-you-a-haskell-for-great-good!/en/chapter-3-types-and-typeclasses.html"><span class="tree-item-title">Chapter 3 Types and Typeclasses</span></a></div><div class="tree-item-children"></div></div><div class="tree-item mod-tree-file" data-depth="4"><div class="tree-item-contents"><a class="tree-item-link" href="курсы/learn-you-a-haskell-for-great-good!/en/chapter-4-syntax-in-functions.html"><span class="tree-item-title">Chapter 4 Syntax in Functions</span></a></div><div class="tree-item-children"></div></div><div class="tree-item mod-tree-file" data-depth="4"><div class="tree-item-contents"><a class="tree-item-link" href="курсы/learn-you-a-haskell-for-great-good!/en/chapter-5-recursion.html"><span class="tree-item-title">Chapter 5 Recursion</span></a></div><div class="tree-item-children"></div></div><div class="tree-item mod-tree-file" data-depth="4"><div class="tree-item-contents"><a class="tree-item-link" href="курсы/learn-you-a-haskell-for-great-good!/en/chapter-6-higher-order-functions.html"><span class="tree-item-title">Chapter 6 Higher order functions</span></a></div><div class="tree-item-children"></div></div><div class="tree-item mod-tree-file" data-depth="4"><div class="tree-item-contents"><a class="tree-item-link" href="курсы/learn-you-a-haskell-for-great-good!/en/chapter-7-modules.html"><span class="tree-item-title">Chapter 7 Modules</span></a></div><div class="tree-item-children"></div></div><div class="tree-item mod-tree-file" data-depth="4"><div class="tree-item-contents"><a class="tree-item-link" href="курсы/learn-you-a-haskell-for-great-good!/en/chapter-8-making-our-own-types-and-typeclasses.html"><span class="tree-item-title">Chapter 8 Making Our Own Types and Typeclasses</span></a></div><div class="tree-item-children"></div></div><div class="tree-item mod-tree-file" data-depth="4"><div class="tree-item-contents"><a class="tree-item-link" href="курсы/learn-you-a-haskell-for-great-good!/en/chapter-9-input-and-output.html"><span class="tree-item-title">Chapter 9 Input and Output</span></a></div><div class="tree-item-children"></div></div><div class="tree-item mod-tree-file" data-depth="4"><div class="tree-item-contents"><a class="tree-item-link" href="курсы/learn-you-a-haskell-for-great-good!/en/table-of-content.html"><span class="tree-item-title">Table Of Content</span></a></div><div class="tree-item-children"></div></div></div></div><div class="tree-item mod-tree-folder mod-collapsible is-collapsed" data-depth="3"><div class="tree-item-contents"><div class="tree-item-icon collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div><a class="tree-item-link" href="курсы/learn-you-a-haskell-for-great-good!/ru"><span class="tree-item-title">ru</span></a></div><div class="tree-item-children"><div class="tree-item mod-tree-file" data-depth="4"><div class="tree-item-contents"><a class="tree-item-link" href="курсы/learn-you-a-haskell-for-great-good!/ru/оглавление.html"><span class="tree-item-title">Оглавление</span></a></div><div class="tree-item-children"></div></div></div></div><div class="tree-item mod-tree-file" data-depth="3"><div class="tree-item-contents"><a class="tree-item-link" href="курсы/learn-you-a-haskell-for-great-good!/readme.html"><span class="tree-item-title">README</span></a></div><div class="tree-item-children"></div></div></div></div></div></div><div class="tree-item mod-tree-folder mod-collapsible is-collapsed" data-depth="1"><div class="tree-item-contents"><div class="tree-item-icon collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div><a class="tree-item-link" href="мои-решения"><span class="tree-item-title">Мои решения</span></a></div><div class="tree-item-children"><div class="tree-item mod-tree-folder mod-collapsible is-collapsed" data-depth="2"><div class="tree-item-contents"><div class="tree-item-icon collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div><a class="tree-item-link" href="мои-решения/о-haskell-по-человечески"><span class="tree-item-title">О Haskell по-человечески</span></a></div><div class="tree-item-children"><div class="tree-item mod-tree-file" data-depth="3"><div class="tree-item-contents"><a class="tree-item-link" href="мои-решения/о-haskell-по-человечески/о-haskell-по-человечески-(итого).html"><span class="tree-item-title">О Haskell по-человечески (Итого)</span></a></div><div class="tree-item-children"></div></div></div></div></div></div><div class="tree-item mod-tree-file" data-depth="1"><div class="tree-item-contents"><a class="tree-item-link" href="отчеты.html"><span class="tree-item-title">Отчеты</span></a></div><div class="tree-item-children"></div></div><div class="tree-item mod-tree-file" data-depth="1"><div class="tree-item-contents"><a class="tree-item-link" href="полезные-ресурсы.html"><span class="tree-item-title">Полезные ресурсы</span></a></div><div class="tree-item-children"></div></div><div class="tree-item mod-tree-file" data-depth="1"><div class="tree-item-contents"><a class="tree-item-link" href="readme.html"><span class="tree-item-title">README</span></a></div><div class="tree-item-children"></div></div></div></div></div></div><div class="document-container"><div class="markdown-preview-view markdown-rendered node-insert-event allow-fold-headings show-indentation-guide allow-fold-lists show-frontmatter" style="tab-size: 4;" tabindex="-1"><style id="MJX-CHTML-styles"></style><div class="markdown-preview-sizer markdown-preview-section" style="padding-bottom: ; padding-top: var(--file-margins); padding-right: var(--file-margins); padding-left: var(--file-margins); width: 100%; position: absolute;"><div class="markdown-preview-pusher" style="width: 1px; height: 0.1px; margin-bottom: 0px;"></div><div class="mod-header"></div><div><h1 data-heading="Syntax in Functions" id="Syntax_in_Functions">Syntax in Functions</h1></div><div><h2 data-heading="Pattern matching" id="Pattern_matching" style="display: flex;"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>Pattern matching</h2></div><div><p><img alt="four!" src="http://s3.amazonaws.com/lyah/pattern.png" referrerpolicy="no-referrer"></p></div><div><p>This chapter will cover some of Haskell's cool syntactic constructs and we'll start with pattern matching. Pattern matching consists of specifying patterns to which some data should conform and then checking to see if it does and deconstructing the data according to those patterns.</p></div><div><p>When defining functions, you can define separate function bodies for different patterns. This leads to really neat code that's simple and readable. You can pattern match on any data type — numbers, characters, lists, tuples, etc. Let's make a really trivial function that checks if the number we supplied to it is a seven or not.</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">lucky</span> <span class="token operator">::</span> <span class="token punctuation">(</span><span class="token constant">Integral</span> <span class="token hvariable">a</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token hvariable">a</span> <span class="token operator">-&gt;</span> <span class="token constant">String</span>
<span class="token hvariable">lucky</span> <span class="token number">7</span> <span class="token operator">=</span> <span class="token string">"LUCKY NUMBER SEVEN!"</span>
<span class="token hvariable">lucky</span> <span class="token hvariable">x</span> <span class="token operator">=</span> <span class="token string">"Sorry, you're out of luck, pal!"</span> 
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>When you call&nbsp;<code>lucky</code>, the patterns will be checked from top to bottom and when it conforms to a pattern, the corresponding function body will be used. The only way a number can conform to the first pattern here is if it is 7. If it's not, it falls through to the second pattern, which matches anything and binds it to&nbsp;<code>x</code>. This function could have also been implemented by using an if statement. But what if we wanted a function that says the numbers from 1 to 5 and says&nbsp;<code>"Not between 1 and 5"</code>&nbsp;for any other number? Without pattern matching, we'd have to make a pretty convoluted if then else tree. However, with it:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">sayMe</span> <span class="token operator">::</span> <span class="token punctuation">(</span><span class="token constant">Integral</span> <span class="token hvariable">a</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token hvariable">a</span> <span class="token operator">-&gt;</span> <span class="token constant">String</span>
<span class="token hvariable">sayMe</span> <span class="token number">1</span> <span class="token operator">=</span> <span class="token string">"One!"</span>
<span class="token hvariable">sayMe</span> <span class="token number">2</span> <span class="token operator">=</span> <span class="token string">"Two!"</span>
<span class="token hvariable">sayMe</span> <span class="token number">3</span> <span class="token operator">=</span> <span class="token string">"Three!"</span>
<span class="token hvariable">sayMe</span> <span class="token number">4</span> <span class="token operator">=</span> <span class="token string">"Four!"</span>
<span class="token hvariable">sayMe</span> <span class="token number">5</span> <span class="token operator">=</span> <span class="token string">"Five!"</span>
<span class="token hvariable">sayMe</span> <span class="token hvariable">x</span> <span class="token operator">=</span> <span class="token string">"Not between 1 and 5"</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Note that if we moved the last pattern (the catch-all one) to the top, it would always say&nbsp;<code>"Not between 1 and 5"</code>, because it would catch all the numbers and they wouldn't have a chance to fall through and be checked for any other patterns.</p></div><div><p>Remember the factorial function we implemented previously? We defined the factorial of a number&nbsp;<code>n</code>&nbsp;as&nbsp;<code>product [1..n]</code>. We can also define a factorial function&nbsp;<em>recursively</em>, the way it is usually defined in mathematics. We start by saying that the factorial of 0 is 1. Then we state that the factorial of any positive integer is that integer multiplied by the factorial of its predecessor. Here's how that looks like translated in Haskell terms.</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">factorial</span> <span class="token operator">::</span> <span class="token punctuation">(</span><span class="token constant">Integral</span> <span class="token hvariable">a</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token hvariable">a</span> <span class="token operator">-&gt;</span> <span class="token hvariable">a</span>
<span class="token hvariable">factorial</span> <span class="token number">0</span> <span class="token operator">=</span> <span class="token number">1</span>
<span class="token hvariable">factorial</span> <span class="token hvariable">n</span> <span class="token operator">=</span> <span class="token hvariable">n</span> <span class="token operator">*</span> <span class="token hvariable">factorial</span> <span class="token punctuation">(</span><span class="token hvariable">n</span> <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>This is the first time we've defined a function recursively. Recursion is important in Haskell and we'll take a closer look at it later. But in a nutshell, this is what happens if we try to get the factorial of, say, 3. It tries to compute&nbsp;<code>3 * factorial 2</code>. The factorial of 2 is&nbsp;<code>2 * factorial 1</code>, so for now we have&nbsp;<code>3 * (2 * factorial 1)</code>.&nbsp;<code>factorial 1</code>&nbsp;is&nbsp;<code>1 * factorial 0</code>, so we have&nbsp;<code>3 * (2 * (1 * factorial 0))</code>. Now here comes the trick — we've defined the factorial of 0 to be just 1 and because it encounters that pattern before the catch-all one, it just returns 1. So the final result is equivalent to&nbsp;<code>3 * (2 * (1 * 1))</code>. Had we written the second pattern on top of the first one, it would catch all numbers, including 0 and our calculation would never terminate. That's why order is important when specifying patterns and it's always best to specify the most specific ones first and then the more general ones later.</p></div><div><p>Pattern matching can also fail. If we define a function like this:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">charName</span> <span class="token operator">::</span> <span class="token constant">Char</span> <span class="token operator">-&gt;</span> <span class="token constant">String</span>
<span class="token hvariable">charName</span> <span class="token char string">'a'</span> <span class="token operator">=</span> <span class="token string">"Albert"</span>
<span class="token hvariable">charName</span> <span class="token char string">'b'</span> <span class="token operator">=</span> <span class="token string">"Broseph"</span>
<span class="token hvariable">charName</span> <span class="token char string">'c'</span> <span class="token operator">=</span> <span class="token string">"Cecil"</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>and then try to call it with an input that we didn't expect, this is what happens:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token hvariable">charName</span> <span class="token char string">'a'</span>
<span class="token string">"Albert"</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token hvariable">charName</span> <span class="token char string">'b'</span>
<span class="token string">"Broseph"</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token hvariable">charName</span> <span class="token char string">'h'</span>
"<span class="token operator">***</span> <span class="token constant">Exception</span><span class="token operator">:</span> <span class="token hvariable">tut</span><span class="token punctuation">.</span><span class="token hvariable">hs</span><span class="token operator">:</span><span class="token punctuation">(</span><span class="token number">53</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token operator">-</span><span class="token punctuation">(</span><span class="token number">55</span><span class="token punctuation">,</span><span class="token number">21</span><span class="token punctuation">)</span><span class="token operator">:</span> <span class="token constant">Non</span><span class="token operator">-</span><span class="token hvariable">exhaustive</span> <span class="token hvariable">patterns</span> <span class="token keyword">in</span> <span class="token hvariable">function</span> <span class="token hvariable">charName</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>It complains that we have non-exhaustive patterns, and rightfully so. When making patterns, we should always include a catch-all pattern so that our program doesn't crash if we get some unexpected input.</p></div><div><p>Pattern matching can also be used on tuples. What if we wanted to make a function that takes two vectors in a 2D space (that are in the form of pairs) and adds them together? To add together two vectors, we add their x components separately and then their y components separately. Here's how we would have done it if we didn't know about pattern matching:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">addVectors</span> <span class="token operator">::</span> <span class="token punctuation">(</span><span class="token constant">Num</span> <span class="token hvariable">a</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">(</span><span class="token hvariable">a</span><span class="token punctuation">,</span> <span class="token hvariable">a</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token punctuation">(</span><span class="token hvariable">a</span><span class="token punctuation">,</span> <span class="token hvariable">a</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token punctuation">(</span><span class="token hvariable">a</span><span class="token punctuation">,</span> <span class="token hvariable">a</span><span class="token punctuation">)</span>
<span class="token hvariable">addVectors</span> <span class="token hvariable">a</span> <span class="token hvariable">b</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token builtin">fst</span> <span class="token hvariable">a</span> <span class="token operator">+</span> <span class="token builtin">fst</span> <span class="token hvariable">b</span><span class="token punctuation">,</span> <span class="token builtin">snd</span> <span class="token hvariable">a</span> <span class="token operator">+</span> <span class="token builtin">snd</span> <span class="token hvariable">b</span><span class="token punctuation">)</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Well, that works, but there's a better way to do it. Let's modify the function so that it uses pattern matching.</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">addVectors</span> <span class="token operator">::</span> <span class="token punctuation">(</span><span class="token constant">Num</span> <span class="token hvariable">a</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">(</span><span class="token hvariable">a</span><span class="token punctuation">,</span> <span class="token hvariable">a</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token punctuation">(</span><span class="token hvariable">a</span><span class="token punctuation">,</span> <span class="token hvariable">a</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token punctuation">(</span><span class="token hvariable">a</span><span class="token punctuation">,</span> <span class="token hvariable">a</span><span class="token punctuation">)</span>
<span class="token hvariable">addVectors</span> <span class="token punctuation">(</span><span class="token hvariable">x1</span><span class="token punctuation">,</span> <span class="token hvariable">y1</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token hvariable">x2</span><span class="token punctuation">,</span> <span class="token hvariable">y2</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token hvariable">x1</span> <span class="token operator">+</span> <span class="token hvariable">x2</span><span class="token punctuation">,</span> <span class="token hvariable">y1</span> <span class="token operator">+</span> <span class="token hvariable">y2</span><span class="token punctuation">)</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>There we go! Much better. Note that this is already a catch-all pattern. The type of&nbsp;<code>addVectors</code>&nbsp;(in both cases) is&nbsp;<code>addVectors :: (Num a) =&gt; (a, a) -&gt; (a, a) - &gt; (a, a)</code>, so we are guaranteed to get two pairs as parameters.</p></div><div><p><code>fst</code>&nbsp;and&nbsp;<code>snd</code>&nbsp;extract the components of pairs. But what about triples? Well, there are no provided functions that do that but we can make our own.</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">first</span> <span class="token operator">::</span> <span class="token punctuation">(</span><span class="token hvariable">a</span><span class="token punctuation">,</span> <span class="token hvariable">b</span><span class="token punctuation">,</span> <span class="token hvariable">c</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token hvariable">a</span>
<span class="token hvariable">first</span> <span class="token punctuation">(</span><span class="token hvariable">x</span><span class="token punctuation">,</span> <span class="token hvariable">_</span><span class="token punctuation">,</span> <span class="token hvariable">_</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token hvariable">x</span>

<span class="token hvariable">second</span> <span class="token operator">::</span> <span class="token punctuation">(</span><span class="token hvariable">a</span><span class="token punctuation">,</span> <span class="token hvariable">b</span><span class="token punctuation">,</span> <span class="token hvariable">c</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token hvariable">b</span>
<span class="token hvariable">second</span> <span class="token punctuation">(</span><span class="token hvariable">_</span><span class="token punctuation">,</span> <span class="token hvariable">y</span><span class="token punctuation">,</span> <span class="token hvariable">_</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token hvariable">y</span>

<span class="token hvariable">third</span> <span class="token operator">::</span> <span class="token punctuation">(</span><span class="token hvariable">a</span><span class="token punctuation">,</span> <span class="token hvariable">b</span><span class="token punctuation">,</span> <span class="token hvariable">c</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token hvariable">c</span>
<span class="token hvariable">third</span> <span class="token punctuation">(</span><span class="token hvariable">_</span><span class="token punctuation">,</span> <span class="token hvariable">_</span><span class="token punctuation">,</span> <span class="token hvariable">z</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token hvariable">z</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>The&nbsp;<code>_</code>&nbsp;means the same thing as it does in list comprehensions. It means that we really don't care what that part is, so we just write a&nbsp;<code>_</code>.</p></div><div><p>Which reminds me, you can also pattern match in list comprehensions. Check this out:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token keyword">let</span> <span class="token hvariable">xs</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">]</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token punctuation">[</span><span class="token hvariable">a</span><span class="token operator">+</span><span class="token hvariable">b</span> <span class="token operator">|</span> <span class="token punctuation">(</span><span class="token hvariable">a</span><span class="token punctuation">,</span><span class="token hvariable">b</span><span class="token punctuation">)</span> <span class="token operator">&lt;-</span> <span class="token hvariable">xs</span><span class="token punctuation">]</span>
<span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">7</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">,</span><span class="token number">8</span><span class="token punctuation">,</span><span class="token number">11</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">]</span> 
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Should a pattern match fail, it will just move on to the next element.</p></div><div><p>Lists themselves can also be used in pattern matching. You can match with the empty list&nbsp;<code>[]</code>&nbsp;or any pattern that involves&nbsp;<code>:</code>&nbsp;and the empty list. But since&nbsp;<code>[1,2,3]</code>&nbsp;is just syntactic sugar for&nbsp;<code>1:2:3:[]</code>, you can also use the former pattern. A pattern like&nbsp;<code>x:xs</code>&nbsp;will bind the head of the list to&nbsp;<code>x</code>&nbsp;and the rest of it to&nbsp;<code>xs</code>, even if there's only one element so&nbsp;<code>xs</code>&nbsp;ends up being an empty list.</p></div><div><p><em>Note</em>: The&nbsp;x:xs&nbsp;pattern is used a lot, especially with recursive functions. But patterns that have&nbsp;:&nbsp;in them only match against lists of length 1 or more.</p></div><div><p>If you want to bind, say, the first three elements to variables and the rest of the list to another variable, you can use something like&nbsp;<code>x:y:z:zs</code>. It will only match against lists that have three elements or more.</p></div><div><p>Now that we know how to pattern match against list, let's make our own implementation of the&nbsp;<code>head</code>&nbsp;function.</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token builtin">head</span>' <span class="token operator">::</span> <span class="token punctuation">[</span><span class="token hvariable">a</span><span class="token punctuation">]</span> <span class="token operator">-&gt;</span> <span class="token hvariable">a</span>
<span class="token builtin">head</span>' <span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token builtin">error</span> <span class="token string">"Can't call head on an empty list, dummy!"</span>
<span class="token builtin">head</span>' <span class="token punctuation">(</span><span class="token hvariable">x</span><span class="token operator">:</span><span class="token hvariable">_</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token hvariable">x</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Checking if it works:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token builtin">head</span>' <span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">]</span>
<span class="token number">4</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token builtin">head</span>' <span class="token string">"Hello"</span>
<span class="token char string">'H'</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Nice! Notice that if you want to bind to several variables (even if one of them is just&nbsp;<code>_</code>&nbsp;and doesn't actually bind at all), we have to surround them in parentheses. Also notice the&nbsp;<code>error</code>&nbsp;function that we used. It takes a string and generates a runtime error, using that string as information about what kind of error occurred. It causes the program to crash, so it's not good to use it too much. But calling&nbsp;<code>head</code>&nbsp;on an empty list doesn't make sense.</p></div><div><p>Let's make a trivial function that tells us some of the first elements of the list in (in)convenient English form.</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">tell</span> <span class="token operator">::</span> <span class="token punctuation">(</span><span class="token constant">Show</span> <span class="token hvariable">a</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">[</span><span class="token hvariable">a</span><span class="token punctuation">]</span> <span class="token operator">-&gt;</span> <span class="token constant">String</span>
<span class="token hvariable">tell</span> <span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">"The list is empty"</span>
<span class="token hvariable">tell</span> <span class="token punctuation">(</span><span class="token hvariable">x</span><span class="token operator">:</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token string">"The list has one element: "</span> <span class="token operator">++</span> <span class="token builtin">show</span> <span class="token hvariable">x</span>
<span class="token hvariable">tell</span> <span class="token punctuation">(</span><span class="token hvariable">x</span><span class="token operator">:</span><span class="token hvariable">y</span><span class="token operator">:</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token string">"The list has two elements: "</span> <span class="token operator">++</span> <span class="token builtin">show</span> <span class="token hvariable">x</span> <span class="token operator">++</span> <span class="token string">" and "</span> <span class="token operator">++</span> <span class="token builtin">show</span> <span class="token hvariable">y</span>
<span class="token hvariable">tell</span> <span class="token punctuation">(</span><span class="token hvariable">x</span><span class="token operator">:</span><span class="token hvariable">y</span><span class="token operator">:</span><span class="token hvariable">_</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token string">"This list is long. The first two elements are: "</span> <span class="token operator">++</span> <span class="token builtin">show</span> <span class="token hvariable">x</span> <span class="token operator">++</span> <span class="token string">" and "</span> <span class="token operator">++</span> <span class="token builtin">show</span> <span class="token hvariable">y</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>This function is safe because it takes care of the empty list, a singleton list, a list with two elements and a list with more than two elements. Note that&nbsp;<code>(x:[])</code>&nbsp;and&nbsp;<code>(x:y:[])</code>&nbsp;could be rewriten as&nbsp;<code>[x]</code>&nbsp;and&nbsp;<code>[x,y]</code>&nbsp;(because its syntatic sugar, we don't need the parentheses). We can't rewrite&nbsp;<code>(x:y:_)</code>&nbsp;with square brackets because it matches any list of length 2 or more.</p></div><div><p>We already implemented our own&nbsp;<code>length</code>&nbsp;function using list comprehension. Now we'll do it by using pattern matching and a little recursion:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token builtin">length</span>' <span class="token operator">::</span> <span class="token punctuation">(</span><span class="token constant">Num</span> <span class="token hvariable">b</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">[</span><span class="token hvariable">a</span><span class="token punctuation">]</span> <span class="token operator">-&gt;</span> <span class="token hvariable">b</span>
<span class="token builtin">length</span>' <span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span>
<span class="token builtin">length</span>' <span class="token punctuation">(</span><span class="token hvariable">_</span><span class="token operator">:</span><span class="token hvariable">xs</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token number">1</span> <span class="token operator">+</span> <span class="token builtin">length</span>' <span class="token hvariable">xs</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>This is similar to the factorial function we wrote earlier. First we defined the result of a known input — the empty list. This is also known as the edge condition. Then in the second pattern we take the list apart by splitting it into a head and a tail. We say that the length is equal to 1 plus the length of the tail. We use&nbsp;<code>_</code>&nbsp;to match the head because we don't actually care what it is. Also note that we've taken care of all possible patterns of a list. The first pattern matches an empty list and the second one matches anything that isn't an empty list.</p></div><div><p>Let's see what happens if we call&nbsp;<code>length'</code>&nbsp;on&nbsp;<code>"ham"</code>. First, it will check if it's an empty list. Because it isn't, it falls through to the second pattern. It matches on the second pattern and there it says that the length is&nbsp;<code>1 + length' "am"</code>, because we broke it into a head and a tail and discarded the head. O-kay. The&nbsp;<code>length'</code>&nbsp;of&nbsp;<code>"am"</code>&nbsp;is, similarly,&nbsp;<code>1 + length' "m"</code>. So right now we have&nbsp;<code>1 + (1 + length' "m")</code>.&nbsp;<code>length' "m"</code>&nbsp;is&nbsp;<code>1 + length' ""</code>&nbsp;(could also be written as&nbsp;<code>1 + length' []</code>). And we've defined&nbsp;<code>length' []</code>&nbsp;to be&nbsp;<code>0</code>. So in the end we have&nbsp;<code>1 + (1 + (1 + 0))</code>.</p></div><div><p>Let's implement&nbsp;<code>sum</code>. We know that the sum of an empty list is 0. We write that down as a pattern. And we also know that the sum of a list is the head plus the sum of the rest of the list. So if we write that down, we get:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token builtin">sum</span>' <span class="token operator">::</span> <span class="token punctuation">(</span><span class="token constant">Num</span> <span class="token hvariable">a</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">[</span><span class="token hvariable">a</span><span class="token punctuation">]</span> <span class="token operator">-&gt;</span> <span class="token hvariable">a</span>
<span class="token builtin">sum</span>' <span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">0</span>
<span class="token builtin">sum</span>' <span class="token punctuation">(</span><span class="token hvariable">x</span><span class="token operator">:</span><span class="token hvariable">xs</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token hvariable">x</span> <span class="token operator">+</span> <span class="token builtin">sum</span>' <span class="token hvariable">xs</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>There's also a thing called&nbsp;<em>as patterns</em>. Those are a handy way of breaking something up according to a pattern and binding it to names whilst still keeping a reference to the whole thing. You do that by putting a name and an&nbsp;<code>@</code>&nbsp;in front of a pattern. For instance, the pattern&nbsp;<code>xs@(x:y:ys)</code>. This pattern will match exactly the same thing as&nbsp;<code>x:y:ys</code>&nbsp;but you can easily get the whole list via&nbsp;<code>xs</code>&nbsp;instead of repeating yourself by typing out&nbsp;<code>x:y:ys</code>&nbsp;in the function body again. Here's a quick and dirty example:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">capital</span> <span class="token operator">::</span> <span class="token constant">String</span> <span class="token operator">-&gt;</span> <span class="token constant">String</span>
<span class="token hvariable">capital</span> <span class="token string">""</span> <span class="token operator">=</span> <span class="token string">"Empty string, whoops!"</span>
<span class="token hvariable">capital</span> <span class="token builtin">all</span><span class="token operator">@</span><span class="token punctuation">(</span><span class="token hvariable">x</span><span class="token operator">:</span><span class="token hvariable">xs</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token string">"The first letter of "</span> <span class="token operator">++</span> <span class="token builtin">all</span> <span class="token operator">++</span> <span class="token string">" is "</span> <span class="token operator">++</span> <span class="token punctuation">[</span><span class="token hvariable">x</span><span class="token punctuation">]</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token hvariable">capital</span> <span class="token string">"Dracula"</span>
<span class="token string">"The first letter of Dracula is D"</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Normally we use as patterns to avoid repeating ourselves when matching against a bigger pattern when we have to use the whole thing again in the function body.</p></div><div><p>One more thing — you can't use&nbsp;<code>++</code>&nbsp;in pattern matches. If you tried to pattern match against&nbsp;<code>(xs ++ ys)</code>, what would be in the first and what would be in the second list? It doesn't make much sense. It would make sense to match stuff against&nbsp;<code>(xs ++ [x,y,z])</code>&nbsp;or just&nbsp;<code>(xs ++ [x])</code>, but because of the nature of lists, you can't do that.</p></div><div><h2 data-heading="Guards, guards!" id="Guards,_guards!" style="display: flex;"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>Guards, guards!</h2></div><div><p><img alt="guards" src="http://s3.amazonaws.com/lyah/guards.png" referrerpolicy="no-referrer"></p></div><div><p>Whereas patterns are a way of making sure a value conforms to some form and deconstructing it, guards are a way of testing whether some property of a value (or several of them) are true or false. That sounds a lot like an if statement and it's very similar. The thing is that guards are a lot more readable when you have several conditions and they play really nicely with patterns.</p></div><div><p>Instead of explaining their syntax, let's just dive in and make a function using guards. We're going to make a simple function that berates you differently depending on your&nbsp;<a data-tooltip-position="top" aria-label="http://en.wikipedia.org/wiki/Body_mass_index" rel="noopener" class="external-link" href="http://en.wikipedia.org/wiki/Body_mass_index" target="_blank">BMI</a>&nbsp;(body mass index). Your BMI equals your weight divided by your height squared. If your BMI is less than 18.5, you're considered underweight. If it's anywhere from 18.5 to 25 then you're considered normal. 25 to 30 is overweight and more than 30 is obese. So here's the function (we won't be calculating it right now, this function just gets a BMI and tells you off)</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">bmiTell</span> <span class="token operator">::</span> <span class="token punctuation">(</span><span class="token constant">RealFloat</span> <span class="token hvariable">a</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token hvariable">a</span> <span class="token operator">-&gt;</span> <span class="token constant">String</span>
<span class="token hvariable">bmiTell</span> <span class="token hvariable">bmi</span>
    <span class="token operator">|</span> <span class="token hvariable">bmi</span> <span class="token operator">&lt;=</span> <span class="token number">18.5</span> <span class="token operator">=</span> <span class="token string">"You're underweight, you emo, you!"</span>
    <span class="token operator">|</span> <span class="token hvariable">bmi</span> <span class="token operator">&lt;=</span> <span class="token number">25.0</span> <span class="token operator">=</span> <span class="token string">"You're supposedly normal. Pffft, I bet you're ugly!"</span>
    <span class="token operator">|</span> <span class="token hvariable">bmi</span> <span class="token operator">&lt;=</span> <span class="token number">30.0</span> <span class="token operator">=</span> <span class="token string">"You're fat! Lose some weight, fatty!"</span>
    <span class="token operator">|</span> <span class="token builtin">otherwise</span>   <span class="token operator">=</span> <span class="token string">"You're a whale, congratulations!"</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Guards are indicated by pipes that follow a function's name and its parameters. Usually, they're indented a bit to the right and lined up. A guard is basically a boolean expression. If it evaluates to&nbsp;<code>True</code>, then the corresponding function body is used. If it evaluates to&nbsp;<code>False</code>, checking drops through to the next guard and so on. If we call this function with&nbsp;<code>24.3</code>, it will first check if that's smaller than or equal to&nbsp;<code>18.5</code>. Because it isn't, it falls through to the next guard. The check is carried out with the second guard and because 24.3 is less than 25.0, the second string is returned.</p></div><div><p>This is very reminiscent of a big if else tree in imperative languages, only this is far better and more readable. While big if else trees are usually frowned upon, sometimes a problem is defined in such a discrete way that you can't get around them. Guards are a very nice alternative for this.</p></div><div><p>Many times, the last guard is&nbsp;<code>otherwise</code>.&nbsp;<code>otherwise</code>&nbsp;is defined simply as&nbsp;<code>otherwise = True</code>&nbsp;and catches everything. This is very similar to patterns, only they check if the input satisfies a pattern but guards check for boolean conditions. If all the guards of a function evaluate to&nbsp;<code>False</code>&nbsp;(and we haven't provided an&nbsp;<code>otherwise</code>&nbsp;catch-all guard), evaluation falls through to the next&nbsp;<strong>pattern</strong>. That's how patterns and guards play nicely together. If no suitable guards or patterns are found, an error is thrown.</p></div><div><p>Of course we can use guards with functions that take as many parameters as we want. Instead of having the user calculate his own BMI before calling the function, let's modify this function so that it takes a height and weight and calculates it for us.</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">bmiTell</span> <span class="token operator">::</span> <span class="token punctuation">(</span><span class="token constant">RealFloat</span> <span class="token hvariable">a</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token hvariable">a</span> <span class="token operator">-&gt;</span> <span class="token hvariable">a</span> <span class="token operator">-&gt;</span> <span class="token constant">String</span>
<span class="token hvariable">bmiTell</span> <span class="token hvariable">weight</span> <span class="token hvariable">height</span>
    <span class="token operator">|</span> <span class="token hvariable">weight</span> <span class="token operator">/</span> <span class="token hvariable">height</span> <span class="token operator">^</span> <span class="token number">2</span> <span class="token operator">&lt;=</span> <span class="token number">18.5</span> <span class="token operator">=</span> <span class="token string">"You're underweight, you emo, you!"</span>
    <span class="token operator">|</span> <span class="token hvariable">weight</span> <span class="token operator">/</span> <span class="token hvariable">height</span> <span class="token operator">^</span> <span class="token number">2</span> <span class="token operator">&lt;=</span> <span class="token number">25.0</span> <span class="token operator">=</span> <span class="token string">"You're supposedly normal. Pffft, I bet you're ugly!"</span>
    <span class="token operator">|</span> <span class="token hvariable">weight</span> <span class="token operator">/</span> <span class="token hvariable">height</span> <span class="token operator">^</span> <span class="token number">2</span> <span class="token operator">&lt;=</span> <span class="token number">30.0</span> <span class="token operator">=</span> <span class="token string">"You're fat! Lose some weight, fatty!"</span>
    <span class="token operator">|</span> <span class="token builtin">otherwise</span>                 <span class="token operator">=</span> <span class="token string">"You're a whale, congratulations!"</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Let's see if I'm fat ...</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token hvariable">bmiTell</span> <span class="token number">85</span> <span class="token number">1.90</span>
<span class="token string">"You're supposedly normal. Pffft, I bet you're ugly!"</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Yay! I'm not fat! But Haskell just called me ugly. Whatever!</p></div><div><p>Note that there's no&nbsp;<code>=</code>&nbsp;right after the function name and its parameters, before the first guard. Many newbies get syntax errors because they sometimes put it there.</p></div><div><p>Another very simple example: let's implement our own&nbsp;<code>max</code>&nbsp;function. If you remember, it takes two things that can be compared and returns the larger of them.</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token builtin">max</span>' <span class="token operator">::</span> <span class="token punctuation">(</span><span class="token constant">Ord</span> <span class="token hvariable">a</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token hvariable">a</span> <span class="token operator">-&gt;</span> <span class="token hvariable">a</span> <span class="token operator">-&gt;</span> <span class="token hvariable">a</span>
<span class="token builtin">max</span>' <span class="token hvariable">a</span> <span class="token hvariable">b</span> 
    <span class="token operator">|</span> <span class="token hvariable">a</span> <span class="token operator">&gt;</span> <span class="token hvariable">b</span>     <span class="token operator">=</span> <span class="token hvariable">a</span>
    <span class="token operator">|</span> <span class="token builtin">otherwise</span> <span class="token operator">=</span> <span class="token hvariable">b</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Guards can also be written inline, although I'd advise against that because it's less readable, even for very short functions. But to demonstrate, we could write&nbsp;<code>max'</code>&nbsp;like this:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token builtin">max</span>' <span class="token operator">::</span> <span class="token punctuation">(</span><span class="token constant">Ord</span> <span class="token hvariable">a</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token hvariable">a</span> <span class="token operator">-&gt;</span> <span class="token hvariable">a</span> <span class="token operator">-&gt;</span> <span class="token hvariable">a</span>
<span class="token builtin">max</span>' <span class="token hvariable">a</span> <span class="token hvariable">b</span> <span class="token operator">|</span> <span class="token hvariable">a</span> <span class="token operator">&gt;</span> <span class="token hvariable">b</span> <span class="token operator">=</span> <span class="token hvariable">a</span> <span class="token operator">|</span> <span class="token builtin">otherwise</span> <span class="token operator">=</span> <span class="token hvariable">b</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Ugh! Not very readable at all! Moving on: let's implement our own&nbsp;<code>compare</code>&nbsp;by using guards.</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">myCompare</span> <span class="token operator">::</span> <span class="token punctuation">(</span><span class="token constant">Ord</span> <span class="token hvariable">a</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token hvariable">a</span> <span class="token operator">-&gt;</span> <span class="token hvariable">a</span> <span class="token operator">-&gt;</span> <span class="token constant">Ordering</span>
<span class="token hvariable">a</span> <span class="token operator">`myCompare`</span> <span class="token hvariable">b</span>
    <span class="token operator">|</span> <span class="token hvariable">a</span> <span class="token operator">&gt;</span> <span class="token hvariable">b</span>     <span class="token operator">=</span> <span class="token constant">GT</span>
    <span class="token operator">|</span> <span class="token hvariable">a</span> <span class="token operator">==</span> <span class="token hvariable">b</span>    <span class="token operator">=</span> <span class="token constant">EQ</span>
    <span class="token operator">|</span> <span class="token builtin">otherwise</span> <span class="token operator">=</span> <span class="token constant">LT</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token number">3</span> <span class="token operator">`myCompare`</span> <span class="token number">2</span>
<span class="token constant">GT</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p><em>Note:</em>&nbsp;Not only can we call functions as infix with backticks, we can also define them using backticks. Sometimes it's easier to read that way.</p></div><div><h2 data-heading="Where!?" id="Where!?" style="display: flex;"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>Where!?</h2></div><div><p>In the previous section, we defined a BMI calculator function and berator like this:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">bmiTell</span> <span class="token operator">::</span> <span class="token punctuation">(</span><span class="token constant">RealFloat</span> <span class="token hvariable">a</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token hvariable">a</span> <span class="token operator">-&gt;</span> <span class="token hvariable">a</span> <span class="token operator">-&gt;</span> <span class="token constant">String</span>
<span class="token hvariable">bmiTell</span> <span class="token hvariable">weight</span> <span class="token hvariable">height</span>
    <span class="token operator">|</span> <span class="token hvariable">weight</span> <span class="token operator">/</span> <span class="token hvariable">height</span> <span class="token operator">^</span> <span class="token number">2</span> <span class="token operator">&lt;=</span> <span class="token number">18.5</span> <span class="token operator">=</span> <span class="token string">"You're underweight, you emo, you!"</span>
    <span class="token operator">|</span> <span class="token hvariable">weight</span> <span class="token operator">/</span> <span class="token hvariable">height</span> <span class="token operator">^</span> <span class="token number">2</span> <span class="token operator">&lt;=</span> <span class="token number">25.0</span> <span class="token operator">=</span> <span class="token string">"You're supposedly normal. Pffft, I bet you're ugly!"</span>
    <span class="token operator">|</span> <span class="token hvariable">weight</span> <span class="token operator">/</span> <span class="token hvariable">height</span> <span class="token operator">^</span> <span class="token number">2</span> <span class="token operator">&lt;=</span> <span class="token number">30.0</span> <span class="token operator">=</span> <span class="token string">"You're fat! Lose some weight, fatty!"</span>
    <span class="token operator">|</span> <span class="token builtin">otherwise</span>                   <span class="token operator">=</span> <span class="token string">"You're a whale, congratulations!"</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Notice that we repeat ourselves here three times. We repeat ourselves three times. Repeating yourself (three times) while programming is about as desirable as getting kicked inna head. Since we repeat the same expression three times, it would be ideal if we could calculate it once, bind it to a name and then use that name instead of the expression. Well, we can modify our function like this:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">bmiTell</span> <span class="token operator">::</span> <span class="token punctuation">(</span><span class="token constant">RealFloat</span> <span class="token hvariable">a</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token hvariable">a</span> <span class="token operator">-&gt;</span> <span class="token hvariable">a</span> <span class="token operator">-&gt;</span> <span class="token constant">String</span>
<span class="token hvariable">bmiTell</span> <span class="token hvariable">weight</span> <span class="token hvariable">height</span>
    <span class="token operator">|</span> <span class="token hvariable">bmi</span> <span class="token operator">&lt;=</span> <span class="token number">18.5</span> <span class="token operator">=</span> <span class="token string">"You're underweight, you emo, you!"</span>
    <span class="token operator">|</span> <span class="token hvariable">bmi</span> <span class="token operator">&lt;=</span> <span class="token number">25.0</span> <span class="token operator">=</span> <span class="token string">"You're supposedly normal. Pffft, I bet you're ugly!"</span>
    <span class="token operator">|</span> <span class="token hvariable">bmi</span> <span class="token operator">&lt;=</span> <span class="token number">30.0</span> <span class="token operator">=</span> <span class="token string">"You're fat! Lose some weight, fatty!"</span>
    <span class="token operator">|</span> <span class="token builtin">otherwise</span>   <span class="token operator">=</span> <span class="token string">"You're a whale, congratulations!"</span>
    <span class="token keyword">where</span> <span class="token hvariable">bmi</span> <span class="token operator">=</span> <span class="token hvariable">weight</span> <span class="token operator">/</span> <span class="token hvariable">height</span> <span class="token operator">^</span> <span class="token number">2</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>We put the keyword&nbsp;<code>where</code>&nbsp;after the guards (usually it's best to indent it as much as the pipes are indented) and then we define several names or functions. These names are visible across the guards and give us the advantage of not having to repeat ourselves. If we decide that we want to calculate BMI a bit differently, we only have to change it once. It also improves readability by giving names to things and can make our programs faster since stuff like our&nbsp;<code>bmi</code>&nbsp;variable here is calculated only once. We could go a bit overboard and present our function like this:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">bmiTell</span> <span class="token operator">::</span> <span class="token punctuation">(</span><span class="token constant">RealFloat</span> <span class="token hvariable">a</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token hvariable">a</span> <span class="token operator">-&gt;</span> <span class="token hvariable">a</span> <span class="token operator">-&gt;</span> <span class="token constant">String</span>
<span class="token hvariable">bmiTell</span> <span class="token hvariable">weight</span> <span class="token hvariable">height</span>
    <span class="token operator">|</span> <span class="token hvariable">bmi</span> <span class="token operator">&lt;=</span> <span class="token hvariable">skinny</span> <span class="token operator">=</span> <span class="token string">"You're underweight, you emo, you!"</span>
    <span class="token operator">|</span> <span class="token hvariable">bmi</span> <span class="token operator">&lt;=</span> <span class="token hvariable">normal</span> <span class="token operator">=</span> <span class="token string">"You're supposedly normal. Pffft, I bet you're ugly!"</span>
    <span class="token operator">|</span> <span class="token hvariable">bmi</span> <span class="token operator">&lt;=</span> <span class="token hvariable">fat</span>    <span class="token operator">=</span> <span class="token string">"You're fat! Lose some weight, fatty!"</span>
    <span class="token operator">|</span> <span class="token builtin">otherwise</span>     <span class="token operator">=</span> <span class="token string">"You're a whale, congratulations!"</span>
    <span class="token keyword">where</span> <span class="token hvariable">bmi</span> <span class="token operator">=</span> <span class="token hvariable">weight</span> <span class="token operator">/</span> <span class="token hvariable">height</span> <span class="token operator">^</span> <span class="token number">2</span>
          <span class="token hvariable">skinny</span> <span class="token operator">=</span> <span class="token number">18.5</span>
          <span class="token hvariable">normal</span> <span class="token operator">=</span> <span class="token number">25.0</span>
          <span class="token hvariable">fat</span> <span class="token operator">=</span> <span class="token number">30.0</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>The names we define in the where section of a function are only visible to that function, so we don't have to worry about them polluting the namespace of other functions. Notice that all the names are aligned at a single column. If we don't align them nice and proper, Haskell gets confused because then it doesn't know they're all part of the same block.</p></div><div><p><em>where</em>&nbsp;bindings aren't shared across function bodies of different patterns. If you want several patterns of one function to access some shared name, you have to define it globally.</p></div><div><p>You can also use where bindings to&nbsp;<strong>pattern match</strong>! We could have rewritten the where section of our previous function as:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded">    <span class="token operator">...</span>
    <span class="token keyword">where</span> <span class="token hvariable">bmi</span> <span class="token operator">=</span> <span class="token hvariable">weight</span> <span class="token operator">/</span> <span class="token hvariable">height</span> <span class="token operator">^</span> <span class="token number">2</span>
          <span class="token punctuation">(</span><span class="token hvariable">skinny</span><span class="token punctuation">,</span> <span class="token hvariable">normal</span><span class="token punctuation">,</span> <span class="token hvariable">fat</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token number">18.5</span><span class="token punctuation">,</span> <span class="token number">25.0</span><span class="token punctuation">,</span> <span class="token number">30.0</span><span class="token punctuation">)</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Let's make another fairly trivial function where we get a first and a last name and give someone back their initials.</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">initials</span> <span class="token operator">::</span> <span class="token constant">String</span> <span class="token operator">-&gt;</span> <span class="token constant">String</span> <span class="token operator">-&gt;</span> <span class="token constant">String</span>
<span class="token hvariable">initials</span> <span class="token hvariable">firstname</span> <span class="token hvariable">lastname</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token hvariable">f</span><span class="token punctuation">]</span> <span class="token operator">++</span> <span class="token string">". "</span> <span class="token operator">++</span> <span class="token punctuation">[</span><span class="token hvariable">l</span><span class="token punctuation">]</span> <span class="token operator">++</span> <span class="token string">"."</span>
    <span class="token keyword">where</span> <span class="token punctuation">(</span><span class="token hvariable">f</span><span class="token operator">:</span><span class="token hvariable">_</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token hvariable">firstname</span>
          <span class="token punctuation">(</span><span class="token hvariable">l</span><span class="token operator">:</span><span class="token hvariable">_</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token hvariable">lastname</span>  
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>We could have done this pattern matching directly in the function's parameters (it would have been shorter and clearer actually) but this just goes to show that it's possible to do it in where bindings as well.</p></div><div><p>Just like we've defined constants in where blocks, you can also define functions. Staying true to our healthy programming theme, let's make a function that takes a list of weight-height pairs and returns a list of BMIs.</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">calcBmis</span> <span class="token operator">::</span> <span class="token punctuation">(</span><span class="token constant">RealFloat</span> <span class="token hvariable">a</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">[</span><span class="token punctuation">(</span><span class="token hvariable">a</span><span class="token punctuation">,</span> <span class="token hvariable">a</span><span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token operator">-&gt;</span> <span class="token punctuation">[</span><span class="token hvariable">a</span><span class="token punctuation">]</span>
<span class="token hvariable">calcBmis</span> <span class="token hvariable">xs</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token hvariable">bmi</span> <span class="token hvariable">w</span> <span class="token hvariable">h</span> <span class="token operator">|</span> <span class="token punctuation">(</span><span class="token hvariable">w</span><span class="token punctuation">,</span> <span class="token hvariable">h</span><span class="token punctuation">)</span> <span class="token operator">&lt;-</span> <span class="token hvariable">xs</span><span class="token punctuation">]</span>
    <span class="token keyword">where</span> <span class="token hvariable">bmi</span> <span class="token hvariable">weight</span> <span class="token hvariable">height</span> <span class="token operator">=</span> <span class="token hvariable">weight</span> <span class="token operator">/</span> <span class="token hvariable">height</span> <span class="token operator">^</span> <span class="token number">2</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>And that's all there is to it! The reason we had to introduce&nbsp;<code>bmi</code>&nbsp;as a function in this example is because we can't just calculate one BMI from the function's parameters. We have to examine the list passed to the function and there's a different BMI for every pair in there.</p></div><div><p><em>where</em>&nbsp;bindings can also be nested. It's a common idiom to make a function and define some helper function in its&nbsp;<em>where</em>&nbsp;clause and then to give those functions helper functions as well, each with its own&nbsp;<em>where</em>&nbsp;clause.</p></div><div><h2 data-heading="Let it be" id="Let_it_be" style="display: flex;"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>Let it be</h2></div><div><p>Very similar to where bindings are let bindings. Where bindings are a syntactic construct that let you bind to variables at the end of a function and the whole function can see them, including all the guards. Let bindings let you bind to variables anywhere and are expressions themselves, but are very local, so they don't span across guards. Just like any construct in Haskell that is used to bind values to names, let bindings can be used for pattern matching. Let's see them in action! This is how we could define a function that gives us a cylinder's surface area based on its height and radius:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">cylinder</span> <span class="token operator">::</span> <span class="token punctuation">(</span><span class="token constant">RealFloat</span> <span class="token hvariable">a</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token hvariable">a</span> <span class="token operator">-&gt;</span> <span class="token hvariable">a</span> <span class="token operator">-&gt;</span> <span class="token hvariable">a</span>
<span class="token hvariable">cylinder</span> <span class="token hvariable">r</span> <span class="token hvariable">h</span> <span class="token operator">=</span>
    <span class="token keyword">let</span> <span class="token hvariable">sideArea</span> <span class="token operator">=</span> <span class="token number">2</span> <span class="token operator">*</span> <span class="token builtin">pi</span> <span class="token operator">*</span> <span class="token hvariable">r</span> <span class="token operator">*</span> <span class="token hvariable">h</span>
        <span class="token hvariable">topArea</span> <span class="token operator">=</span> <span class="token builtin">pi</span> <span class="token operator">*</span> <span class="token hvariable">r</span> <span class="token operator">^</span><span class="token number">2</span>
    <span class="token keyword">in</span>  <span class="token hvariable">sideArea</span> <span class="token operator">+</span> <span class="token number">2</span> <span class="token operator">*</span> <span class="token hvariable">topArea</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p><img alt="let it be" src="http://s3.amazonaws.com/lyah/letitbe.png" referrerpolicy="no-referrer"></p></div><div><p>The form is&nbsp;<code>let &lt;bindings&gt; in &lt;expression&gt;</code>. The names that you define in the&nbsp;<em>let</em>&nbsp;part are accessible to the expression after the&nbsp;<em>in</em>&nbsp;part. As you can see, we could have also defined this with a&nbsp;<em>where</em>&nbsp;binding. Notice that the names are also aligned in a single column. So what's the difference between the two? For now it just seems that&nbsp;<em>let</em>&nbsp;puts the bindings first and the expression that uses them later whereas&nbsp;<em>where</em>&nbsp;is the other way around.</p></div><div><p>The difference is that&nbsp;<em>let</em>&nbsp;bindings are expressions themselves.&nbsp;<em>where</em>&nbsp;bindings are just syntactic constructs. Remember when we did the if statement and it was explained that an if else statement is an expression and you can cram it in almost anywhere?</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token punctuation">[</span><span class="token keyword">if</span> <span class="token number">5</span> <span class="token operator">&gt;</span> <span class="token number">3</span> <span class="token keyword">then</span> <span class="token string">"Woo"</span> <span class="token keyword">else</span> <span class="token string">"Boo"</span><span class="token punctuation">,</span> <span class="token keyword">if</span> <span class="token char string">'a'</span> <span class="token operator">&gt;</span> <span class="token char string">'b'</span> <span class="token keyword">then</span> <span class="token string">"Foo"</span> <span class="token keyword">else</span> <span class="token string">"Bar"</span><span class="token punctuation">]</span>
<span class="token punctuation">[</span><span class="token string">"Woo"</span><span class="token punctuation">,</span> <span class="token string">"Bar"</span><span class="token punctuation">]</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token number">4</span> <span class="token operator">*</span> <span class="token punctuation">(</span><span class="token keyword">if</span> <span class="token number">10</span> <span class="token operator">&gt;</span> <span class="token number">5</span> <span class="token keyword">then</span> <span class="token number">10</span> <span class="token keyword">else</span> <span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">2</span>
<span class="token number">42</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>You can also do that with let bindings.</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token number">4</span> <span class="token operator">*</span> <span class="token punctuation">(</span><span class="token keyword">let</span> <span class="token hvariable">a</span> <span class="token operator">=</span> <span class="token number">9</span> <span class="token keyword">in</span> <span class="token hvariable">a</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">2</span>
<span class="token number">42</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>They can also be used to introduce functions in a local scope:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token punctuation">[</span><span class="token keyword">let</span> <span class="token hvariable">square</span> <span class="token hvariable">x</span> <span class="token operator">=</span> <span class="token hvariable">x</span> <span class="token operator">*</span> <span class="token hvariable">x</span> <span class="token keyword">in</span> <span class="token punctuation">(</span><span class="token hvariable">square</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token hvariable">square</span> <span class="token number">3</span><span class="token punctuation">,</span> <span class="token hvariable">square</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">]</span>
<span class="token punctuation">[</span><span class="token punctuation">(</span><span class="token number">25</span><span class="token punctuation">,</span><span class="token number">9</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">]</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>If we want to bind to several variables inline, we obviously can't align them at columns. That's why we can separate them with semicolons.</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token punctuation">(</span><span class="token keyword">let</span> <span class="token hvariable">a</span> <span class="token operator">=</span> <span class="token number">100</span><span class="token punctuation">;</span> <span class="token hvariable">b</span> <span class="token operator">=</span> <span class="token number">200</span><span class="token punctuation">;</span> <span class="token hvariable">c</span> <span class="token operator">=</span> <span class="token number">300</span> <span class="token keyword">in</span> <span class="token hvariable">a</span><span class="token operator">*</span><span class="token hvariable">b</span><span class="token operator">*</span><span class="token hvariable">c</span><span class="token punctuation">,</span> <span class="token keyword">let</span> <span class="token hvariable">foo</span><span class="token operator">=</span><span class="token string">"Hey "</span><span class="token punctuation">;</span> <span class="token hvariable">bar</span> <span class="token operator">=</span> <span class="token string">"there!"</span> <span class="token keyword">in</span> <span class="token hvariable">foo</span> <span class="token operator">++</span> <span class="token hvariable">bar</span><span class="token punctuation">)</span>
<span class="token punctuation">(</span><span class="token number">6000000</span><span class="token punctuation">,</span><span class="token string">"Hey there!"</span><span class="token punctuation">)</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>You don't have to put a semicolon after the last binding but you can if you want. Like we said before, you can pattern match with&nbsp;<em>let</em>&nbsp;bindings. They're very useful for quickly dismantling a tuple into components and binding them to names and such.</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token punctuation">(</span><span class="token keyword">let</span> <span class="token punctuation">(</span><span class="token hvariable">a</span><span class="token punctuation">,</span><span class="token hvariable">b</span><span class="token punctuation">,</span><span class="token hvariable">c</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">)</span> <span class="token keyword">in</span> <span class="token hvariable">a</span><span class="token operator">+</span><span class="token hvariable">b</span><span class="token operator">+</span><span class="token hvariable">c</span><span class="token punctuation">)</span> <span class="token operator">*</span> <span class="token number">100</span>
<span class="token number">600</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>You can also put&nbsp;<em>let</em>&nbsp;bindings inside list comprehensions. Let's rewrite our previous example of calculating lists of weight-height pairs to use a&nbsp;<em>let</em>&nbsp;inside a list comprehension instead of defining an auxiliary function with a&nbsp;<em>where</em>.</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">calcBmis</span> <span class="token operator">::</span> <span class="token punctuation">(</span><span class="token constant">RealFloat</span> <span class="token hvariable">a</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">[</span><span class="token punctuation">(</span><span class="token hvariable">a</span><span class="token punctuation">,</span> <span class="token hvariable">a</span><span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token operator">-&gt;</span> <span class="token punctuation">[</span><span class="token hvariable">a</span><span class="token punctuation">]</span>
<span class="token hvariable">calcBmis</span> <span class="token hvariable">xs</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token hvariable">bmi</span> <span class="token operator">|</span> <span class="token punctuation">(</span><span class="token hvariable">w</span><span class="token punctuation">,</span> <span class="token hvariable">h</span><span class="token punctuation">)</span> <span class="token operator">&lt;-</span> <span class="token hvariable">xs</span><span class="token punctuation">,</span> <span class="token keyword">let</span> <span class="token hvariable">bmi</span> <span class="token operator">=</span> <span class="token hvariable">w</span> <span class="token operator">/</span> <span class="token hvariable">h</span> <span class="token operator">^</span> <span class="token number">2</span><span class="token punctuation">]</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>We include a&nbsp;<em>let</em>&nbsp;inside a list comprehension much like we would a predicate, only it doesn't filter the list, it only binds to names. The names defined in a&nbsp;<em>let</em>&nbsp;inside a list comprehension are visible to the output function (the part before the&nbsp;<code>|</code>) and all predicates and sections that come after of the binding. So we could make our function return only the BMIs of fat people:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">calcBmis</span> <span class="token operator">::</span> <span class="token punctuation">(</span><span class="token constant">RealFloat</span> <span class="token hvariable">a</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">[</span><span class="token punctuation">(</span><span class="token hvariable">a</span><span class="token punctuation">,</span> <span class="token hvariable">a</span><span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token operator">-&gt;</span> <span class="token punctuation">[</span><span class="token hvariable">a</span><span class="token punctuation">]</span>
<span class="token hvariable">calcBmis</span> <span class="token hvariable">xs</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token hvariable">bmi</span> <span class="token operator">|</span> <span class="token punctuation">(</span><span class="token hvariable">w</span><span class="token punctuation">,</span> <span class="token hvariable">h</span><span class="token punctuation">)</span> <span class="token operator">&lt;-</span> <span class="token hvariable">xs</span><span class="token punctuation">,</span> <span class="token keyword">let</span> <span class="token hvariable">bmi</span> <span class="token operator">=</span> <span class="token hvariable">w</span> <span class="token operator">/</span> <span class="token hvariable">h</span> <span class="token operator">^</span> <span class="token number">2</span><span class="token punctuation">,</span> <span class="token hvariable">bmi</span> <span class="token operator">&gt;=</span> <span class="token number">25.0</span><span class="token punctuation">]</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>We can't use the&nbsp;<code>bmi</code>&nbsp;name in the&nbsp;<code>(w, h) &lt;- xs</code>&nbsp;part because it's defined prior to the&nbsp;<em>let</em>&nbsp;binding.</p></div><div><p>We omitted the&nbsp;<em>in</em>&nbsp;part of the&nbsp;<em>let</em>&nbsp;binding when we used them in list comprehensions because the visibility of the names is already predefined there. However, we could use a&nbsp;<em>let in</em>&nbsp;binding in a predicate and the names defined would only be visible to that predicate. The&nbsp;<em>in</em>&nbsp;part can also be omitted when defining functions and constants directly in GHCi. If we do that, then the names will be visible throughout the entire interactive session.</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token keyword">let</span> <span class="token hvariable">zoot</span> <span class="token hvariable">x</span> <span class="token hvariable">y</span> <span class="token hvariable">z</span> <span class="token operator">=</span> <span class="token hvariable">x</span> <span class="token operator">*</span> <span class="token hvariable">y</span> <span class="token operator">+</span> <span class="token hvariable">z</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token hvariable">zoot</span> <span class="token number">3</span> <span class="token number">9</span> <span class="token number">2</span>
<span class="token number">29</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token keyword">let</span> <span class="token hvariable">boot</span> <span class="token hvariable">x</span> <span class="token hvariable">y</span> <span class="token hvariable">z</span> <span class="token operator">=</span> <span class="token hvariable">x</span> <span class="token operator">*</span> <span class="token hvariable">y</span> <span class="token operator">+</span> <span class="token hvariable">z</span> <span class="token keyword">in</span> <span class="token hvariable">boot</span> <span class="token number">3</span> <span class="token number">4</span> <span class="token number">2</span>
<span class="token number">14</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token hvariable">boot</span>
<span class="token operator">&lt;</span><span class="token hvariable">interactive</span><span class="token operator">&gt;:</span><span class="token number">1</span><span class="token operator">:</span><span class="token number">0</span><span class="token operator">:</span> <span class="token constant">Not</span> <span class="token keyword">in</span> <span class="token hvariable">scope</span><span class="token operator">:</span> `<span class="token hvariable">boot'</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>If&nbsp;<em>let</em>&nbsp;bindings are so cool, why not use them all the time instead of&nbsp;<em>where</em>&nbsp;bindings, you ask? Well, since&nbsp;<em>let</em>&nbsp;bindings are expressions and are fairly local in their scope, they can't be used across guards. Some people prefer&nbsp;<em>where</em>&nbsp;bindings because the names come after the function they're being used in. That way, the function body is closer to its name and type declaration and to some that's more readable.</p></div><div><h2 data-heading="Case expressions" id="Case_expressions" style="display: flex;"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>Case expressions</h2></div><div><p><img alt="case" src="http://s3.amazonaws.com/lyah/case.png" referrerpolicy="no-referrer"></p></div><div><p>Many imperative languages (C, C++, Java, etc.) have case syntax and if you've ever programmed in them, you probably know what it's about. It's about taking a variable and then executing blocks of code for specific values of that variable and then maybe including a catch-all block of code in case the variable has some value for which we didn't set up a case.</p></div><div><p>Haskell takes that concept and one-ups it. Like the name implies, case expressions are, well, expressions, much like if else expressions and&nbsp;<em>let</em>&nbsp;bindings. Not only can we evaluate expressions based on the possible cases of the value of a variable, we can also do pattern matching. Hmmm, taking a variable, pattern matching it, evaluating pieces of code based on its value, where have we heard this before? Oh yeah, pattern matching on parameters in function definitions! Well, that's actually just syntactic sugar for case expressions. These two pieces of code do the same thing and are interchangeable:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token builtin">head</span>' <span class="token operator">::</span> <span class="token punctuation">[</span><span class="token hvariable">a</span><span class="token punctuation">]</span> <span class="token operator">-&gt;</span> <span class="token hvariable">a</span>
<span class="token builtin">head</span>' <span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token builtin">error</span> <span class="token string">"No head for empty lists!"</span>
<span class="token builtin">head</span>' <span class="token punctuation">(</span><span class="token hvariable">x</span><span class="token operator">:</span><span class="token hvariable">_</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token hvariable">x</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token builtin">head</span>' <span class="token operator">::</span> <span class="token punctuation">[</span><span class="token hvariable">a</span><span class="token punctuation">]</span> <span class="token operator">-&gt;</span> <span class="token hvariable">a</span>
<span class="token builtin">head</span>' <span class="token hvariable">xs</span> <span class="token operator">=</span> <span class="token keyword">case</span> <span class="token hvariable">xs</span> <span class="token keyword">of</span> <span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">-&gt;</span> <span class="token builtin">error</span> <span class="token string">"No head for empty lists!"</span>
                      <span class="token punctuation">(</span><span class="token hvariable">x</span><span class="token operator">:</span><span class="token hvariable">_</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token hvariable">x</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>As you can see, the syntax for case expressions is pretty simple:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token keyword">case</span> <span class="token hvariable">expression</span> <span class="token keyword">of</span> <span class="token hvariable">pattern</span> <span class="token operator">-&gt;</span> <span class="token hvariable">result</span>
                   <span class="token hvariable">pattern</span> <span class="token operator">-&gt;</span> <span class="token hvariable">result</span>
                   <span class="token hvariable">pattern</span> <span class="token operator">-&gt;</span> <span class="token hvariable">result</span>
                   <span class="token operator">...</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p><code>expression</code>&nbsp;is matched against the patterns. The pattern matching action is the same as expected: the first pattern that matches the expression is used. If it falls through the whole case expression and no suitable pattern is found, a runtime error occurs.</p></div><div><p>Whereas pattern matching on function parameters can only be done when defining functions, case expressions can be used pretty much anywhere. For instance:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">describeList</span> <span class="token operator">::</span> <span class="token punctuation">[</span><span class="token hvariable">a</span><span class="token punctuation">]</span> <span class="token operator">-&gt;</span> <span class="token constant">String</span>
<span class="token hvariable">describeList</span> <span class="token hvariable">xs</span> <span class="token operator">=</span> <span class="token string">"The list is "</span> <span class="token operator">++</span> <span class="token keyword">case</span> <span class="token hvariable">xs</span> <span class="token keyword">of</span> <span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">-&gt;</span> <span class="token string">"empty."</span>
                                               <span class="token punctuation">[</span><span class="token hvariable">x</span><span class="token punctuation">]</span> <span class="token operator">-&gt;</span> <span class="token string">"a singleton list."</span> 
                                               <span class="token hvariable">xs</span> <span class="token operator">-&gt;</span> <span class="token string">"a longer list."</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>They are useful for pattern matching against something in the middle of an expression. Because pattern matching in function definitions is syntactic sugar for case expressions, we could have also defined this like so:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">describeList</span> <span class="token operator">::</span> <span class="token punctuation">[</span><span class="token hvariable">a</span><span class="token punctuation">]</span> <span class="token operator">-&gt;</span> <span class="token constant">String</span>
<span class="token hvariable">describeList</span> <span class="token hvariable">xs</span> <span class="token operator">=</span> <span class="token string">"The list is "</span> <span class="token operator">++</span> <span class="token hvariable">what</span> <span class="token hvariable">xs</span>
    <span class="token keyword">where</span> <span class="token hvariable">what</span> <span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">"empty."</span>
          <span class="token hvariable">what</span> <span class="token punctuation">[</span><span class="token hvariable">x</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">"a singleton list."</span>
          <span class="token hvariable">what</span> <span class="token hvariable">xs</span> <span class="token operator">=</span> <span class="token string">"a longer list."</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div class="mod-footer"></div></div></div></div><div class="sidebar-right sidebar"><div class="sidebar-content"><span class="sidebar-section-header">Interactive Graph</span><div class="graph-view-placeholder">
		<div class="graph-view-container">
			<div class="graph-icon graph-expand" role="button" aria-label="Expand" data-tooltip-position="top"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon lucide-arrow-up-right"><line x1="7" y1="17" x2="17" y2="7"></line><polyline points="7 7 17 7 17 17"></polyline></svg></div>
			<canvas id="graph-canvas" width="512px" height="512px"></canvas>
		</div>
		</div><div class="tree-container outline-tree" data-depth="0"><div class="tree-header"><span class="sidebar-section-header">Table Of Contents</span><button class="clickable-icon collapse-tree-button"><iconify-icon icon="ph:arrows-in-line-horizontal-bold" width="18px" height="18px" rotate="90deg" color="currentColor"></iconify-icon></button></div><div class="tree-scroll-area"><div class="tree-item mod-tree-heading" data-depth="1"><div class="tree-item-contents"><a class="tree-item-link" href="#Syntax_in_Functions"><span class="tree-item-title">Syntax in Functions</span></a></div><div class="tree-item-children"><div class="tree-item mod-tree-heading" data-depth="2"><div class="tree-item-contents"><a class="tree-item-link" href="#Pattern_matching"><span class="tree-item-title">Pattern matching</span></a></div><div class="tree-item-children"></div></div><div class="tree-item mod-tree-heading" data-depth="2"><div class="tree-item-contents"><a class="tree-item-link" href="#Guards,_guards!"><span class="tree-item-title">Guards, guards!</span></a></div><div class="tree-item-children"></div></div><div class="tree-item mod-tree-heading" data-depth="2"><div class="tree-item-contents"><a class="tree-item-link" href="#Where!?"><span class="tree-item-title">Where!?</span></a></div><div class="tree-item-children"></div></div><div class="tree-item mod-tree-heading" data-depth="2"><div class="tree-item-contents"><a class="tree-item-link" href="#Let_it_be"><span class="tree-item-title">Let it be</span></a></div><div class="tree-item-children"></div></div><div class="tree-item mod-tree-heading" data-depth="2"><div class="tree-item-contents"><a class="tree-item-link" href="#Case_expressions"><span class="tree-item-title">Case expressions</span></a></div><div class="tree-item-children"></div></div></div></div></div></div></div></div></div></body></html>