<!DOCTYPE html>
<html><head>
			
		<title>Chapter 10 Functionally Solving Problems</title>
		<base href="../../../">
		<meta id="root-path" root-path="../../../">

		<link rel="icon" sizes="96x96" href="https://publish-01.obsidian.md/access/f786db9fac45774fa4f0d8112e232d67/favicon-96x96.png">
		<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes, minimum-scale=1.0, maximum-scale=5.0">
		<meta charset="UTF-8">
		<script src="https://code.iconify.design/iconify-icon/1.0.3/iconify-icon.min.js"></script>

			<link rel="stylesheet" href="lib/styles/obsidian-styles.css">
			<link rel="stylesheet" href="lib/styles/theme.css">
			<link rel="stylesheet" href="lib/styles/plugin-styles.css">
			<link rel="stylesheet" href="lib/styles/snippets.css">
			<style>  </style>

			
			<!-- Graph View Data -->
			<script>
			let nodes=
{"nodeCount":22,"linkCount":21,"radii":[7,5.346938775510203,4.855867346938775,4.301020408163265,3.6823979591836737,3.6823979591836737,3.6823979591836737,3.6823979591836737,3.6823979591836737,3.6823979591836737,3.6823979591836737,3.6823979591836737,3.6823979591836737,3.6823979591836737,3.6823979591836737,3.6823979591836737,3.6823979591836737,3.6823979591836737,3.6823979591836737,3.6823979591836737,3.6823979591836737,3.6823979591836737],"labels":["Table Of Content","Отчеты","README","README","О Haskell по-человечески (Итого)","Полезные ресурсы","О Haskell по-человечески (Оригинал)","Оглавление","Chapter 13 For a Few Monads More","Chapter 12 A Fistful of Monads","Chapter 11 Functors, Applicative Functors and Monoids","Chapter 10 Functionally Solving Problems","Chapter 9 Input and Output","Chapter 8 Making Our Own Types and Typeclasses","Chapter 7 Modules","Chapter 6 Higher order functions","Chapter 5 Recursion","Chapter 4 Syntax in Functions","Chapter 14 Zippers","Chapter 1 Introduction","Chapter 2 Starting Out","Chapter 3 Types and Typeclasses"],"paths":["курсы/learn-you-a-haskell-for-great-good!/en/table-of-content.html","отчеты.html","курсы/learn-you-a-haskell-for-great-good!/readme.html","readme.html","мои-решения/о-haskell-по-человечески/о-haskell-по-человечески-(итого).html","полезные-ресурсы.html","курсы/о-haskell-по-человечески/о-haskell-по-человечески-(оригинал).html","курсы/learn-you-a-haskell-for-great-good!/ru/оглавление.html","курсы/learn-you-a-haskell-for-great-good!/en/chapter-13-for-a-few-monads-more.html","курсы/learn-you-a-haskell-for-great-good!/en/chapter-12-a-fistful-of-monads.html","курсы/learn-you-a-haskell-for-great-good!/en/chapter-11-functors,-applicative-functors-and-monoids.html","курсы/learn-you-a-haskell-for-great-good!/en/chapter-10-functionally-solving-problems.html","курсы/learn-you-a-haskell-for-great-good!/en/chapter-9-input-and-output.html","курсы/learn-you-a-haskell-for-great-good!/en/chapter-8-making-our-own-types-and-typeclasses.html","курсы/learn-you-a-haskell-for-great-good!/en/chapter-7-modules.html","курсы/learn-you-a-haskell-for-great-good!/en/chapter-6-higher-order-functions.html","курсы/learn-you-a-haskell-for-great-good!/en/chapter-5-recursion.html","курсы/learn-you-a-haskell-for-great-good!/en/chapter-4-syntax-in-functions.html","курсы/learn-you-a-haskell-for-great-good!/en/chapter-14-zippers.html","курсы/learn-you-a-haskell-for-great-good!/en/chapter-1-introduction.html","курсы/learn-you-a-haskell-for-great-good!/en/chapter-2-starting-out.html","курсы/learn-you-a-haskell-for-great-good!/en/chapter-3-types-and-typeclasses.html"],"linkSources":[3,3,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,2],"linkTargets":[5,1,6,4,2,19,20,21,17,16,15,14,13,12,11,10,9,8,18,0,7]};
			let attractionForce = 1;
			let linkLength = 10;
			let repulsionForce = 150;
			let centralForce = 3;
			let edgePruning = 100;
			</script>
			
<script type="module" src="lib/scripts/graph_view.js"></script>

<script src="lib/scripts/graph_wasm.js"></script>

<script src="lib/scripts/tinycolor.js"></script>

<script src="https://cdnjs.cloudflare.com/ajax/libs/pixi.js/7.2.4/pixi.min.js" integrity="sha512-Ch/O6kL8BqUwAfCF7Ie5SX1Hin+BJgYH4pNjRqXdTEqMsis1TUYg+j6nnI9uduPjGaj7DN4UKCZgpvoExt6dkw==" crossorigin="anonymous" referrerpolicy="no-referrer"></script>

<script src="lib/scripts/webpage.js"></script>

			</head><body class="theme-dark mod-windows is-frameless is-maximized is-hidden-frameless obsidian-app show-inline-title show-view-header" style="--zoom-factor:1; --font-text-size:16px; --line-width:100%; --line-width-adaptive:100%; --file-line-width:100%; --content-width:500em; --sidebar-width:25em; --collapse-arrow-size:0.4em; --tree-horizontal-spacing:1em; --tree-vertical-spacing:0.5em; --sidebar-margin:12px;"><div class="webpage-container"><div class="sidebar-left sidebar"><div class="sidebar-content"><div><label class="theme-toggle-container" for="theme_toggle"><input class="theme-toggle-input" type="checkbox" id="theme_toggle"><div class="toggle-background"></div></label></div><div class="tree-container file-tree mod-nav-indicator" data-depth="0"><div class="tree-header"><span class="sidebar-section-header">learn-haskell-valut</span><button class="clickable-icon collapse-tree-button is-collapsed"><iconify-icon icon="ph:arrows-in-line-horizontal-bold" width="18px" height="18px" rotate="90deg" color="currentColor"></iconify-icon></button></div><div class="tree-scroll-area"><div class="tree-item mod-tree-folder mod-collapsible is-collapsed" data-depth="1"><div class="tree-item-contents"><div class="tree-item-icon collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div><a class="tree-item-link" href="курсы"><span class="tree-item-title">Курсы</span></a></div><div class="tree-item-children"><div class="tree-item mod-tree-folder mod-collapsible is-collapsed" data-depth="2"><div class="tree-item-contents"><div class="tree-item-icon collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div><a class="tree-item-link" href="курсы/о-haskell-по-человечески"><span class="tree-item-title">О Haskell по-человечески</span></a></div><div class="tree-item-children"><div class="tree-item mod-tree-file" data-depth="3"><div class="tree-item-contents"><a class="tree-item-link" href="курсы/о-haskell-по-человечески/о-haskell-по-человечески-(оригинал).html"><span class="tree-item-title">О Haskell по-человечески (Оригинал)</span></a></div><div class="tree-item-children"></div></div></div></div><div class="tree-item mod-tree-folder mod-collapsible is-collapsed" data-depth="2"><div class="tree-item-contents"><div class="tree-item-icon collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div><a class="tree-item-link" href="курсы/learn-you-a-haskell-for-great-good!"><span class="tree-item-title">Learn You a Haskell for Great Good!</span></a></div><div class="tree-item-children"><div class="tree-item mod-tree-folder mod-collapsible is-collapsed" data-depth="3"><div class="tree-item-contents"><div class="tree-item-icon collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div><a class="tree-item-link" href="курсы/learn-you-a-haskell-for-great-good!/en"><span class="tree-item-title">en</span></a></div><div class="tree-item-children"><div class="tree-item mod-tree-file" data-depth="4"><div class="tree-item-contents"><a class="tree-item-link" href="курсы/learn-you-a-haskell-for-great-good!/en/chapter-1-introduction.html"><span class="tree-item-title">Chapter 1 Introduction</span></a></div><div class="tree-item-children"></div></div><div class="tree-item mod-tree-file" data-depth="4"><div class="tree-item-contents"><a class="tree-item-link" href="курсы/learn-you-a-haskell-for-great-good!/en/chapter-10-functionally-solving-problems.html"><span class="tree-item-title">Chapter 10 Functionally Solving Problems</span></a></div><div class="tree-item-children"></div></div><div class="tree-item mod-tree-file" data-depth="4"><div class="tree-item-contents"><a class="tree-item-link" href="курсы/learn-you-a-haskell-for-great-good!/en/chapter-11-functors,-applicative-functors-and-monoids.html"><span class="tree-item-title">Chapter 11 Functors, Applicative Functors and Monoids</span></a></div><div class="tree-item-children"></div></div><div class="tree-item mod-tree-file" data-depth="4"><div class="tree-item-contents"><a class="tree-item-link" href="курсы/learn-you-a-haskell-for-great-good!/en/chapter-12-a-fistful-of-monads.html"><span class="tree-item-title">Chapter 12 A Fistful of Monads</span></a></div><div class="tree-item-children"></div></div><div class="tree-item mod-tree-file" data-depth="4"><div class="tree-item-contents"><a class="tree-item-link" href="курсы/learn-you-a-haskell-for-great-good!/en/chapter-13-for-a-few-monads-more.html"><span class="tree-item-title">Chapter 13 For a Few Monads More</span></a></div><div class="tree-item-children"></div></div><div class="tree-item mod-tree-file" data-depth="4"><div class="tree-item-contents"><a class="tree-item-link" href="курсы/learn-you-a-haskell-for-great-good!/en/chapter-14-zippers.html"><span class="tree-item-title">Chapter 14 Zippers</span></a></div><div class="tree-item-children"></div></div><div class="tree-item mod-tree-file" data-depth="4"><div class="tree-item-contents"><a class="tree-item-link" href="курсы/learn-you-a-haskell-for-great-good!/en/chapter-2-starting-out.html"><span class="tree-item-title">Chapter 2 Starting Out</span></a></div><div class="tree-item-children"></div></div><div class="tree-item mod-tree-file" data-depth="4"><div class="tree-item-contents"><a class="tree-item-link" href="курсы/learn-you-a-haskell-for-great-good!/en/chapter-3-types-and-typeclasses.html"><span class="tree-item-title">Chapter 3 Types and Typeclasses</span></a></div><div class="tree-item-children"></div></div><div class="tree-item mod-tree-file" data-depth="4"><div class="tree-item-contents"><a class="tree-item-link" href="курсы/learn-you-a-haskell-for-great-good!/en/chapter-4-syntax-in-functions.html"><span class="tree-item-title">Chapter 4 Syntax in Functions</span></a></div><div class="tree-item-children"></div></div><div class="tree-item mod-tree-file" data-depth="4"><div class="tree-item-contents"><a class="tree-item-link" href="курсы/learn-you-a-haskell-for-great-good!/en/chapter-5-recursion.html"><span class="tree-item-title">Chapter 5 Recursion</span></a></div><div class="tree-item-children"></div></div><div class="tree-item mod-tree-file" data-depth="4"><div class="tree-item-contents"><a class="tree-item-link" href="курсы/learn-you-a-haskell-for-great-good!/en/chapter-6-higher-order-functions.html"><span class="tree-item-title">Chapter 6 Higher order functions</span></a></div><div class="tree-item-children"></div></div><div class="tree-item mod-tree-file" data-depth="4"><div class="tree-item-contents"><a class="tree-item-link" href="курсы/learn-you-a-haskell-for-great-good!/en/chapter-7-modules.html"><span class="tree-item-title">Chapter 7 Modules</span></a></div><div class="tree-item-children"></div></div><div class="tree-item mod-tree-file" data-depth="4"><div class="tree-item-contents"><a class="tree-item-link" href="курсы/learn-you-a-haskell-for-great-good!/en/chapter-8-making-our-own-types-and-typeclasses.html"><span class="tree-item-title">Chapter 8 Making Our Own Types and Typeclasses</span></a></div><div class="tree-item-children"></div></div><div class="tree-item mod-tree-file" data-depth="4"><div class="tree-item-contents"><a class="tree-item-link" href="курсы/learn-you-a-haskell-for-great-good!/en/chapter-9-input-and-output.html"><span class="tree-item-title">Chapter 9 Input and Output</span></a></div><div class="tree-item-children"></div></div><div class="tree-item mod-tree-file" data-depth="4"><div class="tree-item-contents"><a class="tree-item-link" href="курсы/learn-you-a-haskell-for-great-good!/en/table-of-content.html"><span class="tree-item-title">Table Of Content</span></a></div><div class="tree-item-children"></div></div></div></div><div class="tree-item mod-tree-folder mod-collapsible is-collapsed" data-depth="3"><div class="tree-item-contents"><div class="tree-item-icon collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div><a class="tree-item-link" href="курсы/learn-you-a-haskell-for-great-good!/ru"><span class="tree-item-title">ru</span></a></div><div class="tree-item-children"><div class="tree-item mod-tree-file" data-depth="4"><div class="tree-item-contents"><a class="tree-item-link" href="курсы/learn-you-a-haskell-for-great-good!/ru/оглавление.html"><span class="tree-item-title">Оглавление</span></a></div><div class="tree-item-children"></div></div></div></div><div class="tree-item mod-tree-file" data-depth="3"><div class="tree-item-contents"><a class="tree-item-link" href="курсы/learn-you-a-haskell-for-great-good!/readme.html"><span class="tree-item-title">README</span></a></div><div class="tree-item-children"></div></div></div></div></div></div><div class="tree-item mod-tree-folder mod-collapsible is-collapsed" data-depth="1"><div class="tree-item-contents"><div class="tree-item-icon collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div><a class="tree-item-link" href="мои-решения"><span class="tree-item-title">Мои решения</span></a></div><div class="tree-item-children"><div class="tree-item mod-tree-folder mod-collapsible is-collapsed" data-depth="2"><div class="tree-item-contents"><div class="tree-item-icon collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div><a class="tree-item-link" href="мои-решения/о-haskell-по-человечески"><span class="tree-item-title">О Haskell по-человечески</span></a></div><div class="tree-item-children"><div class="tree-item mod-tree-file" data-depth="3"><div class="tree-item-contents"><a class="tree-item-link" href="мои-решения/о-haskell-по-человечески/о-haskell-по-человечески-(итого).html"><span class="tree-item-title">О Haskell по-человечески (Итого)</span></a></div><div class="tree-item-children"></div></div></div></div></div></div><div class="tree-item mod-tree-file" data-depth="1"><div class="tree-item-contents"><a class="tree-item-link" href="отчеты.html"><span class="tree-item-title">Отчеты</span></a></div><div class="tree-item-children"></div></div><div class="tree-item mod-tree-file" data-depth="1"><div class="tree-item-contents"><a class="tree-item-link" href="полезные-ресурсы.html"><span class="tree-item-title">Полезные ресурсы</span></a></div><div class="tree-item-children"></div></div><div class="tree-item mod-tree-file" data-depth="1"><div class="tree-item-contents"><a class="tree-item-link" href="readme.html"><span class="tree-item-title">README</span></a></div><div class="tree-item-children"></div></div></div></div></div></div><div class="document-container"><div class="markdown-preview-view markdown-rendered node-insert-event allow-fold-headings show-indentation-guide allow-fold-lists show-frontmatter" style="tab-size: 4;" tabindex="-1"><style id="MJX-CHTML-styles"></style><div class="markdown-preview-sizer markdown-preview-section" style="padding-bottom: ; padding-top: var(--file-margins); padding-right: var(--file-margins); padding-left: var(--file-margins); width: 100%; position: absolute;"><div class="markdown-preview-pusher" style="width: 1px; height: 0.1px; margin-bottom: 0px;"></div><div class="mod-header"></div><div><h1 data-heading="Functionally Solving Problems" id="Functionally_Solving_Problems">Functionally Solving Problems</h1></div><div><p>In this chapter, we'll take a look at a few interesting problems and how to think functionally to solve them as elegantly as possible. We probably won't be introducing any new concepts, we'll just be flexing our newly acquired Haskell muscles and practicing our coding skills. Each section will present a different problem. First we'll describe the problem, then we'll try and find out what the best (or least worst) way of solving it is.</p></div><div><h2 data-heading="Reverse Polish notation calculator" id="Reverse_Polish_notation_calculator" style="display: flex;"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>Reverse Polish notation calculator</h2></div><div><p>Usually when we write mathematical expressions in school, we write them in an infix manner. For instance, we write&nbsp;<code>10 - (4 + 3) * 2</code>.&nbsp;<code>+</code>,&nbsp;<code>*</code>&nbsp;and&nbsp;<code>-</code>&nbsp;are infix operators, just like the infix functions we met in Haskell (<code>+</code>,&nbsp;<code>`elem`</code>, etc.). This makes it handy because we, as humans, can parse it easily in our minds by looking at such an expression. The downside to it is that we have to use parentheses to denote precedence.</p></div><div><p><a data-tooltip-position="top" aria-label="http://en.wikipedia.org/wiki/Reverse_Polish_notation" rel="noopener" class="external-link" href="http://en.wikipedia.org/wiki/Reverse_Polish_notation" target="_blank">Reverse Polish notation</a>&nbsp;is another way of writing down mathematical expressions. Initially it looks a bit weird, but it's actually pretty easy to understand and use because there's no need for parentheses and it's very easy to punch into a calculator. While most modern calculators use infix notation, some people still swear by RPN calculators. This is what the previous infix expression looks like in RPN:&nbsp;<code>10 4 3 + 2 * -</code>. How do we calculate what the result of that is? Well, think of a stack. You go over the expression from left to right. Every time a number is encountered, push it on to the stack. When we encounter an operator, take the two numbers that are on top of the stack (we also say that we&nbsp;<em>pop</em>&nbsp;them), use the operator and those two and then push the resulting number back onto the stack. When you reach the end of the expression, you should be left with a single number if the expression was well-formed and that number represents the result.</p></div><div><p><img alt="this expression" src="http://s3.amazonaws.com/lyah/rpn.png" referrerpolicy="no-referrer"></p></div><div><p>Let's go over the expression&nbsp;<code>10 4 3 + 2 * -</code>&nbsp;together! First we push&nbsp;<code>10</code>&nbsp;on to the stack and the stack is now&nbsp;<code>10</code>. The next item is&nbsp;<code>4</code>, so we push it to the stack as well. The stack is now&nbsp;<code>10, 4</code>. We do the same with&nbsp;<code>3</code>&nbsp;and the stack is now&nbsp;<code>10, 4, 3</code>. And now, we encounter an operator, namely&nbsp;<code>+</code>! We pop the two top numbers from the stack (so now the stack is just&nbsp;<code>10</code>), add those numbers together and push that result to the stack. The stack is now&nbsp;<code>10, 7</code>. We push&nbsp;<code>2</code>&nbsp;to the stack, the stack for now is&nbsp;<code>10, 7, 2</code>. We've encountered an operator again, so let's pop&nbsp;<code>7</code>&nbsp;and&nbsp;<code>2</code>&nbsp;off the stack, multiply them and push that result to the stack. Multiplying&nbsp;<code>7</code>&nbsp;and&nbsp;<code>2</code>&nbsp;produces a&nbsp;<code>14</code>, so the stack we have now is&nbsp;<code>10, 14</code>. Finally, there's a&nbsp;<code>-</code>. We pop&nbsp;<code>10</code>&nbsp;and&nbsp;<code>14</code>&nbsp;from the stack, subtract&nbsp;<code>14</code>&nbsp;from&nbsp;<code>10</code>&nbsp;and push that back. The number on the stack is now&nbsp;<code>-4</code>&nbsp;and because there are no more numbers or operators in our expression, that's our result!</p></div><div><p>Now that we know how we'd calculate any RPN expression by hand, let's think about how we could make a Haskell function that takes as its parameter a string that contains a RPN expression, like&nbsp;<code>"10 4 3 + 2 * -"</code>&nbsp;and gives us back its result.</p></div><div><p>What would the type of that function be? We want it to take a string as a parameter and produce a number as its result. So it will probably be something like&nbsp;<code>solveRPN :: (Num a) =&gt; String -&gt; a</code>.</p></div><div><p><em>Protip:</em>&nbsp;it really helps to first think what the type declaration of a function should be before concerning ourselves with the implementation and then write it down. In Haskell, a function's type declaration tells us a whole lot about the function, due to the very strong type system.</p></div><div><p><img alt="HA HA HA" src="http://s3.amazonaws.com/lyah/calculator.png" referrerpolicy="no-referrer"></p></div><div><p>Cool. When implementing a solution to a problem in Haskell, it's also good to think back on how you did it by hand and maybe try to see if you can gain any insight from that. Here we see that we treated every number or operator that was separated by a space as a single item. So it might help us if we start by breaking a string like&nbsp;<code>"10 4 3 + 2 * -"</code>&nbsp;into a list of items like&nbsp;<code>["10","4","3","+","2","*","-"]</code>.</p></div><div><p>Next up, what did we do with that list of items in our head? We went over it from left to right and kept a stack as we did that. Does the previous sentence remind you of anything? Remember, in the section about&nbsp;<a data-tooltip-position="top" aria-label="http://learnyouahaskell.com/higher-order-functions/#folds" rel="noopener" class="external-link" href="http://learnyouahaskell.com/higher-order-functions/#folds" target="_blank">folds</a>, we said that pretty much any function where you traverse a list from left to right or right to left one element by element and build up (accumulate) some result (whether it's a number, a list, a stack, whatever) can be implemented with a fold.</p></div><div><p>In this case, we're going to use a left fold, because we go over the list from left to right. The accumulator value will be our stack and hence, the result from the fold will also be a stack, only as we've seen, it will only have one item.</p></div><div><p>One more thing to think about is, well, how are we going to represent the stack? I propose we use a list. Also I propose that we keep the top of our stack at the head of the list. That's because adding to the head (beginning) of a list is much faster than adding to the end of it. So if we have a stack of, say,&nbsp;<code>10, 4, 3</code>, we'll represent that as the list&nbsp;<code>[3,4,10]</code>.</p></div><div><p>Now we have enough information to roughly sketch our function. It's going to take a string, like,&nbsp;<code>"10 4 3 + 2 * -"</code>&nbsp;and break it down into a list of items by using&nbsp;<code>words</code>&nbsp;to get&nbsp;<code>["10","4","3","+","2","*","-"]</code>. Next, we'll do a left fold over that list and end up with a stack that has a single item, so&nbsp;<code>[-4]</code>. We take that single item out of the list and that's our final result!</p></div><div><p>So here's a sketch of that function:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token import-statement"><span class="token keyword">import</span> Data<span class="token punctuation">.</span>List</span>

<span class="token hvariable">solveRPN</span> <span class="token operator">::</span> <span class="token punctuation">(</span><span class="token constant">Num</span> <span class="token hvariable">a</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token constant">String</span> <span class="token operator">-&gt;</span> <span class="token hvariable">a</span>
<span class="token hvariable">solveRPN</span> <span class="token hvariable">expression</span> <span class="token operator">=</span> <span class="token builtin">head</span> <span class="token punctuation">(</span><span class="token builtin">foldl</span> <span class="token hvariable">foldingFunction</span> <span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token punctuation">(</span><span class="token builtin">words</span> <span class="token hvariable">expression</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token keyword">where</span>   <span class="token hvariable">foldingFunction</span> <span class="token hvariable">stack</span> <span class="token hvariable">item</span> <span class="token operator">=</span> <span class="token operator">...</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>We take the expression and turn it into a list of items. Then we fold over that list of items with the folding function. Mind the&nbsp;<code>[]</code>, which represents the starting accumulator. The accumulator is our stack, so&nbsp;<code>[]</code>&nbsp;represents an empty stack, which is what we start with. After getting the final stack with a single item, we call&nbsp;<code>head</code>&nbsp;on that list to get the item out and then we apply&nbsp;<code>read</code>.</p></div><div><p>So all that's left now is to implement a folding function that will take a stack, like&nbsp;<code>[4,10]</code>, and an item, like&nbsp;<code>"3"</code>&nbsp;and return a new stack&nbsp;<code>[3,4,10]</code>. If the stack is&nbsp;<code>[4,10]</code>&nbsp;and the item&nbsp;<code>"*"</code>, then it will have to return&nbsp;<code>[40]</code>. But before that, let's turn our function into&nbsp;<a data-tooltip-position="top" aria-label="http://learnyouahaskell.com/higher-order-functions#composition" rel="noopener" class="external-link" href="http://learnyouahaskell.com/higher-order-functions#composition" target="_blank">point-free style</a>&nbsp;because it has a lot of parentheses that are kind of freaking me out:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token import-statement"><span class="token keyword">import</span> Data<span class="token punctuation">.</span>List</span>

<span class="token hvariable">solveRPN</span> <span class="token operator">::</span> <span class="token punctuation">(</span><span class="token constant">Num</span> <span class="token hvariable">a</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token constant">String</span> <span class="token operator">-&gt;</span> <span class="token hvariable">a</span>
<span class="token hvariable">solveRPN</span> <span class="token operator">=</span> <span class="token builtin">head</span> <span class="token operator">.</span> <span class="token builtin">foldl</span> <span class="token hvariable">foldingFunction</span> <span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">.</span> <span class="token builtin">words</span>
    <span class="token keyword">where</span>   <span class="token hvariable">foldingFunction</span> <span class="token hvariable">stack</span> <span class="token hvariable">item</span> <span class="token operator">=</span> <span class="token operator">...</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Ah, there we go. Much better. So, the folding function will take a stack and an item and return a new stack. We'll use pattern matching to get the top items of a stack and to pattern match against operators like&nbsp;<code>"*"</code>&nbsp;and&nbsp;<code>"-"</code>.</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">solveRPN</span> <span class="token operator">::</span> <span class="token punctuation">(</span><span class="token constant">Num</span> <span class="token hvariable">a</span><span class="token punctuation">,</span> <span class="token constant">Read</span> <span class="token hvariable">a</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token constant">String</span> <span class="token operator">-&gt;</span> <span class="token hvariable">a</span>
<span class="token hvariable">solveRPN</span> <span class="token operator">=</span> <span class="token builtin">head</span> <span class="token operator">.</span> <span class="token builtin">foldl</span> <span class="token hvariable">foldingFunction</span> <span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">.</span> <span class="token builtin">words</span>
    <span class="token keyword">where</span>   <span class="token hvariable">foldingFunction</span> <span class="token punctuation">(</span><span class="token hvariable">x</span><span class="token operator">:</span><span class="token hvariable">y</span><span class="token operator">:</span><span class="token hvariable">ys</span><span class="token punctuation">)</span> <span class="token string">"*"</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token hvariable">x</span> <span class="token operator">*</span> <span class="token hvariable">y</span><span class="token punctuation">)</span><span class="token operator">:</span><span class="token hvariable">ys</span>
            <span class="token hvariable">foldingFunction</span> <span class="token punctuation">(</span><span class="token hvariable">x</span><span class="token operator">:</span><span class="token hvariable">y</span><span class="token operator">:</span><span class="token hvariable">ys</span><span class="token punctuation">)</span> <span class="token string">"+"</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token hvariable">x</span> <span class="token operator">+</span> <span class="token hvariable">y</span><span class="token punctuation">)</span><span class="token operator">:</span><span class="token hvariable">ys</span>
            <span class="token hvariable">foldingFunction</span> <span class="token punctuation">(</span><span class="token hvariable">x</span><span class="token operator">:</span><span class="token hvariable">y</span><span class="token operator">:</span><span class="token hvariable">ys</span><span class="token punctuation">)</span> <span class="token string">"-"</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token hvariable">y</span> <span class="token operator">-</span> <span class="token hvariable">x</span><span class="token punctuation">)</span><span class="token operator">:</span><span class="token hvariable">ys</span>
            <span class="token hvariable">foldingFunction</span> <span class="token hvariable">xs</span> <span class="token hvariable">numberString</span> <span class="token operator">=</span> <span class="token builtin">read</span> <span class="token hvariable">numberString</span><span class="token operator">:</span><span class="token hvariable">xs</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>We laid this out as four patterns. The patterns will be tried from top to bottom. First the folding function will see if the current item is&nbsp;<code>"*"</code>. If it is, then it will take a list like&nbsp;<code>[3,4,9,3]</code>&nbsp;and call its first two elements&nbsp;<code>x</code>&nbsp;and&nbsp;<code>y</code>&nbsp;respectively. So in this case,&nbsp;<code>x</code>&nbsp;would be&nbsp;<code>3</code>&nbsp;and&nbsp;<code>y</code>&nbsp;would be&nbsp;<code>4</code>.&nbsp;<code>ys</code>&nbsp;would be&nbsp;<code>[9,3]</code>. It will return a list that's just like&nbsp;<code>ys</code>, only it has&nbsp;<code>x</code>&nbsp;and&nbsp;<code>y</code>&nbsp;multiplied as its head. So with this we pop the two topmost numbers off the stack, multiply them and push the result back on to the stack. If the item is not&nbsp;<code>"*"</code>, the pattern matching will fall through and&nbsp;<code>"+"</code>&nbsp;will be checked, and so on.</p></div><div><p>If the item is none of the operators, then we assume it's a string that represents a number. If it's a number, we just call&nbsp;<code>read</code>&nbsp;on that string to get a number from it and return the previous stack but with that number pushed to the top.</p></div><div><p>And that's it! Also noticed that we added an extra class constraint of&nbsp;<code>Read a</code>&nbsp;to the function declaration, because we call&nbsp;<code>read</code>&nbsp;on our string to get the number. So this declaration means that the result can be of any type that's part of the&nbsp;<code>Num</code>&nbsp;and&nbsp;<code>Read</code>&nbsp;typeclasses (like&nbsp;<code>Int</code>,&nbsp;<code>Float</code>, etc.).</p></div><div><p>For the list of items&nbsp;<code>["2","3","+"]</code>, our function will start folding from the left. The intial stack will be&nbsp;<code>[]</code>. It will call the folding function with&nbsp;<code>[]</code>&nbsp;as the stack (accumulator) and&nbsp;<code>"2"</code>&nbsp;as the item. Because that item is not an operator, it will be&nbsp;<code>read</code>&nbsp;and the added to the beginning of&nbsp;<code>[]</code>. So the new stack is now&nbsp;<code>[2]</code>&nbsp;and the folding function will be called with&nbsp;<code>[2]</code>&nbsp;as the stack and&nbsp;<code>["3"]</code>&nbsp;as the item, producing a new stack of&nbsp;<code>[3,2]</code>. Then, it's called for the third time with&nbsp;<code>[3,2]</code>&nbsp;as the stack and&nbsp;<code>"+"</code>&nbsp;as the item. This causes these two numbers to be popped off the stack, added together and pushed back. The final stack is&nbsp;<code>[5]</code>, which is the number that we return.</p></div><div><p>Let's play around with our function:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token hvariable">solveRPN</span> <span class="token string">"10 4 3 + 2 * -"</span>
<span class="token operator">-</span><span class="token number">4</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token hvariable">solveRPN</span> <span class="token string">"2 3 +"</span>
<span class="token number">5</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token hvariable">solveRPN</span> <span class="token string">"90 34 12 33 55 66 + * - +"</span>
<span class="token operator">-</span><span class="token number">3947</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token hvariable">solveRPN</span> <span class="token string">"90 34 12 33 55 66 + * - + -"</span>
<span class="token number">4037</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token hvariable">solveRPN</span> <span class="token string">"90 34 12 33 55 66 + * - + -"</span>
<span class="token number">4037</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token hvariable">solveRPN</span> <span class="token string">"90 3 -"</span>
<span class="token number">87</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Cool, it works! One nice thing about this function is that it can be easily modified to support various other operators. They don't even have to be binary operators. For instance, we can make an operator&nbsp;<code>"log"</code>&nbsp;that just pops one number off the stack and pushes back its logarithm. We can also make a ternary operators that pop three numbers off the stack and push back a result or operators like&nbsp;<code>"sum"</code>&nbsp;which pop off all the numbers and push back their sum.</p></div><div><p>Let's modify our function to take a few more operators. For simplicity's sake, we'll change its type declaration so that it returns a number of type&nbsp;<code>Float</code>.</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token import-statement"><span class="token keyword">import</span> Data<span class="token punctuation">.</span>List</span>

<span class="token hvariable">solveRPN</span> <span class="token operator">::</span> <span class="token constant">String</span> <span class="token operator">-&gt;</span> <span class="token constant">Float</span>
<span class="token hvariable">solveRPN</span> <span class="token operator">=</span> <span class="token builtin">head</span> <span class="token operator">.</span> <span class="token builtin">foldl</span> <span class="token hvariable">foldingFunction</span> <span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">.</span> <span class="token builtin">words</span>
    <span class="token keyword">where</span>   <span class="token hvariable">foldingFunction</span> <span class="token punctuation">(</span><span class="token hvariable">x</span><span class="token operator">:</span><span class="token hvariable">y</span><span class="token operator">:</span><span class="token hvariable">ys</span><span class="token punctuation">)</span> <span class="token string">"*"</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token hvariable">x</span> <span class="token operator">*</span> <span class="token hvariable">y</span><span class="token punctuation">)</span><span class="token operator">:</span><span class="token hvariable">ys</span>
            <span class="token hvariable">foldingFunction</span> <span class="token punctuation">(</span><span class="token hvariable">x</span><span class="token operator">:</span><span class="token hvariable">y</span><span class="token operator">:</span><span class="token hvariable">ys</span><span class="token punctuation">)</span> <span class="token string">"+"</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token hvariable">x</span> <span class="token operator">+</span> <span class="token hvariable">y</span><span class="token punctuation">)</span><span class="token operator">:</span><span class="token hvariable">ys</span>
            <span class="token hvariable">foldingFunction</span> <span class="token punctuation">(</span><span class="token hvariable">x</span><span class="token operator">:</span><span class="token hvariable">y</span><span class="token operator">:</span><span class="token hvariable">ys</span><span class="token punctuation">)</span> <span class="token string">"-"</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token hvariable">y</span> <span class="token operator">-</span> <span class="token hvariable">x</span><span class="token punctuation">)</span><span class="token operator">:</span><span class="token hvariable">ys</span>
            <span class="token hvariable">foldingFunction</span> <span class="token punctuation">(</span><span class="token hvariable">x</span><span class="token operator">:</span><span class="token hvariable">y</span><span class="token operator">:</span><span class="token hvariable">ys</span><span class="token punctuation">)</span> <span class="token string">"/"</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token hvariable">y</span> <span class="token operator">/</span> <span class="token hvariable">x</span><span class="token punctuation">)</span><span class="token operator">:</span><span class="token hvariable">ys</span>
            <span class="token hvariable">foldingFunction</span> <span class="token punctuation">(</span><span class="token hvariable">x</span><span class="token operator">:</span><span class="token hvariable">y</span><span class="token operator">:</span><span class="token hvariable">ys</span><span class="token punctuation">)</span> <span class="token string">"^"</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token hvariable">y</span> <span class="token operator">**</span> <span class="token hvariable">x</span><span class="token punctuation">)</span><span class="token operator">:</span><span class="token hvariable">ys</span>
            <span class="token hvariable">foldingFunction</span> <span class="token punctuation">(</span><span class="token hvariable">x</span><span class="token operator">:</span><span class="token hvariable">xs</span><span class="token punctuation">)</span> <span class="token string">"ln"</span> <span class="token operator">=</span> <span class="token builtin">log</span> <span class="token hvariable">x</span><span class="token operator">:</span><span class="token hvariable">xs</span>
            <span class="token hvariable">foldingFunction</span> <span class="token hvariable">xs</span> <span class="token string">"sum"</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token builtin">sum</span> <span class="token hvariable">xs</span><span class="token punctuation">]</span>
            <span class="token hvariable">foldingFunction</span> <span class="token hvariable">xs</span> <span class="token hvariable">numberString</span> <span class="token operator">=</span> <span class="token builtin">read</span> <span class="token hvariable">numberString</span><span class="token operator">:</span><span class="token hvariable">xs</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Wow, great!&nbsp;<code>/</code>&nbsp;is division of course and&nbsp;<code>**</code>&nbsp;is floating point exponentiation. With the logarithm operator, we just pattern match against a single element and the rest of the stack because we only need one element to perform its natural logarithm. With the sum operator, we just return a stack that has only one element, which is the sum of the stack so far.</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token hvariable">solveRPN</span> <span class="token string">"2.7 ln"</span>
<span class="token number">0.9932518</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token hvariable">solveRPN</span> <span class="token string">"10 10 10 10 sum 4 /"</span>
<span class="token number">10.0</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token hvariable">solveRPN</span> <span class="token string">"10 10 10 10 10 sum 4 /"</span>
<span class="token number">12.5</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token hvariable">solveRPN</span> <span class="token string">"10 2 ^"</span>
<span class="token number">100.0</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Notice that we can include floating point numbers in our expression because&nbsp;<code>read</code>&nbsp;knows how to read them.</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token hvariable">solveRPN</span> <span class="token string">"43.2425 0.5 ^"</span>
<span class="token number">6.575903</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>I think that making a function that can calculate arbitrary floating point RPN expressions and has the option to be easily extended in 10 lines is pretty awesome.</p></div><div><p>One thing to note about this function is that it's not really fault tolerant. When given input that doesn't make sense, it will just crash everything. We'll make a fault tolerant version of this with a type declaration of&nbsp;<code>solveRPN :: String -&gt; Maybe Float</code>&nbsp;once we get to know monads (they're not scary, trust me!). We could make one right now, but it would be a bit tedious because it would involve a lot of checking for&nbsp;<code>Nothing</code>&nbsp;on every step. If you're feeling up to the challenge though, you can go ahead and try it! Hint: you can use&nbsp;<code>reads</code>&nbsp;to see if a read was successful or not.</p></div><div><h2 data-heading="Heathrow to London" id="Heathrow_to_London" style="display: flex;"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>Heathrow to London</h2></div><div><p>Our next problem is this: your plane has just landed in England and you rent a car. You have a meeting really soon and you have to get from Heathrow Airport to London as fast as you can (but safely!).</p></div><div><p>There are two main roads going from Heathrow to London and there's a number of regional roads crossing them. It takes you a fixed amount of time to travel from one crossroads to another. It's up to you to find the optimal path to take so that you get to London as fast as you can! You start on the left side and can either cross to the other main road or go forward.</p></div><div><p><img alt="Heathrow - London" src="http://s3.amazonaws.com/lyah/roads.png" referrerpolicy="no-referrer"></p></div><div><p>As you can see in the picture, the shortest path from Heathrow to London in this case is to start on main road B, cross over, go forward on A, cross over again and then go forward twice on B. If we take this path, it takes us 75 minutes. Had we chosen any other path, it would take more than that.</p></div><div><p>Our job is to make a program that takes input that represents a road system and print out what the shortest path across it is. Here's what the input would look like for this case:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token number">50</span>
<span class="token number">10</span>
<span class="token number">30</span>
<span class="token number">5</span>
<span class="token number">90</span>
<span class="token number">20</span>
<span class="token number">40</span>
<span class="token number">2</span>
<span class="token number">25</span>
<span class="token number">10</span>
<span class="token number">8</span>
<span class="token number">0</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>To mentally parse the input file, read it in threes and mentally split the road system into sections. Each section is comprised of a road A, road B and a crossing road. To have it neatly fit into threes, we say that there's a last crossing section that takes 0 minutes to drive over. That's because we don't care where we arrive in London, as long as we're in London.</p></div><div><p>Just like we did when solving the RPN calculator problem, we're going to solve this problem in three steps:</p></div><div><ul class="has-list-bullet">
<li data-line="0"><div class="list-bullet"></div>Forget Haskell for a minute and think about how we'd solve the problem by hand</li>
<li data-line="1"><div class="list-bullet"></div>Think about how we're going to represent our data in Haskell</li>
<li data-line="2"><div class="list-bullet"></div>Figure out how to operate on that data in Haskell so that we produce at a solution</li>
</ul></div><div><p>In the RPN calculator section, we first figured out that when calculating an expression by hand, we'd keep a sort of stack in our minds and then go over the expression one item at a time. We decided to use a list of strings to represent our expression. Finally, we used a left fold to walk oevr the list of strings while keeping a stack to produce a solution.</p></div><div><p>Okay, so how would we figure out the shortest path from Heathrow to London by hand? Well, we can just sort of look at the whole picture and try to guess what the shortest path is and hopefully we'll make a guess that's right. That solution works for very small inputs, but what if we have a road that has 10,000 sections? Yikes! We also won't be able to say for certain that our solution is the optimal one, we can just sort of say that we're pretty sure.</p></div><div><p>That's not a good solution then. Here's a simplified picture of our road system:</p></div><div><p><img alt="roads" src="http://s3.amazonaws.com/lyah/roads_simple.png" referrerpolicy="no-referrer"></p></div><div><p>Alright, can you figure out what the shortest path to the first crossroads (the first blue dot on A, marked&nbsp;<em>A1</em>) on road A is? That's pretty trivial. We just see if it's shorter to go directly forward on A or if it's shorter to go forward on B and then cross over. Obviously, it's cheaper to go forward via B and then cross over because that takes 40 minutes, whereas going directly via A takes 50 minutes. What about crossroads&nbsp;<em>B1</em>? Same thing. We see that it's a lot cheaper to just go directly via B (incurring a cost of 10 minutes), because going via A and then crossing over would take us a whole 80 minutes!</p></div><div><p>Now we know what the cheapest path to&nbsp;<em>A1</em>&nbsp;is (go via B and then cross over, so we'll say that's&nbsp;<code>B, C</code>&nbsp;with a cost of 40) and we know what the cheapest path to&nbsp;<em>B1</em>&nbsp;is (go directly via B, so that's just&nbsp;<code>B</code>, going at 10). Does this knowledge help us at all if we want to know the cheapest path to the next crossroads on both main roads? Gee golly, it sure does!</p></div><div><p>Let's see what the shortest path to&nbsp;<em>A2</em>&nbsp;would be. To get to&nbsp;<em>A2</em>, we'll either go directly to&nbsp;<em>A2</em>&nbsp;from&nbsp;<em>A1</em>&nbsp;or we'll go forward from&nbsp;<em>B1</em>&nbsp;and then cross over (remember, we can only move forward or cross to the other side). And because we know the cost to&nbsp;<em>A1</em>&nbsp;and&nbsp;<em>B1</em>, we can easily figure out what the best path to&nbsp;<em>A2</em>&nbsp;is. It costs 40 to get to&nbsp;<em>A1</em>&nbsp;and then 5 to get from&nbsp;<em>A1</em>&nbsp;to&nbsp;<em>A2</em>, so that's&nbsp;<code>B, C, A</code>&nbsp;for a cost of 45. It costs only 10 to get to&nbsp;<em>B1</em>, but then it would take an additional 110 minutes to go to&nbsp;<em>B2</em>&nbsp;and then cross over! So obviously, the cheapest path to&nbsp;<em>A2</em>&nbsp;is&nbsp;<code>B, C, A</code>. In the same way, the cheapest way to&nbsp;<em>B2</em>&nbsp;is to go forward from&nbsp;<em>A1</em>&nbsp;and then cross over.</p></div><div><p><em>Maybe you're asking yourself</em>: but what about getting to&nbsp;<em>A2</em>&nbsp;by first crossing over at&nbsp;<em>B1</em>&nbsp;and then going on forward? Well, we already covered crossing from&nbsp;<em>B1</em>&nbsp;to&nbsp;<em>A1</em>&nbsp;when we were looking for the best way to&nbsp;<em>A1</em>, so we don't have to take that into account in the next step as well.</p></div><div><p>Now that we have the best path to&nbsp;<em>A2</em>&nbsp;and&nbsp;<em>B2</em>, we can repeat this indefinitely until we reach the end. Once we've gotten the best paths for&nbsp;<em>A4</em>&nbsp;and&nbsp;<em>B4</em>, the one that's cheaper is the optimal path!</p></div><div><p>So in essence, for the second section, we just repeat the step we did at first, only we take into account what the previous best paths on A and B. We could say that we also took into account the best paths on A and on B in the first step, only they were both empty paths with a cost of 0.</p></div><div><p>Here's a summary. To get the bast path from Heathrow to London, we do this: first we see what the best path to the next crossroads on main road A is. The two options are going directly forward or starting at the opposite road, going forward and then crossing over. We remember the cost and the path. We use the same method to see what the best path to the next crossroads on main road B is and remember that. Then, we see if the path to the next crossroads on A is cheaper if we go from the previous A crossroads or if we go from the previous B crossroads and then cross over. We remember the cheaper path and then we do the same for the crossroads opposite of it. We do this for every section until we reach the end. Once we've reached the end, the cheapest of the two paths that we have is our optimal path!</p></div><div><p>So in essence, we keep one shortest path on the A road and one shortest path on the B road and when we reach the end, the shorter of those two is our path. We now know how to figure out the shortest path by hand. If you had enough time, paper and pencils, you could figure out the shortest path through a road system with any number of sections.</p></div><div><p>Next step! How do we represent this road system with Haskell's data types? One way is to think of the starting points and crossroads as nodes of a graph that point to other crossroads. If we imagine that the starting points actually point to each other with a road that has a length of one, we see that every crossroads (or node) points to the node on the other side and also to the next one on its side. Except for the last nodes, they just point to the other side.</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token keyword">data</span> <span class="token constant">Node</span> <span class="token operator">=</span> <span class="token constant">Node</span> <span class="token constant">Road</span> <span class="token constant">Road</span> <span class="token operator">|</span> <span class="token constant">EndNode</span> <span class="token constant">Road</span>
<span class="token keyword">data</span> <span class="token constant">Road</span> <span class="token operator">=</span> <span class="token constant">Road</span> <span class="token constant">Int</span> <span class="token constant">Node</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>A node is either a normal node and has information about the road that leads to the other main road and the road that leads to the next node or an end node, which only has information about the road to the other main road. A road keeps information about how long it is and which node it points to. For instance, the first part of the road on the A main road would be&nbsp;<code>Road 50 a1</code>&nbsp;where&nbsp;<code>a1</code>&nbsp;would be a node&nbsp;<code>Node x y</code>, where&nbsp;<code>x</code>&nbsp;and&nbsp;<code>y</code>&nbsp;are roads that point to&nbsp;<em>B1</em>&nbsp;and&nbsp;<em>A2</em>.</p></div><div><p>Another way would be to use&nbsp;<code>Maybe</code>&nbsp;for the road parts that point forward. Each node has a road part that point to the opposite road, but only those nodes that aren't the end ones have road parts that point forward.</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token keyword">data</span> <span class="token constant">Node</span> <span class="token operator">=</span> <span class="token constant">Node</span> <span class="token constant">Road</span> <span class="token punctuation">(</span><span class="token constant">Maybe</span> <span class="token constant">Road</span><span class="token punctuation">)</span>
<span class="token keyword">data</span> <span class="token constant">Road</span> <span class="token operator">=</span> <span class="token constant">Road</span> <span class="token constant">Int</span> <span class="token constant">Node</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>This is an alright way to represent the road system in Haskell and we could certainly solve this problem with it, but maybe we could come up with something simpler? If we think back to our solution by hand, we always just checked the lengths of three road parts at once: the road part on the A road, its opposite part on the B road and part C, which touches those two parts and connects them. When we were looking for the shortest path to&nbsp;<em>A1</em>&nbsp;and&nbsp;<em>B1</em>, we only had to deal with the lengths of the first three parts, which have lengths of 50, 10 and 30. We'll call that one section. So the road system that we use for this example can be easily represented as four sections:&nbsp;<code>50, 10, 30</code>,&nbsp;<code>5, 90, 20</code>,&nbsp;<code>40, 2, 25</code>, and&nbsp;<code>10, 8, 0</code>.</p></div><div><p>It's always good to keep our data types as simple as possible, although not any simpler!</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token keyword">data</span> <span class="token constant">Section</span> <span class="token operator">=</span> <span class="token constant">Section</span> <span class="token punctuation">{</span> <span class="token hvariable">getA</span> <span class="token operator">::</span> <span class="token constant">Int</span><span class="token punctuation">,</span> <span class="token hvariable">getB</span> <span class="token operator">::</span> <span class="token constant">Int</span><span class="token punctuation">,</span> <span class="token hvariable">getC</span> <span class="token operator">::</span> <span class="token constant">Int</span> <span class="token punctuation">}</span> <span class="token keyword">deriving</span> <span class="token punctuation">(</span><span class="token constant">Show</span><span class="token punctuation">)</span>
<span class="token keyword">type</span> <span class="token constant">RoadSystem</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token constant">Section</span><span class="token punctuation">]</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>This is pretty much perfect! It's as simple as it goes and I have a feeling it'll work perfectly for implementing our solution.&nbsp;<code>Section</code>&nbsp;is a simple algebraic data type that holds three integers for the lenghts of its three road parts. We introduce a type synonym as well, saying that&nbsp;<code>RoadSystem</code>&nbsp;is a list of sections.</p></div><div><p>We could also use a triple of&nbsp;(Int, Int, Int)&nbsp;to represent a road section. Using tuples instead of making your own algebraic data types is good for some small localized stuff, but it's usually better to make a new type for things like this. It gives the type system more information about what's what. We can use&nbsp;(Int, Int, Int)&nbsp;to represent a road section or a vector in 3D space and we can operate on those two, but that allows us to mix them up. If we use&nbsp;Section&nbsp;and&nbsp;Vector&nbsp;data types, then we can't accidentally add a vector to a section of a road system.</p></div><div><p>Our road system from Heathrow to London can now be represented like this:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">heathrowToLondon</span> <span class="token operator">::</span> <span class="token constant">RoadSystem</span>
<span class="token hvariable">heathrowToLondon</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token constant">Section</span> <span class="token number">50</span> <span class="token number">10</span> <span class="token number">30</span><span class="token punctuation">,</span> <span class="token constant">Section</span> <span class="token number">5</span> <span class="token number">90</span> <span class="token number">20</span><span class="token punctuation">,</span> <span class="token constant">Section</span> <span class="token number">40</span> <span class="token number">2</span> <span class="token number">25</span><span class="token punctuation">,</span> <span class="token constant">Section</span> <span class="token number">10</span> <span class="token number">8</span> <span class="token number">0</span><span class="token punctuation">]</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>All we need to do now is to implement the solution that we came up with previously in Haskell. What should the type declaration for a function that calculates a shortest path for any given road system be? It should take a road system as a parameter and return a path. We'll represent a path as a list as well. Let's introduce a&nbsp;<code>Label</code>&nbsp;type that's just an enumeration of either&nbsp;<code>A</code>,&nbsp;<code>B</code>&nbsp;or&nbsp;<code>C</code>. We'll also make a type synonym:&nbsp;<code>Path</code>.</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token keyword">data</span> <span class="token constant">Label</span> <span class="token operator">=</span> <span class="token constant">A</span> <span class="token operator">|</span> <span class="token constant">B</span> <span class="token operator">|</span> <span class="token constant">C</span> <span class="token keyword">deriving</span> <span class="token punctuation">(</span><span class="token constant">Show</span><span class="token punctuation">)</span>
<span class="token keyword">type</span> <span class="token constant">Path</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">(</span><span class="token constant">Label</span><span class="token punctuation">,</span> <span class="token constant">Int</span><span class="token punctuation">)</span><span class="token punctuation">]</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Our function, we'll call it&nbsp;<code>optimalPath</code>&nbsp;should thus have a type declaration of&nbsp;<code>optimalPath :: RoadSystem -&gt; Path</code>. If called with the road system&nbsp;<code>heathrowToLondon</code>, it should return the following path:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token punctuation">[</span><span class="token punctuation">(</span><span class="token constant">B</span><span class="token punctuation">,</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token constant">C</span><span class="token punctuation">,</span><span class="token number">30</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token constant">A</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token constant">C</span><span class="token punctuation">,</span><span class="token number">20</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token constant">B</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token constant">B</span><span class="token punctuation">,</span><span class="token number">8</span><span class="token punctuation">)</span><span class="token punctuation">]</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>We're going to have to walk over the list with the sections from left to right and keep the optimal path on A and optimal path on B as we go along. We'll accumulate the best path as we walk over the list, left to right. What does that sound like? Ding, ding, ding! That's right, A LEFT FOLD!</p></div><div><p>When doing the solution by hand, there was a step that we repeated over and over again. It involed checking the optimal paths on A and B so far and the current section to produce the new optimal paths on A and B. For instance, at the beginning the optimal paths were&nbsp;<code>[]</code>&nbsp;and&nbsp;<code>[]</code>&nbsp;for A and B respectively. We examined the section&nbsp;<code>Section 50 10 30</code>&nbsp;and concluded that the new optimal path to&nbsp;<em>A1</em>&nbsp;is&nbsp;<code>[(B,10),(C,30)]</code>&nbsp;and the optimal path to&nbsp;<em>B1</em>&nbsp;is&nbsp;<code>[(B,10)]</code>. If you look at this step as a function, it takes a pair of paths and a section and produces a new pair of paths. The type is&nbsp;<code>(Path, Path) -&gt; Section -&gt; (Path, Path)</code>. Let's go ahead and implement this function, because it's bound to be useful.</p></div><div><p><em>Hint:</em>&nbsp;it will be useful because&nbsp;(Path, Path) -&gt; Section -&gt; (Path, Path)&nbsp;can be used as the binary function for a left fold, which has to have a type of&nbsp;a -&gt; b -&gt; a</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">roadStep</span> <span class="token operator">::</span> <span class="token punctuation">(</span><span class="token constant">Path</span><span class="token punctuation">,</span> <span class="token constant">Path</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token constant">Section</span> <span class="token operator">-&gt;</span> <span class="token punctuation">(</span><span class="token constant">Path</span><span class="token punctuation">,</span> <span class="token constant">Path</span><span class="token punctuation">)</span>
<span class="token hvariable">roadStep</span> <span class="token punctuation">(</span><span class="token hvariable">pathA</span><span class="token punctuation">,</span> <span class="token hvariable">pathB</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token constant">Section</span> <span class="token hvariable">a</span> <span class="token hvariable">b</span> <span class="token hvariable">c</span><span class="token punctuation">)</span> <span class="token operator">=</span> 
    <span class="token keyword">let</span> <span class="token hvariable">priceA</span> <span class="token operator">=</span> <span class="token builtin">sum</span> <span class="token operator">$</span> <span class="token builtin">map</span> <span class="token builtin">snd</span> <span class="token hvariable">pathA</span>
        <span class="token hvariable">priceB</span> <span class="token operator">=</span> <span class="token builtin">sum</span> <span class="token operator">$</span> <span class="token builtin">map</span> <span class="token builtin">snd</span> <span class="token hvariable">pathB</span>
        <span class="token hvariable">forwardPriceToA</span> <span class="token operator">=</span> <span class="token hvariable">priceA</span> <span class="token operator">+</span> <span class="token hvariable">a</span>
        <span class="token hvariable">crossPriceToA</span> <span class="token operator">=</span> <span class="token hvariable">priceB</span> <span class="token operator">+</span> <span class="token hvariable">b</span> <span class="token operator">+</span> <span class="token hvariable">c</span>
        <span class="token hvariable">forwardPriceToB</span> <span class="token operator">=</span> <span class="token hvariable">priceB</span> <span class="token operator">+</span> <span class="token hvariable">b</span>
        <span class="token hvariable">crossPriceToB</span> <span class="token operator">=</span> <span class="token hvariable">priceA</span> <span class="token operator">+</span> <span class="token hvariable">a</span> <span class="token operator">+</span> <span class="token hvariable">c</span>
        <span class="token hvariable">newPathToA</span> <span class="token operator">=</span> <span class="token keyword">if</span> <span class="token hvariable">forwardPriceToA</span> <span class="token operator">&lt;=</span> <span class="token hvariable">crossPriceToA</span>
                        <span class="token keyword">then</span> <span class="token punctuation">(</span><span class="token constant">A</span><span class="token punctuation">,</span><span class="token hvariable">a</span><span class="token punctuation">)</span><span class="token operator">:</span><span class="token hvariable">pathA</span>
                        <span class="token keyword">else</span> <span class="token punctuation">(</span><span class="token constant">C</span><span class="token punctuation">,</span><span class="token hvariable">c</span><span class="token punctuation">)</span><span class="token operator">:</span><span class="token punctuation">(</span><span class="token constant">B</span><span class="token punctuation">,</span><span class="token hvariable">b</span><span class="token punctuation">)</span><span class="token operator">:</span><span class="token hvariable">pathB</span>
        <span class="token hvariable">newPathToB</span> <span class="token operator">=</span> <span class="token keyword">if</span> <span class="token hvariable">forwardPriceToB</span> <span class="token operator">&lt;=</span> <span class="token hvariable">crossPriceToB</span>
                        <span class="token keyword">then</span> <span class="token punctuation">(</span><span class="token constant">B</span><span class="token punctuation">,</span><span class="token hvariable">b</span><span class="token punctuation">)</span><span class="token operator">:</span><span class="token hvariable">pathB</span>
                        <span class="token keyword">else</span> <span class="token punctuation">(</span><span class="token constant">C</span><span class="token punctuation">,</span><span class="token hvariable">c</span><span class="token punctuation">)</span><span class="token operator">:</span><span class="token punctuation">(</span><span class="token constant">A</span><span class="token punctuation">,</span><span class="token hvariable">a</span><span class="token punctuation">)</span><span class="token operator">:</span><span class="token hvariable">pathA</span>
    <span class="token keyword">in</span>  <span class="token punctuation">(</span><span class="token hvariable">newPathToA</span><span class="token punctuation">,</span> <span class="token hvariable">newPathToB</span><span class="token punctuation">)</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p><img alt="this is you" src="http://s3.amazonaws.com/lyah/guycar.png" referrerpolicy="no-referrer"></p></div><div><p>What's going on here? First, calculate the optimal price on road A based on the best so far on A and we do the same for B. We do&nbsp;<code>sum $ map snd pathA</code>, so if&nbsp;<code>pathA</code>&nbsp;is something like&nbsp;<code>[(A,100),(C,20)]</code>,&nbsp;<code>priceA</code>&nbsp;becomes&nbsp;<code>120</code>.&nbsp;<code>forwardPriceToA</code>&nbsp;is the price that we would pay if we went to the next crossroads on A if we went there directly from the previous crossroads on A. It equals the best price to our previous A, plus the length of the A part of the current section.&nbsp;<code>crossPriceToA</code>&nbsp;is the price that we would pay if we went to the next A by going forward from the previous B and then crossing over. It's the best price to the previous B so far plus the B length of the section plus the C length of the section. We determine&nbsp;<code>forwardPriceToB</code>&nbsp;and&nbsp;<code>crossPriceToB</code>&nbsp;in the same manner.</p></div><div><p>Now that we know what the best way to A and B is, we just need to make the new paths to A and B based on that. If it's cheaper to go to A by just going forwards, we set&nbsp;<code>newPathToA</code>&nbsp;to be&nbsp;<code>(A,a):pathA</code>. Basically we prepend the&nbsp;<code>Label</code>&nbsp;<code>A</code>&nbsp;and the section length&nbsp;<code>a</code>&nbsp;to the optimal path path on A so far. Basically, we say that the best path to the next A crossroads is the path to the previous A crossroads and then one section forward via A. Remember,&nbsp;<code>A</code>&nbsp;is just a label, whereas&nbsp;<code>a</code>&nbsp;has a type of&nbsp;<code>Int</code>. Why do we prepend instead of doing&nbsp;<code>pathA ++ [(A,a)]</code>? Well, adding an element to the beginning of a list (also known as consing) is much faster than adding it to the end. This means that the path will be the wrong way around once we fold over a list with this function, but it's easy to reverse the list later. If it's cheaper to get to the next A crossroads by going forward from road B and then crossing over, then&nbsp;<code>newPathToA</code>&nbsp;is the old path to B that then goes forward and crosses to A. We do the same thing for&nbsp;<code>newPathToB</code>, only everything's mirrored.</p></div><div><p>Finally, we return&nbsp;<code>newPathToA</code>&nbsp;and&nbsp;<code>newPathToB</code>&nbsp;in a pair.</p></div><div><p>Let's run this function on the first section of&nbsp;<code>heathrowToLondon</code>. Because it's the first section, the best paths on A and B parameter will be a pair of empty lists.</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token hvariable">roadStep</span> <span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token builtin">head</span> <span class="token hvariable">heathrowToLondon</span><span class="token punctuation">)</span>
<span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">(</span><span class="token constant">C</span><span class="token punctuation">,</span><span class="token number">30</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token constant">B</span><span class="token punctuation">,</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token punctuation">(</span><span class="token constant">B</span><span class="token punctuation">,</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Remember, the paths are reversed, so read them from right to left. From this we can read that the best path to the next A is to start on B and then cross over to A and that the best path to the next B is to just go directly forward from the starting point at B.</p></div><div><p><em>Optimization tip:</em>&nbsp;when we do&nbsp;priceA = sum $ map snd pathA, we're calculating the price from the path on every step. We wouldn't have to do that if we implemented&nbsp;roadStep&nbsp;as a&nbsp;(Path, Path, Int, Int) -&gt; Section -&gt; (Path, Path, Int, Int)&nbsp;function where the integers represent the best price on A and B.</p></div><div><p>Now that we have a function that takes a pair of paths and a section and produces a new optimal path, we can just easily do a left fold over a list of sections.&nbsp;<code>roadStep</code>&nbsp;is called with&nbsp;<code>([],[])</code>&nbsp;and the first section and returns a pair of optimal paths to that section. Then, it's called with that pair of paths and the next section and so on. When we've walked over all the sections, we're left with a pair of optimal paths and the shorter of them is our answer. With this in mind, we can implement&nbsp;<code>optimalPath</code>.</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">optimalPath</span> <span class="token operator">::</span> <span class="token constant">RoadSystem</span> <span class="token operator">-&gt;</span> <span class="token constant">Path</span>
<span class="token hvariable">optimalPath</span> <span class="token hvariable">roadSystem</span> <span class="token operator">=</span>
    <span class="token keyword">let</span> <span class="token punctuation">(</span><span class="token hvariable">bestAPath</span><span class="token punctuation">,</span> <span class="token hvariable">bestBPath</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token builtin">foldl</span> <span class="token hvariable">roadStep</span> <span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token hvariable">roadSystem</span>
    <span class="token keyword">in</span>  <span class="token keyword">if</span> <span class="token builtin">sum</span> <span class="token punctuation">(</span><span class="token builtin">map</span> <span class="token builtin">snd</span> <span class="token hvariable">bestAPath</span><span class="token punctuation">)</span> <span class="token operator">&lt;=</span> <span class="token builtin">sum</span> <span class="token punctuation">(</span><span class="token builtin">map</span> <span class="token builtin">snd</span> <span class="token hvariable">bestBPath</span><span class="token punctuation">)</span>
            <span class="token keyword">then</span> <span class="token builtin">reverse</span> <span class="token hvariable">bestAPath</span>
            <span class="token keyword">else</span> <span class="token builtin">reverse</span> <span class="token hvariable">bestBPath</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>We left fold over&nbsp;<code>roadSystem</code>&nbsp;(remember, it's a list of sections) with the starting accumulator being a pair of empty paths. The result of that fold is a pair of paths, so we pattern match on the pair to get the paths themselves. Then, we check which one of these was cheaper and return it. Before returning it, we also reverse it, because the optimal paths so far were reversed due to us choosing consing over appending.</p></div><div><p>Let's test this!</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token hvariable">optimalPath</span> <span class="token hvariable">heathrowToLondon</span>
<span class="token punctuation">[</span><span class="token punctuation">(</span><span class="token constant">B</span><span class="token punctuation">,</span><span class="token number">10</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token constant">C</span><span class="token punctuation">,</span><span class="token number">30</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token constant">A</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token constant">C</span><span class="token punctuation">,</span><span class="token number">20</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token constant">B</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token constant">B</span><span class="token punctuation">,</span><span class="token number">8</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token constant">C</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">]</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>This is the result that we were supposed to get! Awesome! It differs from our expected result a bit because there's a step&nbsp;<code>(C,0)</code>&nbsp;at the end, which means that we cross over to the other road once we're in London, but because that crossing doesn't cost anything, this is still the correct result.</p></div><div><p>We have the function that finds an optimal path based on, now we just have to read a textual representation of a road system from the standard input, convert it into a type of&nbsp;<code>RoadSystem</code>, run that through our&nbsp;<code>optimalPath</code>&nbsp;function and print the path.</p></div><div><p>First off, let's make a function that takes a list and splits it into groups of the same size. We'll call it&nbsp;<code>groupsOf</code>. For a parameter of&nbsp;<code>[1..10]</code>,&nbsp;<code>groupsOf 3</code>&nbsp;should return&nbsp;<code>[[1,2,3],[4,5,6],[7,8,9],[10]]</code>.</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">groupsOf</span> <span class="token operator">::</span> <span class="token constant">Int</span> <span class="token operator">-&gt;</span> <span class="token punctuation">[</span><span class="token hvariable">a</span><span class="token punctuation">]</span> <span class="token operator">-&gt;</span> <span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token hvariable">a</span><span class="token punctuation">]</span><span class="token punctuation">]</span>
<span class="token hvariable">groupsOf</span> <span class="token number">0</span> <span class="token hvariable">_</span> <span class="token operator">=</span> <span class="token builtin">undefined</span>
<span class="token hvariable">groupsOf</span> <span class="token hvariable">_</span> <span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
<span class="token hvariable">groupsOf</span> <span class="token hvariable">n</span> <span class="token hvariable">xs</span> <span class="token operator">=</span> <span class="token builtin">take</span> <span class="token hvariable">n</span> <span class="token hvariable">xs</span> <span class="token operator">:</span> <span class="token hvariable">groupsOf</span> <span class="token hvariable">n</span> <span class="token punctuation">(</span><span class="token builtin">drop</span> <span class="token hvariable">n</span> <span class="token hvariable">xs</span><span class="token punctuation">)</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>A standard recursive function. For an&nbsp;<code>xs</code>&nbsp;of&nbsp;<code>[1..10]</code>&nbsp;and an&nbsp;<code>n</code>&nbsp;of&nbsp;<code>3</code>, this equals&nbsp;<code>[1,2,3] : groupsOf 3 [4,5,6,7,8,9,10]</code>. When the recursion is done, we get our list in groups of three. And here's our&nbsp;<code>main</code>&nbsp;function, which reads from the standard input, makes a&nbsp;<code>RoadSystem</code>&nbsp;out of it and prints out the shortest path:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token import-statement"><span class="token keyword">import</span> Data<span class="token punctuation">.</span>List</span>

<span class="token hvariable">main</span> <span class="token operator">=</span> <span class="token keyword">do</span>
    <span class="token hvariable">contents</span> <span class="token operator">&lt;-</span> <span class="token builtin">getContents</span>
    <span class="token keyword">let</span> <span class="token hvariable">threes</span> <span class="token operator">=</span> <span class="token hvariable">groupsOf</span> <span class="token number">3</span> <span class="token punctuation">(</span><span class="token builtin">map</span> <span class="token builtin">read</span> <span class="token operator">$</span> <span class="token builtin">lines</span> <span class="token hvariable">contents</span><span class="token punctuation">)</span>
        <span class="token hvariable">roadSystem</span> <span class="token operator">=</span> <span class="token builtin">map</span> <span class="token punctuation">(</span><span class="token operator">\</span><span class="token punctuation">[</span><span class="token hvariable">a</span><span class="token punctuation">,</span><span class="token hvariable">b</span><span class="token punctuation">,</span><span class="token hvariable">c</span><span class="token punctuation">]</span> <span class="token operator">-&gt;</span> <span class="token constant">Section</span> <span class="token hvariable">a</span> <span class="token hvariable">b</span> <span class="token hvariable">c</span><span class="token punctuation">)</span> <span class="token hvariable">threes</span>
        <span class="token hvariable">path</span> <span class="token operator">=</span> <span class="token hvariable">optimalPath</span> <span class="token hvariable">roadSystem</span>
        <span class="token hvariable">pathString</span> <span class="token operator">=</span> <span class="token builtin">concat</span> <span class="token operator">$</span> <span class="token builtin">map</span> <span class="token punctuation">(</span><span class="token builtin">show</span> <span class="token operator">.</span> <span class="token builtin">fst</span><span class="token punctuation">)</span> <span class="token hvariable">path</span>
        <span class="token hvariable">pathPrice</span> <span class="token operator">=</span> <span class="token builtin">sum</span> <span class="token operator">$</span> <span class="token builtin">map</span> <span class="token builtin">snd</span> <span class="token hvariable">path</span>
    <span class="token builtin">putStrLn</span> <span class="token operator">$</span> <span class="token string">"The best path to take is: "</span> <span class="token operator">++</span> <span class="token hvariable">pathString</span>
    <span class="token builtin">putStrLn</span> <span class="token operator">$</span> <span class="token string">"The price is: "</span> <span class="token operator">++</span> <span class="token builtin">show</span> <span class="token hvariable">pathPrice</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>First, we get all the contents from the standard input. Then, we call&nbsp;<code>lines</code>&nbsp;with our contents to convert something like&nbsp;<code>"50\n10\n30\n...</code>&nbsp;to&nbsp;<code>["50","10","30"..</code>&nbsp;and then we map&nbsp;<code>read</code>&nbsp;to that to convert it to a list of numbers. We call&nbsp;<code>groupsOf 3</code>&nbsp;on it so that we turn it to a list of lists of length 3. We map the lambda&nbsp;<code>(\[a,b,c] -&gt; Section a b c)</code>&nbsp;over that list of lists. As you can see, the lambda just takes a list of length 3 and turns it into a section. So&nbsp;<code>roadSystem</code>&nbsp;is now our system of roads and it even has the correct type, namely&nbsp;<code>RoadSystem</code>&nbsp;(or&nbsp;<code>[Section]</code>). We call&nbsp;<code>optimalPath</code>&nbsp;with that and then get the path and the price in a nice textual representation and print it out.</p></div><div><p>We save the following text</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token number">50</span>
<span class="token number">10</span>
<span class="token number">30</span>
<span class="token number">5</span>
<span class="token number">90</span>
<span class="token number">20</span>
<span class="token number">40</span>
<span class="token number">2</span>
<span class="token number">25</span>
<span class="token number">10</span>
<span class="token number">8</span>
<span class="token number">0</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>in a file called&nbsp;<code>paths.txt</code>&nbsp;and then feed it to our program.</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token operator">$</span> <span class="token hvariable">cat</span> <span class="token hvariable">paths</span><span class="token punctuation">.</span><span class="token hvariable">txt</span> <span class="token operator">|</span> <span class="token hvariable">runhaskell</span> <span class="token hvariable">heathrow</span><span class="token punctuation">.</span><span class="token hvariable">hs</span>
<span class="token constant">The</span> <span class="token hvariable">best</span> <span class="token hvariable">path</span> <span class="token hvariable">to</span> <span class="token builtin">take</span> <span class="token hvariable">is</span><span class="token operator">:</span> <span class="token constant">BCACBBC</span>
<span class="token constant">The</span> <span class="token hvariable">price</span> <span class="token hvariable">is</span><span class="token operator">:</span> <span class="token number">75</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Works like a charm! You can use your knowledge of the&nbsp;<code>Data.Random</code>&nbsp;module to generate a much longer system of roads, which you can then feed to what we just wrote. If you get stack overflows, try using&nbsp;<code>foldl'</code>&nbsp;instead of&nbsp;<code>foldl</code>, because&nbsp;<code>foldl'</code>&nbsp;is strict.</p></div><div class="mod-footer"></div></div></div></div><div class="sidebar-right sidebar"><div class="sidebar-content"><span class="sidebar-section-header">Interactive Graph</span><div class="graph-view-placeholder">
		<div class="graph-view-container">
			<div class="graph-icon graph-expand" role="button" aria-label="Expand" data-tooltip-position="top"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon lucide-arrow-up-right"><line x1="7" y1="17" x2="17" y2="7"></line><polyline points="7 7 17 7 17 17"></polyline></svg></div>
			<canvas id="graph-canvas" width="512px" height="512px"></canvas>
		</div>
		</div><div class="tree-container outline-tree" data-depth="0"><div class="tree-header"><span class="sidebar-section-header">Table Of Contents</span><button class="clickable-icon collapse-tree-button"><iconify-icon icon="ph:arrows-in-line-horizontal-bold" width="18px" height="18px" rotate="90deg" color="currentColor"></iconify-icon></button></div><div class="tree-scroll-area"><div class="tree-item mod-tree-heading" data-depth="1"><div class="tree-item-contents"><a class="tree-item-link" href="#Functionally_Solving_Problems"><span class="tree-item-title">Functionally Solving Problems</span></a></div><div class="tree-item-children"><div class="tree-item mod-tree-heading" data-depth="2"><div class="tree-item-contents"><a class="tree-item-link" href="#Reverse_Polish_notation_calculator"><span class="tree-item-title">Reverse Polish notation calculator</span></a></div><div class="tree-item-children"></div></div><div class="tree-item mod-tree-heading" data-depth="2"><div class="tree-item-contents"><a class="tree-item-link" href="#Heathrow_to_London"><span class="tree-item-title">Heathrow to London</span></a></div><div class="tree-item-children"></div></div></div></div></div></div></div></div></div></body></html>