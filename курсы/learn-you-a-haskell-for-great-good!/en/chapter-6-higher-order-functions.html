<!DOCTYPE html>
<html><head>
			
		<title>Chapter 6 Higher order functions</title>
		<base href="../../../">
		<meta id="root-path" root-path="../../../">

		<link rel="icon" sizes="96x96" href="https://publish-01.obsidian.md/access/f786db9fac45774fa4f0d8112e232d67/favicon-96x96.png">
		<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=yes, minimum-scale=1.0, maximum-scale=5.0">
		<meta charset="UTF-8">
		<script src="https://code.iconify.design/iconify-icon/1.0.3/iconify-icon.min.js"></script>

			<link rel="stylesheet" href="lib/styles/obsidian-styles.css">
			<link rel="stylesheet" href="lib/styles/theme.css">
			<link rel="stylesheet" href="lib/styles/plugin-styles.css">
			<link rel="stylesheet" href="lib/styles/snippets.css">
			<style>  </style>

			
			<!-- Graph View Data -->
			<script>
			let nodes=
{"nodeCount":22,"linkCount":21,"radii":[7,5.346938775510203,4.855867346938775,4.301020408163265,3.6823979591836737,3.6823979591836737,3.6823979591836737,3.6823979591836737,3.6823979591836737,3.6823979591836737,3.6823979591836737,3.6823979591836737,3.6823979591836737,3.6823979591836737,3.6823979591836737,3.6823979591836737,3.6823979591836737,3.6823979591836737,3.6823979591836737,3.6823979591836737,3.6823979591836737,3.6823979591836737],"labels":["Table Of Content","Отчеты","README","README","О Haskell по-человечески (Итого)","Полезные ресурсы","О Haskell по-человечески (Оригинал)","Оглавление","Chapter 13 For a Few Monads More","Chapter 12 A Fistful of Monads","Chapter 11 Functors, Applicative Functors and Monoids","Chapter 10 Functionally Solving Problems","Chapter 9 Input and Output","Chapter 8 Making Our Own Types and Typeclasses","Chapter 7 Modules","Chapter 6 Higher order functions","Chapter 5 Recursion","Chapter 4 Syntax in Functions","Chapter 14 Zippers","Chapter 1 Introduction","Chapter 2 Starting Out","Chapter 3 Types and Typeclasses"],"paths":["курсы/learn-you-a-haskell-for-great-good!/en/table-of-content.html","отчеты.html","курсы/learn-you-a-haskell-for-great-good!/readme.html","readme.html","мои-решения/о-haskell-по-человечески/о-haskell-по-человечески-(итого).html","полезные-ресурсы.html","курсы/о-haskell-по-человечески/о-haskell-по-человечески-(оригинал).html","курсы/learn-you-a-haskell-for-great-good!/ru/оглавление.html","курсы/learn-you-a-haskell-for-great-good!/en/chapter-13-for-a-few-monads-more.html","курсы/learn-you-a-haskell-for-great-good!/en/chapter-12-a-fistful-of-monads.html","курсы/learn-you-a-haskell-for-great-good!/en/chapter-11-functors,-applicative-functors-and-monoids.html","курсы/learn-you-a-haskell-for-great-good!/en/chapter-10-functionally-solving-problems.html","курсы/learn-you-a-haskell-for-great-good!/en/chapter-9-input-and-output.html","курсы/learn-you-a-haskell-for-great-good!/en/chapter-8-making-our-own-types-and-typeclasses.html","курсы/learn-you-a-haskell-for-great-good!/en/chapter-7-modules.html","курсы/learn-you-a-haskell-for-great-good!/en/chapter-6-higher-order-functions.html","курсы/learn-you-a-haskell-for-great-good!/en/chapter-5-recursion.html","курсы/learn-you-a-haskell-for-great-good!/en/chapter-4-syntax-in-functions.html","курсы/learn-you-a-haskell-for-great-good!/en/chapter-14-zippers.html","курсы/learn-you-a-haskell-for-great-good!/en/chapter-1-introduction.html","курсы/learn-you-a-haskell-for-great-good!/en/chapter-2-starting-out.html","курсы/learn-you-a-haskell-for-great-good!/en/chapter-3-types-and-typeclasses.html"],"linkSources":[3,3,1,1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,2,2],"linkTargets":[5,1,6,4,2,19,20,21,17,16,15,14,13,12,11,10,9,8,18,0,7]};
			let attractionForce = 1;
			let linkLength = 10;
			let repulsionForce = 150;
			let centralForce = 3;
			let edgePruning = 100;
			</script>
			
<script type="module" src="lib/scripts/graph_view.js"></script>

<script src="lib/scripts/graph_wasm.js"></script>

<script src="lib/scripts/tinycolor.js"></script>

<script src="https://cdnjs.cloudflare.com/ajax/libs/pixi.js/7.2.4/pixi.min.js" integrity="sha512-Ch/O6kL8BqUwAfCF7Ie5SX1Hin+BJgYH4pNjRqXdTEqMsis1TUYg+j6nnI9uduPjGaj7DN4UKCZgpvoExt6dkw==" crossorigin="anonymous" referrerpolicy="no-referrer"></script>

<script src="lib/scripts/webpage.js"></script>

			</head><body class="theme-dark mod-windows is-frameless is-maximized is-hidden-frameless obsidian-app show-inline-title show-view-header" style="--zoom-factor:1; --font-text-size:16px; --line-width:100%; --line-width-adaptive:100%; --file-line-width:100%; --content-width:500em; --sidebar-width:25em; --collapse-arrow-size:0.4em; --tree-horizontal-spacing:1em; --tree-vertical-spacing:0.5em; --sidebar-margin:12px;"><div class="webpage-container"><div class="sidebar-left sidebar"><div class="sidebar-content"><div><label class="theme-toggle-container" for="theme_toggle"><input class="theme-toggle-input" type="checkbox" id="theme_toggle"><div class="toggle-background"></div></label></div><div class="tree-container file-tree mod-nav-indicator" data-depth="0"><div class="tree-header"><span class="sidebar-section-header">learn-haskell-valut</span><button class="clickable-icon collapse-tree-button is-collapsed"><iconify-icon icon="ph:arrows-in-line-horizontal-bold" width="18px" height="18px" rotate="90deg" color="currentColor"></iconify-icon></button></div><div class="tree-scroll-area"><div class="tree-item mod-tree-folder mod-collapsible is-collapsed" data-depth="1"><div class="tree-item-contents"><div class="tree-item-icon collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div><a class="tree-item-link" href="курсы"><span class="tree-item-title">Курсы</span></a></div><div class="tree-item-children"><div class="tree-item mod-tree-folder mod-collapsible is-collapsed" data-depth="2"><div class="tree-item-contents"><div class="tree-item-icon collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div><a class="tree-item-link" href="курсы/о-haskell-по-человечески"><span class="tree-item-title">О Haskell по-человечески</span></a></div><div class="tree-item-children"><div class="tree-item mod-tree-file" data-depth="3"><div class="tree-item-contents"><a class="tree-item-link" href="курсы/о-haskell-по-человечески/о-haskell-по-человечески-(оригинал).html"><span class="tree-item-title">О Haskell по-человечески (Оригинал)</span></a></div><div class="tree-item-children"></div></div></div></div><div class="tree-item mod-tree-folder mod-collapsible is-collapsed" data-depth="2"><div class="tree-item-contents"><div class="tree-item-icon collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div><a class="tree-item-link" href="курсы/learn-you-a-haskell-for-great-good!"><span class="tree-item-title">Learn You a Haskell for Great Good!</span></a></div><div class="tree-item-children"><div class="tree-item mod-tree-folder mod-collapsible is-collapsed" data-depth="3"><div class="tree-item-contents"><div class="tree-item-icon collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div><a class="tree-item-link" href="курсы/learn-you-a-haskell-for-great-good!/en"><span class="tree-item-title">en</span></a></div><div class="tree-item-children"><div class="tree-item mod-tree-file" data-depth="4"><div class="tree-item-contents"><a class="tree-item-link" href="курсы/learn-you-a-haskell-for-great-good!/en/chapter-1-introduction.html"><span class="tree-item-title">Chapter 1 Introduction</span></a></div><div class="tree-item-children"></div></div><div class="tree-item mod-tree-file" data-depth="4"><div class="tree-item-contents"><a class="tree-item-link" href="курсы/learn-you-a-haskell-for-great-good!/en/chapter-10-functionally-solving-problems.html"><span class="tree-item-title">Chapter 10 Functionally Solving Problems</span></a></div><div class="tree-item-children"></div></div><div class="tree-item mod-tree-file" data-depth="4"><div class="tree-item-contents"><a class="tree-item-link" href="курсы/learn-you-a-haskell-for-great-good!/en/chapter-11-functors,-applicative-functors-and-monoids.html"><span class="tree-item-title">Chapter 11 Functors, Applicative Functors and Monoids</span></a></div><div class="tree-item-children"></div></div><div class="tree-item mod-tree-file" data-depth="4"><div class="tree-item-contents"><a class="tree-item-link" href="курсы/learn-you-a-haskell-for-great-good!/en/chapter-12-a-fistful-of-monads.html"><span class="tree-item-title">Chapter 12 A Fistful of Monads</span></a></div><div class="tree-item-children"></div></div><div class="tree-item mod-tree-file" data-depth="4"><div class="tree-item-contents"><a class="tree-item-link" href="курсы/learn-you-a-haskell-for-great-good!/en/chapter-13-for-a-few-monads-more.html"><span class="tree-item-title">Chapter 13 For a Few Monads More</span></a></div><div class="tree-item-children"></div></div><div class="tree-item mod-tree-file" data-depth="4"><div class="tree-item-contents"><a class="tree-item-link" href="курсы/learn-you-a-haskell-for-great-good!/en/chapter-14-zippers.html"><span class="tree-item-title">Chapter 14 Zippers</span></a></div><div class="tree-item-children"></div></div><div class="tree-item mod-tree-file" data-depth="4"><div class="tree-item-contents"><a class="tree-item-link" href="курсы/learn-you-a-haskell-for-great-good!/en/chapter-2-starting-out.html"><span class="tree-item-title">Chapter 2 Starting Out</span></a></div><div class="tree-item-children"></div></div><div class="tree-item mod-tree-file" data-depth="4"><div class="tree-item-contents"><a class="tree-item-link" href="курсы/learn-you-a-haskell-for-great-good!/en/chapter-3-types-and-typeclasses.html"><span class="tree-item-title">Chapter 3 Types and Typeclasses</span></a></div><div class="tree-item-children"></div></div><div class="tree-item mod-tree-file" data-depth="4"><div class="tree-item-contents"><a class="tree-item-link" href="курсы/learn-you-a-haskell-for-great-good!/en/chapter-4-syntax-in-functions.html"><span class="tree-item-title">Chapter 4 Syntax in Functions</span></a></div><div class="tree-item-children"></div></div><div class="tree-item mod-tree-file" data-depth="4"><div class="tree-item-contents"><a class="tree-item-link" href="курсы/learn-you-a-haskell-for-great-good!/en/chapter-5-recursion.html"><span class="tree-item-title">Chapter 5 Recursion</span></a></div><div class="tree-item-children"></div></div><div class="tree-item mod-tree-file" data-depth="4"><div class="tree-item-contents"><a class="tree-item-link" href="курсы/learn-you-a-haskell-for-great-good!/en/chapter-6-higher-order-functions.html"><span class="tree-item-title">Chapter 6 Higher order functions</span></a></div><div class="tree-item-children"></div></div><div class="tree-item mod-tree-file" data-depth="4"><div class="tree-item-contents"><a class="tree-item-link" href="курсы/learn-you-a-haskell-for-great-good!/en/chapter-7-modules.html"><span class="tree-item-title">Chapter 7 Modules</span></a></div><div class="tree-item-children"></div></div><div class="tree-item mod-tree-file" data-depth="4"><div class="tree-item-contents"><a class="tree-item-link" href="курсы/learn-you-a-haskell-for-great-good!/en/chapter-8-making-our-own-types-and-typeclasses.html"><span class="tree-item-title">Chapter 8 Making Our Own Types and Typeclasses</span></a></div><div class="tree-item-children"></div></div><div class="tree-item mod-tree-file" data-depth="4"><div class="tree-item-contents"><a class="tree-item-link" href="курсы/learn-you-a-haskell-for-great-good!/en/chapter-9-input-and-output.html"><span class="tree-item-title">Chapter 9 Input and Output</span></a></div><div class="tree-item-children"></div></div><div class="tree-item mod-tree-file" data-depth="4"><div class="tree-item-contents"><a class="tree-item-link" href="курсы/learn-you-a-haskell-for-great-good!/en/table-of-content.html"><span class="tree-item-title">Table Of Content</span></a></div><div class="tree-item-children"></div></div></div></div><div class="tree-item mod-tree-folder mod-collapsible is-collapsed" data-depth="3"><div class="tree-item-contents"><div class="tree-item-icon collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div><a class="tree-item-link" href="курсы/learn-you-a-haskell-for-great-good!/ru"><span class="tree-item-title">ru</span></a></div><div class="tree-item-children"><div class="tree-item mod-tree-file" data-depth="4"><div class="tree-item-contents"><a class="tree-item-link" href="курсы/learn-you-a-haskell-for-great-good!/ru/оглавление.html"><span class="tree-item-title">Оглавление</span></a></div><div class="tree-item-children"></div></div></div></div><div class="tree-item mod-tree-file" data-depth="3"><div class="tree-item-contents"><a class="tree-item-link" href="курсы/learn-you-a-haskell-for-great-good!/readme.html"><span class="tree-item-title">README</span></a></div><div class="tree-item-children"></div></div></div></div></div></div><div class="tree-item mod-tree-folder mod-collapsible is-collapsed" data-depth="1"><div class="tree-item-contents"><div class="tree-item-icon collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div><a class="tree-item-link" href="мои-решения"><span class="tree-item-title">Мои решения</span></a></div><div class="tree-item-children"><div class="tree-item mod-tree-folder mod-collapsible is-collapsed" data-depth="2"><div class="tree-item-contents"><div class="tree-item-icon collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div><a class="tree-item-link" href="мои-решения/о-haskell-по-человечески"><span class="tree-item-title">О Haskell по-человечески</span></a></div><div class="tree-item-children"><div class="tree-item mod-tree-file" data-depth="3"><div class="tree-item-contents"><a class="tree-item-link" href="мои-решения/о-haskell-по-человечески/о-haskell-по-человечески-(итого).html"><span class="tree-item-title">О Haskell по-человечески (Итого)</span></a></div><div class="tree-item-children"></div></div></div></div></div></div><div class="tree-item mod-tree-file" data-depth="1"><div class="tree-item-contents"><a class="tree-item-link" href="отчеты.html"><span class="tree-item-title">Отчеты</span></a></div><div class="tree-item-children"></div></div><div class="tree-item mod-tree-file" data-depth="1"><div class="tree-item-contents"><a class="tree-item-link" href="полезные-ресурсы.html"><span class="tree-item-title">Полезные ресурсы</span></a></div><div class="tree-item-children"></div></div><div class="tree-item mod-tree-file" data-depth="1"><div class="tree-item-contents"><a class="tree-item-link" href="readme.html"><span class="tree-item-title">README</span></a></div><div class="tree-item-children"></div></div></div></div></div></div><div class="document-container"><div class="markdown-preview-view markdown-rendered node-insert-event allow-fold-headings show-indentation-guide allow-fold-lists show-frontmatter" style="tab-size: 4;" tabindex="-1"><style id="MJX-CHTML-styles"></style><div class="markdown-preview-sizer markdown-preview-section" style="padding-bottom: ; padding-top: var(--file-margins); padding-right: var(--file-margins); padding-left: var(--file-margins); width: 100%; position: absolute;"><div class="markdown-preview-pusher" style="width: 1px; height: 0.1px; margin-bottom: 0px;"></div><div class="mod-header"></div><div><h1 data-heading="Higher order functions" id="Higher_order_functions">Higher order functions</h1></div><div><p><img alt="sun" src="http://s3.amazonaws.com/lyah/sun.png" referrerpolicy="no-referrer"></p></div><div><p>Haskell functions can take functions as parameters and return functions as return values. A function that does either of those is called a higher order function. Higher order functions aren't just a part of the Haskell experience, they pretty much are the Haskell experience. It turns out that if you want to define computations by defining what stuff&nbsp;<em>is</em>&nbsp;instead of defining steps that change some state and maybe looping them, higher order functions are indispensable. They're a really powerful way of solving problems and thinking about programs.</p></div><div><h2 data-heading="Curried functions" id="Curried_functions" style="display: flex;"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>Curried functions</h2></div><div><p>Every function in Haskell officially only takes one parameter. So how is it possible that we defined and used several functions that take more than one parameter so far? Well, it's a clever trick! All the functions that accepted&nbsp;<em>several parameters</em>&nbsp;so far have been&nbsp;<strong>curried functions</strong>. What does that mean? You'll understand it best on an example. Let's take our good friend, the&nbsp;<code>max</code>&nbsp;function. It looks like it takes two parameters and returns the one that's bigger. Doing&nbsp;<code>max 4 5</code>&nbsp;first creates a function that takes a parameter and returns either&nbsp;<code>4</code>&nbsp;or that parameter, depending on which is bigger. Then,&nbsp;<code>5</code>&nbsp;is applied to that function and that function produces our desired result. That sounds like a mouthful but it's actually a really cool concept. The following two calls are equivalent:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token builtin">max</span> <span class="token number">4</span> <span class="token number">5</span>
<span class="token number">5</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token punctuation">(</span><span class="token builtin">max</span> <span class="token number">4</span><span class="token punctuation">)</span> <span class="token number">5</span>
<span class="token number">5</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p><img alt="haskell curry" src="http://s3.amazonaws.com/lyah/curry.png" referrerpolicy="no-referrer"></p></div><div><p>Putting a space between two things is simply&nbsp;<strong>function application</strong>. The space is sort of like an operator and it has the highest precedence. Let's examine the type of&nbsp;<code>max</code>. It's&nbsp;<code>max :: (Ord a) =&gt; a -&gt; a -&gt; a</code>. That can also be written as&nbsp;<code>max :: (Ord a) =&gt; a -&gt; (a -&gt; a)</code>. That could be read as:&nbsp;<code>max</code>&nbsp;takes an&nbsp;<code>a</code>&nbsp;and returns (that's the&nbsp;<code>-&gt;</code>) a function that takes an&nbsp;<code>a</code>&nbsp;and returns an&nbsp;<code>a</code>. That's why the return type and the parameters of functions are all simply separated with arrows.</p></div><div><p>So how is that beneficial to us? Simply speaking, if we call a function with too few parameters, we get back a&nbsp;<strong>partially applied</strong>&nbsp;function, meaning a function that takes as many parameters as we left out. Using partial application (calling functions with too few parameters, if you will) is a neat way to create functions on the fly so we can pass them to another function or to seed them with some data.</p></div><div><p>Take a look at this offensively simple function:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">multThree</span> <span class="token operator">::</span> <span class="token punctuation">(</span><span class="token constant">Num</span> <span class="token hvariable">a</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token hvariable">a</span> <span class="token operator">-&gt;</span> <span class="token hvariable">a</span> <span class="token operator">-&gt;</span> <span class="token hvariable">a</span> <span class="token operator">-&gt;</span> <span class="token hvariable">a</span>
<span class="token hvariable">multThree</span> <span class="token hvariable">x</span> <span class="token hvariable">y</span> <span class="token hvariable">z</span> <span class="token operator">=</span> <span class="token hvariable">x</span> <span class="token operator">*</span> <span class="token hvariable">y</span> <span class="token operator">*</span> <span class="token hvariable">z</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>What really happens when we do&nbsp;<code>multThree 3 5 9</code>&nbsp;or&nbsp;<code>((multThree 3) 5) 9</code>? First,&nbsp;<code>3</code>&nbsp;is applied to&nbsp;<code>multThree</code>, because they're separated by a space. That creates a function that takes one parameter and returns a function. So then&nbsp;<code>5</code>&nbsp;is applied to that, which creates a function that will take a parameter and multiply it by 15.&nbsp;<code>9</code>&nbsp;is applied to that function and the result is 135 or something. Remember that this function's type could also be written as&nbsp;<code>multThree :: (Num a) =&gt; a -&gt; (a -&gt; (a -&gt; a))</code>. The thing before the&nbsp;<code>-&gt;</code>&nbsp;is the parameter that a function takes and the thing after it is what it returns. So our function takes an&nbsp;<code>a</code>&nbsp;and returns a function of type&nbsp;<code>(Num a) =&gt; a -&gt; (a -&gt; a)</code>. Similarly, this function takes an&nbsp;<code>a</code>&nbsp;and returns a function of type&nbsp;<code>(Num a) =&gt; a -&gt; a</code>. And this function, finally, just takes an&nbsp;<code>a</code>&nbsp;and returns an&nbsp;<code>a</code>. Take a look at this:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token keyword">let</span> <span class="token hvariable">multTwoWithNine</span> <span class="token operator">=</span> <span class="token hvariable">multThree</span> <span class="token number">9</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token hvariable">multTwoWithNine</span> <span class="token number">2</span> <span class="token number">3</span>
<span class="token number">54</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token keyword">let</span> <span class="token hvariable">multWithEighteen</span> <span class="token operator">=</span> <span class="token hvariable">multTwoWithNine</span> <span class="token number">2</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token hvariable">multWithEighteen</span> <span class="token number">10</span>
<span class="token number">180</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>By calling functions with too few parameters, so to speak, we're creating new functions on the fly. What if we wanted to create a function that takes a number and compares it to&nbsp;<code>100</code>? We could do something like this:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">compareWithHundred</span> <span class="token operator">::</span> <span class="token punctuation">(</span><span class="token constant">Num</span> <span class="token hvariable">a</span><span class="token punctuation">,</span> <span class="token constant">Ord</span> <span class="token hvariable">a</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token hvariable">a</span> <span class="token operator">-&gt;</span> <span class="token constant">Ordering</span>
<span class="token hvariable">compareWithHundred</span> <span class="token hvariable">x</span> <span class="token operator">=</span> <span class="token builtin">compare</span> <span class="token number">100</span> <span class="token hvariable">x</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>If we call it with&nbsp;<code>99</code>, it returns a&nbsp;<code>GT</code>. Simple stuff. Notice that the&nbsp;<code>x</code>&nbsp;is on the right hand side on both sides of the equation. Now let's think about what&nbsp;<code>compare 100</code>&nbsp;returns. It returns a function that takes a number and compares it with&nbsp;<code>100</code>. Wow! Isn't that the function we wanted? We can rewrite this as:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">compareWithHundred</span> <span class="token operator">::</span> <span class="token punctuation">(</span><span class="token constant">Num</span> <span class="token hvariable">a</span><span class="token punctuation">,</span> <span class="token constant">Ord</span> <span class="token hvariable">a</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token hvariable">a</span> <span class="token operator">-&gt;</span> <span class="token constant">Ordering</span>
<span class="token hvariable">compareWithHundred</span> <span class="token operator">=</span> <span class="token builtin">compare</span> <span class="token number">100</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>The type declaration stays the same, because&nbsp;<code>compare 100</code>&nbsp;returns a function. Compare has a type of&nbsp;<code>(Ord a) =&gt; a -&gt; (a -&gt; Ordering)</code>&nbsp;and calling it with&nbsp;<code>100</code>&nbsp;returns a&nbsp;<code>(Num a, Ord a) =&gt; a -&gt; Ordering</code>. The additional class constraint sneaks up there because&nbsp;<code>100</code>&nbsp;is also part of the&nbsp;<code>Num</code>&nbsp;typeclass.</p></div><div><p><em>Yo!</em>&nbsp;Make sure you really understand how curried functions and partial application work because they're really important!</p></div><div><p>Infix functions can also be partially applied by using sections. To section an infix function, simply surround it with parentheses and only supply a parameter on one side. That creates a function that takes one parameter and then applies it to the side that's missing an operand. An insultingly trivial function:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">divideByTen</span> <span class="token operator">::</span> <span class="token punctuation">(</span><span class="token constant">Floating</span> <span class="token hvariable">a</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token hvariable">a</span> <span class="token operator">-&gt;</span> <span class="token hvariable">a</span>
<span class="token hvariable">divideByTen</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token operator">/</span><span class="token number">10</span><span class="token punctuation">)</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Calling, say,&nbsp;<code>divideByTen 200</code>&nbsp;is equivalent to doing&nbsp;<code>200 / 10</code>, as is doing&nbsp;<code>(/10) 200</code>. A function that checks if a character supplied to it is an uppercase letter:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">isUpperAlphanum</span> <span class="token operator">::</span> <span class="token constant">Char</span> <span class="token operator">-&gt;</span> <span class="token constant">Bool</span>
<span class="token hvariable">isUpperAlphanum</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token operator">`elem`</span> <span class="token punctuation">[</span><span class="token char string">'A'</span><span class="token operator">..</span><span class="token char string">'Z'</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>The only special thing about sections is using&nbsp;<code>-</code>. From the definition of sections,&nbsp;<code>(-4)</code>&nbsp;would result in a function that takes a number and subtracts 4 from it. However, for convenience,&nbsp;<code>(-4)</code>&nbsp;means minus four. So if you want to make a function that subtracts 4 from the number it gets as a parameter, partially apply the&nbsp;<code>subtract</code>&nbsp;function like so:&nbsp;<code>(subtract 4)</code>.</p></div><div><p>What happens if we try to just do&nbsp;<code>multThree 3 4</code>&nbsp;in GHCI instead of binding it to a name with a&nbsp;<em>let</em>&nbsp;or passing it to another function?</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token hvariable">multThree</span> <span class="token number">3</span> <span class="token number">4</span>
<span class="token operator">&lt;</span><span class="token hvariable">interactive</span><span class="token operator">&gt;:</span><span class="token number">1</span><span class="token operator">:</span><span class="token number">0</span><span class="token operator">:</span>
    <span class="token constant">No</span> <span class="token keyword">instance</span> <span class="token hvariable">for</span> <span class="token punctuation">(</span><span class="token constant">Show</span> <span class="token punctuation">(</span><span class="token hvariable">t</span> <span class="token operator">-&gt;</span> <span class="token hvariable">t</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
      <span class="token hvariable">arising</span> <span class="token hvariable">from</span> <span class="token hvariable">a</span> <span class="token hvariable">use</span> <span class="token keyword">of</span> `<span class="token builtin">print</span>' <span class="token hvariable">at</span> <span class="token operator">&lt;</span><span class="token hvariable">interactive</span><span class="token operator">&gt;:</span><span class="token number">1</span><span class="token operator">:</span><span class="token number">0</span><span class="token operator">-</span><span class="token number">12</span>
    <span class="token constant">Possible</span> <span class="token hvariable">fix</span><span class="token operator">:</span> <span class="token hvariable">add</span> <span class="token hvariable">an</span> <span class="token keyword">instance</span> <span class="token hvariable">declaration</span> <span class="token hvariable">for</span> <span class="token punctuation">(</span><span class="token constant">Show</span> <span class="token punctuation">(</span><span class="token hvariable">t</span> <span class="token operator">-&gt;</span> <span class="token hvariable">t</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token constant">In</span> <span class="token hvariable">the</span> <span class="token hvariable">expression</span><span class="token operator">:</span> <span class="token builtin">print</span> <span class="token hvariable">it</span>
    <span class="token constant">In</span> <span class="token hvariable">a</span> '<span class="token keyword">do</span>' <span class="token hvariable">expression</span><span class="token operator">:</span> <span class="token builtin">print</span> <span class="token hvariable">it</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>GHCI is telling us that the expression produced a function of type&nbsp;<code>a -&gt; a</code>&nbsp;but it doesn't know how to print it to the screen. Functions aren't instances of the&nbsp;<code>Show</code>&nbsp;typeclass, so we can't get a neat string representation of a function. When we do, say,&nbsp;<code>1 + 1</code>&nbsp;at the GHCI prompt, it first calculates that to&nbsp;<code>2</code>&nbsp;and then calls&nbsp;<code>show</code>&nbsp;on&nbsp;<code>2</code>&nbsp;to get a textual representation of that number. And the textual representation of&nbsp;<code>2</code>&nbsp;is just the string&nbsp;<code>"2"</code>, which then gets printed to our screen.</p></div><div><h2 data-heading="Some higher-orderism is in order" id="Some_higher-orderism_is_in_order" style="display: flex;"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>Some higher-orderism is in order</h2></div><div><p>Functions can take functions as parameters and also return functions. To illustrate this, we're going to make a function that takes a function and then applies it twice to something!</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">applyTwice</span> <span class="token operator">::</span> <span class="token punctuation">(</span><span class="token hvariable">a</span> <span class="token operator">-&gt;</span> <span class="token hvariable">a</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token hvariable">a</span> <span class="token operator">-&gt;</span> <span class="token hvariable">a</span>
<span class="token hvariable">applyTwice</span> <span class="token hvariable">f</span> <span class="token hvariable">x</span> <span class="token operator">=</span> <span class="token hvariable">f</span> <span class="token punctuation">(</span><span class="token hvariable">f</span> <span class="token hvariable">x</span><span class="token punctuation">)</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p><img alt="rocktopus" src="http://s3.amazonaws.com/lyah/bonus.png" referrerpolicy="no-referrer"></p></div><div><p>First of all, notice the type declaration. Before, we didn't need parentheses because&nbsp;<code>-&gt;</code>&nbsp;is naturally right-associative. However, here, they're mandatory. They indicate that the first parameter is a function that takes something and returns that same thing. The second parameter is something of that type also and the return value is also of the same type. We could read this type declaration in the curried way, but to save ourselves a headache, we'll just say that this function takes two parameters and returns one thing. The first parameter is a function (of type&nbsp;<code>a -&gt; a</code>) and the second is that same&nbsp;<code>a</code>. The function can also be&nbsp;<code>Int -&gt; Int</code>&nbsp;or&nbsp;<code>String -&gt; String</code>&nbsp;or whatever. But then, the second parameter to also has to be of that type.</p></div><div><p><em>Note:</em>&nbsp;From now on, we'll say that functions take several parameters despite each function actually taking only one parameter and returning partially applied functions until we reach a function that returns a solid value. So for simplicity's sake, we'll say that&nbsp;a -&gt; a -&gt; a&nbsp;takes two parameters, even though we know what's really going on under the hood.</p></div><div><p>The body of the function is pretty simple. We just use the parameter&nbsp;<code>f</code>&nbsp;as a function, applying&nbsp;<code>x</code>&nbsp;to it by separating them with a space and then applying the result to&nbsp;<code>f</code>&nbsp;again. Anyway, playing around with the function:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token hvariable">applyTwice</span> <span class="token punctuation">(</span><span class="token operator">+</span><span class="token number">3</span><span class="token punctuation">)</span> <span class="token number">10</span>
<span class="token number">16</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token hvariable">applyTwice</span> <span class="token punctuation">(</span><span class="token operator">++</span> <span class="token string">" HAHA"</span><span class="token punctuation">)</span> <span class="token string">"HEY"</span>
<span class="token string">"HEY HAHA HAHA"</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token hvariable">applyTwice</span> <span class="token punctuation">(</span><span class="token string">"HAHA "</span> <span class="token operator">++</span><span class="token punctuation">)</span> <span class="token string">"HEY"</span>
<span class="token string">"HAHA HAHA HEY"</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token hvariable">applyTwice</span> <span class="token punctuation">(</span><span class="token hvariable">multThree</span> <span class="token number">2</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token number">9</span>
<span class="token number">144</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token hvariable">applyTwice</span> <span class="token punctuation">(</span><span class="token number">3</span><span class="token operator">:</span><span class="token punctuation">)</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span>
<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">]</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>The awesomeness and usefulness of partial application is evident. If our function requires us to pass it a function that takes only one parameter, we can just partially apply a function to the point where it takes only one parameter and then pass it.</p></div><div><p>Now we're going to use higher order programming to implement a really useful function that's in the standard library. It's called&nbsp;<code>zipWith</code>. It takes a function and two lists as parameters and then joins the two lists by applying the function between corresponding elements. Here's how we'll implement it:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token builtin">zipWith</span>' <span class="token operator">::</span> <span class="token punctuation">(</span><span class="token hvariable">a</span> <span class="token operator">-&gt;</span> <span class="token hvariable">b</span> <span class="token operator">-&gt;</span> <span class="token hvariable">c</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token punctuation">[</span><span class="token hvariable">a</span><span class="token punctuation">]</span> <span class="token operator">-&gt;</span> <span class="token punctuation">[</span><span class="token hvariable">b</span><span class="token punctuation">]</span> <span class="token operator">-&gt;</span> <span class="token punctuation">[</span><span class="token hvariable">c</span><span class="token punctuation">]</span>
<span class="token builtin">zipWith</span>' <span class="token hvariable">_</span> <span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token hvariable">_</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
<span class="token builtin">zipWith</span>' <span class="token hvariable">_</span> <span class="token hvariable">_</span> <span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
<span class="token builtin">zipWith</span>' <span class="token hvariable">f</span> <span class="token punctuation">(</span><span class="token hvariable">x</span><span class="token operator">:</span><span class="token hvariable">xs</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token hvariable">y</span><span class="token operator">:</span><span class="token hvariable">ys</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token hvariable">f</span> <span class="token hvariable">x</span> <span class="token hvariable">y</span> <span class="token operator">:</span> <span class="token builtin">zipWith</span>' <span class="token hvariable">f</span> <span class="token hvariable">xs</span> <span class="token hvariable">ys</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Look at the type declaration. The first parameter is a function that takes two things and produces a third thing. They don't have to be of the same type, but they can. The second and third parameter are lists. The result is also a list. The first has to be a list of&nbsp;<code>a</code>'s, because the joining function takes&nbsp;<code>a</code>'s as its first argument. The second has to be a list of&nbsp;<code>b</code>'s, because the second parameter of the joining function is of type&nbsp;<code>b</code>. The result is a list of&nbsp;<code>c</code>'s. If the type declaration of a function says it accepts an&nbsp;<code>a -&gt; b -&gt; c</code>&nbsp;function as a parameter, it will also accept an&nbsp;<code>a -&gt; a -&gt; a</code>&nbsp;function, but not the other way around! Remember that when you're making functions, especially higher order ones, and you're unsure of the type, you can just try omitting the type declaration and then checking what Haskell infers it to be by using&nbsp;<code>:t</code>.</p></div><div><p>The action in the function is pretty similar to the normal&nbsp;<code>zip</code>. The edge conditions are the same, only there's an extra argument, the joining function, but that argument doesn't matter in the edge conditions, so we just use a&nbsp;<code>_</code>&nbsp;for it. And function body at the last pattern is also similar to&nbsp;<code>zip</code>, only it doesn't do&nbsp;<code>(x,y)</code>, but&nbsp;<code>f x y</code>. A single higher order function can be used for a multitude of different tasks if it's general enough. Here's a little demonstration of all the different things our&nbsp;<code>zipWith'</code>&nbsp;function can do:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token builtin">zipWith</span>' <span class="token punctuation">(</span><span class="token operator">+</span><span class="token punctuation">)</span> <span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">]</span> <span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">]</span>
<span class="token punctuation">[</span><span class="token number">6</span><span class="token punctuation">,</span><span class="token number">8</span><span class="token punctuation">,</span><span class="token number">7</span><span class="token punctuation">,</span><span class="token number">9</span><span class="token punctuation">]</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token builtin">zipWith</span>' <span class="token builtin">max</span> <span class="token punctuation">[</span><span class="token number">6</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token punctuation">[</span><span class="token number">7</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">]</span>
<span class="token punctuation">[</span><span class="token number">7</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">]</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token builtin">zipWith</span>' <span class="token punctuation">(</span><span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">[</span><span class="token string">"foo "</span><span class="token punctuation">,</span> <span class="token string">"bar "</span><span class="token punctuation">,</span> <span class="token string">"baz "</span><span class="token punctuation">]</span> <span class="token punctuation">[</span><span class="token string">"fighters"</span><span class="token punctuation">,</span> <span class="token string">"hoppers"</span><span class="token punctuation">,</span> <span class="token string">"aldrin"</span><span class="token punctuation">]</span>
<span class="token punctuation">[</span><span class="token string">"foo fighters"</span><span class="token punctuation">,</span><span class="token string">"bar hoppers"</span><span class="token punctuation">,</span><span class="token string">"baz aldrin"</span><span class="token punctuation">]</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token builtin">zipWith</span>' <span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token builtin">replicate</span> <span class="token number">5</span> <span class="token number">2</span><span class="token punctuation">)</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token operator">..</span><span class="token punctuation">]</span>
<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">,</span><span class="token number">8</span><span class="token punctuation">,</span><span class="token number">10</span><span class="token punctuation">]</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token builtin">zipWith</span>' <span class="token punctuation">(</span><span class="token builtin">zipWith</span>' <span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">]</span> <span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">]</span>
<span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token number">9</span><span class="token punctuation">,</span><span class="token number">20</span><span class="token punctuation">,</span><span class="token number">30</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">,</span><span class="token number">12</span><span class="token punctuation">,</span><span class="token number">12</span><span class="token punctuation">]</span><span class="token punctuation">]</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>As you can see, a single higher order function can be used in very versatile ways. Imperative programming usually uses stuff like for loops, while loops, setting something to a variable, checking its state, etc. to achieve some behavior and then wrap it around an interface, like a function. Functional programming uses higher order functions to abstract away common patterns, like examining two lists in pairs and doing something with those pairs or getting a set of solutions and eliminating the ones you don't need.</p></div><div><p>We'll implement another function that's already in the standard library, called&nbsp;<code>flip</code>. Flip simply takes a function and returns a function that is like our original function, only the first two arguments are flipped. We can implement it like so:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token builtin">flip</span>' <span class="token operator">::</span> <span class="token punctuation">(</span><span class="token hvariable">a</span> <span class="token operator">-&gt;</span> <span class="token hvariable">b</span> <span class="token operator">-&gt;</span> <span class="token hvariable">c</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token punctuation">(</span><span class="token hvariable">b</span> <span class="token operator">-&gt;</span> <span class="token hvariable">a</span> <span class="token operator">-&gt;</span> <span class="token hvariable">c</span><span class="token punctuation">)</span>
<span class="token builtin">flip</span>' <span class="token hvariable">f</span> <span class="token operator">=</span> <span class="token hvariable">g</span>
    <span class="token keyword">where</span> <span class="token hvariable">g</span> <span class="token hvariable">x</span> <span class="token hvariable">y</span> <span class="token operator">=</span> <span class="token hvariable">f</span> <span class="token hvariable">y</span> <span class="token hvariable">x</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Reading the type declaration, we say that it takes a function that takes an&nbsp;<code>a</code>&nbsp;and a&nbsp;<code>b</code>&nbsp;and returns a function that takes a&nbsp;<code>b</code>&nbsp;and an&nbsp;<code>a</code>. But because functions are curried by default, the second pair of parentheses is really unnecessary, because&nbsp;<code>-&gt;</code>&nbsp;is right associative by default.&nbsp;<code>(a -&gt; b -&gt; c) -&gt; (b -&gt; a -&gt; c)</code>&nbsp;is the same as&nbsp;<code>(a -&gt; b -&gt; c) -&gt; (b -&gt; (a -&gt; c))</code>, which is the same as&nbsp;<code>(a -&gt; b -&gt; c) -&gt; b -&gt; a -&gt; c</code>. We wrote that&nbsp;<code>g x y = f y x</code>. If that's true, then&nbsp;<code>f y x = g x y</code>&nbsp;must also hold, right? Keeping that in mind, we can define this function in an even simpler manner.</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token builtin">flip</span>' <span class="token operator">::</span> <span class="token punctuation">(</span><span class="token hvariable">a</span> <span class="token operator">-&gt;</span> <span class="token hvariable">b</span> <span class="token operator">-&gt;</span> <span class="token hvariable">c</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token hvariable">b</span> <span class="token operator">-&gt;</span> <span class="token hvariable">a</span> <span class="token operator">-&gt;</span> <span class="token hvariable">c</span>
<span class="token builtin">flip</span>' <span class="token hvariable">f</span> <span class="token hvariable">y</span> <span class="token hvariable">x</span> <span class="token operator">=</span> <span class="token hvariable">f</span> <span class="token hvariable">x</span> <span class="token hvariable">y</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Here, we take advantage of the fact that functions are curried. When we call&nbsp;<code>flip' f</code>&nbsp;without the parameters&nbsp;<code>y</code>&nbsp;and&nbsp;<code>x</code>, it will return an&nbsp;<code>f</code>&nbsp;that takes those two parameters but calls them flipped. Even though flipped functions are usually passed to other functions, we can take advantage of currying when making higher-order functions by thinking ahead and writing what their end result would be if they were called fully applied.</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token builtin">flip</span>' <span class="token builtin">zip</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">]</span> <span class="token string">"hello"</span>
<span class="token punctuation">[</span><span class="token punctuation">(</span><span class="token char string">'h'</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token char string">'e'</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token char string">'l'</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token char string">'l'</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token char string">'o'</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">]</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token builtin">zipWith</span> <span class="token punctuation">(</span><span class="token builtin">flip</span>' <span class="token builtin">div</span><span class="token punctuation">)</span> <span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token operator">..</span><span class="token punctuation">]</span> <span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">,</span><span class="token number">8</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">]</span>
<span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">]</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><h2 data-heading="Maps and filters" id="Maps_and_filters" style="display: flex;"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>Maps and filters</h2></div><div><p><code>map</code>&nbsp;takes a function and a list and applies that function to every element in the list, producing a new list. Let's see what its type signature is and how it's defined.</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token builtin">map</span> <span class="token operator">::</span> <span class="token punctuation">(</span><span class="token hvariable">a</span> <span class="token operator">-&gt;</span> <span class="token hvariable">b</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token punctuation">[</span><span class="token hvariable">a</span><span class="token punctuation">]</span> <span class="token operator">-&gt;</span> <span class="token punctuation">[</span><span class="token hvariable">b</span><span class="token punctuation">]</span>
<span class="token builtin">map</span> <span class="token hvariable">_</span> <span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
<span class="token builtin">map</span> <span class="token hvariable">f</span> <span class="token punctuation">(</span><span class="token hvariable">x</span><span class="token operator">:</span><span class="token hvariable">xs</span><span class="token punctuation">)</span> <span class="token operator">=</span> <span class="token hvariable">f</span> <span class="token hvariable">x</span> <span class="token operator">:</span> <span class="token builtin">map</span> <span class="token hvariable">f</span> <span class="token hvariable">xs</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>The type signature says that it takes a function that takes an&nbsp;<code>a</code>&nbsp;and returns a&nbsp;<code>b</code>, a list of&nbsp;<code>a</code>'s and returns a list of&nbsp;<code>b</code>'s. It's interesting that just by looking at a function's type signature, you can sometimes tell what it does.&nbsp;<code>map</code>&nbsp;is one of those really versatile higher-order functions that can be used in millions of different ways. Here it is in action:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token builtin">map</span> <span class="token punctuation">(</span><span class="token operator">+</span><span class="token number">3</span><span class="token punctuation">)</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">]</span>
<span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">8</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">9</span><span class="token punctuation">]</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token builtin">map</span> <span class="token punctuation">(</span><span class="token operator">++</span> <span class="token string">"!"</span><span class="token punctuation">)</span> <span class="token punctuation">[</span><span class="token string">"BIFF"</span><span class="token punctuation">,</span> <span class="token string">"BANG"</span><span class="token punctuation">,</span> <span class="token string">"POW"</span><span class="token punctuation">]</span>
<span class="token punctuation">[</span><span class="token string">"BIFF!"</span><span class="token punctuation">,</span><span class="token string">"BANG!"</span><span class="token punctuation">,</span><span class="token string">"POW!"</span><span class="token punctuation">]</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token builtin">map</span> <span class="token punctuation">(</span><span class="token builtin">replicate</span> <span class="token number">3</span><span class="token punctuation">)</span> <span class="token punctuation">[</span><span class="token number">3</span><span class="token operator">..</span><span class="token number">6</span><span class="token punctuation">]</span>
<span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token number">6</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">]</span><span class="token punctuation">]</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token builtin">map</span> <span class="token punctuation">(</span><span class="token builtin">map</span> <span class="token punctuation">(</span><span class="token operator">^</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token number">7</span><span class="token punctuation">,</span><span class="token number">8</span><span class="token punctuation">]</span><span class="token punctuation">]</span>
<span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token number">9</span><span class="token punctuation">,</span><span class="token number">16</span><span class="token punctuation">,</span><span class="token number">25</span><span class="token punctuation">,</span><span class="token number">36</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token number">49</span><span class="token punctuation">,</span><span class="token number">64</span><span class="token punctuation">]</span><span class="token punctuation">]</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token builtin">map</span> <span class="token builtin">fst</span> <span class="token punctuation">[</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token number">6</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">]</span>
<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">]</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>You've probably noticed that each of these could be achieved with a list comprehension.&nbsp;<code>map (+3) [1,5,3,1,6]</code>&nbsp;is the same as writing&nbsp;<code>[x+3 | x &lt;- [1,5,3,1,6]]</code>. However, using&nbsp;<code>map</code>&nbsp;is much more readable for cases where you only apply some function to the elements of a list, especially once you're dealing with maps of maps and then the whole thing with a lot of brackets can get a bit messy.</p></div><div><p><code>filter</code>&nbsp;is a function that takes a predicate (a predicate is a function that tells whether something is true or not, so in our case, a function that returns a boolean value) and a list and then returns the list of elements that satisfy the predicate. The type signature and implementation go like this:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token builtin">filter</span> <span class="token operator">::</span> <span class="token punctuation">(</span><span class="token hvariable">a</span> <span class="token operator">-&gt;</span> <span class="token constant">Bool</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token punctuation">[</span><span class="token hvariable">a</span><span class="token punctuation">]</span> <span class="token operator">-&gt;</span> <span class="token punctuation">[</span><span class="token hvariable">a</span><span class="token punctuation">]</span>
<span class="token builtin">filter</span> <span class="token hvariable">_</span> <span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>
<span class="token builtin">filter</span> <span class="token hvariable">p</span> <span class="token punctuation">(</span><span class="token hvariable">x</span><span class="token operator">:</span><span class="token hvariable">xs</span><span class="token punctuation">)</span> 
    <span class="token operator">|</span> <span class="token hvariable">p</span> <span class="token hvariable">x</span>       <span class="token operator">=</span> <span class="token hvariable">x</span> <span class="token operator">:</span> <span class="token builtin">filter</span> <span class="token hvariable">p</span> <span class="token hvariable">xs</span>
    <span class="token operator">|</span> <span class="token builtin">otherwise</span> <span class="token operator">=</span> <span class="token builtin">filter</span> <span class="token hvariable">p</span> <span class="token hvariable">xs</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Pretty simple stuff. If&nbsp;<code>p x</code>&nbsp;evaluates to&nbsp;<code>True</code>, the element gets included in the new list. If it doesn't, it stays out. Some usage examples:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token builtin">filter</span> <span class="token punctuation">(</span><span class="token operator">&gt;</span><span class="token number">3</span><span class="token punctuation">)</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">]</span>
<span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">]</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token builtin">filter</span> <span class="token punctuation">(</span><span class="token operator">==</span><span class="token number">3</span><span class="token punctuation">)</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">]</span>
<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token builtin">filter</span> <span class="token builtin">even</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token operator">..</span><span class="token number">10</span><span class="token punctuation">]</span>
<span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">,</span><span class="token number">8</span><span class="token punctuation">,</span><span class="token number">10</span><span class="token punctuation">]</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token keyword">let</span> <span class="token hvariable">notNull</span> <span class="token hvariable">x</span> <span class="token operator">=</span> <span class="token builtin">not</span> <span class="token punctuation">(</span><span class="token builtin">null</span> <span class="token hvariable">x</span><span class="token punctuation">)</span> <span class="token keyword">in</span> <span class="token builtin">filter</span> <span class="token hvariable">notNull</span> <span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">]</span>
<span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">]</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token builtin">filter</span> <span class="token punctuation">(</span><span class="token operator">`elem`</span> <span class="token punctuation">[</span><span class="token char string">'a'</span><span class="token operator">..</span><span class="token char string">'z'</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token string">"u LaUgH aT mE BeCaUsE I aM diFfeRent"</span>
<span class="token string">"uagameasadifeent"</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token builtin">filter</span> <span class="token punctuation">(</span><span class="token operator">`elem`</span> <span class="token punctuation">[</span><span class="token char string">'A'</span><span class="token operator">..</span><span class="token char string">'Z'</span><span class="token punctuation">]</span><span class="token punctuation">)</span> <span class="token string">"i lauGh At You BecAuse u r aLL the Same"</span>
<span class="token string">"GAYBALLS"</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>All of this could also be achived with list comprehensions by the use of predicates. There's no set rule for when to use&nbsp;<code>map</code>&nbsp;and&nbsp;<code>filter</code>&nbsp;versus using list comprehension, you just have to decide what's more readable depending on the code and the context. The&nbsp;<code>filter</code>&nbsp;equivalent of applying several predicates in a list comprehension is either filtering something several times or joining the predicates with the logical&nbsp;<code>&amp;&amp;</code>&nbsp;function.</p></div><div><p>Remember our quicksort function from the&nbsp;<a data-tooltip-position="top" aria-label="http://learnyouahaskell.com/recursion" rel="noopener" class="external-link" href="http://learnyouahaskell.com/recursion" target="_blank">previous chapter</a>? We used list comprehensions to filter out the list elements that are smaller than (or equal to) and larger than the pivot. We can achieve the same functionality in a more readable way by using&nbsp;<code>filter</code>:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">quicksort</span> <span class="token operator">::</span> <span class="token punctuation">(</span><span class="token constant">Ord</span> <span class="token hvariable">a</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">[</span><span class="token hvariable">a</span><span class="token punctuation">]</span> <span class="token operator">-&gt;</span> <span class="token punctuation">[</span><span class="token hvariable">a</span><span class="token punctuation">]</span>  
<span class="token hvariable">quicksort</span> <span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>  
<span class="token hvariable">quicksort</span> <span class="token punctuation">(</span><span class="token hvariable">x</span><span class="token operator">:</span><span class="token hvariable">xs</span><span class="token punctuation">)</span> <span class="token operator">=</span>   
    <span class="token keyword">let</span> <span class="token hvariable">smallerSorted</span> <span class="token operator">=</span> <span class="token hvariable">quicksort</span> <span class="token punctuation">(</span><span class="token builtin">filter</span> <span class="token punctuation">(</span><span class="token operator">&lt;=</span><span class="token hvariable">x</span><span class="token punctuation">)</span> <span class="token hvariable">xs</span><span class="token punctuation">)</span>
        <span class="token hvariable">biggerSorted</span> <span class="token operator">=</span> <span class="token hvariable">quicksort</span> <span class="token punctuation">(</span><span class="token builtin">filter</span> <span class="token punctuation">(</span><span class="token operator">&gt;</span><span class="token hvariable">x</span><span class="token punctuation">)</span> <span class="token hvariable">xs</span><span class="token punctuation">)</span> 
    <span class="token keyword">in</span>  <span class="token hvariable">smallerSorted</span> <span class="token operator">++</span> <span class="token punctuation">[</span><span class="token hvariable">x</span><span class="token punctuation">]</span> <span class="token operator">++</span> <span class="token hvariable">biggerSorted</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p><img alt="map" src="http://s3.amazonaws.com/lyah/map.png" referrerpolicy="no-referrer"></p></div><div><p>Mapping and filtering is the bread and butter of every functional programmer's toolbox. Uh. It doesn't matter if you do it with the&nbsp;<code>map</code>&nbsp;and&nbsp;<code>filter</code>&nbsp;functions or list comprehensions. Recall how we solved the problem of finding right triangles with a certain circumference. With imperative programming, we would have solved it by nesting three loops and then testing if the current combination satisfies a right triangle and if it has the right perimeter. If that's the case, we would have printed it out to the screen or something. In functional programming, that pattern is achieved with mapping and filtering. You make a function that takes a value and produces some result. We map that function over a list of values and then we filter the resulting list out for the results that satisfy our search. Thanks to Haskell's laziness, even if you map something over a list several times and filter it several times, it will only pass over the list once.</p></div><div><p>Let's&nbsp;<strong>find the largest number under 100,000 that's divisible by 3829</strong>. To do that, we'll just filter a set of possibilities in which we know the solution lies.</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">largestDivisible</span> <span class="token operator">::</span> <span class="token punctuation">(</span><span class="token constant">Integral</span> <span class="token hvariable">a</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token hvariable">a</span>
<span class="token hvariable">largestDivisible</span> <span class="token operator">=</span> <span class="token builtin">head</span> <span class="token punctuation">(</span><span class="token builtin">filter</span> <span class="token hvariable">p</span> <span class="token punctuation">[</span><span class="token number">100000</span><span class="token punctuation">,</span><span class="token number">99999</span><span class="token operator">..</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
    <span class="token keyword">where</span> <span class="token hvariable">p</span> <span class="token hvariable">x</span> <span class="token operator">=</span> <span class="token hvariable">x</span> <span class="token operator">`mod`</span> <span class="token number">3829</span> <span class="token operator">==</span> <span class="token number">0</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>We first make a list of all numbers lower than 100,000, descending. Then we filter it by our predicate and because the numbers are sorted in a descending manner, the largest number that satisfies our predicate is the first element of the filtered list. We didn't even need to use a finite list for our starting set. That's laziness in action again. Because we only end up using the head of the filtered list, it doesn't matter if the filtered list is finite or infinite. The evaluation stops when the first adequate solution is found.</p></div><div><p>Next up, we're going to&nbsp;<strong>find the sum of all odd squares that are smaller than 10,000</strong>. But first, because we'll be using it in our solution, we're going to introduce the&nbsp;<code>takeWhile</code>&nbsp;function. It takes a predicate and a list and then goes from the beginning of the list and returns its elements while the predicate holds true. Once an element is found for which the predicate doesn't hold, it stops. If we wanted to get the first word of the string&nbsp;<code>"elephants know how to party"</code>, we could do&nbsp;<code>takeWhile (/=' ') "elephants know how to party"</code>&nbsp;and it would return&nbsp;<code>"elephants"</code>. Okay. The sum of all odd squares that are smaller than 10,000. First, we'll begin by mapping the&nbsp;<code>(^2)</code>&nbsp;function to the infinite list&nbsp;<code>[1..]</code>. Then we filter them so we only get the odd ones. And then, we'll take elements from that list while they are smaller than 10,000. Finally, we'll get the sum of that list. We don't even have to define a function for that, we can do it in one line in GHCI:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token builtin">sum</span> <span class="token punctuation">(</span><span class="token builtin">takeWhile</span> <span class="token punctuation">(</span><span class="token operator">&lt;</span><span class="token number">10000</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token builtin">filter</span> <span class="token builtin">odd</span> <span class="token punctuation">(</span><span class="token builtin">map</span> <span class="token punctuation">(</span><span class="token operator">^</span><span class="token number">2</span><span class="token punctuation">)</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token operator">..</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token number">166650</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Awesome! We start with some initial data (the infinite list of all natural numbers) and then we map over it, filter it and cut it until it suits our needs and then we just sum it up. We could have also written this using list comprehensions:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token builtin">sum</span> <span class="token punctuation">(</span><span class="token builtin">takeWhile</span> <span class="token punctuation">(</span><span class="token operator">&lt;</span><span class="token number">10000</span><span class="token punctuation">)</span> <span class="token punctuation">[</span><span class="token hvariable">n</span><span class="token operator">^</span><span class="token number">2</span> <span class="token operator">|</span> <span class="token hvariable">n</span> <span class="token operator">&lt;-</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token operator">..</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token builtin">odd</span> <span class="token punctuation">(</span><span class="token hvariable">n</span><span class="token operator">^</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
<span class="token number">166650</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>It's a matter of taste as to which one you find prettier. Again, Haskell's property of laziness is what makes this possible. We can map over and filter an infinite list, because it won't actually map and filter it right away, it'll delay those actions. Only when we force Haskell to show us the sum does the&nbsp;<code>sum</code>&nbsp;function say to the&nbsp;<code>takeWhile</code>&nbsp;that it needs those numbers.&nbsp;<code>takeWhile</code>&nbsp;forces the filtering and mapping to occur, but only until a number greater than or equal to 10,000 is encountered.</p></div><div><p>For our next problem, we'll be dealing with Collatz sequences. We take a natural number. If that number is even, we divide it by two. If it's odd, we multiply it by 3 and then add 1 to that. We take the resulting number and apply the same thing to it, which produces a new number and so on. In essence, we get a chain of numbers. It is thought that for all starting numbers, the chains finish at the number 1. So if we take the starting number 13, we get this sequence:&nbsp;<em>13, 40, 20, 10, 5, 16, 8, 4, 2, 1</em>. 13*3 + 1 equals 40. 40 divided by 2 is 20, etc. We see that the chain has 10 terms.</p></div><div><p>Now what we want to know is this:&nbsp;<strong>for all starting numbers between 1 and 100, how many chains have a length greater than 15?</strong>&nbsp;First off, we'll write a function that produces a chain:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">chain</span> <span class="token operator">::</span> <span class="token punctuation">(</span><span class="token constant">Integral</span> <span class="token hvariable">a</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token hvariable">a</span> <span class="token operator">-&gt;</span> <span class="token punctuation">[</span><span class="token hvariable">a</span><span class="token punctuation">]</span>
<span class="token hvariable">chain</span> <span class="token number">1</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span>
<span class="token hvariable">chain</span> <span class="token hvariable">n</span>
    <span class="token operator">|</span> <span class="token builtin">even</span> <span class="token hvariable">n</span> <span class="token operator">=</span>  <span class="token hvariable">n</span><span class="token operator">:</span><span class="token hvariable">chain</span> <span class="token punctuation">(</span><span class="token hvariable">n</span> <span class="token operator">`div`</span> <span class="token number">2</span><span class="token punctuation">)</span>
    <span class="token operator">|</span> <span class="token builtin">odd</span> <span class="token hvariable">n</span>  <span class="token operator">=</span>  <span class="token hvariable">n</span><span class="token operator">:</span><span class="token hvariable">chain</span> <span class="token punctuation">(</span><span class="token hvariable">n</span><span class="token operator">*</span><span class="token number">3</span> <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Because the chains end at 1, that's the edge case. This is a pretty standard recursive function.</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token hvariable">chain</span> <span class="token number">10</span>
<span class="token punctuation">[</span><span class="token number">10</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">16</span><span class="token punctuation">,</span><span class="token number">8</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">]</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token hvariable">chain</span> <span class="token number">1</span>
<span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token hvariable">chain</span> <span class="token number">30</span>
<span class="token punctuation">[</span><span class="token number">30</span><span class="token punctuation">,</span><span class="token number">15</span><span class="token punctuation">,</span><span class="token number">46</span><span class="token punctuation">,</span><span class="token number">23</span><span class="token punctuation">,</span><span class="token number">70</span><span class="token punctuation">,</span><span class="token number">35</span><span class="token punctuation">,</span><span class="token number">106</span><span class="token punctuation">,</span><span class="token number">53</span><span class="token punctuation">,</span><span class="token number">160</span><span class="token punctuation">,</span><span class="token number">80</span><span class="token punctuation">,</span><span class="token number">40</span><span class="token punctuation">,</span><span class="token number">20</span><span class="token punctuation">,</span><span class="token number">10</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">16</span><span class="token punctuation">,</span><span class="token number">8</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">]</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Yay! It seems to be working correctly. And now, the function that tells us the answer to our question:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">numLongChains</span> <span class="token operator">::</span> <span class="token constant">Int</span>
<span class="token hvariable">numLongChains</span> <span class="token operator">=</span> <span class="token builtin">length</span> <span class="token punctuation">(</span><span class="token builtin">filter</span> <span class="token hvariable">isLong</span> <span class="token punctuation">(</span><span class="token builtin">map</span> <span class="token hvariable">chain</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token operator">..</span><span class="token number">100</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
    <span class="token keyword">where</span> <span class="token hvariable">isLong</span> <span class="token hvariable">xs</span> <span class="token operator">=</span> <span class="token builtin">length</span> <span class="token hvariable">xs</span> <span class="token operator">&gt;</span> <span class="token number">15</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>We map the&nbsp;<code>chain</code>&nbsp;function to&nbsp;<code>[1..100]</code>&nbsp;to get a list of chains, which are themselves represented as lists. Then, we filter them by a predicate that just checks whether a list's length is longer than 15. Once we've done the filtering, we see how many chains are left in the resulting list.</p></div><div><p><em>Note:</em>&nbsp;This function has a type of&nbsp;numLongChains :: Int&nbsp;because&nbsp;length&nbsp;returns an&nbsp;Int&nbsp;instead of a&nbsp;Num a&nbsp;for historical reasons. If we wanted to return a more general&nbsp;Num a, we could have used&nbsp;fromIntegral&nbsp;on the resulting length.</p></div><div><p>Using&nbsp;<code>map</code>, we can also do stuff like&nbsp;<code>map (*) [0..]</code>, if not for any other reason than to illustrate how currying works and how (partially applied) functions are real values that you can pass around to other functions or put into lists (you just can't turn them to strings). So far, we've only mapped functions that take one parameter over lists, like&nbsp;<code>map (*2) [0..]</code>&nbsp;to get a list of type&nbsp;<code>(Num a) =&gt; [a]</code>, but we can also do&nbsp;<code>map (*) [0..]</code>&nbsp;without a problem. What happens here is that the number in the list is applied to the function&nbsp;<code>*</code>, which has a type of&nbsp;<code>(Num a) =&gt; a -&gt; a -&gt; a</code>. Applying only one parameter to a function that takes two parameters returns a function that takes one parameter. If we map&nbsp;<code>*</code>&nbsp;over the list&nbsp;<code>[0..]</code>, we get back a list of functions that only take one parameter, so&nbsp;<code>(Num a) =&gt; [a -&gt; a]</code>.&nbsp;<code>map (*) [0..]</code>&nbsp;produces a list like the one we'd get by writing&nbsp;<code>[(0*),(1*),(2*),(3*),(4*),(5*)..</code>.</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token keyword">let</span> <span class="token hvariable">listOfFuns</span> <span class="token operator">=</span> <span class="token builtin">map</span> <span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">)</span> <span class="token punctuation">[</span><span class="token number">0</span><span class="token operator">..</span><span class="token punctuation">]</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token punctuation">(</span><span class="token hvariable">listOfFuns</span> <span class="token operator">!!</span> <span class="token number">4</span><span class="token punctuation">)</span> <span class="token number">5</span>
<span class="token number">20</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Getting the element with the index&nbsp;<code>4</code>&nbsp;from our list returns a function that's equivalent to&nbsp;<code>(4*)</code>. And then, we just apply&nbsp;<code>5</code>&nbsp;to that function. So that's like writing&nbsp;<code>(4*) 5</code>&nbsp;or just&nbsp;<code>4 * 5</code>.</p></div><div><h2 data-heading="Lambdas" id="Lambdas" style="display: flex;"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>Lambdas</h2></div><div><p><img alt="lambda" src="http://s3.amazonaws.com/lyah/lambda.png" referrerpolicy="no-referrer"></p></div><div><p>Lambdas are basically anonymous functions that are used because we need some functions only once. Normally, we make a lambda with the sole purpose of passing it to a higher-order function. To make a lambda, we write a&nbsp;<code>\</code>&nbsp;(because it kind of looks like the greek letter lambda if you squint hard enough) and then we write the parameters, separated by spaces. After that comes a&nbsp;<code>-&gt;</code>&nbsp;and then the function body. We usually surround them by parentheses, because otherwise they extend all the way to the right.</p></div><div><p>If you look about 5 inches up, you'll see that we used a&nbsp;<em>where</em>&nbsp;binding in our&nbsp;<code>numLongChains</code>&nbsp;function to make the&nbsp;<code>isLong</code>&nbsp;function for the sole purpose of passing it to&nbsp;<code>filter</code>. Well, instead of doing that, we can use a lambda:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">numLongChains</span> <span class="token operator">::</span> <span class="token constant">Int</span>
<span class="token hvariable">numLongChains</span> <span class="token operator">=</span> <span class="token builtin">length</span> <span class="token punctuation">(</span><span class="token builtin">filter</span> <span class="token punctuation">(</span><span class="token operator">\</span><span class="token hvariable">xs</span> <span class="token operator">-&gt;</span> <span class="token builtin">length</span> <span class="token hvariable">xs</span> <span class="token operator">&gt;</span> <span class="token number">15</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token builtin">map</span> <span class="token hvariable">chain</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token operator">..</span><span class="token number">100</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Lambdas are expressions, that's why we can just pass them like that. The expression&nbsp;<code>(\xs -&gt; length xs &gt; 15)</code>&nbsp;returns a function that tells us whether the length of the list passed to it is greater than 15.</p></div><div><p><img alt="lamb" src="http://s3.amazonaws.com/lyah/lamb.png" referrerpolicy="no-referrer"></p></div><div><p>People who are not well acquainted with how currying and partial application works often use lambdas where they don't need to. For instance, the expressions&nbsp;<code>map (+3) [1,6,3,2]</code>&nbsp;and&nbsp;<code>map (\x -&gt; x + 3) [1,6,3,2]</code>&nbsp;are equivalent since both&nbsp;<code>(+3)</code>&nbsp;and&nbsp;<code>(\x -&gt; x + 3)</code>&nbsp;are functions that take a number and add 3 to it. Needless to say, making a lambda in this case is stupid since using partial application is much more readable.</p></div><div><p>Like normal functions, lambdas can take any number of parameters:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token builtin">zipWith</span> <span class="token punctuation">(</span><span class="token operator">\</span><span class="token hvariable">a</span> <span class="token hvariable">b</span> <span class="token operator">-&gt;</span> <span class="token punctuation">(</span><span class="token hvariable">a</span> <span class="token operator">*</span> <span class="token number">30</span> <span class="token operator">+</span> <span class="token number">3</span><span class="token punctuation">)</span> <span class="token operator">/</span> <span class="token hvariable">b</span><span class="token punctuation">)</span> <span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">]</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">]</span>
<span class="token punctuation">[</span><span class="token number">153.0</span><span class="token punctuation">,</span><span class="token number">61.5</span><span class="token punctuation">,</span><span class="token number">31.0</span><span class="token punctuation">,</span><span class="token number">15.75</span><span class="token punctuation">,</span><span class="token number">6.6</span><span class="token punctuation">]</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>And like normal functions, you can pattern match in lambdas. The only difference is that you can't define several patterns for one parameter, like making a&nbsp;<code>[]</code>&nbsp;and a&nbsp;<code>(x:xs)</code>&nbsp;pattern for the same parameter and then having values fall through. If a pattern matching fails in a lambda, a runtime error occurs, so be careful when pattern matching in lambdas!</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token builtin">map</span> <span class="token punctuation">(</span><span class="token operator">\</span><span class="token punctuation">(</span><span class="token hvariable">a</span><span class="token punctuation">,</span><span class="token hvariable">b</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token hvariable">a</span> <span class="token operator">+</span> <span class="token hvariable">b</span><span class="token punctuation">)</span> <span class="token punctuation">[</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token number">6</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">6</span><span class="token punctuation">)</span><span class="token punctuation">,</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">]</span>
<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">8</span><span class="token punctuation">,</span><span class="token number">9</span><span class="token punctuation">,</span><span class="token number">8</span><span class="token punctuation">,</span><span class="token number">7</span><span class="token punctuation">]</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Lambdas are normally surrounded by parentheses unless we mean for them to extend all the way to the right. Here's something interesting: due to the way functions are curried by default, these two are equivalent:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">addThree</span> <span class="token operator">::</span> <span class="token punctuation">(</span><span class="token constant">Num</span> <span class="token hvariable">a</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token hvariable">a</span> <span class="token operator">-&gt;</span> <span class="token hvariable">a</span> <span class="token operator">-&gt;</span> <span class="token hvariable">a</span> <span class="token operator">-&gt;</span> <span class="token hvariable">a</span>
<span class="token hvariable">addThree</span> <span class="token hvariable">x</span> <span class="token hvariable">y</span> <span class="token hvariable">z</span> <span class="token operator">=</span> <span class="token hvariable">x</span> <span class="token operator">+</span> <span class="token hvariable">y</span> <span class="token operator">+</span> <span class="token hvariable">z</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">addThree</span> <span class="token operator">::</span> <span class="token punctuation">(</span><span class="token constant">Num</span> <span class="token hvariable">a</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token hvariable">a</span> <span class="token operator">-&gt;</span> <span class="token hvariable">a</span> <span class="token operator">-&gt;</span> <span class="token hvariable">a</span> <span class="token operator">-&gt;</span> <span class="token hvariable">a</span>
<span class="token hvariable">addThree</span> <span class="token operator">=</span> <span class="token operator">\</span><span class="token hvariable">x</span> <span class="token operator">-&gt;</span> <span class="token operator">\</span><span class="token hvariable">y</span> <span class="token operator">-&gt;</span> <span class="token operator">\</span><span class="token hvariable">z</span> <span class="token operator">-&gt;</span> <span class="token hvariable">x</span> <span class="token operator">+</span> <span class="token hvariable">y</span> <span class="token operator">+</span> <span class="token hvariable">z</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>If we define a function like this, it's obvious why the type declaration is what it is. There are three&nbsp;<code>-&gt;</code>'s in both the type declaration and the equation. But of course, the first way to write functions is far more readable, the second one is pretty much a gimmick to illustrate currying.</p></div><div><p>However, there are times when using this notation is cool. I think that the&nbsp;<code>flip</code>&nbsp;function is the most readable when defined like so:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token builtin">flip</span>' <span class="token operator">::</span> <span class="token punctuation">(</span><span class="token hvariable">a</span> <span class="token operator">-&gt;</span> <span class="token hvariable">b</span> <span class="token operator">-&gt;</span> <span class="token hvariable">c</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token hvariable">b</span> <span class="token operator">-&gt;</span> <span class="token hvariable">a</span> <span class="token operator">-&gt;</span> <span class="token hvariable">c</span>
<span class="token builtin">flip</span>' <span class="token hvariable">f</span> <span class="token operator">=</span> <span class="token operator">\</span><span class="token hvariable">x</span> <span class="token hvariable">y</span> <span class="token operator">-&gt;</span> <span class="token hvariable">f</span> <span class="token hvariable">y</span> <span class="token hvariable">x</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Even though that's the same as writing&nbsp;<code>flip' f x y = f y x</code>, we make it obvious that this will be used for producing a new function most of the time. The most common use case with&nbsp;<code>flip</code>&nbsp;is calling it with just the function parameter and then passing the resulting function on to a map or a filter. So use lambdas in this way when you want to make it explicit that your function is mainly meant to be partially applied and passed on to a function as a parameter.</p></div><div><h2 data-heading="Only folds and horses" id="Only_folds_and_horses" style="display: flex;"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>Only folds and horses</h2></div><div><p><img alt="folded bird" src="http://s3.amazonaws.com/lyah/origami.png" referrerpolicy="no-referrer"></p></div><div><p>Back when we were dealing with recursion, we noticed a theme throughout many of the recursive functions that operated on lists. Usually, we'd have an edge case for the empty list. We'd introduce the&nbsp;<code>x:xs</code>&nbsp;pattern and then we'd do some action that involves a single element and the rest of the list. It turns out this is a very common pattern, so a couple of very useful functions were introduced to encapsulate it. These functions are called folds. They're sort of like the&nbsp;<code>map</code>&nbsp;function, only they reduce the list to some single value.</p></div><div><p>A fold takes a binary function, a starting value (I like to call it the accumulator) and a list to fold up. The binary function itself takes two parameters. The binary function is called with the accumulator and the first (or last) element and produces a new accumulator. Then, the binary function is called again with the new accumulator and the now new first (or last) element, and so on. Once we've walked over the whole list, only the accumulator remains, which is what we've reduced the list to.</p></div><div><p>First let's take a look at the&nbsp;<code>foldl</code>&nbsp;function, also called the left fold. It folds the list up from the left side. The binary function is applied between the starting value and the head of the list. That produces a new accumulator value and the binary function is called with that value and the next element, etc.</p></div><div><p>Let's implement&nbsp;<code>sum</code>&nbsp;again, only this time, we'll use a fold instead of explicit recursion.</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token builtin">sum</span>' <span class="token operator">::</span> <span class="token punctuation">(</span><span class="token constant">Num</span> <span class="token hvariable">a</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">[</span><span class="token hvariable">a</span><span class="token punctuation">]</span> <span class="token operator">-&gt;</span> <span class="token hvariable">a</span>
<span class="token builtin">sum</span>' <span class="token hvariable">xs</span> <span class="token operator">=</span> <span class="token builtin">foldl</span> <span class="token punctuation">(</span><span class="token operator">\</span><span class="token hvariable">acc</span> <span class="token hvariable">x</span> <span class="token operator">-&gt;</span> <span class="token hvariable">acc</span> <span class="token operator">+</span> <span class="token hvariable">x</span><span class="token punctuation">)</span> <span class="token number">0</span> <span class="token hvariable">xs</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Testing, one two three:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token builtin">sum</span>' <span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">]</span>
<span class="token number">11</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p><img alt="foldl" src="http://s3.amazonaws.com/lyah/foldl.png" referrerpolicy="no-referrer"></p></div><div><p>Let's take an in-depth look into how this fold happens.&nbsp;<code>\acc x -&gt; acc + x</code>&nbsp;is the binary function.&nbsp;<code>0</code>&nbsp;is the starting value and&nbsp;<code>xs</code>&nbsp;is the list to be folded up. Now first,&nbsp;<code>0</code>&nbsp;is used as the&nbsp;<code>acc</code>&nbsp;parameter to the binary function and&nbsp;<code>3</code>&nbsp;is used as the&nbsp;<code>x</code>&nbsp;(or the current element) parameter.&nbsp;<code>0 + 3</code>&nbsp;produces a&nbsp;<code>3</code>&nbsp;and it becomes the new accumulator value, so to speak. Next up,&nbsp;<code>3</code>&nbsp;is used as the accumulator value and&nbsp;<code>5</code>&nbsp;as the current element and&nbsp;<code>8</code>&nbsp;becomes the new accumulator value. Moving forward,&nbsp;<code>8</code>&nbsp;is the accumulator value,&nbsp;<code>2</code>&nbsp;is the current element, the new accumulator value is&nbsp;<code>10</code>. Finally, that&nbsp;<code>10</code>&nbsp;is used as the accumulator value and&nbsp;<code>1</code>&nbsp;as the current element, producing an&nbsp;<code>11</code>. Congratulations, you've done a fold!</p></div><div><p>This professional diagram on the left illustrates how a fold happens, step by step (day by day!). The greenish brown number is the accumulator value. You can see how the list is sort of consumed up from the left side by the accumulator. Om nom nom nom! If we take into account that functions are curried, we can write this implementation ever more succinctly, like so:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token builtin">sum</span>' <span class="token operator">::</span> <span class="token punctuation">(</span><span class="token constant">Num</span> <span class="token hvariable">a</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">[</span><span class="token hvariable">a</span><span class="token punctuation">]</span> <span class="token operator">-&gt;</span> <span class="token hvariable">a</span>
<span class="token builtin">sum</span>' <span class="token operator">=</span> <span class="token builtin">foldl</span> <span class="token punctuation">(</span><span class="token operator">+</span><span class="token punctuation">)</span> <span class="token number">0</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>The lambda function&nbsp;<code>(\acc x -&gt; acc + x)</code>&nbsp;is the same as&nbsp;<code>(+)</code>. We can omit the&nbsp;<code>xs</code>&nbsp;as the parameter because calling&nbsp;<code>foldl (+) 0</code>&nbsp;will return a function that takes a list. Generally, if you have a function like&nbsp;<code>foo a = bar b a</code>, you can rewrite it as&nbsp;<code>foo = bar b</code>, because of currying.</p></div><div><p>Anyhoo, let's implement another function with a left fold before moving on to right folds. I'm sure you all know that&nbsp;<code>elem</code>&nbsp;checks whether a value is part of a list so I won't go into that again (whoops, just did!). Let's implement it with a left fold.</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token builtin">elem</span>' <span class="token operator">::</span> <span class="token punctuation">(</span><span class="token constant">Eq</span> <span class="token hvariable">a</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token hvariable">a</span> <span class="token operator">-&gt;</span> <span class="token punctuation">[</span><span class="token hvariable">a</span><span class="token punctuation">]</span> <span class="token operator">-&gt;</span> <span class="token constant">Bool</span>
<span class="token builtin">elem</span>' <span class="token hvariable">y</span> <span class="token hvariable">ys</span> <span class="token operator">=</span> <span class="token builtin">foldl</span> <span class="token punctuation">(</span><span class="token operator">\</span><span class="token hvariable">acc</span> <span class="token hvariable">x</span> <span class="token operator">-&gt;</span> <span class="token keyword">if</span> <span class="token hvariable">x</span> <span class="token operator">==</span> <span class="token hvariable">y</span> <span class="token keyword">then</span> <span class="token constant">True</span> <span class="token keyword">else</span> <span class="token hvariable">acc</span><span class="token punctuation">)</span> <span class="token constant">False</span> <span class="token hvariable">ys</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Well, well, well, what do we have here? The starting value and accumulator here is a boolean value. The type of the accumulator value and the end result is always the same when dealing with folds. Remember that if you ever don't know what to use as a starting value, it'll give you some idea. We start off with&nbsp;<code>False</code>. It makes sense to use&nbsp;<code>False</code>&nbsp;as a starting value. We assume it isn't there. Also, if we call a fold on an empty list, the result will just be the starting value. Then we check the current element is the element we're looking for. If it is, we set the accumulator to&nbsp;<code>True</code>. If it's not, we just leave the accumulator unchanged. If it was&nbsp;<code>False</code>&nbsp;before, it stays that way because this current element is not it. If it was&nbsp;<code>True</code>, we leave it at that.</p></div><div><p>The right fold,&nbsp;<code>foldr</code>&nbsp;works in a similar way to the left fold, only the accumulator eats up the values from the right. Also, the left fold's binary function has the accumulator as the first parameter and the current value as the second one (so&nbsp;<code>\acc x -&gt; ...</code>), the right fold's binary function has the current value as the first parameter and the accumulator as the second one (so&nbsp;<code>\x acc -&gt; ...</code>). It kind of makes sense that the right fold has the accumulator on the right, because it folds from the right side.</p></div><div><p>The accumulator value (and hence, the result) of a fold can be of any type. It can be a number, a boolean or even a new list. We'll be implementing the map function with a right fold. The accumulator will be a list, we'll be accumulating the mapped list element by element. From that, it's obvious that the starting element will be an empty list.</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token builtin">map</span>' <span class="token operator">::</span> <span class="token punctuation">(</span><span class="token hvariable">a</span> <span class="token operator">-&gt;</span> <span class="token hvariable">b</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token punctuation">[</span><span class="token hvariable">a</span><span class="token punctuation">]</span> <span class="token operator">-&gt;</span> <span class="token punctuation">[</span><span class="token hvariable">b</span><span class="token punctuation">]</span>
<span class="token builtin">map</span>' <span class="token hvariable">f</span> <span class="token hvariable">xs</span> <span class="token operator">=</span> <span class="token builtin">foldr</span> <span class="token punctuation">(</span><span class="token operator">\</span><span class="token hvariable">x</span> <span class="token hvariable">acc</span> <span class="token operator">-&gt;</span> <span class="token hvariable">f</span> <span class="token hvariable">x</span> <span class="token operator">:</span> <span class="token hvariable">acc</span><span class="token punctuation">)</span> <span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token hvariable">xs</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>If we're mapping&nbsp;<code>(+3)</code>&nbsp;to&nbsp;<code>[1,2,3]</code>, we approach the list from the right side. We take the last element, which is&nbsp;<code>3</code>&nbsp;and apply the function to it, which ends up being&nbsp;<code>6</code>. Then, we prepend it to the accumulator, which is was&nbsp;<code>[]</code>.&nbsp;<code>6:[]</code>&nbsp;is&nbsp;<code>[6]</code>&nbsp;and that's now the accumulator. We apply&nbsp;<code>(+3)</code>&nbsp;to&nbsp;<code>2</code>, that's&nbsp;<code>5</code>&nbsp;and we prepend (<code>:</code>) it to the accumulator, so the accumulator is now&nbsp;<code>[5,6]</code>. We apply&nbsp;<code>(+3)</code>&nbsp;to&nbsp;<code>1</code>&nbsp;and prepend that to the accumulator and so the end value is&nbsp;<code>[4,5,6]</code>.</p></div><div><p>Of course, we could have implemented this function with a left fold too. It would be&nbsp;<code>map' f xs = foldl (\acc x -&gt; acc ++ [f x]) [] xs</code>, but the thing is that the&nbsp;<code>++</code>&nbsp;function is much more expensive than&nbsp;<code>:</code>, so we usually use right folds when we're building up new lists from a list.</p></div><div><p><img alt="fold this up!" src="http://s3.amazonaws.com/lyah/washmachine.png" referrerpolicy="no-referrer"></p></div><div><p>If you reverse a list, you can do a right fold on it just like you would have done a left fold and vice versa. Sometimes you don't even have to do that. The&nbsp;<code>sum</code>&nbsp;function can be implemented pretty much the same with a left and right fold. One big difference is that right folds work on infinite lists, whereas left ones don't! To put it plainly, if you take an infinite list at some point and you fold it up from the right, you'll eventually reach the beginning of the list. However, if you take an infinite list at a point and you try to fold it up from the left, you'll never reach an end!</p></div><div><p><strong>Folds can be used to implstrongent any function where you traverse a list once, elstrongent by elstrongent, and then return something based on that. Whenever you want to traverse a list to return something, chances are you want a fold.</strong>&nbsp;That's why folds are, along with maps and filters, one of the most useful types of functions in functional programming.</p></div><div><p>The&nbsp;<code>foldl1</code>&nbsp;and&nbsp;<code>foldr1</code>&nbsp;functions work much like&nbsp;<code>foldl</code>&nbsp;and&nbsp;<code>foldr</code>, only you don't need to provide them with an explicit starting value. They assume the first (or last) element of the list to be the starting value and then start the fold with the element next to it. With that in mind, the&nbsp;<code>sum</code>&nbsp;function can be implemented like so:&nbsp;<code>sum = foldl1 (+)</code>. Because they depend on the lists they fold up having at least one element, they cause runtime errors if called with empty lists.&nbsp;<code>foldl</code>&nbsp;and&nbsp;<code>foldr</code>, on the other hand, work fine with empty lists. When making a fold, think about how it acts on an empty list. If the function doesn't make sense when given an empty list, you can probably use a&nbsp;<code>foldl1</code>&nbsp;or&nbsp;<code>foldr1</code>&nbsp;to implement it.</p></div><div><p>Just to show you how powerful folds are, we're going to implement a bunch of standard library functions by using folds:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token builtin">maximum</span>' <span class="token operator">::</span> <span class="token punctuation">(</span><span class="token constant">Ord</span> <span class="token hvariable">a</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">[</span><span class="token hvariable">a</span><span class="token punctuation">]</span> <span class="token operator">-&gt;</span> <span class="token hvariable">a</span>
<span class="token builtin">maximum</span>' <span class="token operator">=</span> <span class="token builtin">foldr1</span> <span class="token punctuation">(</span><span class="token operator">\</span><span class="token hvariable">x</span> <span class="token hvariable">acc</span> <span class="token operator">-&gt;</span> <span class="token keyword">if</span> <span class="token hvariable">x</span> <span class="token operator">&gt;</span> <span class="token hvariable">acc</span> <span class="token keyword">then</span> <span class="token hvariable">x</span> <span class="token keyword">else</span> <span class="token hvariable">acc</span><span class="token punctuation">)</span>

<span class="token builtin">reverse</span>' <span class="token operator">::</span> <span class="token punctuation">[</span><span class="token hvariable">a</span><span class="token punctuation">]</span> <span class="token operator">-&gt;</span> <span class="token punctuation">[</span><span class="token hvariable">a</span><span class="token punctuation">]</span>
<span class="token builtin">reverse</span>' <span class="token operator">=</span> <span class="token builtin">foldl</span> <span class="token punctuation">(</span><span class="token operator">\</span><span class="token hvariable">acc</span> <span class="token hvariable">x</span> <span class="token operator">-&gt;</span> <span class="token hvariable">x</span> <span class="token operator">:</span> <span class="token hvariable">acc</span><span class="token punctuation">)</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>

<span class="token builtin">product</span>' <span class="token operator">::</span> <span class="token punctuation">(</span><span class="token constant">Num</span> <span class="token hvariable">a</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">[</span><span class="token hvariable">a</span><span class="token punctuation">]</span> <span class="token operator">-&gt;</span> <span class="token hvariable">a</span>
<span class="token builtin">product</span>' <span class="token operator">=</span> <span class="token builtin">foldr1</span> <span class="token punctuation">(</span><span class="token operator">*</span><span class="token punctuation">)</span>

<span class="token builtin">filter</span>' <span class="token operator">::</span> <span class="token punctuation">(</span><span class="token hvariable">a</span> <span class="token operator">-&gt;</span> <span class="token constant">Bool</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token punctuation">[</span><span class="token hvariable">a</span><span class="token punctuation">]</span> <span class="token operator">-&gt;</span> <span class="token punctuation">[</span><span class="token hvariable">a</span><span class="token punctuation">]</span>
<span class="token builtin">filter</span>' <span class="token hvariable">p</span> <span class="token operator">=</span> <span class="token builtin">foldr</span> <span class="token punctuation">(</span><span class="token operator">\</span><span class="token hvariable">x</span> <span class="token hvariable">acc</span> <span class="token operator">-&gt;</span> <span class="token keyword">if</span> <span class="token hvariable">p</span> <span class="token hvariable">x</span> <span class="token keyword">then</span> <span class="token hvariable">x</span> <span class="token operator">:</span> <span class="token hvariable">acc</span> <span class="token keyword">else</span> <span class="token hvariable">acc</span><span class="token punctuation">)</span> <span class="token punctuation">[</span><span class="token punctuation">]</span>

<span class="token builtin">head</span>' <span class="token operator">::</span> <span class="token punctuation">[</span><span class="token hvariable">a</span><span class="token punctuation">]</span> <span class="token operator">-&gt;</span> <span class="token hvariable">a</span>
<span class="token builtin">head</span>' <span class="token operator">=</span> <span class="token builtin">foldr1</span> <span class="token punctuation">(</span><span class="token operator">\</span><span class="token hvariable">x</span> <span class="token hvariable">_</span> <span class="token operator">-&gt;</span> <span class="token hvariable">x</span><span class="token punctuation">)</span>

<span class="token builtin">last</span>' <span class="token operator">::</span> <span class="token punctuation">[</span><span class="token hvariable">a</span><span class="token punctuation">]</span> <span class="token operator">-&gt;</span> <span class="token hvariable">a</span>
<span class="token builtin">last</span>' <span class="token operator">=</span> <span class="token builtin">foldl1</span> <span class="token punctuation">(</span><span class="token operator">\</span><span class="token hvariable">_</span> <span class="token hvariable">x</span> <span class="token operator">-&gt;</span> <span class="token hvariable">x</span><span class="token punctuation">)</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p><code>head</code>&nbsp;is better implemented by pattern matching, but this just goes to show, you can still achieve it by using folds. Our&nbsp;<code>reverse'</code>&nbsp;definition is pretty clever, I think. We take a starting value of an empty list and then approach our list from the left and just prepend to our accumulator. In the end, we build up a reversed list.&nbsp;<code>\acc x -&gt; x : acc</code>&nbsp;kind of looks like the&nbsp;<code>:</code>&nbsp;function, only the parameters are flipped. That's why we could have also written our reverse as&nbsp;<code>foldl (flip (:)) []</code>.</p></div><div><p>Another way to picture right and left folds is like this: say we have a right fold and the binary function is&nbsp;<code>f</code>&nbsp;and the starting value is&nbsp;<code>z</code>. If we're right folding over the list&nbsp;<code>[3,4,5,6]</code>, we're essentially doing this:&nbsp;<code>f 3 (f 4 (f 5 (f 6 z)))</code>.&nbsp;<code>f</code>&nbsp;is called with the last element in the list and the accumulator, that value is given as the accumulator to the next to last value and so on. If we take&nbsp;<code>f</code>&nbsp;to be&nbsp;<code>+</code>&nbsp;and the starting accumulator value to be&nbsp;<code>0</code>, that's&nbsp;<code>3 + (4 + (5 + (6 + 0)))</code>. Or if we write&nbsp;<code>+</code>&nbsp;as a prefix function, that's&nbsp;<code>(+) 3 ((+) 4 ((+) 5 ((+) 6 0)))</code>. Similarly, doing a left fold over that list with&nbsp;<code>g</code>&nbsp;as the binary function and&nbsp;<code>z</code>&nbsp;as the accumulator is the equivalent of&nbsp;<code>g (g (g (g z 3) 4) 5) 6</code>. If we use&nbsp;<code>flip (:)</code>&nbsp;as the binary function and&nbsp;<code>[]</code>&nbsp;as the accumulator (so we're reversing the list), then that's the equivalent of&nbsp;<code>flip (:) (flip (:) (flip (:) (flip (:) [] 3) 4) 5) 6</code>. And sure enough, if you evaluate that expression, you get&nbsp;<code>[6,5,4,3]</code>.</p></div><div><p><code>scanl</code>&nbsp;and&nbsp;<code>scanr</code>&nbsp;are like&nbsp;<code>foldl</code>&nbsp;and&nbsp;<code>foldr</code>, only they report all the intermediate accumulator states in the form of a list. There are also&nbsp;<code>scanl1</code>&nbsp;and&nbsp;<code>scanr1</code>, which are analogous to&nbsp;<code>foldl1</code>&nbsp;and&nbsp;<code>foldr1</code>.</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token builtin">scanl</span> <span class="token punctuation">(</span><span class="token operator">+</span><span class="token punctuation">)</span> <span class="token number">0</span> <span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">]</span>
<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">8</span><span class="token punctuation">,</span><span class="token number">10</span><span class="token punctuation">,</span><span class="token number">11</span><span class="token punctuation">]</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token builtin">scanr</span> <span class="token punctuation">(</span><span class="token operator">+</span><span class="token punctuation">)</span> <span class="token number">0</span> <span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">]</span>
<span class="token punctuation">[</span><span class="token number">11</span><span class="token punctuation">,</span><span class="token number">8</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">]</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token builtin">scanl1</span> <span class="token punctuation">(</span><span class="token operator">\</span><span class="token hvariable">acc</span> <span class="token hvariable">x</span> <span class="token operator">-&gt;</span> <span class="token keyword">if</span> <span class="token hvariable">x</span> <span class="token operator">&gt;</span> <span class="token hvariable">acc</span> <span class="token keyword">then</span> <span class="token hvariable">x</span> <span class="token keyword">else</span> <span class="token hvariable">acc</span><span class="token punctuation">)</span> <span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">7</span><span class="token punctuation">,</span><span class="token number">9</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">]</span>
<span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token number">7</span><span class="token punctuation">,</span><span class="token number">9</span><span class="token punctuation">,</span><span class="token number">9</span><span class="token punctuation">,</span><span class="token number">9</span><span class="token punctuation">]</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token builtin">scanl</span> <span class="token punctuation">(</span><span class="token builtin">flip</span> <span class="token punctuation">(</span><span class="token operator">:</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">[</span><span class="token punctuation">]</span> <span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">1</span><span class="token punctuation">]</span>
<span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">]</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>When using a&nbsp;<code>scanl</code>, the final result will be in the last element of the resulting list while a&nbsp;<code>scanr</code>&nbsp;will place the result in the head.</p></div><div><p>Scans are used to monitor the progression of a function that can be implemented as a fold. Let's answer us this question:&nbsp;<strong>How many elstrongents does it take for the sum of the roots of all natural numbers to exceed 1000?</strong>&nbsp;To get the squares of all natural numbers, we just do&nbsp;<code>map sqrt [1..]</code>. Now, to get the sum, we could do a fold, but because we're interested in how the sum progresses, we're going to do a scan. Once we've done the scan, we just see how many sums are under 1000. The first sum in the scanlist will be 1, normally. The second will be 1 plus the square root of 2. The third will be that plus the square root of 3. If there are X sums under 1000, then it takes X+1 elements for the sum to exceed 1000.</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">sqrtSums</span> <span class="token operator">::</span> <span class="token constant">Int</span>
<span class="token hvariable">sqrtSums</span> <span class="token operator">=</span> <span class="token builtin">length</span> <span class="token punctuation">(</span><span class="token builtin">takeWhile</span> <span class="token punctuation">(</span><span class="token operator">&lt;</span><span class="token number">1000</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token builtin">scanl1</span> <span class="token punctuation">(</span><span class="token operator">+</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token builtin">map</span> <span class="token builtin">sqrt</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token operator">..</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token number">1</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token hvariable">sqrtSums</span>
<span class="token number">131</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token builtin">sum</span> <span class="token punctuation">(</span><span class="token builtin">map</span> <span class="token builtin">sqrt</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token operator">..</span><span class="token number">131</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
<span class="token number">1005.0942035344083</span>
<span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token builtin">sum</span> <span class="token punctuation">(</span><span class="token builtin">map</span> <span class="token builtin">sqrt</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token operator">..</span><span class="token number">130</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
<span class="token number">993.6486803921487</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>We use&nbsp;<code>takeWhile</code>&nbsp;here instead of&nbsp;<code>filter</code>&nbsp;because&nbsp;<code>filter</code>&nbsp;doesn't work on infinite lists. Even though we know the list is ascending,&nbsp;<code>filter</code>&nbsp;doesn't, so we use&nbsp;<code>takeWhile</code>&nbsp;to cut the scanlist off at the first occurence of a sum greater than 1000.</p></div><div><h2 data-heading="Function application with $" id="Function_application_with_$" style="display: flex;"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>Function application with $</h2></div><div><p>Alright, next up, we'll take a look at the&nbsp;<code>$</code>&nbsp;function, also called&nbsp;<em>function application</em>. First of all, let's check out how it's defined:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token punctuation">(</span><span class="token operator">$</span><span class="token punctuation">)</span> <span class="token operator">::</span> <span class="token punctuation">(</span><span class="token hvariable">a</span> <span class="token operator">-&gt;</span> <span class="token hvariable">b</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token hvariable">a</span> <span class="token operator">-&gt;</span> <span class="token hvariable">b</span>
<span class="token hvariable">f</span> <span class="token operator">$</span> <span class="token hvariable">x</span> <span class="token operator">=</span> <span class="token hvariable">f</span> <span class="token hvariable">x</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p><img alt="dollar" src="http://s3.amazonaws.com/lyah/dollar.png" referrerpolicy="no-referrer"></p></div><div><p>What the heck? What is this useless operator? It's just function application! Well, almost, but not quite! Whereas normal function application (putting a space between two things) has a really high precedence, the&nbsp;<code>$</code>&nbsp;function has the lowest precedence. Function application with a space is left-associative (so&nbsp;<code>f a b c</code>&nbsp;is the same as&nbsp;<code>((f a) b) c)</code>), function application with&nbsp;<code>$</code>&nbsp;is right-associative.</p></div><div><p>That's all very well, but how does this help us? Most of the time, it's a convenience function so that we don't have to write so many parentheses. Consider the expression&nbsp;<code>sum (map sqrt [1..130])</code>. Because&nbsp;<code>$</code>&nbsp;has such a low precedence, we can rewrite that expression as&nbsp;<code>sum $ map sqrt [1..130]</code>, saving ourselves precious keystrokes! When a&nbsp;<code>$</code>&nbsp;is encountered, the expression on its right is applied as the parameter to the function on its left. How about&nbsp;<code>sqrt 3 + 4 + 9</code>? This adds together 9, 4 and the square root of 3. If we want get the square root of&nbsp;<em>3 + 4 + 9</em>, we'd have to write&nbsp;<code>sqrt (3 + 4 + 9)</code>&nbsp;or if we use&nbsp;<code>$</code>&nbsp;we can write it as&nbsp;<code>sqrt $ 3 + 4 + 9</code>&nbsp;because&nbsp;<code>$</code>&nbsp;has the lowest precedence of any operator. That's why you can imagine a&nbsp;<code>$</code>&nbsp;being sort of the equivalent of writing an opening parentheses and then writing a closing one on the far right side of the expression.</p></div><div><p>How about&nbsp;<code>sum (filter (&gt; 10) (map (*2) [2..10]))</code>? Well, because&nbsp;<code>$</code>&nbsp;is right-associative,&nbsp;<code>f (g (z x))</code>&nbsp;is equal to&nbsp;<code>f $ g $ z x</code>. And so, we can rewrite&nbsp;<code>sum (filter (&gt; 10) (map (*2) [2..10]))</code>&nbsp;as&nbsp;<code>sum $ filter (&gt; 10) $ map (*2) [2..10]</code>.</p></div><div><p>But apart from getting rid of parentheses,&nbsp;<code>$</code>&nbsp;means that function application can be treated just like another function. That way, we can, for instance, map function application over a list of functions.</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token builtin">map</span> <span class="token punctuation">(</span><span class="token operator">$</span> <span class="token number">3</span><span class="token punctuation">)</span> <span class="token punctuation">[</span><span class="token punctuation">(</span><span class="token number">4</span><span class="token operator">+</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token number">10</span><span class="token operator">*</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token punctuation">(</span><span class="token operator">^</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token builtin">sqrt</span><span class="token punctuation">]</span>
<span class="token punctuation">[</span><span class="token number">7.0</span><span class="token punctuation">,</span><span class="token number">30.0</span><span class="token punctuation">,</span><span class="token number">9.0</span><span class="token punctuation">,</span><span class="token number">1.7320508075688772</span><span class="token punctuation">]</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><h2 data-heading="Function composition" id="Function_composition" style="display: flex;"><div class="heading-collapse-indicator collapse-indicator collapse-icon"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon right-triangle"><path d="M3 8L12 17L21 8"></path></svg></div>Function composition</h2></div><div><p>In mathematics, function composition is defined like this:&nbsp;<img alt="(f . g)(x) = f(g(x))" src="http://s3.amazonaws.com/lyah/composition.png" referrerpolicy="no-referrer">, meaning that composing two functions produces a new function that, when called with a parameter, say,&nbsp;<em>x</em>&nbsp;is the equivalent of calling&nbsp;<em>g</em>&nbsp;with the parameter&nbsp;<em>x</em>&nbsp;and then calling the&nbsp;<em>f</em>&nbsp;with that result.</p></div><div><p>In Haskell, function composition is pretty much the same thing. We do function composition with the&nbsp;<code>.</code>&nbsp;function, which is defined like so:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token punctuation">(</span><span class="token punctuation">.</span><span class="token punctuation">)</span> <span class="token operator">::</span> <span class="token punctuation">(</span><span class="token hvariable">b</span> <span class="token operator">-&gt;</span> <span class="token hvariable">c</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token punctuation">(</span><span class="token hvariable">a</span> <span class="token operator">-&gt;</span> <span class="token hvariable">b</span><span class="token punctuation">)</span> <span class="token operator">-&gt;</span> <span class="token hvariable">a</span> <span class="token operator">-&gt;</span> <span class="token hvariable">c</span>
<span class="token hvariable">f</span> <span class="token operator">.</span> <span class="token hvariable">g</span> <span class="token operator">=</span> <span class="token operator">\</span><span class="token hvariable">x</span> <span class="token operator">-&gt;</span> <span class="token hvariable">f</span> <span class="token punctuation">(</span><span class="token hvariable">g</span> <span class="token hvariable">x</span><span class="token punctuation">)</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p><img alt="notes" src="http://s3.amazonaws.com/lyah/notes.png" referrerpolicy="no-referrer"></p></div><div><p>Mind the type declaration.&nbsp;<code>f</code>&nbsp;must take as its parameter a value that has the same type as&nbsp;<code>g</code>'s return value. So the resulting function takes a parameter of the same type that&nbsp;<code>g</code>&nbsp;takes and returns a value of the same type that&nbsp;<code>f</code>&nbsp;returns. The expression&nbsp;<code>negate . (* 3)</code>&nbsp;returns a function that takes a number, multiplies it by 3 and then negates it.</p></div><div><p>One of the uses for function composition is making functions on the fly to pass to other functions. Sure, can use lambdas for that, but many times, function composition is clearer and more concise. Say we have a list of numbers and we want to turn them all into negative numbers. One way to do that would be to get each number's absolute value and then negate it, like so:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token builtin">map</span> <span class="token punctuation">(</span><span class="token operator">\</span><span class="token hvariable">x</span> <span class="token operator">-&gt;</span> <span class="token builtin">negate</span> <span class="token punctuation">(</span><span class="token builtin">abs</span> <span class="token hvariable">x</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">6</span><span class="token punctuation">,</span><span class="token number">7</span><span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">19</span><span class="token punctuation">,</span><span class="token number">24</span><span class="token punctuation">]</span>
<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">6</span><span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">7</span><span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">19</span><span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">24</span><span class="token punctuation">]</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Notice the lambda and how it looks like the result function composition. Using function composition, we can rewrite that as:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token builtin">map</span> <span class="token punctuation">(</span><span class="token builtin">negate</span> <span class="token operator">.</span> <span class="token builtin">abs</span><span class="token punctuation">)</span> <span class="token punctuation">[</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">6</span><span class="token punctuation">,</span><span class="token number">7</span><span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">19</span><span class="token punctuation">,</span><span class="token number">24</span><span class="token punctuation">]</span>
<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">5</span><span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">6</span><span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">7</span><span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">19</span><span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">24</span><span class="token punctuation">]</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Fabulous! Function composition is right-associative, so we can compose many functions at a time. The expression&nbsp;<code>f (g (z x))</code>&nbsp;is equivalent to&nbsp;<code>(f . g . z) x</code>. With that in mind, we can turn</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token builtin">map</span> <span class="token punctuation">(</span><span class="token operator">\</span><span class="token hvariable">xs</span> <span class="token operator">-&gt;</span> <span class="token builtin">negate</span> <span class="token punctuation">(</span><span class="token builtin">sum</span> <span class="token punctuation">(</span><span class="token builtin">tail</span> <span class="token hvariable">xs</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token operator">..</span><span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token number">3</span><span class="token operator">..</span><span class="token number">6</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token operator">..</span><span class="token number">7</span><span class="token punctuation">]</span><span class="token punctuation">]</span>
<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">14</span><span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">15</span><span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">27</span><span class="token punctuation">]</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>into</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">ghci</span><span class="token operator">&gt;</span> <span class="token builtin">map</span> <span class="token punctuation">(</span><span class="token builtin">negate</span> <span class="token operator">.</span> <span class="token builtin">sum</span> <span class="token operator">.</span> <span class="token builtin">tail</span><span class="token punctuation">)</span> <span class="token punctuation">[</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token operator">..</span><span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token number">3</span><span class="token operator">..</span><span class="token number">6</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token operator">..</span><span class="token number">7</span><span class="token punctuation">]</span><span class="token punctuation">]</span>
<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">14</span><span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">15</span><span class="token punctuation">,</span><span class="token operator">-</span><span class="token number">27</span><span class="token punctuation">]</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>But what about functions that take several parameters? Well, if we want to use them in function composition, we usually have to partially apply them just so much that each function takes just one parameter.&nbsp;<code>sum (replicate 5 (max 6.7 8.9))</code>&nbsp;can be rewritten as&nbsp;<code>(sum . replicate 5 . max 6.7) 8.9</code>&nbsp;or as&nbsp;<code>sum . replicate 5 . max 6.7 $ 8.9</code>. What goes on in here is this: a function that takes what&nbsp;<code>max 6.7</code>&nbsp;takes and applies&nbsp;<code>replicate 5</code>&nbsp;to it is created. Then, a function that takes the result of that and does a sum of it is created. Finally, that function is called with&nbsp;<code>8.9</code>. But normally, you just read that as: apply&nbsp;<code>8.9</code>&nbsp;to&nbsp;<code>max 6.7</code>, then apply&nbsp;<code>replicate 5</code>&nbsp;to that and then apply&nbsp;<code>sum</code>&nbsp;to that. If you want to rewrite an expression with a lot of parentheses by using function composition, you can start by putting the last parameter of the innermost function after a&nbsp;<code>$</code>&nbsp;and then just composing all the other function calls, writing them without their last parameter and putting dots between them. If you have&nbsp;<code>replicate 100 (product (map (*3) (zipWith max [1,2,3,4,5] [4,5,6,7,8])))</code>, you can write it as&nbsp;<code>replicate 100 . product . map (*3) . zipWith max [1,2,3,4,5] $ [4,5,6,7,8]</code>. If the expression ends with three parentheses, chances are that if you translate it into function composition, it'll have three composition operators.</p></div><div><p>Another common use of function composition is defining functions in the so-called point free style (also called the point<em>less</em>&nbsp;style). Take for example this function that we wrote earlier:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token builtin">sum</span>' <span class="token operator">::</span> <span class="token punctuation">(</span><span class="token constant">Num</span> <span class="token hvariable">a</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">[</span><span class="token hvariable">a</span><span class="token punctuation">]</span> <span class="token operator">-&gt;</span> <span class="token hvariable">a</span>   
<span class="token builtin">sum</span>' <span class="token hvariable">xs</span> <span class="token operator">=</span> <span class="token builtin">foldl</span> <span class="token punctuation">(</span><span class="token operator">+</span><span class="token punctuation">)</span> <span class="token number">0</span> <span class="token hvariable">xs</span>   
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>The&nbsp;<code>xs</code>&nbsp;is exposed on both right sides. Because of currying, we can omit the&nbsp;<code>xs</code>&nbsp;on both sides, because calling&nbsp;<code>foldl (+) 0</code>&nbsp;creates a function that takes a list. Writing the function as&nbsp;<code>sum' = foldl (+) 0</code>&nbsp;is called writing it in point free style. How would we write this in point free style?</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">fn</span> <span class="token hvariable">x</span> <span class="token operator">=</span> <span class="token builtin">ceiling</span> <span class="token punctuation">(</span><span class="token builtin">negate</span> <span class="token punctuation">(</span><span class="token builtin">tan</span> <span class="token punctuation">(</span><span class="token builtin">cos</span> <span class="token punctuation">(</span><span class="token builtin">max</span> <span class="token number">50</span> <span class="token hvariable">x</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>We can't just get rid of the&nbsp;<code>x</code>&nbsp;on both right right sides. The&nbsp;<code>x</code>&nbsp;in the function body has parentheses after it.&nbsp;<code>cos (max 50)</code>&nbsp;wouldn't make sense. You can't get the cosine of a function. What we can do is express&nbsp;<code>fn</code>&nbsp;as a composition of functions.</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">fn</span> <span class="token operator">=</span> <span class="token builtin">ceiling</span> <span class="token operator">.</span> <span class="token builtin">negate</span> <span class="token operator">.</span> <span class="token builtin">tan</span> <span class="token operator">.</span> <span class="token builtin">cos</span> <span class="token operator">.</span> <span class="token builtin">max</span> <span class="token number">50</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Excellent! Many times, a point free style is more readable and concise, because it makes you think about functions and what kind of functions composing them results in instead of thinking about data and how it's shuffled around. You can take simple functions and use composition as glue to form more complex functions. However, many times, writing a function in point free style can be less readable if a function is too complex. That's why making long chains of function composition is discouraged, although I plead guilty of sometimes being too composition-happy. The prefered style is to use&nbsp;<em>let</em>&nbsp;bindings to give labels to intermediary results or split the problem into sub-problems and then put it together so that the function makes sense to someone reading it instead of just making a huge composition chain.</p></div><div><p>In the section about maps and filters, we solved a problem of finding the sum of all odd squares that are smaller than 10,000. Here's what the solution looks like when put into a function.</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">oddSquareSum</span> <span class="token operator">::</span> <span class="token constant">Integer</span>
<span class="token hvariable">oddSquareSum</span> <span class="token operator">=</span> <span class="token builtin">sum</span> <span class="token punctuation">(</span><span class="token builtin">takeWhile</span> <span class="token punctuation">(</span><span class="token operator">&lt;</span><span class="token number">10000</span><span class="token punctuation">)</span> <span class="token punctuation">(</span><span class="token builtin">filter</span> <span class="token builtin">odd</span> <span class="token punctuation">(</span><span class="token builtin">map</span> <span class="token punctuation">(</span><span class="token operator">^</span><span class="token number">2</span><span class="token punctuation">)</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token operator">..</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>   
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>Being such a fan of function composition, I would have probably written that like this:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">oddSquareSum</span> <span class="token operator">::</span> <span class="token constant">Integer</span>
<span class="token hvariable">oddSquareSum</span> <span class="token operator">=</span> <span class="token builtin">sum</span> <span class="token operator">.</span> <span class="token builtin">takeWhile</span> <span class="token punctuation">(</span><span class="token operator">&lt;</span><span class="token number">10000</span><span class="token punctuation">)</span> <span class="token operator">.</span> <span class="token builtin">filter</span> <span class="token builtin">odd</span> <span class="token operator">.</span> <span class="token builtin">map</span> <span class="token punctuation">(</span><span class="token operator">^</span><span class="token number">2</span><span class="token punctuation">)</span> <span class="token operator">$</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token operator">..</span><span class="token punctuation">]</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>However, if there was a chance of someone else reading that code, I would have written it like this:</p></div><div><pre class="language-haskell" tabindex="0"><code class="language-haskell is-loaded"><span class="token hvariable">oddSquareSum</span> <span class="token operator">::</span> <span class="token constant">Integer</span>
<span class="token hvariable">oddSquareSum</span> <span class="token operator">=</span> 
    <span class="token keyword">let</span> <span class="token hvariable">oddSquares</span> <span class="token operator">=</span> <span class="token builtin">filter</span> <span class="token builtin">odd</span> <span class="token operator">$</span> <span class="token builtin">map</span> <span class="token punctuation">(</span><span class="token operator">^</span><span class="token number">2</span><span class="token punctuation">)</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token operator">..</span><span class="token punctuation">]</span>
        <span class="token hvariable">belowLimit</span> <span class="token operator">=</span> <span class="token builtin">takeWhile</span> <span class="token punctuation">(</span><span class="token operator">&lt;</span><span class="token number">10000</span><span class="token punctuation">)</span> <span class="token hvariable">oddSquares</span>
    <span class="token keyword">in</span>  <span class="token builtin">sum</span> <span class="token hvariable">belowLimit</span>
</code><button class="copy-code-button">Копировать</button></pre></div><div><p>It wouldn't win any code golf competition, but someone reading the function will probably find it easier to read than a composition chain.</p></div><div class="mod-footer"></div></div></div></div><div class="sidebar-right sidebar"><div class="sidebar-content"><span class="sidebar-section-header">Interactive Graph</span><div class="graph-view-placeholder">
		<div class="graph-view-container">
			<div class="graph-icon graph-expand" role="button" aria-label="Expand" data-tooltip-position="top"><svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon lucide-arrow-up-right"><line x1="7" y1="17" x2="17" y2="7"></line><polyline points="7 7 17 7 17 17"></polyline></svg></div>
			<canvas id="graph-canvas" width="512px" height="512px"></canvas>
		</div>
		</div><div class="tree-container outline-tree" data-depth="0"><div class="tree-header"><span class="sidebar-section-header">Table Of Contents</span><button class="clickable-icon collapse-tree-button"><iconify-icon icon="ph:arrows-in-line-horizontal-bold" width="18px" height="18px" rotate="90deg" color="currentColor"></iconify-icon></button></div><div class="tree-scroll-area"><div class="tree-item mod-tree-heading" data-depth="1"><div class="tree-item-contents"><a class="tree-item-link" href="#Higher_order_functions"><span class="tree-item-title">Higher order functions</span></a></div><div class="tree-item-children"><div class="tree-item mod-tree-heading" data-depth="2"><div class="tree-item-contents"><a class="tree-item-link" href="#Curried_functions"><span class="tree-item-title">Curried functions</span></a></div><div class="tree-item-children"></div></div><div class="tree-item mod-tree-heading" data-depth="2"><div class="tree-item-contents"><a class="tree-item-link" href="#Some_higher-orderism_is_in_order"><span class="tree-item-title">Some higher-orderism is in order</span></a></div><div class="tree-item-children"></div></div><div class="tree-item mod-tree-heading" data-depth="2"><div class="tree-item-contents"><a class="tree-item-link" href="#Maps_and_filters"><span class="tree-item-title">Maps and filters</span></a></div><div class="tree-item-children"></div></div><div class="tree-item mod-tree-heading" data-depth="2"><div class="tree-item-contents"><a class="tree-item-link" href="#Lambdas"><span class="tree-item-title">Lambdas</span></a></div><div class="tree-item-children"></div></div><div class="tree-item mod-tree-heading" data-depth="2"><div class="tree-item-contents"><a class="tree-item-link" href="#Only_folds_and_horses"><span class="tree-item-title">Only folds and horses</span></a></div><div class="tree-item-children"></div></div><div class="tree-item mod-tree-heading" data-depth="2"><div class="tree-item-contents"><a class="tree-item-link" href="#Function_application_with_$"><span class="tree-item-title">Function application with $</span></a></div><div class="tree-item-children"></div></div><div class="tree-item mod-tree-heading" data-depth="2"><div class="tree-item-contents"><a class="tree-item-link" href="#Function_composition"><span class="tree-item-title">Function composition</span></a></div><div class="tree-item-children"></div></div></div></div></div></div></div></div></div></body></html>